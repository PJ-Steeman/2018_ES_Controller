
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 14.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 14.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 14.lst



 Line  I  Addr  Code            Source

    1:				$nolist
  179:
  180:		N      007F	stack_init	equ	07fh
  181:
  182:		N      0000			org	0000h
  183:	  0000	02 00 06			ljmp	start
  184:		N      0003			org	0003h
  185:	  0003	02 00 17			ljmp	int_handler_int0
  186:
  187:	  0006	75 81 7F	start:		mov	sp,#stack_init
  188:	  0009	74 64				mov	a,#100
  189:	  000B	12 00 10			lcall	subrout1
  190:	  000E	80 FE		loop:		jmp	loop
  191:
  192:	  0010	D2 88		subrout1:	setb	it0
  193:	  0012	D2 AF				setb	ea
  194:	  0014	D2 A8				setb	ex0
  195:	  0016	22				ret
  196:
  197:	  0017			int_handler_int0:
  198:	  0017	14				dec	a
  199:	  0018	60 01				jz	teller
  200:	  001A	32		eind_tel:	reti
  201:
  202:	  001B	15 A0		teller:		dec	p2
  203:	  001D	74 64				mov	a,#100
  204:	  001F	80 F9				jmp 	eind_tel
  205:
  206:				$include (c:/aduc800_mideA.inc)
  207: 1			;******************************************************************************
  208: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  209: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  210: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  211: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  212: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  213: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  214: 1			;******************************************************************************
  215: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  216: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  217: 1			;******************************************************************************
  218: 1
  219: 1
  220: 1			;******************************************************************************

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  221: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  222: 1			; hebben voor onze toepassing. Door een module te definieren via het
  223: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  224: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  225: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  226: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  227: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  228: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  229: 1			; definities.
  230: 1			;******************************************************************************
  231: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  232: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  233: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  234: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  235: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  236: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  237: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  238: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  239: 1
  240: 1			ifdef    aduc_key
  241: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  242: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  243: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  244: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  245: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  246: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  247: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  248: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  249: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  250: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  251: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  252: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  253: 1			;definities wel gemaakt worden.
  254: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  255: 1			                            ;anders commentaar van maken!
  256: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  257: 1			                            ;gelezen, anders commentaar van maken!
  258: 1			;******************************************************************************
  259: 1			;Declaraties van de flags voor de aduc_key driver.
  260: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  261: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  262: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  263: 1			;switch_init en read_switch.
  264: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  265: 1			                                ;bereik = 20h-2fh!
  266: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  267: 1			                                   ;een geldige waarde bevat
  268: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  269: 1			                                   ;die de detectie mode aangeeft
  270: 1			;declaratie van de read_switch flags
  271: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  272: 1			                                   ;ontdenderde schakelaars zijn
  273: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  274: 1			                                   ;flanken zijn
  275: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  276: 1			                                   ;flanken zijn

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  277: 1			ifdef    matrix        ;matrix keyboard
  278: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  279: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  280: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  281: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  282: 1			;toepassing.
  283: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  284: 1			                                ;geheugenbuffer
  285: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  286: 1			                                ;debounce en de flankdetectie samples stockeren
  287: 1			                                ;de eerste 4 bytes dienen voor debouncing
  288: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  289: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  290: 1			                                ;toetswaarde aangeeft
  291: 1			                                ;bij een geldige keyvalid flag ('1')
  292: 1			endif    ;einde matrix keyboard
  293: 1
  294: 1			ifdef    dipswitch
  295: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  296: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  297: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  298: 1			;toepassing
  299: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  300: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  301: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  302: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  303: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  304: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  305: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  306: 1			endif    ;einde dipswitch
  307: 1			;******************************************************************************
  308: 1			endif    ;einde aduc_key
  309: 1
  310: 1
  311: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  312: 1
  313: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  314: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  315: 1			endif                               ;dus doen we dit hier nog eens!
  316: 1			;******************************************************************************
  317: 1
  318: 1			;******************************************************************************
  319: 1			;
  320: 1			; ADuc_lcd.inc
  321: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  322: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  323: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  324: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  325: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  326: 1			; het plaatsen van de cursor op een correcte plaats).
  327: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  328: 1			; display gebruiken.
  329: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  330: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  331: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  332: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  333: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  334: 1			;
  335: 1			; Versie ADuC832v1.1:
  336: 1			; Hier is het LCD verbonden met pinnen van poort0
  337: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  338: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  339: 1			;
  340: 1			; Versie ADuC832v2.2:
  341: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  342: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  343: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  344: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  345: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  346: 1			;
  347: 1			;
  348: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  349: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  350: 1			;  aduclcd0.inc
  351: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  352: 1			;  aduclcd1.inc
  353: 1			;    -00dh en 00ah worden door outchar verwerkt
  354: 1			;    -bij de init wordt het display anders opgestart
  355: 1			;
  356: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  357: 1			;  van gebruik en uitgebreid  met :
  358: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  359: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  360: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  361: 1			;    debug doeleinden
  362: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  363: 1			;    user codes aan te maken
  364: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  365: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  366: 1			;
  367: 1			; Beschikbare routines:
  368: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  369: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  370: 1			; build_adr, delay2ms, delay60us
  371: 1			;******************************************************************************
  372: 1
  373: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  374: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  375: 1			e             bit    lcdport.2            ;enable
  376: 1			rs            bit    lcdport.3            ;register select
  377: 1			endif    ;einde aduc832_v1_1
  378: 1
  379: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  380: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  381: 1	B	 F1	e             bit    lcdport.1            ;enable
  382: 1	B	 F0	rs            bit    lcdport.0            ;register select
  383: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  384: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  385: 1			endif    ;einde aduc832_v2_0
  386: 1
  387: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  388: 1			;het uitvoeren van de overeenkomstige commando's.

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  389: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  390: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  391: 1
  392: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  393: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  394: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  395: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  396: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  397: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  398: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  399: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  400: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  401: 1
  402: 1			;******************************************************************************
  403: 1			;
  404: 1			; initlcd
  405: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  406: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  407: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  408: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  409: 1			; Na initialisering wordt het scherm leeg gemaakt.
  410: 1			;
  411: 1			; registergebruik: geen
  412: 1			;
  413: 1			;******************************************************************************
  414: 1
  415: 1  0021	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  416: 1  0023	C0 D0		              push   psw
  417: 1  0025	C0 F0		              push   b
  418: 1			ifdef  aduc832_v1_1
  419: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  420: 1			                                   ;let op:twee laagste bits worden
  421: 1			                                   ;niet gebruikt
  422: 1			endif
  423: 1
  424: 1			ifdef    aduc832_v2_0
  425: 1  0027	12 03 17	              lcall  i2cinit              ;LCD via een I2C bus
  426: 1  002A	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  427: 1			                                          ;buzzer en backlight  op 1 gezet
  428: 1  002D	12 04 1A	              lcall  porttolcd            ;data uit b naar het scherm
  429: 1			endif
  430: 1
  431: 1  0030	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  432: 1  0032	12 02 EC	initlcd1:     lcall  delay2ms
  433: 1  0035	D5 E0 FA	              djnz   acc,initlcd1
  434: 1  0038	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  435: 1  003A	12 01 A3	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  436: 1  003D	12 02 EC	              lcall  delay2ms      ;om het display altijd opgestart
  437: 1  0040	74 30		              mov    a,#00110000b  ;te krijgen.
  438: 1  0042	12 01 A3	              lcall  outhnibc
  439: 1  0045	12 02 EC	              lcall  delay2ms
  440: 1  0048	74 30		              mov    a,#00110000b
  441: 1  004A	12 01 A3	              lcall  outhnibc
  442: 1  004D	12 02 EC	              lcall  delay2ms
  443: 1  0050	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  444: 1  0052	12 01 A3	              lcall  outhnibc      ;hoge nibble naar het controleregister

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  445: 1  0055	12 02 EC	              lcall  delay2ms      ;niet nodig volgens datasheet
  446: 1  0058	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  447: 1  005A	12 01 8D	              lcall  outc          ;naar display
  448: 1  005D	12 02 EC	              lcall  delay2ms      ;is iets te lang volgens datasheet
  449: 1  0060	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  450: 1  0062	12 01 8D	              lcall  outc
  451: 1  0065	12 02 EC	              lcall  delay2ms      ;ook deze delay is iets te lang
  452: 1  0068	74 01		              mov    a,#displayon  ;clear display and home cursor
  453: 1  006A	12 01 8D	              lcall  outc
  454: 1  006D	12 02 EC	              lcall  delay2ms      ;deze wachttijd is bijna juist
  455: 1  0070	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  456: 1  0072	12 01 8D	              lcall  outc
  457: 1  0075	12 02 EC	              lcall  delay2ms      ;wachten weer veel te lang
  458: 1  0078	D0 F0		              pop    b
  459: 1  007A	D0 D0		              pop    psw           ;registers terug in orde zetten
  460: 1  007C	D0 E0		              pop    acc
  461: 1  007E	22		              ret                  ;einde van de initialisatie
  462: 1
  463: 1			;******************************************************************************
  464: 1			;
  465: 1			; outcharlcd
  466: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  467: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  468: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  469: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  470: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  471: 1			; De controlekarakters komen overeen met volgende acties:
  472: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  473: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  474: 1			;              (line feed+ carriage return!)
  475: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  476: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  477: 1			;      011h   =cursor on, blink mode
  478: 1			;      012h   =cursor on, no blink mode
  479: 1			;      013h   =cursor off
  480: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  481: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  482: 1			;              van het LCD
  483: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  484: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  485: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  486: 1			; positie 6 (C5H-80H=45H)
  487: 1			;
  488: 1			; Deze routine vernietigt geen registers
  489: 1			;
  490: 1			;******************************************************************************
  491: 1
  492: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  493: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  494: 1			; dataregister van het scherm.
  495: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  496: 1			; controlebyte doorsturen naar het LCD.
  497: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  498: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  499: 1			; naar de LCD sturen.
  500: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  501: 1  007F	C0 E0		outcharlcd:   push   acc           ;registers op stack
  502: 1  0081	C0 D0		              push   psw
  503: 1  0083	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  504: 1  0086	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  505: 1  0088	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  506: 1  008B	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  507: 1  008D	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  508: 1  0090	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  509: 1
  510: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  511: 1			; Als het een commando is, moeten we het uitvoeren.
  512: 1			; Indien niet, gewoon terug zonder actie!
  513: 1
  514: 1  0092	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  515: 1  0095	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  516: 1  0097	80 28		              sjmp   outcharlcd9          ;afsluiten
  517: 1
  518: 1  0099	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  519: 1  009C	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  520: 1  009E	80 21		              sjmp   outcharlcd9
  521: 1
  522: 1  00A0	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  523: 1  00A3	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  524: 1  00A5	80 1A		              sjmp   outcharlcd9
  525: 1
  526: 1  00A7	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  527: 1  00AA	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  528: 1  00AC	80 13		              sjmp   outcharlcd9
  529: 1
  530: 1  00AE	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  531: 1  00B1	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  532: 1  00B3	80 0C		              sjmp   outcharlcd9
  533: 1
  534: 1  00B5	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  535: 1  00B8	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  536: 1  00BA	80 05		              sjmp   outcharlcd9
  537: 1
  538: 1
  539: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  540: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  541: 1
  542: 1  00BC	12 01 53	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  543: 1  00BF	80 03		              sjmp   outcharlcde   ;einde routine
  544: 1
  545: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  546: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  547: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  548: 1			; op dat adres te zetten.
  549: 1
  550: 1  00C1	12 01 8D	outcharlcd9:  lcall  outc          ;klaar
  551: 1  00C4	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  552: 1  00C6	D0 E0		              pop    acc
  553: 1  00C8	22		              ret
  554: 1
  555: 1			;******************************************************************************
  556: 1			;

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  557: 1			; outniblcd
  558: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  559: 1			; op het lcd scherm.
  560: 1			;
  561: 1			; de routine vernietigt geen registers
  562: 1			;
  563: 1			;******************************************************************************
  564: 1
  565: 1  00C9	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  566: 1  00CB	C0 D0		              push   psw
  567: 1  00CD	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  568: 1  00CF	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  569: 1  00D1	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  570: 1  00D4	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  571: 1  00D6	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  572: 1  00D8	12 01 53	outniblcde:   lcall  outd          ;naar het scherm
  573: 1  00DB	D0 D0		              pop    psw
  574: 1  00DD	D0 E0		              pop    acc
  575: 1  00DF	22		              ret
  576: 1
  577: 1			;******************************************************************************
  578: 1			;
  579: 1			; outbytelcd
  580: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  581: 1			;
  582: 1			; de routine vernietigt geen registers
  583: 1			;
  584: 1			;******************************************************************************
  585: 1
  586: 1  00E0	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  587: 1  00E2	C0 D0		              push   psw
  588: 1  00E4	C4		              swap   a             ;bitjes omruilen
  589: 1  00E5	12 00 C9	              lcall  outniblcd
  590: 1  00E8	C4		              swap   a             ;nog eens
  591: 1  00E9	12 00 C9	              lcall  outniblcd
  592: 1  00EC	D0 D0		              pop    psw
  593: 1  00EE	D0 E0		              pop    acc
  594: 1  00F0	22		              ret
  595: 1
  596: 1			;******************************************************************************
  597: 1			;
  598: 1			; dispdptrlcd
  599: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  600: 1			;
  601: 1			; de routine vernietigt geen registers
  602: 1			;
  603: 1			;******************************************************************************
  604: 1
  605: 1  00F1	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  606: 1  00F3	C0 D0		              push   psw
  607: 1  00F5	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  608: 1  00F7	12 00 E0	              lcall  outbytelcd
  609: 1  00FA	E5 82		              mov    a,dpl         ;dan het lage deel
  610: 1  00FC	12 00 E0	              lcall  outbytelcd
  611: 1  00FF	D0 D0		              pop    psw
  612: 1  0101	D0 E0		              pop    acc

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  613: 1  0103	22		              ret
  614: 1
  615: 1			;******************************************************************************
  616: 1			;
  617: 1			; outmsgalcd
  618: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  619: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  620: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  621: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  622: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  623: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  624: 1			;
  625: 1			; de routine vernietigt geen registers
  626: 1			;
  627: 1			;******************************************************************************
  628: 1
  629: 1  0104	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  630: 1  0106	C0 D0		              push   psw
  631: 1  0108	C0 83		              push   dph           ;ook de data pointer
  632: 1  010A	C0 82		              push   dpl
  633: 1
  634: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  635: 1
  636: 1  010C	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  637: 1  010D	93		              movc   a,@a+dptr     ;waarde lezen
  638: 1  010E	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  639: 1
  640: 1			; de code is niet 0 dus versturen met outchar
  641: 1
  642: 1  0110	12 00 7F	              lcall  outcharlcd    ;weg er mee
  643: 1  0113	A3		              inc    dptr          ;naar volgende ascii code wijzen
  644: 1  0114	02 01 0C	              ljmp   outmsgalcd1   ;lus sluiten
  645: 1
  646: 1  0117	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  647: 1  0119	D0 83		              pop    dph
  648: 1  011B	D0 D0		              pop    psw
  649: 1  011D	D0 E0		              pop    acc
  650: 1  011F	22		              ret
  651: 1
  652: 1			;******************************************************************************
  653: 1			;
  654: 1			; regtolcd
  655: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  656: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  657: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  658: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  659: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  660: 1			;
  661: 1			; de routine vernietigt geen registers
  662: 1			;
  663: 1			;******************************************************************************
  664: 1
  665: 1
  666: 1  0120	C0 E0		regtolcd:     push   acc           ;registers op de stack
  667: 1  0122	C0 D0		              push   psw
  668: 1  0124	E8		              mov    a,r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  669: 1  0125	C0 E0		              push   acc
  670: 1  0127	E9		              mov    a,r1
  671: 1  0128	C0 E0		              push   acc
  672: 1  012A	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  673: 1  012C	12 00 7F	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  674: 1			                                   ;plaats
  675: 1  012F	79 00		              mov    r1,#000h      ;werkt als loopcounter
  676: 1  0131	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  677: 1  0132	12 00 7F	              lcall  outcharlcd    ;weg er mee
  678: 1  0135	08		              inc    r0
  679: 1  0136	09		              inc    r1
  680: 1  0137	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  681: 1			                                          ;nieuwe lijn genomen worden
  682: 1  013A	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  683: 1  013C	12 00 7F	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  684: 1			                                   ;plaats
  685: 1
  686: 1  013F	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  687: 1  0140	12 00 7F	              lcall  outcharlcd    ;weg er mee
  688: 1  0143	08		              inc    r0
  689: 1  0144	09		              inc    r1
  690: 1  0145	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  691: 1  0148	D0 E0		              pop    acc
  692: 1  014A	F9		              mov    r1,a
  693: 1  014B	D0 E0		              pop    acc
  694: 1  014D	F8		              mov    r0,a
  695: 1  014E	D0 D0		              pop    psw           ;registers herstellen
  696: 1  0150	D0 E0		              pop    acc
  697: 1  0152	22		              ret
  698: 1
  699: 1			;******************************************************************************
  700: 1			;
  701: 1			; outd
  702: 1			; Is een routine die naar het data register van het display een
  703: 1			; volledige byte stuurt.
  704: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  705: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  706: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  707: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  708: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  709: 1			;
  710: 1			; De routine vernietigt geen registers.
  711: 1			;
  712: 1			;******************************************************************************
  713: 1
  714: 1  0153	C0 E0		outd:         push   acc           ;registers op stack zetten
  715: 1  0155	C0 D0		              push   psw
  716: 1  0157	12 01 63	              lcall  outhnibd      ;hoogste vier bits verzenden
  717: 1			ifdef     aduc832_v1_1
  718: 1			              lcall  delay60us     ;niet echt nodig
  719: 1			endif
  720: 1  015A	C4		              swap   a             ;bitjes omruilen
  721: 1  015B	12 01 63	              lcall  outhnibd      ;naar het scherm sturen
  722: 1
  723: 1			ifdef    aduc832_v1_1
  724: 1			              lcall  delay60us     ;altijd goed

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  725: 1			endif
  726: 1
  727: 1  015E	D0 D0		              pop    psw           ;registers terug herstellen
  728: 1  0160	D0 E0		              pop    acc
  729: 1  0162	22		              ret
  730: 1
  731: 1			;******************************************************************************
  732: 1			;
  733: 1			; outhnibd
  734: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  735: 1			; lcd scherm.
  736: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  737: 1			; de routine vernietigt geen registers.
  738: 1			;
  739: 1			;******************************************************************************
  740: 1			ifdef     aduc832_v1_1
  741: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  742: 1			              push   psw
  743: 1			              setb   rs            ;controle lijn in orde
  744: 1			              clr    e             ;deselectie display
  745: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  746: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  747: 1			              mov     c,acc.6      ;afblijven!
  748: 1			              mov     lcdport.6,c
  749: 1			              mov     c,acc.5
  750: 1			              mov     lcdport.5,c
  751: 1			              mov     c,acc.4
  752: 1			              mov     lcdport.4,c
  753: 1			              setb   e             ;display enabelen
  754: 1			              nop                  ;450ns is normaal gezien voldoende
  755: 1			              clr    e             ;display deselecteren
  756: 1			              pop    psw           ;registers herstellen
  757: 1			              pop    acc
  758: 1			              ret
  759: 1			endif
  760: 1
  761: 1			ifdef    aduc832_v2_0
  762: 1  0163	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  763: 1  0165	C0 D0		              push   psw
  764: 1  0167	C0 F0		              push   b             ;werkregister
  765: 1  0169	12 04 33	              lcall  lcdtoport     ;lees de expander naar b register
  766: 1  016C	D2 F0		              setb   rs            ;controle lijn in orde
  767: 1  016E	C2 F1		              clr    e             ;deselectie display
  768: 1  0170	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  769: 1  0172	03		              rr     a             ;bits op juiste plaats zetten
  770: 1  0173	03		              rr     a             ;voor b reg
  771: 1  0174	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  772: 1  0177	42 F0		              orl    b,a           ;bij elkaar voegen
  773: 1  0179	12 04 1A	              lcall  porttolcd     ;naar expander
  774: 1  017C	D2 F1		              setb   e             ;display enabelen
  775: 1  017E	12 04 1A	              lcall  porttolcd
  776: 1  0181	C2 F1		              clr    e             ;display deselecteren
  777: 1  0183	12 04 1A	              lcall  porttolcd
  778: 1  0186	D0 F0		              pop    b
  779: 1  0188	D0 D0		              pop    psw           ;registers herstellen
  780: 1  018A	D0 E0		              pop    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  781: 1  018C	22		              ret
  782: 1			endif
  783: 1			;******************************************************************************
  784: 1			;
  785: 1			; outc
  786: 1			; Is een routine die naar het controleregister van het display een
  787: 1			; volledige byte (commando) stuurt.
  788: 1			; De routine vernietigt geen registers.
  789: 1			;
  790: 1			;******************************************************************************
  791: 1
  792: 1  018D	C0 E0		outc:         push   acc           ;registers op stack zetten
  793: 1  018F	C0 D0		              push   psw
  794: 1  0191	12 01 A3	              lcall  outhnibc      ;hoogste vier bits verzenden
  795: 1  0194	12 02 EC	              lcall  delay2ms      ;niet echt nodig
  796: 1  0197	C4		              swap   a             ;bitjes omruilen
  797: 1  0198	12 01 A3	              lcall  outhnibc      ;naar het scherm sturen
  798: 1  019B	12 02 EC	              lcall  delay2ms      ;altijd goed voor traagste commando
  799: 1  019E	D0 D0		              pop    psw           ;registers terug herstellen
  800: 1  01A0	D0 E0		              pop    acc
  801: 1  01A2	22		              ret
  802: 1
  803: 1			;******************************************************************************
  804: 1			;
  805: 1			; outhnibc
  806: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  807: 1			; het lcd scherm.
  808: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  809: 1			; de routine vernietigt geen registers.
  810: 1			;
  811: 1			;******************************************************************************
  812: 1			ifdef     aduc832_v1_1
  813: 1			outhnibc:     push   acc           ;registers op stack plaatsen
  814: 1			              push   psw
  815: 1			              clr    rs            ;controle lijn in orde
  816: 1			              clr    e             ;deselectie display
  817: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  818: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  819: 1			              mov     c,acc.6      ;afblijven!
  820: 1			              mov     lcdport.6,c
  821: 1			              mov     c,acc.5
  822: 1			              mov     lcdport.5,c
  823: 1			              mov     c,acc.4
  824: 1			              mov     lcdport.4,c
  825: 1			              setb   e             ;display enabelen
  826: 1			              nop                  ;450ns is normaal gezien voldoende
  827: 1			              clr    e             ;display deselecteren
  828: 1			              pop    psw           ;registers herstellen
  829: 1			              pop    acc
  830: 1			              ret
  831: 1			endif
  832: 1
  833: 1			ifdef    aduc832_v2_0
  834: 1  01A3	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
  835: 1  01A5	C0 D0		              push   psw
  836: 1  01A7	C0 F0		              push   b             ;werkregister

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  837: 1  01A9	12 04 33	              lcall  lcdtoport     ;lees de expander naar b register
  838: 1  01AC	C2 F0		              clr    rs            ;controle lijn in orde
  839: 1  01AE	C2 F1		              clr    e             ;deselectie display
  840: 1  01B0	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  841: 1  01B2	03		              rr     a             ;bits op juiste plaats zetten
  842: 1  01B3	03		              rr     a             ;voor b reg
  843: 1  01B4	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  844: 1  01B7	42 F0		              orl    b,a           ;bij elkaar voegen
  845: 1  01B9	12 04 1A	              lcall  porttolcd     ;naar expnder
  846: 1  01BC	D2 F1		              setb   e             ;display enabelen
  847: 1  01BE	12 04 1A	              lcall  porttolcd
  848: 1  01C1	C2 F1		              clr    e             ;display deselecteren
  849: 1  01C3	12 04 1A	              lcall  porttolcd
  850: 1  01C6	D0 F0		              pop    b
  851: 1  01C8	D0 D0		              pop    psw           ;registers herstellen
  852: 1  01CA	D0 E0		              pop    acc
  853: 1  01CC	22		              ret
  854: 1			endif
  855: 1
  856: 1			;******************************************************************************
  857: 1			; hexbuf2lcd
  858: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  859: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  860: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  861: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  862: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  863: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  864: 1			;
  865: 1			; ADR| HEX DATA  |
  866: 1			; 42 |AF 2D 23 5A|
  867: 1			;
  868: 1			; Deze routine vernietigt geen registers
  869: 1			;******************************************************************************
  870: 1
  871: 1  01CD	C0 E0		hexbuf2lcd:   push   acc
  872: 1  01CF	C0 F0		              push   b
  873: 1  01D1	C0 D0		              push   psw
  874: 1  01D3	C0 82		              push   dpl
  875: 1  01D5	C0 83		              push   dph
  876: 1  01D7	E8		              mov     a,r0
  877: 1  01D8	C0 E0		              push   acc
  878: 1  01DA	90 02 16	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
  879: 1  01DD	12 01 04	              lcall   outmsgalcd
  880: 1  01E0	E8		              mov    a,r0            ;neem pointerwaarde
  881: 1  01E1	12 00 E0	              lcall  outbytelcd      ;byte afdrukken als startadres
  882: 1  01E4	74 20		              mov    a,#' '          ;spatie afdrukken
  883: 1  01E6	12 00 7F	              lcall  outcharlcd
  884: 1  01E9	74 7C		              mov    a,#'|'          ;pipe afdrukken
  885: 1  01EB	12 00 7F	              lcall  outcharlcd
  886: 1  01EE	75 F0 04	              mov    b,#4            ;bytecounter=4
  887: 1  01F1	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  888: 1  01F2	12 00 E0	              lcall  outbytelcd      ;byte naar buiten
  889: 1  01F5	74 20		              mov    a,#' '          ;neem whitespace char
  890: 1  01F7	12 00 7F	              lcall  outcharlcd       ;druk af
  891: 1  01FA	08		              inc    r0              ;volgende byte
  892: 1  01FB	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  893: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  894: 1  01FE	74 CF		              mov    a,#0cfh         ;adres laatste char
  895: 1  0200	12 00 7F	              lcall   outcharlcd
  896: 1  0203	74 7C		              mov    a,#'|'          ;neem pipe
  897: 1  0205	12 00 7F	              lcall  outcharlcd      ;ascii code afdrukken
  898: 1  0208	D0 E0		hexbuf2lcde:  pop    acc
  899: 1  020A	F8		              mov   r0,a
  900: 1  020B	D0 83		              pop   dph
  901: 1  020D	D0 82		              pop   dpl
  902: 1  020F	D0 D0		              pop   psw
  903: 1  0211	D0 F0		              pop   b
  904: 1  0213	D0 E0		              pop   acc
  905: 1  0215	22		              ret
  906: 1			                        ;'0123456789abcdef'
  907: 1  0216	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  021A	52 7C 20 48
       1  021E	45 58 20 44
       1  0222	41 54 41 20
       1  0226	20 7C C0 00
  908: 1
  909: 1
  910: 1			;******************************************************************************
  911: 1			; barlcd
  912: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
  913: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
  914: 1			; de inhoud van A
  915: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
  916: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
  917: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
  918: 1			; aangemaakt in de LCD CGRAM.
  919: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
  920: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
  921: 1			;       lcall build
  922: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
  923: 1			;       mov     a, #42h     ;de startlocatie is 42h
  924: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
  925: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
  926: 1			;
  927: 1			; Deze routine vernietigt geen registers.
  928: 1			;******************************************************************************
  929: 1
  930: 1  022A	C0 82		barlcd:       push   dpl
  931: 1  022C	88 82		              mov     dpl,r0
  932: 1  022E	C0 82		              push   dpl
  933: 1  0230	C0 E0		              push   acc            ;bewaar startlocatie
  934: 1  0232	C0 D0		              push   psw            ;bewaar status
  935: 1  0234	C0 F0		              push   b              ;bewaar aantal bar's
  936: 1  0236	F5 F0		              mov    b,a            ;bewaar startlocatie
  937: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
  938: 1  0238	E8		              mov    a,r0           ;neem maximum aantal bar's
  939: 1  0239	C0 F0		              push   b              ;bewaar startadres
  940: 1  023B	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
  941: 1  023E	84		              div    ab             ;bereken dus het aantal nodige blokjes
  942: 1  023F	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
  943: 1  0240	E5 F0		              mov    a,b            ;neem restbars
  944: 1  0242	60 01		              jz     barlcd_1       ;als nul dan verder

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  945: 1  0244	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
  946: 1  0245	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
  947: 1  0247	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
  948: 1  0249	12 00 7F	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
  949: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
  950: 1  024C	74 13		              mov    a,#13h         ;cursor off
  951: 1  024E	12 00 7F	              lcall  outcharlcd     ;stuur naar LCD
  952: 1  0251	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
  953: 1  0253	C0 F0		              push   b              ;en weer bewaren
  954: 1  0255	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
  955: 1  0257	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
  956: 1  0259	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
  957: 1  025C	84		              div    ab             ;A=aantal volle blokjes, B=rest
  958: 1  025D	C0 F0		              push   b              ;bewaar rest
  959: 1  025F	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
  960: 1  0261	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
  961: 1
  962: 1			;Druk de volle 5x8 blokjes af van de bargraph
  963: 1  0263	74 04		              mov    a,#4           ;neem code voor vol blokje
  964: 1  0265	12 01 53	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
  965: 1  0268	18		              dec    r0             ;verminder karaktersteller
  966: 1  0269	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
  967: 1
  968: 1			;Druk het onvolledige blokje (rest) af
  969: 1  026C	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
  970: 1  026E	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
  971: 1  0270	14		              dec    a              ;converteer rest naar code voor de
  972: 1			                                    ;overeenkomende bar's
  973: 1  0271	12 01 53	              lcall  outd           ;druk resterende bar's af
  974: 1  0274	18		              dec    r0             ;verminder karakterteller
  975: 1
  976: 1			;Test of we aan het einde van de bargraph zitten..
  977: 1  0275	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
  978: 1  0278	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
  979: 1
  980: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
  981: 1  027A	74 20		barlcd4:      mov    a,#' '         ;neem spatie
  982: 1  027C	12 01 53	              lcall  outd           ;en druk af
  983: 1  027F	18		              dec    r0             ;karakterteller verminderen
  984: 1  0280	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
  985: 1
  986: 1  0282	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
  987: 1  0284	D0 D0		              pop    psw            ;haal status weer
  988: 1  0286	D0 E0		              pop    acc            ;haal startlocatie weer
  989: 1  0288	D0 82		              pop    dpl
  990: 1  028A	A8 82		              mov    r0,dpl
  991: 1  028C	D0 82		              pop    dpl
  992: 1  028E	22		              ret
  993: 1
  994: 1
  995: 1
  996: 1			;******************************************************************************
  997: 1			; barchars
  998: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
  999: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
 1000: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

 1001: 1			; kunnen pas daarna worden gebruikt.
 1002: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
 1003: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
 1004: 1			; (max. 3 extra char's).
 1005: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
 1006: 1			; opgeslagen met MSB=1.
 1007: 1			;******************************************************************************
 1008: 1
 1009: 1  028F	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1010: 1  0290	10		              db 00010000b
 1011: 1  0291	10		              db 00010000b
 1012: 1  0292	10		              db 00010000b
 1013: 1  0293	10		              db 00010000b
 1014: 1  0294	10		              db 00010000b
 1015: 1  0295	10		              db 00010000b
 1016: 1  0296	10		              db 00010000b
 1017: 1
 1018: 1  0297	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1019: 1  0298	18		              db 00011000b
 1020: 1  0299	18		              db 00011000b
 1021: 1  029A	18		              db 00011000b
 1022: 1  029B	18		              db 00011000b
 1023: 1  029C	18		              db 00011000b
 1024: 1  029D	18		              db 00011000b
 1025: 1  029E	18		              db 00011000b
 1026: 1
 1027: 1  029F	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1028: 1  02A0	1C		              db 00011100b
 1029: 1  02A1	1C		              db 00011100b
 1030: 1  02A2	1C		              db 00011100b
 1031: 1  02A3	1C		              db 00011100b
 1032: 1  02A4	1C		              db 00011100b
 1033: 1  02A5	1C		              db 00011100b
 1034: 1  02A6	1C		              db 00011100b
 1035: 1
 1036: 1  02A7	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1037: 1  02A8	1E		              db 00011110b
 1038: 1  02A9	1E		              db 00011110b
 1039: 1  02AA	1E		              db 00011110b
 1040: 1  02AB	1E		              db 00011110b
 1041: 1  02AC	1E		              db 00011110b
 1042: 1  02AD	1E		              db 00011110b
 1043: 1  02AE	1E		              db 00011110b
 1044: 1
 1045: 1  02AF	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1046: 1  02B0	1F		              db 00011111b
 1047: 1  02B1	1F		              db 00011111b
 1048: 1  02B2	1F		              db 00011111b
 1049: 1  02B3	1F		              db 00011111b
 1050: 1  02B4	1F		              db 00011111b
 1051: 1  02B5	1F		              db 00011111b
 1052: 1  02B6	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1053: 1
 1054: 1			;******************************************************************************
 1055: 1			;
 1056: 1			; build

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1057: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1058: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1059: 1			; overeen komen met de ASCII codes 00h-07h.
 1060: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1061: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1062: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1063: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1064: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1065: 1			;
 1066: 1			; De routine vernietigt geen registers.
 1067: 1			;
 1068: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1069: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1070: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1071: 1			;      lcall  outcharlcd         ; druk de karakter af
 1072: 1			;
 1073: 1			;eigenkarakter:
 1074: 1			;      db 00001110b
 1075: 1			;      db 00001010b
 1076: 1			;      db 00001110b
 1077: 1			;      db 00000100b
 1078: 1			;      db 00011111b
 1079: 1			;      db 00000100b
 1080: 1			;      db 00001010b
 1081: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1082: 1			;******************************************************************************
 1083: 1
 1084: 1  02B7	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1085: 1  02B9	C0 D0		              push   psw
 1086: 1  02BB	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1087: 1  02BD	12 02 C5	              lcall  build_adr
 1088: 1  02C0	D0 D0		              pop    psw
 1089: 1  02C2	D0 E0		              pop    acc
 1090: 1  02C4	22		              ret                  ;terug
 1091: 1
 1092: 1			;******************************************************************************
 1093: 1			; build_adr
 1094: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1095: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1096: 1			; die overeen komen met de ASCII codes 00h-07h.
 1097: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1098: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1099: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1100: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1101: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1102: 1			;
 1103: 1			; De routine vernietigt geen registers.
 1104: 1			;
 1105: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1106: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1107: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1108: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1109: 1			;      lcall  outcharlcd        ; druk de karakter af
 1110: 1			;
 1111: 1			;eigenkarakters:
 1112: 1			;      db 00001110b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1113: 1			;      db 00001010b
 1114: 1			;      db 00001110b
 1115: 1			;       db 00000100b
 1116: 1			;      db 00011111b
 1117: 1			;      db 00000100b
 1118: 1			;      db 00001010b
 1119: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1120: 1			;******************************************************************************
 1121: 1  02C5	C0 E0		build_adr:      push   acc
 1122: 1  02C7	C0 D0		              push   psw
 1123: 1  02C9	C0 83		              push   dph
 1124: 1  02CB	C0 82		              push   dpl
 1125: 1  02CD	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1126: 1  02CF	12 01 8D	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1127: 1  02D2	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1128: 1  02D4	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1129: 1  02D5	12 01 53	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1130: 1  02D8	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1131: 1  02DB	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1132: 1  02DC	80 F4		              sjmp   build3
 1133: 1  02DE	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1134: 1  02E0	12 01 8D	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1135: 1  02E3	D0 82		              pop    dpl
 1136: 1  02E5	D0 83		              pop    dph
 1137: 1  02E7	D0 D0		              pop    psw
 1138: 1  02E9	D0 E0		              pop    acc
 1139: 1  02EB	22		              ret
 1140: 1
 1141: 1			;******************************************************************************
 1142: 1			;
 1143: 1			; delay2ms
 1144: 1			; Is een vertragingsroutine van 2ms.
 1145: 1			;
 1146: 1			; De routine vernietigt geen registers.
 1147: 1			;
 1148: 1			;******************************************************************************
 1149: 1
 1150: 1  02EC	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1151: 1  02EE	C0 D0		              push   psw
 1152: 1  02F0	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1153: 1  02F2	12 02 FD	delay2ms1:    lcall  delay60us
 1154: 1  02F5	D5 E0 FA	              djnz   acc,delay2ms1
 1155: 1  02F8	D0 D0		              pop    psw           ;registers herstellen
 1156: 1  02FA	D0 E0		              pop    acc
 1157: 1  02FC	22		              ret
 1158: 1
 1159: 1			;******************************************************************************
 1160: 1			;
 1161: 1			; delay60us.
 1162: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1163: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1164: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1165: 1			;
 1166: 1			; de routine vernietigt geen registers.
 1167: 1			;
 1168: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1169: 1
 1170: 1  02FD	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1171: 1  02FF	C0 D0		              push   psw
 1172: 1  0301	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1173: 1  0303	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1174: 1
 1175: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1176: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1177: 1
 1178: 1  0305	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1179: 1  0308	D0 E0		              pop    acc           ;registers herstellen
 1180: 1  030A	D0 D0		              pop    psw
 1181: 1  030C	22		              ret
 1182: 1
 1183: 1  030D	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1184: 1  030F	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1185: 1  0312	D0 D0		              pop    psw
 1186: 1  0314	D0 E0		              pop    acc
 1187: 1  0316	22		              ret
 1188: 1
 1189: 1			endif        ;einde van aduc_lcd
 1190: 1
 1191: 1
 1192: 1
 1193: 1
 1194: 1			ifdef aduc_i2c
 1195: 1			;******************************************************************************
 1196: 1			;
 1197: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1198: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1199: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1200: 1			;
 1201: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1202: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1203: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1204: 1			;
 1205: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1206: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1207: 1			;
 1208: 1			; Beschikbare routines:
 1209: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1210: 1			; i2cstart     :verzenden van een start conditie
 1211: 1			; i2cstop      :verzenden van een stop conditie
 1212: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1213: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1214: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1215: 1			;               negende klokpuls
 1216: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1217: 1			;               negende klokpuls
 1218: 1			;
 1219: 1			; Toevoeging [dp]
 1220: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1221: 1			;               een slavedevice
 1222: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1223: 1			;               en plaatst deze in een geheugenbuffer
 1224: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1225: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1226: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1227: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1228: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1229: 1
 1230: 1			;******************************************************************************
 1231: 1			; i2cinit
 1232: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1233: 1			;******************************************************************************
 1234: 1  0317	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1235: 1  0319	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1236: 1  031B	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1237: 1  031D	D2 EB		                setb    i2cm            ;master mode inschakelen
 1238: 1  031F	22		                ret
 1239: 1			;******************************************************************************
 1240: 1			; i2cstart
 1241: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1242: 1			;******************************************************************************
 1243: 1  0320	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1244: 1  0322	C2 EF		                clr     mdo             ;data moet laag worden
 1245: 1  0324	D2 EE		                setb    mde             ;data pin enable
 1246: 1  0326	C2 ED		                clr     mco             ;klok laag maken
 1247: 1  0328	22		                ret
 1248: 1			;******************************************************************************
 1249: 1			; i2cstop
 1250: 1			; Dit is een subroutine die de stop conditie opwekt.
 1251: 1			;******************************************************************************
 1252: 1  0329	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1253: 1  032B	D2 EE		                setb    mde             ;data mag naar buiten
 1254: 1  032D	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1255: 1  032F	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1256: 1  0331	22		                ret
 1257: 1
 1258: 1			;******************************************************************************
 1259: 1			; i2coutbyte
 1260: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1261: 1			; De routine vernietigt geen registers.
 1262: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1263: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1264: 1			;         uitvoeren van de routine.
 1265: 1			;******************************************************************************
 1266: 1  0332	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1267: 1  0334	C0 F0		                push    b
 1268: 1  0336	75 F0 08	                mov     b,#008h         ;loopcounter
 1269: 1  0339	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1270: 1  033A	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1271: 1  033C	D2 EE		                setb    mde             ;pin als output activeren
 1272: 1  033E	D2 ED		                setb    mco             ;klokpukls hoog
 1273: 1  0340	C2 ED		                clr     mco             ;klokpuls laag
 1274: 1  0342	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1275: 1  0345	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1276: 1  0347	D2 ED		                setb    mco             ;klokpuls hoog
 1277: 1  0349	A2 EC		                mov     c,mdi           ;data inlezen in de carry

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1278: 1  034B	C2 ED		                clr     mco             ;klokpuls terug laag
 1279: 1  034D	D0 F0		                pop     b
 1280: 1  034F	D0 E0		                pop     acc             ;registers herstellen
 1281: 1  0351	22		                ret
 1282: 1
 1283: 1			;******************************************************************************
 1284: 1			; i2cinbyteack
 1285: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1286: 1			; De routine vernietigt geen registers. De routine zal als
 1287: 1			; negende bit een ack verzenden.
 1288: 1			;******************************************************************************
 1289: 1  0352	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1290: 1  0354	C0 D0		                push    psw
 1291: 1  0356	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1292: 1  0359	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1293: 1  035B	D2 ED		                setb    mco             ;klokpuls hoog
 1294: 1  035D	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1295: 1  035F	C2 ED		                clr     mco             ;klokpuls terug laag
 1296: 1  0361	33		                rlc     a               ;in accu shiften
 1297: 1  0362	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1298: 1  0365	C3		                clr     c               ;ack verzenden
 1299: 1  0366	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1300: 1  0368	D2 EE		                setb    mde             ;pin als output activeren
 1301: 1  036A	D2 ED		                setb    mco             ;klokpukls hoog
 1302: 1  036C	C2 ED		                clr     mco             ;klokpuls laag
 1303: 1  036E	D0 D0		                pop     psw             ;registers herstellen
 1304: 1  0370	D0 F0		                pop     b
 1305: 1  0372	22		                ret
 1306: 1
 1307: 1			;******************************************************************************
 1308: 1			; i2cinbytenack
 1309: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1310: 1			; De routine vernietigt geen registers. De routine zal als
 1311: 1			; negende bit een nack verzenden.
 1312: 1			;******************************************************************************
 1313: 1  0373	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1314: 1  0375	C0 D0		                push    psw
 1315: 1  0377	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1316: 1  037A	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1317: 1  037C	D2 ED		                setb    mco             ;klokpuls hoog
 1318: 1  037E	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1319: 1  0380	C2 ED		                clr     mco             ;klokpuls terug laag
 1320: 1  0382	33		                rlc     a               ;in accu shiften
 1321: 1  0383	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1322: 1  0386	D3		                setb    c               ;nack verzenden
 1323: 1  0387	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1324: 1  0389	D2 EE		                setb    mde             ;pin als output activeren
 1325: 1  038B	D2 ED		                setb    mco             ;klokpukls hoog
 1326: 1  038D	C2 ED		                clr     mco             ;klokpuls laag
 1327: 1  038F	D0 D0		                pop     psw             ;registers herstellen
 1328: 1  0391	D0 F0		                pop     b
 1329: 1  0393	22		                ret
 1330: 1
 1331: 1			;******************************************************************************
 1332: 1			; i2csenddata
 1333: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1334: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1335: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1336: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1337: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1338: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1339: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1340: 1			;
 1341: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1342: 1			; pointer naar deze data.  .
 1343: 1
 1344: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1345: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1346: 1			;         B       = aantal te versturen bytes (minimum 1)
 1347: 1			;         R0      = startadres van te versturen datablok
 1348: 1			;
 1349: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1350: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1351: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1352: 1			;               verzonden byte waarvoor er geen ack kwam.
 1353: 1			;
 1354: 1			; Deze routine vernietigt niets...
 1355: 1			;******************************************************************************
 1356: 1  0394	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1357: 1  0396	C0 D0		                    push   psw
 1358: 1  0398	E8		                    mov    a,r0
 1359: 1  0399	C0 E0		                    push   acc           ;r0 op stack
 1360: 1
 1361: 1  039B	12 03 20	                    lcall  i2cstart      ;genereer startconditie
 1362: 1  039E	E5 83		                    mov    a,dph         ;neem adresbyte
 1363: 1  03A0	12 03 32	                    lcall  i2coutbyte    ;en verstuur naar slave
 1364: 1  03A3	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1365: 1  03A5	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1366: 1  03A7	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1367: 1  03A9	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1368: 1			;10 bit adressering!
 1369: 1  03AC	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1370: 1  03AE	12 03 32	                    lcall  i2coutbyte    ;en verstuur naar slave
 1371: 1  03B1	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1372: 1			;7 bit adressering!
 1373: 1  03B3	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1374: 1  03B4	12 03 32	                    lcall  i2coutbyte    ;en verstuur naar slave
 1375: 1  03B7	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1376: 1  03B9	08		                    inc    r0            ;volgende byte
 1377: 1  03BA	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1378: 1  03BD	12 03 29	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1379: 1  03C0	D0 E0		                    pop    acc
 1380: 1  03C2	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1381: 1  03C3	D0 D0		                    pop    psw
 1382: 1  03C5	C3		                    clr    c             ;alles is ok!
 1383: 1  03C6	D0 E0		                    pop    acc
 1384: 1  03C8	22		                    ret
 1385: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1386: 1  03C9	12 03 29	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1387: 1  03CC	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1388: 1  03CE	D0 D0		                    pop    psw
 1389: 1  03D0	D3		                    setb   c            ;terug met foutmelding

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1390: 1  03D1	D0 E0		                    pop    acc
 1391: 1  03D3	22		                    ret
 1392: 1
 1393: 1			;******************************************************************************
 1394: 1			; i2crcvdata
 1395: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1396: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1397: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1398: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1399: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1400: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1401: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1402: 1			;
 1403: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1404: 1			; is een pointer naar de start van dit ontvangen datablok.
 1405: 1			;
 1406: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1407: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1408: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1409: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1410: 1			;
 1411: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1412: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1413: 1			;               het adres, wordt de CY bit geset bij return.
 1414: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1415: 1			;
 1416: 1			; Deze routine vernietigt verder niets...
 1417: 1			;******************************************************************************
 1418: 1  03D4	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1419: 1  03D6	C0 D0		                    push    psw
 1420: 1  03D8	E8		                    mov     a,r0            ;r0 op stack
 1421: 1  03D9	C0 E0		                    push    acc
 1422: 1
 1423: 1  03DB	12 03 20	                    lcall   i2cstart        ;genereer startconditie
 1424: 1  03DE	E5 83		                    mov     a,dph           ;neem adresbyte
 1425: 1  03E0	12 03 32	                    lcall   i2coutbyte      ;en verstuur naar slave
 1426: 1  03E3	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1427: 1  03E5	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1428: 1  03E7	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1429: 1  03E9	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1430: 1			;10 bit adressering!
 1431: 1  03EC	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1432: 1  03EE	12 03 32	                    lcall   i2coutbyte      ;en verstuur naar slave
 1433: 1  03F1	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1434: 1			;7 bit adressering!
 1435: 1
 1436: 1  03F3	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1437: 1  03F6	12 03 73	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1438: 1  03F9	F6		                    mov     @r0,a           ;en deze ook bewaren
 1439: 1  03FA	80 07		                    sjmp    i2crcvdata3
 1440: 1  03FC	12 03 52	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1441: 1  03FF	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1442: 1  0400	08		                    inc     r0              ;pointer verhogen
 1443: 1  0401	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1444: 1
 1445: 1  0403	12 03 29	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1446: 1  0406	D0 E0		                    pop     acc
 1447: 1  0408	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1448: 1  0409	D0 D0		                    pop     psw
 1449: 1  040B	C3		                    clr     c               ;alles is ok!
 1450: 1  040C	D0 E0		                    pop     acc
 1451: 1  040E	22		                    ret
 1452: 1			;fout: geen ack gekregen bij het versturen van het adres
 1453: 1  040F	12 03 29	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1454: 1  0412	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1455: 1  0414	D0 D0		                    pop        psw
 1456: 1  0416	D3		                    setb    c               ;terug met foutmelding
 1457: 1  0417	D0 E0		                    pop        acc
 1458: 1  0419	22		                    ret
 1459: 1
 1460: 1
 1461: 1			;******************************************************************************
 1462: 1			;
 1463: 1			; porttolcd
 1464: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1465: 1			; scherm stuurt via de port expander.
 1466: 1			;
 1467: 1			; Gebruikt geen registers
 1468: 1			;
 1469: 1			;******************************************************************************
 1470: 1
 1471: 1  041A	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1472: 1  041C	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1473: 1  041E	12 03 20	              lcall  i2cstart      ;vertrokken
 1474: 1			ifdef    pcf8574
 1475: 1			              mov    a,#01000000b  ;schrijven naar expander
 1476: 1			endif
 1477: 1			ifdef    pcf8574A
 1478: 1  0421	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1479: 1			endif
 1480: 1  0423	12 03 32	              lcall  i2coutbyte    ;weg er mee
 1481: 1  0426	E5 F0		              mov    a,b           ;data verzenden
 1482: 1  0428	12 03 32	              lcall  i2coutbyte
 1483: 1  042B	12 03 29	              lcall  i2cstop       ;transactie sluiten
 1484: 1  042E	D0 D0		              pop    psw
 1485: 1  0430	D0 E0		              pop    acc
 1486: 1  0432	22		              ret
 1487: 1
 1488: 1			;******************************************************************************
 1489: 1			;
 1490: 1			; lcdtoport
 1491: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1492: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1493: 1			; aansturen van de buzzer en backlight.
 1494: 1			;
 1495: 1			; output: b register
 1496: 1			;
 1497: 1			;******************************************************************************
 1498: 1
 1499: 1  0433	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1500: 1  0435	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1501: 1  0437	12 03 20	              lcall  i2cstart      ;vertrokken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1502: 1			ifdef    pcf8574
 1503: 1			              mov    a,#01000000b  ;schrijven naar expander
 1504: 1			endif
 1505: 1			ifdef    pcf8574A
 1506: 1  043A	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1507: 1			endif
 1508: 1  043C	12 03 32	              lcall  i2coutbyte    ;weg er mee
 1509: 1  043F	12 03 73	              lcall  i2cinbytenack ;data inlezen
 1510: 1  0442	12 03 29	              lcall  i2cstop
 1511: 1  0445	F5 F0		              mov    b,a
 1512: 1  0447	D0 D0		              pop    psw
 1513: 1  0449	D0 E0		              pop    acc
 1514: 1  044B	22		              ret
 1515: 1
 1516: 1			;******************************************************************************
 1517: 1			;
 1518: 1			; lcdlighton
 1519: 1			; Dit is een subroutine die de backlight inschakeld
 1520: 1			;
 1521: 1			; Gebruikt geen registers
 1522: 1			;
 1523: 1			;******************************************************************************
 1524: 1
 1525: 1  044C	C0 F0		lcdlighton:   push   b
 1526: 1  044E	12 04 33	              lcall  lcdtoport     ;expander lezen
 1527: 1  0451	C2 F6		              clr    b.6           ;licht aan doen
 1528: 1  0453	12 04 1A	              lcall  porttolcd     ;expander schrijven
 1529: 1  0456	D0 F0		              pop    b
 1530: 1  0458	22		              ret
 1531: 1
 1532: 1
 1533: 1			;******************************************************************************
 1534: 1			;
 1535: 1			; lcdlightoff
 1536: 1			; Dit is een subroutine die de backlight uitschakeld
 1537: 1			;
 1538: 1			; Gebruikt geen registers
 1539: 1			;
 1540: 1			;******************************************************************************
 1541: 1
 1542: 1  0459	C0 F0		lcdlightoff:  push   b
 1543: 1  045B	12 04 33	              lcall  lcdtoport     ;expander lezen
 1544: 1  045E	D2 F6		              setb   b.6           ;licht uit doen
 1545: 1  0460	12 04 1A	              lcall  porttolcd     ;expander schrijven
 1546: 1  0463	D0 F0		              pop    b
 1547: 1  0465	22		              ret
 1548: 1
 1549: 1			;******************************************************************************
 1550: 1			;
 1551: 1			; lcdbuzon
 1552: 1			; Dit is een subroutine die de buzzer inschakeld
 1553: 1			;
 1554: 1			; Gebruikt geen registers
 1555: 1			;
 1556: 1			;******************************************************************************
 1557: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1558: 1  0466	C0 F0		lcdbuzon:     push   b
 1559: 1  0468	12 04 33	              lcall  lcdtoport     ;expander lezen
 1560: 1  046B	C2 F7		              clr    b.7           ;buzzer aan doen
 1561: 1  046D	12 04 1A	              lcall  porttolcd     ;expander schrijven
 1562: 1  0470	D0 F0		              pop    b
 1563: 1  0472	22		              ret
 1564: 1
 1565: 1			;******************************************************************************
 1566: 1			;
 1567: 1			; lcdbuzoff
 1568: 1			; Dit is een subroutine die de buzzer uitschakeld
 1569: 1			;
 1570: 1			; Gebruikt geen registers
 1571: 1			;
 1572: 1			;******************************************************************************
 1573: 1
 1574: 1  0473	C0 F0		lcdbuzoff:    push   b
 1575: 1  0475	12 04 33	              lcall  lcdtoport     ;expander lezen
 1576: 1  0478	D2 F7		              setb   b.7           ;buzzer aan doen
 1577: 1  047A	12 04 1A	              lcall  porttolcd     ;expander schrijven
 1578: 1  047D	D0 F0		              pop    b
 1579: 1  047F	22		              ret
 1580: 1
 1581: 1			endif    ;einde aduc_i2c
 1582: 1			;******************************************************************************
 1583: 1
 1584: 1
 1585: 1
 1586: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1587: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1588: 1			;
 1589: 1			; ADuCsio.inc
 1590: 1			; Is een include file voor de ADuC832 microcontroller.
 1591: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1592: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1593: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1594: 1			; afwijking van de standaard routines is de initsio subroutine.
 1595: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1596: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1597: 1			; zijn.
 1598: 1			;
 1599: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1600: 1			;
 1601: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1602: 1
 1603: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1604: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1605: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1606: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1607: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1608: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1609: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1610: 1
 1611: 1  0480	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1612: 1			                                                        ;van het scherm
 1613: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1614: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1615: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1616: 1
 1617: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1618: 1			;
 1619: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1620: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1621: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1622: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1623: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1624: 1			;
 1625: 1			; de routine gebruikt de psw
 1626: 1			;
 1627: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1628: 1
 1629: 1  0484	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1630: 1  0486	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1631: 1  0488	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1632: 1  048A	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1633: 1  048D	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1634: 1
 1635: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1636: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1637: 1
 1638: 1  048F	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1639: 1  0492	F4		              cpl    a             ;bitbangen om laten uit te komen
 1640: 1  0493	C3		              clr    c             ;verder doen
 1641: 1  0494	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1642: 1  0496	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1643: 1  0498	24 80		              add    a,#080h       ;nu alles in orde
 1644: 1  049A	F5 9E		              mov    t3con,a       ;baud rate klaar
 1645: 1  049C	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1646: 1  049F	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1647: 1  04A0	D0 E0		              pop    acc
 1648: 1  04A2	22		              ret
 1649: 1
 1650: 1  04A3	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1651: 1  04A4	D0 E0		              pop    acc
 1652: 1  04A6	22		              ret
 1653: 1
 1654: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1655: 1			;
 1656: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1657: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1658: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1659: 1			;
 1660: 1			; de routine gebruikt geen registers.
 1661: 1			;
 1662: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1663: 1
 1664: 1  04A7	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1665: 1  04A9	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1666: 1  04AC	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1667: 1  04AE	22		              RET
 1668: 1
 1669: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1670: 1			;
 1671: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1672: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1673: 1			;
 1674: 1			; de routine gebruikt geen registers.
 1675: 1			;
 1676: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1677: 1
 1678: 1  04AF	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1679: 1  04B1	C0 D0		              push   psw
 1680: 1  04B3	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1681: 1  04B5	12 05 C1	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1682: 1  04B8	12 04 A7	              LCALL  OUTCHAR       ;VERSTUREN
 1683: 1  04BB	12 05 08	              LCALL  XONXOFF       ;FLOW CONTROL
 1684: 1  04BE	D0 D0		              pop    psw           ;registers herstellen
 1685: 1  04C0	D0 E0		              pop    acc
 1686: 1  04C2	22		              RET
 1687: 1
 1688: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1689: 1			;
 1690: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1691: 1			; WORDT XONXOFF GEBRUIKT.
 1692: 1			;
 1693: 1			; de routine gebruikt geen registers.
 1694: 1			;
 1695: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1696: 1
 1697: 1  04C3	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1698: 1  04C5	C0 D0		              push   psw
 1699: 1  04C7	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1700: 1  04C9	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1701: 1  04CA	12 04 AF	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1702: 1  04CD	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1703: 1  04CF	12 04 AF	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1704: 1  04D2	D0 D0		              pop    psw           ;registers herstellen
 1705: 1  04D4	D0 E0		              pop    acc
 1706: 1  04D6	22		              RET
 1707: 1
 1708: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1709: 1			;
 1710: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1711: 1			; VAN DE CURSOR.
 1712: 1			;
 1713: 1			; de routine gebruikt geen registers.
 1714: 1			;
 1715: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1716: 1
 1717: 1  04D7	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1718: 1  04D9	C0 D0		              push   psw
 1719: 1  04DB	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1720: 1  04DD	12 04 C3	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1721: 1  04E0	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1722: 1  04E2	12 04 C3	              LCALL  OUTBYTE       ;WEG ER MEE
 1723: 1  04E5	D0 D0		              pop    psw           ;registers herstellen
 1724: 1  04E7	D0 E0		              pop    acc
 1725: 1  04E9	22		              RET                  ;EINDE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1726: 1
 1727: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1728: 1			;
 1729: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1730: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1731: 1			;
 1732: 1			; de routine gebruikt geen registers.
 1733: 1			;
 1734: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1735: 1
 1736: 1  04EA	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1737: 1  04EC	C0 D0		              push   psw
 1738: 1  04EE	C0 82		              push   dpl
 1739: 1  04F0	C0 83		              push   dph
 1740: 1  04F2	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1741: 1  04F3	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1742: 1  04F4	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1743: 1  04F6	12 04 A7	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1744: 1  04F9	12 05 08	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1745: 1  04FC	A3		              INC    DPTR          ;DPTR AANPASSEN
 1746: 1  04FD	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1747: 1  04FF	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1748: 1  0501	D0 82		              pop    dpl
 1749: 1  0503	D0 D0		              pop    psw
 1750: 1  0505	D0 E0		              pop    acc
 1751: 1  0507	22		              RET                  ;EINDE ROUTINE
 1752: 1
 1753: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1754: 1			;
 1755: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1756: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1757: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1758: 1			; VERDER DOORGEGEVEN.
 1759: 1			;
 1760: 1			; de routine gebruikt geen registers.
 1761: 1			;
 1762: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1763: 1
 1764: 1  0508	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1765: 1  050A	C0 D0		              push   psw
 1766: 1  050C	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1767: 1  050F	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 1768: 1  0511	D0 E0		              pop    acc
 1769: 1  0513	22		              RET                  ;ANDERS EINDE
 1770: 1  0514	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1771: 1  0516	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1772: 1  0519	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1773: 1  051C	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1774: 1
 1775: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1776: 1			;
 1777: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1778: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1779: 1			;
 1780: 1			; de routine gebruikt de accu.
 1781: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1782: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1783: 1
 1784: 1  051E	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 1785: 1  0521	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 1786: 1  0523	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1787: 1  0525	22		              RET
 1788: 1
 1789: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1790: 1			;
 1791: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1792: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1793: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 1794: 1			; DE CARRY OP 1 GEZET WORDEN.
 1795: 1			;
 1796: 1			; De routine gebruikt de accu EN PSW.
 1797: 1			;
 1798: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1799: 1
 1800: 1  0526	C0 F0		INBYTE:       PUSH     B
 1801: 1  0528	12 05 1E	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1802: 1  052B	12 05 B4	              LCALL  LOWUPTR
 1803: 1  052E	12 05 CF	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1804: 1  0531	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1805: 1  0533	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1806: 1  0534	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1807: 1  0536	12 05 1E	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1808: 1  0539	12 05 B4	              LCALL  LOWUPTR
 1809: 1  053C	12 05 CF	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1810: 1  053F	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1811: 1  0541	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1812: 1  0543	D0 F0		INBYTE1:      POP     B
 1813: 1  0545	22		              RET
 1814: 1
 1815: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1816: 1			;
 1817: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1818: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1819: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1820: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1821: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1822: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1823: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 1824: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1825: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1826: 1			; bepalen.
 1827: 1			;
 1828: 1			; De routine gebruikt  r0 .
 1829: 1			;
 1830: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1831: 1
 1832: 1  0546	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1833: 1  0548	C0 D0		              push   psw
 1834: 1  054A	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1835: 1  054C	12 05 1E	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 1836: 1  054F	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1837: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1838: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1839: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1840: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 1841: 1			; GEVOERD.
 1842: 1  0551	12 05 B4	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1843: 1  0554	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1844: 1  0557	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1845: 1  0558	D0 D0		              pop    psw                  ;registers herstellen
 1846: 1  055A	D0 E0		              pop    acc
 1847: 1  055C	22		              RET                         ;EINDE VAN DE ROUTINE
 1848: 1
 1849: 1  055D	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 1850: 1  0560	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1851: 1  0563	74 07		INBUFA4:      MOV    A,#BEEP
 1852: 1  0565	12 04 A7	INBUFA7:      LCALL  OUTCHAR
 1853: 1  0568	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1854: 1
 1855: 1  056A	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1856: 1  056B	90 04 80	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1857: 1  056E	12 04 EA	              LCALL  OUTMSGA
 1858: 1  0571	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 1859: 1  0573	12 05 A6	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1860: 1  0576	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1861: 1  0578	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1862: 1  057B	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1863: 1  057D	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1864: 1  057E	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1865: 1  057F	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1866: 1
 1867: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1868: 1			;
 1869: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1870: 1			;
 1871: 1			; De routine gebruikt niets.
 1872: 1			;
 1873: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1874: 1
 1875: 1  0581	C0 E0		BDELETE:      PUSH     ACC
 1876: 1  0583	C0 D0		              PUSH     PSW
 1877: 1  0585	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1878: 1  0586	C0 E0		              PUSH     ACC
 1879: 1  0588	E9		              MOV     A,R1
 1880: 1  0589	C0 E0		              PUSH     ACC
 1881: 1  058B	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1882: 1  058D	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1883: 1  058F	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1884: 1  0590	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1885: 1  0593	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1886: 1  0594	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1887: 1  0597	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1888: 1  0599	F9		              MOV     R1,A
 1889: 1  059A	D0 E0		              POP     ACC
 1890: 1  059C	F8		              MOV     R0,A
 1891: 1  059D	D0 D0		              POP     PSW
 1892: 1  059F	D0 E0		              POP     ACC
 1893: 1  05A1	22		              RET                         ;EINDE VAN DE ROUTINE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1894: 1  05A2	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1895: 1  05A3	09		              INC    R1
 1896: 1  05A4	80 ED		              SJMP   BDELETE3
 1897: 1
 1898: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1899: 1			;
 1900: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1901: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1902: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1903: 1			; AANZIEN.
 1904: 1			;
 1905: 1			; De routine gebruikt de accu en de psw.
 1906: 1			;
 1907: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1908: 1
 1909: 1  05A6	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 1910: 1  05A9	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 1911: 1  05AB	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 1912: 1  05AE	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 1913: 1  05B0	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 1914: 1  05B1	22		              RET
 1915: 1  05B2	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 1916: 1  05B3	22		              RET
 1917: 1
 1918: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1919: 1			;
 1920: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 1921: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 1922: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 1923: 1			; AANGEPAST WORDEN.
 1924: 1			;
 1925: 1			; De routine gebruikt de accu en psw .
 1926: 1			;
 1927: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1928: 1
 1929: 1  05B4	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 1930: 1  05B7	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 1931: 1  05B9	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 1932: 1  05BC	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 1933: 1  05BE	94 20		              SUBB   A,#020H              ;OMZETTING
 1934: 1  05C0	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 1935: 1
 1936: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1937: 1			;
 1938: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 1939: 1			; ASCII CODE.
 1940: 1			;
 1941: 1			; De routine gebruikt de accu .
 1942: 1			;
 1943: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1944: 1
 1945: 1  05C1	C0 D0		BATRANS:      PUSH   PSW
 1946: 1  05C3	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 1947: 1  05C6	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 1948: 1  05C8	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 1949: 1  05CA	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1950: 1  05CC	D0 D0		              POP     PSW
 1951: 1  05CE	22		              RET
 1952: 1
 1953: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1954: 1			;
 1955: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 1956: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 1957: 1			; GEVAL WORDT DE CARRY GEZET.
 1958: 1			;
 1959: 1			; De routine gebruikt de accu en de psw.
 1960: 1			;
 1961: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1962: 1
 1963: 1  05CF	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 1964: 1  05D0	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 1965: 1  05D2	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 1966: 1  05D4	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 1967: 1  05D7	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 1968: 1  05D9	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 1969: 1  05DB	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 1970: 1  05DD	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 1971: 1  05E0	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 1972: 1  05E1	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 1973: 1  05E3	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 1974: 1  05E4	22		ASCBINTRANS1: RET
 1975: 1
 1976: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1977: 1			;
 1978: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 1979: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 1980: 1			;
 1981: 1			; De routine gebruikt de accu en de psw.
 1982: 1			;
 1983: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1984: 1
 1985: 1  05E5	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 1986: 1  05E6	12 05 CF	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 1987: 1  05E9	22		              RET                         ;EINDE OMZETTING
 1988: 1
 1989: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1990: 1			;
 1991: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 1992: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 1993: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 1994: 1			;
 1995: 1			; De routine gebruikt de accu, r0.
 1996: 1			;
 1997: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1998: 1
 1999: 1  05EA	C0 F0		ASCII2:       PUSH   B
 2000: 1  05EC	12 05 E5	              LCALL  ASCII1               ;OMZETTEN
 2001: 1  05EF	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 2002: 1  05F1	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 2003: 1  05F2	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 2004: 1  05F4	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 2005: 1  05F5	12 05 E5	              LCALL  ASCII1               ;KARAKTER OMZETTEN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2006: 1  05F8	40 02		              JC     ASCII21               ;WEG ALS C=1
 2007: 1  05FA	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 2008: 1  05FC	D0 F0		ASCII21:      POP     B
 2009: 1  05FE	22		              RET
 2010: 1
 2011: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2012: 1			;
 2013: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2014: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2015: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2016: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2017: 1			;
 2018: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2019: 1			;
 2020: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2021: 1
 2022: 1  05FF	12 05 EA	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2023: 1  0602	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2024: 1  0604	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2025: 1  0606	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2026: 1  0607	12 05 EA	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2027: 1  060A	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2028: 1  060C	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2029: 1  060E	22		ASCII41:      RET
 2030: 1
 2031: 1			endif        ;einde van aduc_sio
 2032: 1			;*******************************************************************************
 2033: 1
 2034: 1
 2035: 1			ifdef        aduc_math    ;rekenkundige routines
 2036: 1			;*******************************************************************************
 2037: 1			; aduc_math
 2038: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2039: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2040: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2041: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2042: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2043: 1			; zoals aangegeven:
 2044: 1			;
 2045: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2046: 1			;        ---------------------------
 2047: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2048: 1			;        ---------------------------                             statusbit = f0
 2049: 1			;        ---------------------------
 2050: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2051: 1			;        ---------------------------
 2052: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2053: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2054: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2055: 1			; return en moeten hiervoor worden gereserveerd.
 2056: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2057: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2058: 1			; en unsigned getallen.
 2059: 1			;
 2060: 1			; Beschikbare routines:
 2061: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2062: 1			; Conversie routines:
 2063: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2064: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2065: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2066: 1			;
 2067: 1			; Som:
 2068: 1			; s_add16, add16, s_add32, add32
 2069: 1			;
 2070: 1			; Verschil:
 2071: 1			; s_sub16, sub16, s_sub32, sub32
 2072: 1			;
 2073: 1			; Vermenigvuldigen:
 2074: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2075: 1			;
 2076: 1			; Delen:
 2077: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2078: 1			;
 2079: 1			; Vemenigvuldig met factor:
 2080: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2081: 1			;
 2082: 1			; Vierkantswortel:
 2083: 1			; sqrt32, s_sqrt32
 2084: 1			;
 2085: 1			; Schuiven:
 2086: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2087: 1			;
 2088: 1			; Vergelijken:
 2089: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2090: 1			;
 2091: 1			; Tabel lookup:
 2092: 1			; table_lu
 2093: 1			;
 2094: 1			; Gonemetrische functies:
 2095: 1			; Cordic = sinus,cosinus
 2096: 1			;
 2097: 1			;*******************************************************************************
 2098: 1
 2099: 1			;*******************************************************************************
 2100: 1			;
 2101: 1			; bcdhex8     (45,77us @16.777216MHz)
 2102: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2103: 1			; naar een 2's complement hex getal.
 2104: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2105: 1			; een waarde 00h tot 63h.
 2106: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2107: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2108: 1			; input:      R0 = waarde tussen 00h en 99h.
 2109: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2110: 1			; output:     R0 = 2's complement waarde
 2111: 1			;             cy=1 bij out of range van r0
 2112: 1			;             cy=0 bij conversie ok
 2113: 1			; vernietigt: niets
 2114: 1			;*******************************************************************************
 2115: 1  060F	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2116: 1  0611	C0 D0		              push   psw
 2117: 1  0613	C0 F0		              push   b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2118: 1
 2119: 1  0615	E8		              mov    a,r0                 ;neem te converteren waarde
 2120: 1  0616	F5 F0		              mov    b,a
 2121: 1  0618	54 0F		              anl    a,#0fh
 2122: 1  061A	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2123: 1  061D	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2124: 1  061F	E5 F0		              mov    a,b
 2125: 1  0621	54 F0		              anl    a,#0f0h
 2126: 1  0623	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2127: 1  0626	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2128: 1
 2129: 1  0628	E8		              mov    a,r0
 2130: 1  0629	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2131: 1  062B	C4		              swap   a
 2132: 1  062C	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2133: 1  062F	A4		              mul    ab
 2134: 1  0630	F5 F0		              mov    b,a                  ;bewaar dit product even
 2135: 1  0632	E8		              mov    a,r0
 2136: 1  0633	54 0F		              anl    a,#00fh
 2137: 1  0635	F8		              mov    r0,a
 2138: 1  0636	E5 F0		              mov    a,b
 2139: 1  0638	28		              add    a,r0                 ;eenheden er bijtellen
 2140: 1  0639	F8		              mov    r0,a
 2141: 1
 2142: 1  063A	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2143: 1  063C	12 07 3D	              lcall  magsig8              ;omzetten naar 2's complement
 2144: 1
 2145: 1  063F	D0 F0		              pop    b
 2146: 1  0641	D0 D0		              pop    psw
 2147: 1  0643	C2 D7		              clr    cy                   ;geen fout
 2148: 1  0645	D0 E0		              pop    acc
 2149: 1  0647	22		              ret
 2150: 1
 2151: 1  0648	D0 F0		bcdhex82:     pop    b
 2152: 1  064A	D0 D0		              pop    psw
 2153: 1  064C	D2 D7		              setb   cy                   ;fout! r0 out of range
 2154: 1  064E	D0 E0		              pop    acc
 2155: 1  0650	22		              ret
 2156: 1
 2157: 1			;*******************************************************************************
 2158: 1			;
 2159: 1			; hexbcd8     (38,4us @16.777216MHz)
 2160: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2161: 1			; naar een 8bit bcd getal.
 2162: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2163: 1			; bcdgetal van 00h tot +99h.
 2164: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2165: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2166: 1			; bcdgetal 00h tot -99h
 2167: 1			;
 2168: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2169: 1			;
 2170: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2171: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2172: 1			;             cy=1 bij out of range van r0
 2173: 1			;             cy=0 bij conversie ok

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2174: 1			; vernietigt: niets
 2175: 1			;*******************************************************************************
 2176: 1  0651	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2177: 1  0653	C0 D0		                push    psw
 2178: 1  0655	C0 F0		                push    b
 2179: 1  0657	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2180: 1  0658	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2181: 1  065B	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2182: 1  065D	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2183: 1  0660	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2184: 1  0662	D0 F0		                pop     b
 2185: 1  0664	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2186: 1  0666	D3		                setb    c
 2187: 1  0667	D0 E0		                pop     acc
 2188: 1  0669	22		                ret
 2189: 1  066A	12 08 05	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2190: 1  066D	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2191: 1  066E	75 F0 0A	                mov     b,#10
 2192: 1  0671	84		                div     ab
 2193: 1  0672	C4		                swap    a
 2194: 1  0673	25 F0		                add     a,b
 2195: 1  0675	F8		                mov     r0,a
 2196: 1  0676	D0 F0		                pop     b               ;registers herstellen
 2197: 1  0678	D0 E0		                pop     acc             ;psw van stack halen
 2198: 1  067A	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2199: 1  067C	92 E5		                mov     acc.5,c
 2200: 1  067E	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2201: 1  0680	C3		                clr     c               ;status: conversie ok
 2202: 1  0681	D0 E0		                pop     acc
 2203: 1  0683	22		                ret
 2204: 1
 2205: 1
 2206: 1
 2207: 1			;*******************************************************************************
 2208: 1			;
 2209: 1			; bcdhex16    (86,6us @16.777216MHz)
 2210: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2211: 1			; omzetten naar een 2's complement hex getal.
 2212: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2213: 1			; naareen waarde 0000h tot 270fh.
 2214: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2215: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2216: 1			; van -270fh).
 2217: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2218: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2219: 1			; output:     R1,R0 = 2's complement waarde
 2220: 1			;             cy=1 bij out of range van r1,r0
 2221: 1			;             cy=0 bij conversie ok
 2222: 1			; vernietigt: niets
 2223: 1			;*******************************************************************************
 2224: 1  0684	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2225: 1  0686	C0 D0		              push   psw
 2226: 1  0688	C0 F0		              push   b
 2227: 1
 2228: 1  068A	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2229: 1  068B	F5 F0		              mov    b,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2230: 1  068D	54 0F		              anl    a,#0fh
 2231: 1  068F	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2232: 1  0692	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2233: 1  0694	E5 F0		              mov    a,b
 2234: 1  0696	54 F0		              anl    a,#0f0h
 2235: 1  0698	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2236: 1  069B	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2237: 1  069D	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2238: 1  069E	F5 F0		              mov    b,a
 2239: 1  06A0	54 0F		              anl    a,#0fh
 2240: 1  06A2	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2241: 1  06A5	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2242: 1  06A7	E5 F0		              mov    a,b
 2243: 1  06A9	54 F0		              anl    a,#0f0h
 2244: 1  06AB	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2245: 1  06AE	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2246: 1
 2247: 1  06B0	E8		              mov    a,r0                  ;neem low byte voor conversie
 2248: 1  06B1	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2249: 1  06B3	C0 E0		              push   acc                   ;en even bewaren
 2250: 1
 2251: 1  06B5	E8		              mov    a,r0
 2252: 1  06B6	C4		              swap   a
 2253: 1  06B7	54 0F		              anl    a,#00fh              ;tientallen
 2254: 1  06B9	75 F0 0A	              mov    b,#00ah              ;maal tien
 2255: 1  06BC	A4		              mul    ab                   ;
 2256: 1  06BD	D0 F0		              pop    b                    ;neem eenheden
 2257: 1  06BF	25 F0		              add    a,b                  ;tel bij tientallen
 2258: 1  06C1	C0 E0		              push   acc                  ;weer bewaren
 2259: 1
 2260: 1  06C3	E9		              mov    a,r1                 ;neem high byte voor conversie
 2261: 1  06C4	54 F0		              anl    a,#0f0h
 2262: 1  06C6	C4		              swap   a
 2263: 1  06C7	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2264: 1
 2265: 1  06C9	E9		              mov    a,r1                  ;neem high byte voor conversie
 2266: 1  06CA	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2267: 1  06CC	75 F0 64	              mov    b,#100d              ;en maal honderd
 2268: 1  06CF	A4		              mul    ab
 2269: 1  06D0	A9 F0		              mov    r1,b
 2270: 1  06D2	F8		              mov    r0,a
 2271: 1
 2272: 1  06D3	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2273: 1  06D5	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2274: 1  06D8	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2275: 1  06D9	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2276: 1  06DC	A4		              mul    ab
 2277: 1  06DD	28		              add    a,r0                 ;tel honderdtallen bij de
 2278: 1  06DE	F8		              mov    r0,a                 ;duizendtallen
 2279: 1  06DF	E9		              mov    a,r1
 2280: 1  06E0	35 F0		              addc   a,b
 2281: 1  06E2	F9		              mov    r1,a
 2282: 1
 2283: 1  06E3	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2284: 1  06E5	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2285: 1  06E6	F8		              mov    r0,a                 ;duizendtallen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2286: 1  06E7	74 00		              mov    a,#000h
 2287: 1  06E9	39		              addc   a,r1
 2288: 1  06EA	F9		              mov    r1,a                 ;omzetting klaar
 2289: 1
 2290: 1  06EB	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2291: 1  06ED	12 07 71	              lcall  magsig16             ;omzetten naar 2's complement
 2292: 1
 2293: 1  06F0	D0 F0		              pop    b
 2294: 1  06F2	D0 D0		              pop    psw
 2295: 1  06F4	C2 D7		              clr    cy                   ;geen fout
 2296: 1  06F6	D0 E0		              pop    acc
 2297: 1  06F8	22		              ret
 2298: 1
 2299: 1  06F9	D0 F0		bcdhex162:    pop    b
 2300: 1  06FB	D0 D0		              pop    psw
 2301: 1  06FD	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2302: 1  06FF	D0 E0		              pop    acc
 2303: 1  0701	22		              ret
 2304: 1
 2305: 1			;*******************************************************************************
 2306: 1			;
 2307: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2308: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2309: 1			; naar een 24bit bcd getal.
 2310: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2311: 1			; bcdgetal van 000000h tot +032767h.
 2312: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2313: 1			; naar een bcdgetal 000000h tot -032768h
 2314: 1			;
 2315: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2316: 1			;
 2317: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2318: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2319: 1			;
 2320: 1			; vernietigt: niets
 2321: 1			;*******************************************************************************
 2322: 1			;
 2323: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2324: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2325: 1			; naar een 24bit bcd getal.
 2326: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2327: 1			; bcdgetal van 000000h tot 065535h.
 2328: 1			;
 2329: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2330: 1			;
 2331: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2332: 1			;
 2333: 1			; vernietigt: niets
 2334: 1			;*******************************************************************************
 2335: 1  0702	12 08 37	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2336: 1  0705	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2337: 1  0707	C0 D0		                push   psw
 2338: 1  0709	C0 F0		                push   b
 2339: 1  070B	C0 82		                push   dpl
 2340: 1
 2341: 1  070D	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2342: 1  0710	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2343: 1  0712	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2344: 1  0714	12 0B E6	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2345: 1  0717	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2346: 1  0718	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2347: 1			                                        ;dus eerst eenheden, dan tientallen
 2348: 1			                                        ;honderdtallen, duizendtallen en
 2349: 1			                                        ;tienduizendtallen
 2350: 1  071A	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2351: 1
 2352: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2353: 1
 2354: 1  071D	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2355: 1  071F	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2356: 1  0720	D0 E0		                pop    acc              ;duizendtallen ophalen
 2357: 1  0722	C4		                swap   a                ;en combineren met de
 2358: 1  0723	F5 82		                mov    dpl,a
 2359: 1  0725	D0 E0		                pop    acc              ;honderdtallen van de stack
 2360: 1  0727	25 82		                add    a,dpl
 2361: 1  0729	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2362: 1  072A	D0 E0		                pop    acc              ;tientallen van de stack halen
 2363: 1  072C	C4		                swap   a
 2364: 1  072D	F5 82		                mov    dpl,a
 2365: 1  072F	D0 E0		                pop    acc              ;en combineren met de eenheden
 2366: 1  0731	25 82		                add    a,dpl
 2367: 1  0733	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2368: 1
 2369: 1  0734	D0 82		                pop    dpl              ;registers herstellen
 2370: 1  0736	D0 F0		                pop    b
 2371: 1  0738	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2372: 1  073A	D0 E0		                pop    acc
 2373: 1  073C	22		                ret
 2374: 1
 2375: 1			;*******************************************************************************
 2376: 1			; magsig8        (13,6us @16.777216MHz)
 2377: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2378: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2379: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2380: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2381: 1			;           (f0 en f1 zijn 1 als negatief)
 2382: 1			;
 2383: 1			; output:   r0 = 2's complement
 2384: 1			;
 2385: 1			; vernietigt: niets
 2386: 1			;*******************************************************************************
 2387: 1
 2388: 1  073D	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2389: 1  073F	C0 D0		               push   psw
 2390: 1  0741	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2391: 1  0744	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2392: 1  0747	80 09		               sjmp   magsig8c
 2393: 1
 2394: 1  0749	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2395: 1  074C	80 04		               sjmp   magsig8c
 2396: 1
 2397: 1  074E	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2398: 1  074F	F4		               cpl    a                  ;complementeer abs waarde
 2399: 1  0750	04		               inc    a                  ;r0 = complement(r0)+1
 2400: 1  0751	F8		               mov    r0,a               ;bewaar in 2's complement
 2401: 1  0752	D0 D0		magsig8c:      pop    psw
 2402: 1  0754	D0 E0		               pop    acc
 2403: 1  0756	22		               ret                        ;klaar
 2404: 1
 2405: 1			;*******************************************************************************
 2406: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2407: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2408: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2409: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2410: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2411: 1			;           (f0 en f1 zijn 1 als negatief)
 2412: 1			;
 2413: 1			; output:   r4 = 2's complement
 2414: 1			;
 2415: 1			; vernietigt: niets
 2416: 1			;*******************************************************************************
 2417: 1
 2418: 1  0757	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2419: 1  0759	C0 D0		               push    psw
 2420: 1  075B	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2421: 1  075E	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2422: 1  0761	80 EF		               sjmp    magsig8c
 2423: 1
 2424: 1  0763	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2425: 1  0766	80 04		               sjmp    magsig8acc1c
 2426: 1
 2427: 1  0768	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2428: 1  0769	F4		               cpl     a                 ;complementeer abs waarde
 2429: 1  076A	04		               inc     a                 ;r4 = complement(r0)+1
 2430: 1  076B	FC		               mov     r4,a              ;bewaar in 2's complement
 2431: 1  076C	D0 D0		magsig8acc1c:  pop     psw
 2432: 1  076E	D0 E0		               pop     acc
 2433: 1  0770	22		               ret                       ;klaar
 2434: 1
 2435: 1			;*******************************************************************************
 2436: 1			; magsig16        (16,6us @16.777216MHz)
 2437: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2438: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2439: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2440: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2441: 1			;           (f0 en f1 zijn 1 als negatief)
 2442: 1			;
 2443: 1			; output:   r1,r0 = 2's complement
 2444: 1			;
 2445: 1			; vernietigt: niets
 2446: 1			;*******************************************************************************
 2447: 1  0771	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2448: 1  0773	C0 D0		               push    psw
 2449: 1  0775	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2450: 1  0778	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2451: 1  077B	80 0F		               sjmp    magsig16c
 2452: 1
 2453: 1  077D	30 D1 02	magsig16b:     jnb     f1,magsig16a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2454: 1  0780	80 0A		               sjmp    magsig16c
 2455: 1
 2456: 1  0782	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2457: 1  0783	F4		               cpl     a                ;complementeer het dan
 2458: 1  0784	24 01		               add     a, #1            ;en tel er 1 bij
 2459: 1  0786	F8		               mov     r0,a
 2460: 1  0787	E9		               mov     a,r1             ;neem volgende byte
 2461: 1  0788	F4		               cpl     a                ;complementeer en tel carry erbij
 2462: 1  0789	34 00		               addc    a,#0
 2463: 1  078B	F9		               mov     r1,a
 2464: 1  078C	D0 D0		magsig16c:     pop     psw
 2465: 1  078E	D0 E0		               pop     acc
 2466: 1  0790	22		               ret
 2467: 1
 2468: 1			;*******************************************************************************
 2469: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2470: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2471: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2472: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2473: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2474: 1			;           (f0 en f1 zijn 1 als negatief)
 2475: 1			;
 2476: 1			; output:   r5,r4 = 2's complement
 2477: 1			;
 2478: 1			; vernietigt: niets
 2479: 1			;*******************************************************************************
 2480: 1  0791	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2481: 1  0793	C0 D0		                push    psw
 2482: 1  0795	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2483: 1  0798	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2484: 1  079B	80 0F		                sjmp    magsig16acc1c
 2485: 1
 2486: 1  079D	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2487: 1  07A0	80 0A		                sjmp    magsig16acc1c
 2488: 1
 2489: 1  07A2	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2490: 1  07A3	F4		                cpl     a                   ;complementeer het dan
 2491: 1  07A4	24 01		                add     a,#1                ;en tel er 1 bij
 2492: 1  07A6	FC		                mov     r4,a
 2493: 1  07A7	ED		                mov     a,r5                ;neem volgende byte
 2494: 1  07A8	F4		                cpl     a                   ;complementeer en tel carry erbij
 2495: 1  07A9	34 00		                addc    a,#0
 2496: 1  07AB	FD		                mov     r5,a
 2497: 1  07AC	D0 D0		magsig16acc1c:  pop     psw
 2498: 1  07AE	D0 E0		                pop     acc
 2499: 1  07B0	22		                ret
 2500: 1
 2501: 1			;*******************************************************************************
 2502: 1			; magsig32        (22,2us @16.777216MHz)
 2503: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2504: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2505: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2506: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2507: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2508: 1			;           (f0 en f1 zijn 1 als negatief)
 2509: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2510: 1			; output:   r3,r2,r1,r0 = 2's complement
 2511: 1			;
 2512: 1			; vernietigt: niets
 2513: 1			;*******************************************************************************
 2514: 1  07B1	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2515: 1  07B3	C0 D0		               push    psw
 2516: 1  07B5	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2517: 1  07B8	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2518: 1  07BB	80 19		               sjmp    magsig32c
 2519: 1
 2520: 1  07BD	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2521: 1  07C0	80 14		               sjmp    magsig32c
 2522: 1
 2523: 1  07C2	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2524: 1  07C3	F4		               cpl     a                 ;complementeer het dan
 2525: 1  07C4	24 01		               add     a,#1             ;en tel er 1 bij
 2526: 1  07C6	F8		               mov     r0,a
 2527: 1  07C7	E9		               mov     a,r1             ;neem volgende byte
 2528: 1  07C8	F4		               cpl     a                 ;complementeer en tel carry erbij
 2529: 1  07C9	34 00		               addc    a,#0
 2530: 1  07CB	F9		               mov     r1,a
 2531: 1  07CC	EA		               mov     a,r2            ;neem volgende byte
 2532: 1  07CD	F4		               cpl     a                ;complementeer en tel carry erbij
 2533: 1  07CE	34 00		               addc    a,#0
 2534: 1  07D0	FA		               mov     r2,a
 2535: 1  07D1	EB		               mov     a,r3            ;neem volgende byte
 2536: 1  07D2	F4		               cpl     a                ;complementeer en tel carry erbij
 2537: 1  07D3	34 00		               addc    a,#0
 2538: 1  07D5	FB		               mov     r3,a
 2539: 1
 2540: 1  07D6	D0 D0		magsig32c:     pop     psw
 2541: 1  07D8	D0 E0		               pop     acc
 2542: 1  07DA	22		               ret
 2543: 1
 2544: 1
 2545: 1
 2546: 1			;*******************************************************************************
 2547: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2548: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2549: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2550: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2551: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2552: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2553: 1			;           (f0 en f1 zijn 1 als negatief)
 2554: 1			;
 2555: 1			; output:   r7,r6,r5,r4 = 2's complement
 2556: 1			;
 2557: 1			; vernietigt: niets
 2558: 1			;*******************************************************************************
 2559: 1  07DB	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2560: 1  07DD	C0 D0		               push    psw
 2561: 1  07DF	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2562: 1  07E2	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2563: 1  07E5	80 19		               sjmp    magsig32acc1c
 2564: 1
 2565: 1  07E7	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2566: 1  07EA	80 14		               sjmp    magsig32acc1c
 2567: 1
 2568: 1  07EC	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2569: 1  07ED	F4		               cpl     a                 ;complementeer het dan
 2570: 1  07EE	24 01		               add     a,#1             ;en tel er 1 bij
 2571: 1  07F0	FC		               mov     r4,a
 2572: 1  07F1	ED		               mov     a,r5             ;neem volgende byte
 2573: 1  07F2	F4		               cpl     a                 ;complementeer en tel carry erbij
 2574: 1  07F3	34 00		               addc    a,#0
 2575: 1  07F5	FD		               mov     r5,a
 2576: 1  07F6	EE		               mov     a,r6             ;neem volgende byte
 2577: 1  07F7	F4		               cpl     a                 ;complementeer en tel carry erbij
 2578: 1  07F8	34 00		               addc    a,#0
 2579: 1  07FA	FE		               mov     r6,a
 2580: 1  07FB	EF		               mov     a,r7             ;neem volgende byte
 2581: 1  07FC	F4		               cpl     a                ;complementeer en tel carry erbij
 2582: 1  07FD	34 00		               addc    a,#0
 2583: 1  07FF	FF		               mov     r7,a
 2584: 1
 2585: 1  0800	D0 D0		magsig32acc1c: pop     psw
 2586: 1  0802	D0 E0		               pop     acc
 2587: 1  0804	22		               ret
 2588: 1
 2589: 1
 2590: 1			;*******************************************************************************
 2591: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2592: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2593: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2594: 1			; input:     r0 = 2's complement byte in acc0
 2595: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2596: 1			; output:    r0 = absolute waarde
 2597: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2598: 1			;
 2599: 1			; vernietigt: niets
 2600: 1			;*******************************************************************************
 2601: 1
 2602: 1  0805	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2603: 1  0807	C0 D0		                push    psw
 2604: 1  0809	E8		                mov     a,r0               ;neem lsb van acc0
 2605: 1  080A	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2606: 1  080D	D0 D0		                pop     psw
 2607: 1  080F	C2 D5		                clr     f0                 ;nee, positief...klaar
 2608: 1  0811	D0 E0		                pop     acc
 2609: 1  0813	22		                ret
 2610: 1  0814	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2611: 1  0815	04		                inc     a                   ;een erbij
 2612: 1  0816	F8		                mov     r0,a               ;bewaar
 2613: 1  0817	D0 D0		                pop     psw
 2614: 1  0819	D2 D5		                setb    f0                 ;f0=1 als negatief
 2615: 1  081B	D0 E0		                pop     acc
 2616: 1  081D	22		                ret
 2617: 1
 2618: 1			;*******************************************************************************
 2619: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2620: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2621: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2622: 1			; input:     r4 = 2's complement byte in acc1
 2623: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2624: 1			; output:    r4 = absolute waarde
 2625: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2626: 1			;
 2627: 1			; vernietigt: niets
 2628: 1			;*******************************************************************************
 2629: 1
 2630: 1  081E	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2631: 1  0820	C0 D0		                push    psw
 2632: 1  0822	EC		                mov     a,r4               ;neem lsb van acc0
 2633: 1  0823	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2634: 1  0826	D0 D0		                pop     psw
 2635: 1  0828	C2 D1		                clr     f1                 ;nee, positief...klaar
 2636: 1  082A	D0 E0		                pop     acc
 2637: 1  082C	22		                ret
 2638: 1  082D	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2639: 1  082E	04		                inc     a                   ;een erbij
 2640: 1  082F	FC		                mov     r4,a               ;bewaar
 2641: 1  0830	D0 D0		                pop     psw
 2642: 1  0832	D2 D1		                setb    f1                 ;f0=1 als negatief
 2643: 1  0834	D0 E0		                pop     acc
 2644: 1  0836	22		                ret
 2645: 1
 2646: 1			;*******************************************************************************
 2647: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2648: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2649: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2650: 1			; input:     r1,r0 = 2's complement word in acc0
 2651: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2652: 1			; output:    r1,r0 = absolute waarde
 2653: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2654: 1			;
 2655: 1			; vernietigt: niets
 2656: 1			;*******************************************************************************
 2657: 1
 2658: 1  0837	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2659: 1  0839	C0 D0		                push    psw
 2660: 1  083B	E9		                mov     a,r1               ; neem msb van acc0
 2661: 1  083C	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2662: 1  083F	D0 D0		                pop     psw
 2663: 1  0841	C2 D5		                clr     f0                 ;f0=0 als positief
 2664: 1  0843	D0 E0		                pop     acc
 2665: 1  0845	22		                ret                        ;klaar
 2666: 1
 2667: 1  0846	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2668: 1  0847	F4		                cpl     a                  ;complementeren
 2669: 1  0848	24 01		                add     a,#1               ;en een bijtellen
 2670: 1  084A	F8		                mov     r0,a
 2671: 1  084B	E9		                mov     a,r1
 2672: 1  084C	F4		                cpl     a                  ;complement eer volgende byte
 2673: 1  084D	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2674: 1  084F	F9		                mov     r1,a
 2675: 1  0850	D0 D0		                pop     psw
 2676: 1  0852	D2 D5		                setb    f0                 ;f0=1 als negatief
 2677: 1  0854	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2678: 1  0856	22		                ret
 2679: 1
 2680: 1
 2681: 1			;*******************************************************************************
 2682: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2683: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2684: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2685: 1			; input:     r5,r4 = 2's complement word in acc1
 2686: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2687: 1			; output:    r5,r4 = absolute waarde
 2688: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2689: 1			;
 2690: 1			; vernietigt: niets
 2691: 1			;*******************************************************************************
 2692: 1
 2693: 1  0857	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2694: 1  0859	C0 D0		                push    psw
 2695: 1  085B	ED		                mov     a,r5               ;neem msb van acc1
 2696: 1  085C	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2697: 1  085F	D0 D0		                pop     psw
 2698: 1  0861	C2 D1		                clr     f1                 ;f1=0 als positief
 2699: 1  0863	D0 E0		                pop    acc
 2700: 1  0865	22		                ret                        ;klaar
 2701: 1
 2702: 1  0866	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2703: 1  0867	F4		                cpl     a                   ;complementeren
 2704: 1  0868	24 01		                add     a,#1               ;en een bijtellen
 2705: 1  086A	FC		                mov     r4,a
 2706: 1  086B	ED		                mov     a,r5
 2707: 1  086C	F4		                cpl     a                  ;complementeer volgende byte
 2708: 1  086D	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2709: 1  086F	FD		                mov     r5,a
 2710: 1  0870	D0 D0		                pop     psw
 2711: 1  0872	D2 D1		                setb    f1                ;f1=1 als negatief
 2712: 1  0874	D0 E0		                pop     acc
 2713: 1  0876	22		                ret
 2714: 1
 2715: 1
 2716: 1			;*******************************************************************************
 2717: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2718: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2719: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2720: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2721: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2722: 1			; output:    r7,r6 = absolute waarde
 2723: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2724: 1			;
 2725: 1			; vernietigt: niets
 2726: 1			;*******************************************************************************
 2727: 1
 2728: 1  0877	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2729: 1  0879	C0 D0		                push    psw
 2730: 1  087B	EF		                mov     a,r7                ; neem msb van acc1 high
 2731: 1  087C	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2732: 1  087F	D0 D0		                pop     psw
 2733: 1  0881	C2 D5		                clr     f0                  ;f0=0 als positief

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2734: 1  0883	D0 E0		                pop     acc
 2735: 1  0885	22		                ret                         ;klaar
 2736: 1
 2737: 1  0886	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2738: 1  0887	F4		                cpl     a                   ;complementeren
 2739: 1  0888	24 01		                add     a,#1               ;en een bijtellen
 2740: 1  088A	FE		                mov     r6,a
 2741: 1  088B	EF		                mov     a,r7
 2742: 1  088C	F4		                cpl     a                  ;complementeer volgende byte
 2743: 1  088D	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2744: 1  088F	FF		                mov     r7,a
 2745: 1  0890	D0 D0		                pop     psw
 2746: 1  0892	D2 D5		                setb    f0                ;f0=1 als negatief
 2747: 1  0894	D0 E0		                pop     acc
 2748: 1  0896	22		                ret
 2749: 1
 2750: 1
 2751: 1			;*******************************************************************************
 2752: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2753: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2754: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 2755: 1			;
 2756: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2757: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2758: 1			;            (-2147483648 tot +2147483647)
 2759: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2760: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2761: 1			;
 2762: 1			; vernietigt: niets
 2763: 1			;*******************************************************************************
 2764: 1
 2765: 1  0897	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2766: 1  0899	C0 D0		                push    psw
 2767: 1  089B	EB		                mov     a,r3               ;neem msb van acc0
 2768: 1  089C	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2769: 1  089F	D0 D0		                pop     psw                ;nee, positief
 2770: 1  08A1	C2 D5		                clr     f0
 2771: 1  08A3	D0 E0		                pop     acc
 2772: 1  08A5	22		                ret                        ;klaar
 2773: 1
 2774: 1  08A6	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2775: 1  08A7	F4		                cpl     a                  ;complementeren
 2776: 1  08A8	24 01		                add     a,#1               ;en een bijtellen
 2777: 1  08AA	F8		                mov     r0,a
 2778: 1  08AB	E9		                mov     a,r1               ;neem volgende byte
 2779: 1  08AC	F4		                cpl     a                  ;complementeer volgende byte
 2780: 1  08AD	34 00		                addc    a,#0
 2781: 1  08AF	F9		                mov     r1,a
 2782: 1  08B0	EA		                mov     a,r2               ;neem volgende byte
 2783: 1  08B1	F4		                cpl     a                  ;complementeer volgende byte
 2784: 1  08B2	34 00		                addc    a,#0
 2785: 1  08B4	FA		                mov     r2,a
 2786: 1  08B5	EB		                mov     a,r3               ;neem volgende byte
 2787: 1  08B6	F4		                cpl     a                  ;complementeer volgende byte
 2788: 1  08B7	34 00		                addc    a,#0
 2789: 1  08B9	FB		                mov     r3,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2790: 1  08BA	D0 D0		                pop     psw
 2791: 1  08BC	D2 D5		                setb    f0                 ;negatief: f0=1
 2792: 1  08BE	D0 E0		                pop     acc
 2793: 1  08C0	22		                ret                        ;klaar
 2794: 1
 2795: 1			;*******************************************************************************
 2796: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2797: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2798: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2799: 1			;
 2800: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2801: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2802: 1			;            (-2147483648 tot +2147483647)
 2803: 1			; output:    r7,r6,r5,r4 = absolute waarde
 2804: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2805: 1			;
 2806: 1			; vernietigt: niets
 2807: 1			;*******************************************************************************
 2808: 1
 2809: 1  08C1	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2810: 1  08C3	C0 D0		                push    psw
 2811: 1  08C5	EF		                mov     a,r7               ;neem msb van acc0
 2812: 1  08C6	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2813: 1  08C9	D0 D0		                pop     psw                ;nee, positief
 2814: 1  08CB	C2 D1		                clr     f1
 2815: 1  08CD	D0 E0		                pop     acc
 2816: 1  08CF	22		                ret                        ;klaar
 2817: 1
 2818: 1  08D0	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2819: 1  08D1	F4		                cpl     a                   ;complementeren
 2820: 1  08D2	24 01		                add     a,#1               ;en een bijtellen
 2821: 1  08D4	FC		                mov     r4,a
 2822: 1  08D5	ED		                mov     a,r5               ;neem volgende byte
 2823: 1  08D6	F4		                cpl     a                  ;complementeer volgende byte
 2824: 1  08D7	34 00		                addc    a,#0
 2825: 1  08D9	FD		                mov     r5,a
 2826: 1  08DA	EE		                mov     a,r6               ;neem volgende byte
 2827: 1  08DB	F4		                cpl     a                  ;complementeer volgende byte
 2828: 1  08DC	34 00		                addc    a,#0
 2829: 1  08DE	FE		                mov     r6,a
 2830: 1  08DF	EF		                mov     a,r7               ;neem volgende byte
 2831: 1  08E0	F4		                cpl     a                  ;complementeer volgende byte
 2832: 1  08E1	34 00		                addc    a,#0
 2833: 1  08E3	FF		                mov     r7,a
 2834: 1  08E4	D0 D0		                pop     psw
 2835: 1  08E6	D2 D1		                setb    f1                 ;negatief: f0=1
 2836: 1  08E8	D0 E0		                pop     acc
 2837: 1  08EA	22		                ret                        ;klaar
 2838: 1
 2839: 1
 2840: 1			;*******************************************************************************
 2841: 1			; s_add16        (19,35us @16.777216MHz)
 2842: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2843: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2844: 1			; input:     r1,r0 = acc0
 2845: 1			;            r5,r4 = acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2846: 1			;
 2847: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2848: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2849: 1			;                  gebruik van r3,r2 is niet nodig
 2850: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2851: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2852: 1			;
 2853: 1			; vernietigt:  niets
 2854: 1			;*******************************************************************************
 2855: 1  08EB	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2856: 1  08ED	C0 D0		               push    psw
 2857: 1
 2858: 1  08EF	E8		               mov     a,r0           ;tel de soft accumulators op
 2859: 1  08F0	2C		               add     a,r4           ;low byte eerst
 2860: 1  08F1	F8		               mov     r0,a           ;resultaat bewaren
 2861: 1  08F2	E9		               mov     a,r1           ;nu de high bytes
 2862: 1  08F3	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2863: 1  08F4	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2864: 1
 2865: 1  08F5	92 D5		               mov     f0,c
 2866: 1  08F7	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 2867: 1  08F9	92 D1		               mov     f1,c
 2868: 1  08FB	A2 D5		               mov     c,f0           ;herstel carrybit
 2869: 1
 2870: 1  08FD	74 00		               mov     a,#00h
 2871: 1  08FF	34 00		               addc    a,#00h
 2872: 1  0901	FA		               mov     r2,a            ;24bit resultaat klaar
 2873: 1
 2874: 1  0902	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2875: 1
 2876: 1  0905	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2877: 1  0906	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2878: 1  0909	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 2879: 1  090B	7B FF		               mov     r3,#0ffh
 2880: 1  090D	80 04		               sjmp    s_add162
 2881: 1  090F	7A 00		s_add161:      mov     r2,#00h
 2882: 1  0911	7B 00		               mov     r3,#00h
 2883: 1  0913	D0 D0		s_add162:      pop     psw
 2884: 1  0915	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2885: 1  0916	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2886: 1  0918	22		               ret
 2887: 1
 2888: 1  0919	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2889: 1  091B	C3		               clr     c
 2890: 1  091C	D0 E0		               pop     acc
 2891: 1  091E	22		               ret
 2892: 1
 2893: 1			;*******************************************************************************
 2894: 1			; add16        (13,6us @16.777216MHz)
 2895: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2896: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2897: 1			; input:     r1,r0 = acc0
 2898: 1			;            r5,r4 = acc1
 2899: 1			;
 2900: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2901: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2902: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2903: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 2904: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 2905: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 2906: 1			;
 2907: 1			; vernietigt:  niets
 2908: 1			;*******************************************************************************
 2909: 1
 2910: 1  091F	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 2911: 1  0921	C0 D0		               push    psw
 2912: 1  0923	E8		               mov     a,r0           ;tel de soft accumulators op
 2913: 1  0924	2C		               add     a,r4           ;low byte eerst
 2914: 1  0925	F8		               mov     r0,a           ;resultaat bewaren
 2915: 1  0926	E9		               mov     a,r1           ;nu de high bytes
 2916: 1  0927	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2917: 1  0928	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2918: 1  0929	50 08		               jnc     add161          ;geen 24 bit resultaat
 2919: 1
 2920: 1  092B	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 2921: 1  092D	D0 D0		               pop     psw
 2922: 1  092F	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2923: 1  0930	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 2924: 1  0932	22		               ret
 2925: 1
 2926: 1  0933	7A 00		add161:        mov     r2,#00h
 2927: 1  0935	D0 D0		               pop     psw
 2928: 1  0937	C3		               clr     c               ;aangeven aan de gebruiker dat het
 2929: 1  0938	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 2930: 1  093A	22		               ret
 2931: 1
 2932: 1			;*******************************************************************************
 2933: 1			; s_add32        (28,0us @16.777216MHz)
 2934: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2935: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 2936: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2937: 1			; input:     r3,r2,r1,r0 = acc0
 2938: 1			;            r7,r6,r5,r4 = acc1
 2939: 1			;
 2940: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2941: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2942: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 2943: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 2944: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 2945: 1			;
 2946: 1			; vernietigt:  niets
 2947: 1			;*******************************************************************************
 2948: 1  093B	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 2949: 1  093D	C0 D0		               push    psw
 2950: 1
 2951: 1  093F	E8		               mov     a,r0           ;tel de soft accumulators op
 2952: 1  0940	2C		               add     a,r4           ;low byte eerst
 2953: 1  0941	F8		               mov     r0,a           ;resultaat bewaren
 2954: 1  0942	E9		               mov     a,r1           ;nu de hogere bytes
 2955: 1  0943	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2956: 1  0944	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2957: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2958: 1  0945	EA		               mov     a,r2           ;derde bytes optellen
 2959: 1  0946	3E		               addc    a,r6           ;optellen met eventuele overdracht
 2960: 1  0947	FA		               mov     r2,a           ;24bit resultaat is klaar
 2961: 1  0948	EB		               mov     a,r3           ;nu de ms bytes
 2962: 1  0949	3F		               addc    a,r7           ;optellen met eventuele overdracht
 2963: 1  094A	FB		               mov     r3,a           ;32 bit resultaat is klaar
 2964: 1
 2965: 1  094B	92 D5		               mov     f0,c
 2966: 1  094D	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 2967: 1  094F	92 D1		               mov     f1,c
 2968: 1  0951	A2 D5		               mov     c,f0           ;herstel carrybit
 2969: 1
 2970: 1  0953	74 00		               mov     a,#00h
 2971: 1  0955	34 00		               addc    a,#00h
 2972: 1  0957	FC		               mov     r4,a            ;40bit resultaat klaar
 2973: 1
 2974: 1  0958	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 2975: 1  095B	EC		               mov     a,r4            ;ja, sign extention toepassen!
 2976: 1  095C	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 2977: 1  095F	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 2978: 1  0961	80 02		               sjmp    s_add322
 2979: 1  0963	7C 00		s_add321:      mov     r4,#00h
 2980: 1  0965	D0 D0		s_add322:      pop     psw
 2981: 1  0967	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2982: 1  0968	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 2983: 1  096A	22		               ret
 2984: 1
 2985: 1  096B	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 2986: 1  096D	C3		               clr     c
 2987: 1  096E	D0 E0		               pop     acc
 2988: 1  0970	22		               ret
 2989: 1
 2990: 1
 2991: 1			;*******************************************************************************
 2992: 1			; add32        (18,0us @16.777216MHz)
 2993: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 2994: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 2995: 1			; input:     r3,r2,r1,r0 = acc0
 2996: 1			;            r7,r6,r5,r4 = acc1
 2997: 1			;
 2998: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 2999: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3000: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3001: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 3002: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3003: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3004: 1			;
 3005: 1			; vernietigt:  niets
 3006: 1			;*******************************************************************************
 3007: 1  0971	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 3008: 1  0973	C0 D0		               push    psw
 3009: 1  0975	E8		               mov     a,r0           ;tel de soft accumulators op
 3010: 1  0976	2C		               add     a,r4           ;low byte eerst
 3011: 1  0977	F8		               mov     r0,a           ;resultaat bewaren
 3012: 1  0978	E9		               mov     a,r1           ;nu de hogere bytes
 3013: 1  0979	3D		               addc    a,r5           ;optellen met eventuele overdracht

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3014: 1  097A	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3015: 1
 3016: 1  097B	EA		               mov     a,r2           ;derde bytes optellen
 3017: 1  097C	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3018: 1  097D	FA		               mov     r2,a           ;24bit resultaat is klaar
 3019: 1  097E	EB		               mov     a,r3           ;nu de ms bytes
 3020: 1  097F	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3021: 1  0980	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3022: 1
 3023: 1  0981	50 08		               jnc     add321          ;geen 40 bit resultaat
 3024: 1
 3025: 1  0983	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3026: 1  0985	D0 D0		               pop     psw
 3027: 1  0987	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3028: 1  0988	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3029: 1  098A	22		               ret
 3030: 1
 3031: 1  098B	7C 00		add321:        mov     r4,#00h
 3032: 1  098D	D0 D0		               pop     psw
 3033: 1  098F	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3034: 1  0990	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3035: 1  0992	22		               ret
 3036: 1
 3037: 1
 3038: 1			;*******************************************************************************
 3039: 1			; s_sub16        (24,4us @16.777216MHz)
 3040: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3041: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3042: 1			; input:     r1,r0 = acc0
 3043: 1			;            r5,r4 = acc1
 3044: 1			;
 3045: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3046: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3047: 1			;                  gebruik van r3,r2 is niet nodig
 3048: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3049: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3050: 1			;
 3051: 1			; vernietigt:  niets
 3052: 1			;*******************************************************************************
 3053: 1  0993	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3054: 1  0995	C0 D0		                push    psw
 3055: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3056: 1
 3057: 1  0997	EC		                mov   	a,r4            ;verander het teken van acc1
 3058: 1  0998	F4		                cpl    	a               ;door het 2's complement te nemen
 3059: 1  0999	24 01		                add   	a,#1
 3060: 1  099B	FC		                mov    	r4,a
 3061: 1  099C	ED		                mov    	a,r5
 3062: 1  099D	F4		                cpl    	a
 3063: 1  099E	34 00		                addc	a,#0
 3064: 1  09A0	FD		                mov    	r5,a
 3065: 1			;acc0+acc1
 3066: 1  09A1	E8						mov		a,r0
 3067: 1  09A2	2C						add		a,r4
 3068: 1  09A3	F8						mov		r0,a
 3069: 1  09A4	E9						mov		a,r1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3070: 1  09A5	3D						addc	a,r5
 3071: 1  09A6	F9						mov		r1,a
 3072: 1
 3073: 1  09A7	92 D5		                mov    f0,c
 3074: 1  09A9	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3075: 1  09AB	92 D1		                mov    f1,c
 3076: 1  09AD	A2 D5		                mov    c,f0            ;herstel carrybit
 3077: 1
 3078: 1  09AF	74 00		                mov    a,#00h
 3079: 1  09B1	34 00		                addc   a,#00h
 3080: 1  09B3	FA		                mov    r2,a            ;24bit resultaat klaar
 3081: 1
 3082: 1  09B4	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3083: 1  09B7	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3084: 1  09B8	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3085: 1  09BB	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3086: 1  09BD	7B FF		                mov    r3,#0ffh
 3087: 1  09BF	80 04		                sjmp   s_sub162
 3088: 1  09C1	7A 00		s_sub161:       mov    r2,#00h
 3089: 1  09C3	7B 00		                mov    r3,#00h
 3090: 1  09C5	D0 D0		s_sub162:       pop    psw
 3091: 1  09C7	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3092: 1  09C8	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3093: 1  09CA	22		                ret
 3094: 1
 3095: 1  09CB	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3096: 1  09CD	C3		                clr    c
 3097: 1  09CE	D0 E0		                pop    acc
 3098: 1  09D0	22		                ret
 3099: 1
 3100: 1			;*******************************************************************************
 3101: 1			; sub16            (14,4us @16.777216MHz)
 3102: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3103: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3104: 1			; input:     r1,r0 = acc0
 3105: 1			;            r5,r4 = acc1
 3106: 1			;
 3107: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3108: 1			;            bij een underflow r2 op ffh zetten
 3109: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3110: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3111: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3112: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3113: 1			;
 3114: 1			; vernietigt:  niets
 3115: 1			;*******************************************************************************
 3116: 1
 3117: 1  09D1	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3118: 1  09D3	C0 D0		                push    psw
 3119: 1  09D5	C3		                clr     c
 3120: 1  09D6	E8		                mov     a,r0            ;tel de soft accumulators op
 3121: 1  09D7	9C		                subb    a,r4            ;low byte eerst
 3122: 1  09D8	F8		                mov     r0,a            ;resultaat bewaren
 3123: 1  09D9	E9		                mov     a,r1            ;nu de high bytes
 3124: 1  09DA	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3125: 1  09DB	F9		                mov    r1,a             ;16 bit resultaat is klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3126: 1  09DC	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3127: 1
 3128: 1  09DE	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3129: 1  09E0	D0 D0		                pop     psw
 3130: 1  09E2	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3131: 1  09E3	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3132: 1  09E5	22		                ret
 3133: 1
 3134: 1  09E6	7A 00		sub161:         mov     r2,#00h
 3135: 1  09E8	D0 D0		                pop     psw
 3136: 1  09EA	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3137: 1  09EB	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3138: 1  09ED	22		                ret
 3139: 1
 3140: 1			;*******************************************************************************
 3141: 1			; s_sub32        (27,2us @16.777216MHz)
 3142: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3143: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3144: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3145: 1			; input:     r3,r2,r1,r0 = acc0
 3146: 1			;            r7,r6,r5,r4 = acc1
 3147: 1			;
 3148: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3149: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3150: 1			;                  gebruik van r4 is niet nodig
 3151: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3152: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3153: 1			;
 3154: 1			; vernietigt:  niets
 3155: 1			;*******************************************************************************
 3156: 1  09EE	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3157: 1  09F0	C0 D0		                push   psw
 3158: 1
 3159: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3160: 1
 3161: 1  09F2	EC		                mov    	a,r4            ;verander het teken van acc1
 3162: 1  09F3	F4		                cpl    	a               ;door het 2's complement te nemen
 3163: 1  09F4	24 01		                add    	a,#1
 3164: 1  09F6	FC		                mov    	r4,a
 3165: 1  09F7	ED		                mov    	a,r5
 3166: 1  09F8	F4		                cpl    	a
 3167: 1  09F9	34 00		                addc	a,#0
 3168: 1  09FB	FD		                mov    	r5,a
 3169: 1  09FC	EE		                mov    	a,r6
 3170: 1  09FD	F4		                cpl    	a
 3171: 1  09FE	34 00		                addc   	a,#0
 3172: 1  0A00	FE		                mov    	r6,a
 3173: 1  0A01	EF		                mov    	a,r7
 3174: 1  0A02	F4		                cpl    	a
 3175: 1  0A03	34 00		                addc   	a,#0
 3176: 1  0A05	FF		                mov    	r7,a
 3177: 1			;acc0+acc1
 3178: 1  0A06	E8						mov		a,r0
 3179: 1  0A07	2C						add		a,r4
 3180: 1  0A08	F8						mov		r0,a
 3181: 1  0A09	E9						mov		a,r1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3182: 1  0A0A	3D						addc	a,r5
 3183: 1  0A0B	F9						mov		r1,a
 3184: 1  0A0C	EA						mov		a,r2
 3185: 1  0A0D	3E						addc	a,r6
 3186: 1  0A0E	FA						mov		r2,a
 3187: 1  0A0F	EB						mov		a,r3
 3188: 1  0A10	3F						addc	a,r7
 3189: 1  0A11	FB						mov		r3,a
 3190: 1
 3191: 1  0A12	92 D5		                mov   f0,c
 3192: 1  0A14	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3193: 1  0A16	92 D1		                mov   f1,c
 3194: 1  0A18	A2 D5		                mov   c,f0            ;herstel carrybit
 3195: 1
 3196: 1  0A1A	74 00		                mov   a,#00h
 3197: 1  0A1C	34 00		                addc  a,#00h
 3198: 1  0A1E	FC		                mov   r4,a            ;40bit resultaat klaar
 3199: 1
 3200: 1  0A1F	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3201: 1
 3202: 1  0A22	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3203: 1  0A23	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3204: 1  0A26	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3205: 1  0A28	80 02		                sjmp   s_sub322
 3206: 1  0A2A	7C 00		s_sub321:       mov   r4,#00h
 3207: 1  0A2C	D0 D0		s_sub322:       pop   psw
 3208: 1  0A2E	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3209: 1  0A2F	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3210: 1  0A31	22		                ret
 3211: 1
 3212: 1  0A32	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3213: 1  0A34	C3		                clr   c
 3214: 1  0A35	D0 E0		                pop   acc
 3215: 1  0A37	22		                ret
 3216: 1
 3217: 1
 3218: 1			;*******************************************************************************
 3219: 1			; sub32        (18,7us @16.777216MHz)
 3220: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3221: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3222: 1			; input:     r3,r2,r1,r0 = acc0
 3223: 1			;            r7,r6,r5,r4 = acc1
 3224: 1			;
 3225: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3226: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3227: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3228: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3229: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3230: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3231: 1			;
 3232: 1			; vernietigt:  niets
 3233: 1			;*******************************************************************************
 3234: 1  0A38	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3235: 1  0A3A	C0 D0		               push    psw
 3236: 1  0A3C	C3		               clr       c
 3237: 1  0A3D	E8		               mov     a,r0           ;maak verschil van de soft accumulators

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3238: 1  0A3E	9C		               subb    a,r4           ;low byte eerst
 3239: 1  0A3F	F8		               mov     r0,a           ;resultaat bewaren
 3240: 1  0A40	E9		               mov     a,r1           ;nu de hogere bytes
 3241: 1  0A41	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3242: 1  0A42	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3243: 1
 3244: 1  0A43	EA		               mov     a,r2           ;derde bytes optellen
 3245: 1  0A44	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3246: 1  0A45	FA		               mov     r2,a           ;24bit resultaat is klaar
 3247: 1  0A46	EB		               mov     a,r3           ;nu de ms bytes
 3248: 1  0A47	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3249: 1  0A48	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3250: 1
 3251: 1  0A49	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3252: 1
 3253: 1  0A4B	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3254: 1  0A4D	D0 D0		               pop     psw
 3255: 1  0A4F	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3256: 1  0A50	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3257: 1  0A52	22		               ret
 3258: 1
 3259: 1  0A53	7C 00		sub321:        mov     r4,#00h
 3260: 1  0A55	D0 D0		               pop     psw
 3261: 1  0A57	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3262: 1  0A58	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3263: 1  0A5A	22		               ret
 3264: 1
 3265: 1
 3266: 1
 3267: 1			;*******************************************************************************
 3268: 1			; mul16        (71,2us @16.777216MHz)
 3269: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3270: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3271: 1			; input:     r1,r0 = acc0
 3272: 1			;            r5,r4 = acc1
 3273: 1			;
 3274: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3275: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3276: 1			;
 3277: 1			; vernietigt:  niets
 3278: 1			;*******************************************************************************
 3279: 1  0A5B	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3280: 1  0A5D	C0 D0		                push    psw
 3281: 1  0A5F	C0 F0		                push    b
 3282: 1  0A61	C0 82		                push    dpl
 3283: 1  0A63	C0 83		                push    dph
 3284: 1
 3285: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3286: 1
 3287: 1  0A65	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3288: 1  0A67	89 83		                mov     dph,r1
 3289: 1  0A69	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3290: 1  0A6B	08		                inc     r0              ;pointer naar eerste vrije plaats
 3291: 1  0A6C	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3292: 1  0A6E	E5 81		                mov     a,sp            ;plaats alloceren
 3293: 1  0A70	24 03		                add     a,#3            ;3 bytes nodig

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3294: 1  0A72	F5 81		                mov     sp,a            ;stackpointer verzetten
 3295: 1
 3296: 1  0A74	E5 82		                mov     a,dpl            ;acc0 lsb
 3297: 1  0A76	8C F0		                mov     b,r4            ;acc1 lsb
 3298: 1  0A78	A4		                mul     ab
 3299: 1  0A79	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3300: 1  0A7A	08		                inc     r0
 3301: 1  0A7B	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3302: 1
 3303: 1  0A7D	E5 83		                mov     a,dph            ;acc0 msb
 3304: 1  0A7F	8C F0		                mov     b,r4            ;acc1 lsb
 3305: 1  0A81	A4		                mul     ab
 3306: 1
 3307: 1  0A82	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3308: 1  0A83	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3309: 1  0A84	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3310: 1  0A86	34 00		                addc    a,#0
 3311: 1  0A88	08		                inc     r0               ;bewaar als tussenresultaat
 3312: 1  0A89	F6		                mov     @r0,a
 3313: 1
 3314: 1  0A8A	E5 82		                mov     a,dpl            ;acc0 lsb
 3315: 1  0A8C	8D F0		                mov     b,r5             ;acc1 msb
 3316: 1  0A8E	A4		                mul     ab
 3317: 1  0A8F	18		                dec     r0
 3318: 1  0A90	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3319: 1  0A91	F6		                mov     @r0,a            ;en bewaar weer
 3320: 1  0A92	08		                inc     r0
 3321: 1  0A93	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3322: 1  0A95	36		                addc    a,@r0
 3323: 1  0A96	F6		                mov     @r0,a            ;en bewaar weer
 3324: 1  0A97	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3325: 1
 3326: 1  0A99	E5 83		                mov     a,dph            ;acc0 msb
 3327: 1  0A9B	8D F0		                mov     b,r5             ;acc1 msb
 3328: 1  0A9D	A4		                mul     AB
 3329: 1  0A9E	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3330: 1  0A9F	FA		                mov     r2,a
 3331: 1  0AA0	E5 F0		                mov     a,b
 3332: 1  0AA2	34 00		                addc    a,#0
 3333: 1
 3334: 1  0AA4	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3335: 1  0AA6	34 00		                addc    a,#0
 3336: 1
 3337: 1  0AA8	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3338: 1  0AA9	18		                dec     r0
 3339: 1  0AAA	86 83		                mov     dph,@r0
 3340: 1  0AAC	18		                dec     r0
 3341: 1  0AAD	86 82		                mov     dpl,@r0
 3342: 1
 3343: 1  0AAF	89 81		                mov     sp,r1            ;zet stackpointer terug
 3344: 1  0AB1	A9 83		                mov     r1,dph
 3345: 1  0AB3	A8 82		                mov     r0,dpl
 3346: 1
 3347: 1  0AB5	D0 83		                pop     dph              ;herstel de bewaarde registers
 3348: 1  0AB7	D0 82		                pop     dpl
 3349: 1  0AB9	D0 F0		                pop     b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3350: 1  0ABB	D0 D0		                pop     psw
 3351: 1  0ABD	D0 E0		                pop     acc
 3352: 1  0ABF	22		                ret
 3353: 1
 3354: 1
 3355: 1
 3356: 1			;*******************************************************************************
 3357: 1			; mul16acc1        (71,2us @16.777216MHz)
 3358: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3359: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3360: 1			; input:     r5,r4 = acc1 low
 3361: 1			;            r7,r6 = acc1 high
 3362: 1			;
 3363: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3364: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3365: 1			;
 3366: 1			; vernietigt:  niets
 3367: 1			;*******************************************************************************
 3368: 1  0AC0	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3369: 1  0AC2	C0 D0		                push    psw
 3370: 1  0AC4	C0 F0		                push    b
 3371: 1  0AC6	C0 82		                push    dpl
 3372: 1  0AC8	C0 83		                push    dph
 3373: 1
 3374: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3375: 1
 3376: 1  0ACA	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3377: 1  0ACC	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3378: 1
 3379: 1  0ACE	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3380: 1  0AD0	08		                inc     r0               ;pointer naar eerste vrije plaats
 3381: 1  0AD1	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3382: 1  0AD3	E5 81		                mov     a,sp             ;plaats alloceren
 3383: 1  0AD5	24 03		                add     a,#3             ;3 bytes nodig
 3384: 1  0AD7	F5 81		                mov     sp,a             ;stackpointer verzetten
 3385: 1
 3386: 1  0AD9	EC		                mov     a,r4             ;acc1 low lsb
 3387: 1  0ADA	8E F0		                mov     b,r6             ;acc1 high lsb
 3388: 1  0ADC	A4		                mul     ab
 3389: 1  0ADD	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3390: 1  0ADE	08		                inc     r0
 3391: 1  0ADF	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3392: 1
 3393: 1  0AE1	ED		                mov     a,r5             ;acc1 low msb
 3394: 1  0AE2	8E F0		                mov     b,r6             ;acc1 high lsb
 3395: 1  0AE4	A4		                mul     ab
 3396: 1
 3397: 1  0AE5	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3398: 1  0AE6	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3399: 1  0AE7	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3400: 1  0AE9	34 00		                addc    a,#0
 3401: 1  0AEB	08		                inc     r0               ;bewaar als tussenresultaat
 3402: 1  0AEC	F6		                mov     @r0,a
 3403: 1
 3404: 1  0AED	EC		                mov     a,r4             ;acc1 low lsb
 3405: 1  0AEE	8F F0		                mov     b,r7             ;acc1 high msb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3406: 1  0AF0	A4		                mul     ab
 3407: 1  0AF1	18		                dec     r0
 3408: 1  0AF2	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3409: 1  0AF3	F6		                mov     @r0,a            ;en bewaar weer
 3410: 1  0AF4	08		                inc     r0
 3411: 1  0AF5	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3412: 1  0AF7	36		                addc    a,@r0
 3413: 1  0AF8	F6		                mov     @r0,a            ;en bewaar weer
 3414: 1  0AF9	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3415: 1
 3416: 1  0AFB	ED		                mov     a,r5             ;acc1 low msb
 3417: 1  0AFC	8F F0		                mov     b,r7             ;acc1 high msb
 3418: 1  0AFE	A4		                mul     AB
 3419: 1
 3420: 1  0AFF	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3421: 1  0B00	FE		                mov     r6,a             ;deze byte van product is al klaar
 3422: 1  0B01	E5 F0		                mov     a,b
 3423: 1  0B03	34 00		                addc    a,#0
 3424: 1  0B05	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3425: 1  0B07	34 00		                addc    a,#0
 3426: 1
 3427: 1  0B09	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3428: 1  0B0A	18		                dec     r0
 3429: 1  0B0B	E6		                mov     a,@r0
 3430: 1  0B0C	FD		                mov     r5,a
 3431: 1  0B0D	18		                dec     r0
 3432: 1  0B0E	E6		                mov     a,@r0
 3433: 1  0B0F	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3434: 1
 3435: 1  0B10	89 81		                mov     sp,r1            ;zet stackpointer terug
 3436: 1  0B12	A9 83		                mov     r1,dph
 3437: 1  0B14	A8 82		                mov     r0,dpl
 3438: 1
 3439: 1  0B16	D0 83		                pop     dph              ;herstel de bewaarde registers
 3440: 1  0B18	D0 82		                pop     dpl
 3441: 1  0B1A	D0 F0		                pop     b
 3442: 1  0B1C	D0 D0		                pop     psw
 3443: 1  0B1E	D0 E0		                pop     acc
 3444: 1  0B20	22		                ret
 3445: 1
 3446: 1			;*******************************************************************************
 3447: 1			; s_mul16        (121,1us @16.777216MHz)
 3448: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3449: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3450: 1			; input:     r1,r0 = acc0
 3451: 1			;            r5,r4 = acc1
 3452: 1			;
 3453: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3454: 1			;                                  -1073709056 tot +1073741824
 3455: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3456: 1			;
 3457: 1			; vernietigt:  niets
 3458: 1			;*******************************************************************************
 3459: 1  0B21	12 08 37	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3460: 1  0B24	12 08 57	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3461: 1  0B27	12 0A 5B	                lcall    mul16           ;maak product

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3462: 1  0B2A	12 07 B1	                lcall    magsig32        ;maak 2's complement formaat
 3463: 1  0B2D	22		                ret                      ;klaar
 3464: 1
 3465: 1			;*******************************************************************************
 3466: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3467: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3468: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3469: 1			; input:     r5,r4 = acc1 low
 3470: 1			;            r7,r6 = acc1 high
 3471: 1			;
 3472: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3473: 1			;                                  -1073709056 tot +1073741824
 3474: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3475: 1			; vernietigt:  niets
 3476: 1			;*******************************************************************************
 3477: 1  0B2E	12 08 57	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3478: 1  0B31	12 08 77	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3479: 1  0B34	12 0A C0	                lcall    mul16acc1       ;maak product
 3480: 1  0B37	12 07 DB	                lcall    magsig32acc1    ;maak 2's complement formaat
 3481: 1  0B3A	22		                ret                      ;klaar
 3482: 1
 3483: 1			;*******************************************************************************
 3484: 1			; s_mul816        (83,5us @16.777216MHz)
 3485: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3486: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3487: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3488: 1			; input:     r1,r0 = acc0
 3489: 1			;               r4 = acc1
 3490: 1			;
 3491: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3492: 1			;                                  -4194176 tot +4194304
 3493: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3494: 1			; vernietigt:  niets
 3495: 1			;*******************************************************************************
 3496: 1  0B3B	12 08 37	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3497: 1  0B3E	12 08 1E	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3498: 1  0B41	12 0B 48	                lcall    mul816          ;8bit x 16 bit product
 3499: 1  0B44	12 07 B1	                lcall    magsig32        ;abs. waarde naar 2's complement
 3500: 1  0B47	22		                ret
 3501: 1
 3502: 1			;*******************************************************************************
 3503: 1			; mul816        (29,4us @16.777216MHz)
 3504: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3505: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3506: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3507: 1			; input:     r1,r0 = acc0
 3508: 1			;               r4 = acc1
 3509: 1			;
 3510: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3511: 1			;                           0..16711425 (000000h..feff01h)
 3512: 1			;
 3513: 1			; vernietigt:  niets
 3514: 1			;*******************************************************************************
 3515: 1  0B48	C0 E0		mul816:         push    acc             ;bewaar registers
 3516: 1  0B4A	C0 F0		                push    b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3517: 1  0B4C	C0 D0		                push    psw
 3518: 1  0B4E	EC		                mov     a,r4            ;neem acc1
 3519: 1  0B4F	88 F0		                mov     b,r0            ;neem lsb van acc0
 3520: 1  0B51	A4		                mul     ab              ;maak product
 3521: 1  0B52	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3522: 1  0B53	C0 F0		                push    b               ;bewaar lsb van het product
 3523: 1  0B55	EC		                mov     a,r4            ;neem acc1
 3524: 1  0B56	89 F0		                mov     b,r1            ;neem msb can acc0
 3525: 1  0B58	A4		                mul     ab              ;maak product
 3526: 1  0B59	AA F0		                mov     r2,b            ;bewaar msb van product even
 3527: 1  0B5B	F5 F0		                mov     b,a             ;verplaats lsb van product
 3528: 1  0B5D	D0 E0		                pop     acc             ;neem msb van vorig product
 3529: 1  0B5F	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3530: 1  0B61	F9		                mov     r1,a            ;de middenste byte is klaar
 3531: 1  0B62	EA		                mov     a,r2            ;tel nu de eventuele
 3532: 1  0B63	34 00		                addc    a,#0            ;carry bij de msb
 3533: 1  0B65	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3534: 1  0B66	7B 00		                mov     r3,#0
 3535: 1  0B68	D0 D0		                pop     psw
 3536: 1  0B6A	D0 F0		                pop     b
 3537: 1  0B6C	D0 E0		                pop     acc
 3538: 1  0B6E	22		                ret
 3539: 1
 3540: 1			;*******************************************************************************
 3541: 1			; s_mac16        (145,1us @16.777216MHz)
 3542: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3543: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3544: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3545: 1			; input:     r7,r6 = acc1 (high word)
 3546: 1			;            r5,r4 = acc1 (low  word)
 3547: 1			;
 3548: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3549: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3550: 1			;                          -2147483648 tot +2147483647
 3551: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3552: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3553: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3554: 1			;
 3555: 1			; vernietigt:  niets
 3556: 1			;*******************************************************************************
 3557: 1  0B6F	12 0B 2E	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3558: 1  0B72	C0 E0		                push    acc
 3559: 1  0B74	C0 D0		                push    psw
 3560: 1  0B76	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3561: 1  0B77	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3562: 1  0B78	F8		                mov     r0,a
 3563: 1  0B79	ED		                mov     a,r5
 3564: 1  0B7A	39		                addc    a,r1
 3565: 1  0B7B	F9		                mov     r1,a
 3566: 1  0B7C	EE		                mov     a,r6
 3567: 1  0B7D	3A		                addc    a,r2
 3568: 1  0B7E	FA		                mov     r2,a
 3569: 1  0B7F	EF		                mov     a,r7
 3570: 1  0B80	3B		                addc    a,r3
 3571: 1  0B81	FB		                mov     r3,a
 3572: 1  0B82	20 D2 06	                jb      ov,s_mac161

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3573: 1  0B85	D0 D0		                pop     psw
 3574: 1  0B87	C3		                clr     c                ;ok, 32bit som binnen bereik
 3575: 1  0B88	D0 E0		                pop     acc
 3576: 1  0B8A	22		                ret
 3577: 1  0B8B	D0 D0		s_mac161:       pop     psw
 3578: 1  0B8D	D3		                setb    c                ;fout! 32bit som buiten bereik
 3579: 1  0B8E	D0 E0		                pop     acc
 3580: 1  0B90	22		                ret
 3581: 1
 3582: 1
 3583: 1			;*******************************************************************************
 3584: 1			; s_div8        (78us @16.777216MHz)
 3585: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3586: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3587: 1			; input:    r0 = acc0 deeltal (2's compl)
 3588: 1			;           r4 = acc1 deler   (2's compl)
 3589: 1			;
 3590: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3591: 1			;           r4 = rest (2's compl)
 3592: 1			;           cy=1 bij acc1=0 (deling door nul)
 3593: 1			;            cy=0 in andere gevallen
 3594: 1			;
 3595: 1			; vernietigt: niets
 3596: 1			;*******************************************************************************
 3597: 1  0B91	12 08 05	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3598: 1  0B94	12 08 1E	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3599: 1  0B97	12 0B A3	                lcall   div8
 3600: 1  0B9A	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3601: 1  0B9C	12 07 3D	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3602: 1  0B9F	12 07 57	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3603: 1  0BA2	22		s_div81:        ret
 3604: 1
 3605: 1			;*******************************************************************************
 3606: 1			; div8        (19,4us @16.777216MHz)
 3607: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3608: 1			; absolute waarde
 3609: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3610: 1			; input:    r0 = acc0 deeltal
 3611: 1			;           r4 = acc1 deler
 3612: 1			;
 3613: 1			; output:   r0 = quotient van deling acc0/acc1
 3614: 1			;           r4 = rest
 3615: 1			;           cy=1 bij acc1=0 (deling door nul)
 3616: 1			;            cy=0 in andere gevallen
 3617: 1			;
 3618: 1			; vernietigt: niets
 3619: 1			;*******************************************************************************
 3620: 1  0BA3	C0 E0		div8:           push    acc             ;bewaar registers
 3621: 1  0BA5	C0 F0		                push    b
 3622: 1  0BA7	C0 D0		                push    psw
 3623: 1  0BA9	EC		                mov     a,r4            ;neem deler
 3624: 1  0BAA	60 0F		                jz      div81           ;deling door nul?
 3625: 1  0BAC	E8		                mov     a,r0            ;nee, neem deeltal
 3626: 1  0BAD	8C F0		                mov     b,r4            ;en deler
 3627: 1  0BAF	84		                div     ab              ;en maak deling
 3628: 1  0BB0	F8		                mov     r0,a            ;bewaar quotient in acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3629: 1  0BB1	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3630: 1  0BB3	D0 D0		                pop     psw             ;herstel registers
 3631: 1  0BB5	D0 F0		                pop     b
 3632: 1  0BB7	D0 E0		                pop     acc
 3633: 1  0BB9	C3		                clr     c                ;geen deling door nul
 3634: 1  0BBA	22		                ret
 3635: 1
 3636: 1  0BBB	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3637: 1  0BBD	D0 F0		                pop     b
 3638: 1  0BBF	D0 E0		                pop     acc
 3639: 1  0BC1	D3		                setb    c
 3640: 1  0BC2	22		                ret
 3641: 1
 3642: 1
 3643: 1			;*******************************************************************************
 3644: 1			; s_div16        (469,1us @16.777216MHz)
 3645: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3646: 1			; 2's Complement Format
 3647: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3648: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3649: 1			;           r5, r4 = acc1 deler   (2's compl)
 3650: 1			;
 3651: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3652: 1			;           r5, r4 = rest
 3653: 1			;           cy=1 bij acc1=0 (deling door nul)
 3654: 1			;            cy=0 in andere gevallen
 3655: 1			;
 3656: 1			; vernietigt: niets
 3657: 1			;*******************************************************************************
 3658: 1  0BC3	C0 E0		s_div16:        push    acc
 3659: 1  0BC5	C0 D0		                push    psw
 3660: 1  0BC7	ED		                mov     a,r5            ;neem msb van deler
 3661: 1  0BC8	4C		                orl     a,r4            ;combineer met lsb van deler
 3662: 1  0BC9	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3663: 1  0BCB	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3664: 1  0BCD	D0 E0		                pop     acc
 3665: 1  0BCF	D3		                setb    C               ;fout, deling door nul!
 3666: 1  0BD0	22		                ret
 3667: 1
 3668: 1  0BD1	12 08 37	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3669: 1  0BD4	12 08 57	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3670: 1  0BD7	12 0B E6	                lcall   div16
 3671: 1  0BDA	12 07 71	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3672: 1  0BDD	12 07 91	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3673: 1  0BE0	D0 D0		                pop     psw
 3674: 1  0BE2	C3		                clr     C               ;delig ok
 3675: 1  0BE3	D0 E0		                pop     acc
 3676: 1  0BE5	22		                ret                     ;klaar
 3677: 1
 3678: 1			;*******************************************************************************
 3679: 1			; div16            (405,1us @16.777216MHz)
 3680: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3681: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3682: 1			; input:    r1, r0 = Deeltal (acc0)
 3683: 1			;           r5, r4 = Deler   (acc1)
 3684: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3685: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3686: 1			;           r5, r4 = rest van de deling acc0/acc1
 3687: 1			;            cy=1 bij deling door nul (acc1=0)
 3688: 1			;            cy=0 bij normale deling
 3689: 1			;
 3690: 1			; vernietigt: niets
 3691: 1			;*******************************************************************************
 3692: 1
 3693: 1  0BE6	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3694: 1  0BE8	C0 D0		                push    psw
 3695: 1			;check voor deling door nul
 3696: 1  0BEA	EC		                mov     a,r4           ;neem lsb deler
 3697: 1  0BEB	4D		                orl     a,r5           ;combineer met msb van deler
 3698: 1  0BEC	70 06		                jnz     div160         ;niet nul, dan verder werken
 3699: 1  0BEE	D0 D0		                pop     psw            ;als nul, dikke snul
 3700: 1  0BF0	D3		                setb    c              ;terug met errorstatus
 3701: 1  0BF1	D0 E0		                pop     acc
 3702: 1  0BF3	22		                ret
 3703: 1
 3704: 1  0BF4	C0 F0		div160:         push    b              ;registers verder bewaren
 3705: 1  0BF6	EF		                mov     a,r7
 3706: 1  0BF7	C0 E0		                push    acc            ;push r7 op stack
 3707: 1  0BF9	EE		                mov     a,r6
 3708: 1  0BFA	C0 E0		                push    acc            ;push r6 op stack
 3709: 1  0BFC	EB		                mov     a,r3
 3710: 1  0BFD	C0 E0		                push    acc            ;push r3 op stack
 3711: 1  0BFF	EA		                mov     a,r2
 3712: 1  0C00	C0 E0		                push    acc            ;push r2 op stack
 3713: 1  0C02	C0 83		                push    dph
 3714: 1  0C04	C0 82		                push    dpl
 3715: 1
 3716: 1  0C06	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3717: 1  0C08	7B 00		                mov     r3,#0
 3718: 1  0C0A	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3719: 1  0C0C	7E 00		                mov     r6,#0
 3720: 1  0C0E	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3721: 1
 3722: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3723: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3724: 1			;het aantal significante bits af in de lusteller b
 3725: 1
 3726: 1  0C11	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3727: 1  0C12	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3728: 1  0C15	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3729: 1  0C16	E8		                mov     a,r0            ;lsb van deeltal nemen
 3730: 1  0C17	33		                rlc     a                ;en opschuiven
 3731: 1  0C18	F8		                mov     r0,a
 3732: 1  0C19	E9		                mov     a,r1            ;msb van deeltal nemen
 3733: 1  0C1A	33		                rlc     a
 3734: 1  0C1B	F9		                mov     r1,a
 3735: 1  0C1C	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3736: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3737: 1  0C1F	7C 00		                mov     r4,#0
 3738: 1  0C21	7D 00		                mov     r5,#0
 3739: 1  0C23	80 2E		                sjmp    div164          ;klaar!
 3740: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3741: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3742: 1
 3743: 1  0C25	C3		div162:            clr     C            ;start met carry op nul
 3744: 1  0C26	E8		                mov     a,r0            ;schuif deeltal naar links
 3745: 1  0C27	33		                rlc     a
 3746: 1  0C28	F8		                mov     r0,a
 3747: 1  0C29	E9		                mov     a,r1
 3748: 1  0C2A	33		                rlc     a
 3749: 1  0C2B	F9		                mov     r1,a
 3750: 1  0C2C	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3751: 1  0C2D	33		                rlc     a               ;gedeeltelijke rest
 3752: 1  0C2E	FE		                mov     r6,a
 3753: 1  0C2F	EF		                mov     a,r7
 3754: 1  0C30	33		                rlc     a
 3755: 1  0C31	FF		                mov     r7,a
 3756: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3757: 1  0C32	EE		                mov     a,r6
 3758: 1  0C33	C3		                clr     C
 3759: 1  0C34	9C		                subb    a,r4
 3760: 1  0C35	F5 82		                mov     dpl,a
 3761: 1  0C37	EF		                mov     a,r7
 3762: 1  0C38	9D		                subb    a,r5
 3763: 1  0C39	F5 83		                mov     dph,a
 3764: 1  0C3B	40 04		                jc      div163
 3765: 1  0C3D	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3766: 1  0C3F	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3767: 1
 3768: 1  0C41	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3769: 1  0C42	EA		                mov     a,r2            ;binnenschuiven
 3770: 1  0C43	33		                rlc     a
 3771: 1  0C44	FA		                mov     r2,a
 3772: 1  0C45	EB		                mov     a,r3
 3773: 1  0C46	33		                rlc     a
 3774: 1  0C47	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 3775: 1  0C48	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3776: 1
 3777: 1  0C4B	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3778: 1  0C4C	F9		                mov     r1,a
 3779: 1  0C4D	EA		                mov     a,r2
 3780: 1  0C4E	F8		                mov     r0,a
 3781: 1  0C4F	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3782: 1  0C50	FD		                mov     r5,a
 3783: 1  0C51	EE		                mov     a,r6
 3784: 1  0C52	FC		                mov     r4,a
 3785: 1
 3786: 1  0C53	D0 82		div164:         pop     dpl             ;registers herstellen
 3787: 1  0C55	D0 83		                pop     dph
 3788: 1  0C57	D0 E0		                pop     acc
 3789: 1  0C59	FA		                mov     r2,a            ;r2 van stack halen
 3790: 1  0C5A	D0 E0		                pop     acc
 3791: 1  0C5C	FB		                mov     r3,a            ;r3 van stack halen
 3792: 1  0C5D	D0 E0		                pop     acc
 3793: 1  0C5F	FE		                mov     r6,a            ;r6 van stack halen
 3794: 1  0C60	D0 E0		                pop     acc
 3795: 1  0C62	FF		                mov     r7,a            ;r7 van stack halen
 3796: 1  0C63	D0 F0		                pop     b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3797: 1  0C65	D0 D0		                pop     psw
 3798: 1  0C67	C3		                clr     c               ;deling ok
 3799: 1  0C68	D0 E0		                pop     acc
 3800: 1  0C6A	22		                ret
 3801: 1
 3802: 1
 3803: 1			;*******************************************************************************
 3804: 1			; s_div32        (2,15ms @16.777216MHz)
 3805: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3806: 1			; 2's Complement Format
 3807: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3808: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3809: 1			;
 3810: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 3811: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3812: 1			;
 3813: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3814: 1			;           r7,r6,r5, r4 = rest
 3815: 1			;           cy=1 bij acc1=0 (deling door nul)
 3816: 1			;            cy=0 in andere gevallen
 3817: 1			;
 3818: 1			; vernietigt: niets
 3819: 1			;*******************************************************************************
 3820: 1  0C6B	C0 E0		s_div32:        push    acc
 3821: 1  0C6D	C0 D0		                push    psw
 3822: 1  0C6F	EF		                mov     a,r7            ;neem msb van deler
 3823: 1  0C70	4E		                orl     a,r6            ;combineer met lsb's van deler
 3824: 1  0C71	4D		                orl     a,r5
 3825: 1  0C72	4C		                orl     a,r4
 3826: 1  0C73	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3827: 1  0C75	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3828: 1  0C77	D0 E0		                pop     acc
 3829: 1  0C79	D3		                setb    C                ;fout, deling door nul!
 3830: 1  0C7A	22		                ret
 3831: 1
 3832: 1  0C7B	12 08 97	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3833: 1  0C7E	12 08 C1	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3834: 1  0C81	12 0C 90	                lcall   div32            ;deel 32bit/32bit
 3835: 1  0C84	12 07 B1	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3836: 1  0C87	12 07 DB	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3837: 1  0C8A	D0 D0		                pop     psw
 3838: 1  0C8C	C3		                clr     C                ;delig ok
 3839: 1  0C8D	D0 E0		                pop     acc
 3840: 1  0C8F	22		                ret                        ;klaar
 3841: 1
 3842: 1
 3843: 1			;*******************************************************************************
 3844: 1			; div32        (2,09ms @16.777216MHz)
 3845: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3846: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3847: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3848: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3849: 1			;
 3850: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 3851: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3852: 1			;            cy=1 bij deling door nul (acc1=0)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3853: 1			;            cy=0 bij normale deling
 3854: 1			;
 3855: 1			; vernietigt: niets
 3856: 1			;*******************************************************************************
 3857: 1  0C90	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3858: 1  0C92	C0 D0		                push    psw
 3859: 1			;check voor deling door nul
 3860: 1  0C94	EF		                mov     a,r7            ;neem msb van deler
 3861: 1  0C95	4E		                orl     a,r6            ;combineer met lsb's van deler
 3862: 1  0C96	4D		                orl     a,r5
 3863: 1  0C97	4C		                orl     a,r4
 3864: 1  0C98	70 06		                jnz     div320          ;niet nul, dan verder werken
 3865: 1  0C9A	D0 D0		                pop     psw             ;als nul, dikke snul
 3866: 1  0C9C	D3		                setb    c               ;terug met errorstatus
 3867: 1  0C9D	D0 E0		                pop     acc
 3868: 1  0C9F	22		                ret
 3869: 1
 3870: 1  0CA0	C0 F0		div320:         push    b                ;registers verder bewaren
 3871: 1  0CA2	C0 83		                push    dph
 3872: 1  0CA4	C0 82		                push    dpl
 3873: 1
 3874: 1  0CA6	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3875: 1
 3876: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3877: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3878: 1			;het aantal significante bits af in de lusteller b
 3879: 1
 3880: 1  0CA9	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3881: 1  0CAA	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3882: 1  0CAD	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3883: 1  0CAE	E8		                mov     a,r0            ;lsb van deeltal nemen
 3884: 1  0CAF	33		                rlc     a               ;en opschuiven
 3885: 1  0CB0	F8		                mov     r0,a
 3886: 1  0CB1	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 3887: 1  0CB2	33		                rlc     a
 3888: 1  0CB3	F9		                mov     r1,a
 3889: 1  0CB4	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3890: 1  0CB5	33		                rlc     a
 3891: 1  0CB6	FA		                mov     r2,a
 3892: 1  0CB7	EB		                mov     a,r3           ;lsb van deeltal nemen
 3893: 1  0CB8	33		                rlc     a
 3894: 1  0CB9	FB		                mov     r3,a
 3895: 1  0CBA	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3896: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3897: 1  0CBD	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3898: 1  0CBF	7E 00		                mov     r6,#0
 3899: 1  0CC1	7D 00		                mov     r5,#0
 3900: 1  0CC3	7C 00		                mov     r4,#0
 3901: 1  0CC5	02 0D 8E	                ljmp    div324           ;klaar!
 3902: 1
 3903: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 3904: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 3905: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 3906: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 3907: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 3908: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3909: 1  0CC8			div320b:
 3910: 1  0CC8	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 3911: 1
 3912: 1  0CCB	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 3913: 1  0CCD	24 0C		                add     a,#12           ;met 12 plaatsen
 3914: 1  0CCF	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 3915: 1
 3916: 1  0CD1	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 3917: 1  0CD2	C0 E0		                push    acc
 3918: 1  0CD4	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 3919: 1  0CD5	C0 E0		                push    acc
 3920: 1
 3921: 1  0CD7	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 3922: 1  0CD9	08		                inc     r0              ;de deler
 3923: 1  0CDA	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 3924: 1  0CDC	24 05		                add     a,#5            ;het tijdelijk verschil X
 3925: 1  0CDE	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 3926: 1  0CDF	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 3927: 1  0CE1	24 09		                add     a,#9            ;quotient
 3928: 1  0CE3	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 3929: 1
 3930: 1			;Eenmalig de variabelen op stack initaliseren
 3931: 1			;Tijdelijk quotient op nul zetten
 3932: 1
 3933: 1  0CE5	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 3934: 1  0CE7	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 3935: 1  0CE8	C0 F0		                push    b                ;loopteller deling bewaren
 3936: 1  0CEA	75 F0 04	                mov     b,#4
 3937: 1  0CED	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 3938: 1  0CEF	09		                inc     r1
 3939: 1  0CF0	D5 F0 FA	                djnz    b,div320c
 3940: 1  0CF3	D0 F0		                pop     b                ;loopteller deling ophalen
 3941: 1  0CF5	19		                dec     r1
 3942: 1  0CF6	19		                dec     r1
 3943: 1  0CF7	19		                dec     r1
 3944: 1  0CF8	19		                dec     r1               ;pointer weer op startadres quotient
 3945: 1  0CF9	C9		                xch     a,r1             ;weer omwisselen
 3946: 1  0CFA	C5 82		                xch     a,dpl
 3947: 1
 3948: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 3949: 1  0CFC	EC		                mov     a,r4
 3950: 1  0CFD	F6		                mov     @r0,a
 3951: 1  0CFE	08		                inc     r0
 3952: 1  0CFF	ED		                mov     a,r5
 3953: 1  0D00	F6		                mov     @r0,a
 3954: 1  0D01	08		                inc     r0
 3955: 1  0D02	EE		                mov     a,r6
 3956: 1  0D03	F6		                mov     @r0,a
 3957: 1  0D04	08		                inc     r0
 3958: 1  0D05	EF		                mov     a,r7
 3959: 1  0D06	F6		                mov     @r0,a
 3960: 1  0D07	18		                dec     r0             ;pointer herstellen naar lsb van deler
 3961: 1  0D08	18		                dec     r0
 3962: 1  0D09	18		                dec     r0
 3963: 1
 3964: 1  0D0A	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3965: 1  0D0C	7E 00		                mov     r6,#0
 3966: 1  0D0E	7D 00		                mov     r5,#0
 3967: 1  0D10	7C 00		                mov     r4,#0
 3968: 1
 3969: 1
 3970: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 3971: 1  0D12	C3		div322:         clr     C               ;start met carry op nul
 3972: 1
 3973: 1  0D13	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 3974: 1  0D15	33		                rlc     a
 3975: 1  0D16	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 3976: 1  0D18	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 3977: 1  0D1A	D0 E0		                pop     acc             ;r1 van deeltal van stack
 3978: 1  0D1C	33		                rlc     a
 3979: 1  0D1D	C0 E0		                push    acc             ;en weer bewaren
 3980: 1  0D1F	05 81		                inc     sp              ;stackpointer weer corrigeren
 3981: 1
 3982: 1  0D21	EA		                mov     a,r2
 3983: 1  0D22	33		                rlc     a
 3984: 1  0D23	FA		                mov     r2,a
 3985: 1  0D24	EB		                mov     a,r3
 3986: 1  0D25	33		                rlc     a
 3987: 1  0D26	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 3988: 1
 3989: 1  0D27	EC		                mov     a,r4            ;schuif carry van deeltal in de
 3990: 1  0D28	33		                rlc     a               ;gedeeltelijke rest r7..r4
 3991: 1  0D29	FC		                mov     r4,a
 3992: 1  0D2A	ED		                mov     a,r5
 3993: 1  0D2B	33		                rlc     a
 3994: 1  0D2C	FD		                mov     r5,a
 3995: 1  0D2D	EE		                mov     a,r6
 3996: 1  0D2E	33		                rlc     a
 3997: 1  0D2F	FE		                mov     r6,a
 3998: 1  0D30	EF		                mov     a,r7
 3999: 1  0D31	33		                rlc     a
 4000: 1  0D32	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 4001: 1
 4002: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 4003: 1
 4004: 1  0D33	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 4005: 1  0D34	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 4006: 1  0D35	96		                subb    a,@r0           ;trek er de lsb deler af
 4007: 1  0D36	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4008: 1  0D37	08		                inc     r0              ;pointers aanpassen
 4009: 1  0D38	09		                inc     r1
 4010: 1  0D39	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4011: 1  0D3A	96		                subb    a,@r0           ;trek er volgende byte deler af
 4012: 1  0D3B	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4013: 1  0D3C	08		                inc     r0              ;pointers aanpassen
 4014: 1  0D3D	09		                inc     r1
 4015: 1  0D3E	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4016: 1  0D3F	96		                subb    a,@r0           ;trek er volgende byte deler af
 4017: 1  0D40	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4018: 1  0D41	08		                inc     r0              ;pointers aanpassen
 4019: 1  0D42	09		                inc     r1
 4020: 1  0D43	EF		                mov     a,r7            ;msb van gedeeltelijke rest

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4021: 1  0D44	96		                subb    a,@r0           ;trek er msb deler af
 4022: 1  0D45	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4023: 1  0D46	18		                dec     r0              ;pointers herstellen naar lsb's
 4024: 1  0D47	18		                dec     r0
 4025: 1  0D48	18		                dec     r0
 4026: 1  0D49	19		                dec     r1
 4027: 1  0D4A	19		                dec     r1
 4028: 1  0D4B	19		                dec     r1
 4029: 1
 4030: 1  0D4C	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4031: 1  0D4E	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4032: 1  0D4F	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4033: 1  0D50	09		                inc     r1
 4034: 1  0D51	E7		                mov     a,@r1
 4035: 1  0D52	FD		                mov     r5,a
 4036: 1  0D53	09		                inc     r1
 4037: 1  0D54	E7		                mov     a,@r1
 4038: 1  0D55	FE		                mov     r6,a
 4039: 1  0D56	09		                inc     r1
 4040: 1  0D57	E7		                mov     a,@r1
 4041: 1  0D58	FF		                mov     r7,a
 4042: 1  0D59	19		                dec     r1              ;met pointer weer naar lsb van
 4043: 1  0D5A	19		                dec     r1              ;het tijdelijk verschil wijzen
 4044: 1  0D5B	19		                dec     r1
 4045: 1
 4046: 1
 4047: 1  0D5C	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4048: 1  0D5D	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4049: 1  0D5F	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4050: 1  0D60	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4051: 1  0D62	E7		                mov     a,@r1           ;neem lsb van qoutient
 4052: 1  0D63	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4053: 1  0D64	F7		                mov     @r1,a
 4054: 1  0D65	09		                inc     r1              ;volgende byte
 4055: 1  0D66	E7		                mov     a,@r1
 4056: 1  0D67	33		                rlc     a
 4057: 1  0D68	F7		                mov     @r1,a
 4058: 1  0D69	09		                inc     r1              ;volgende byte
 4059: 1  0D6A	E7		                mov     a,@r1
 4060: 1  0D6B	33		                rlc     a
 4061: 1  0D6C	F7		                mov     @r1,a
 4062: 1  0D6D	09		                inc     r1              ;volgende byte
 4063: 1  0D6E	E7		                mov     a,@r1
 4064: 1  0D6F	33		                rlc     a
 4065: 1  0D70	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4066: 1  0D71	19		                dec     r1
 4067: 1  0D72	19		                dec     r1
 4068: 1  0D73	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4069: 1  0D74	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4070: 1  0D76	C9		                xch     a,r1            ;r1=pointer naar verschil
 4071: 1  0D77	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4072: 1
 4073: 1  0D79	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4074: 1
 4075: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4076: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4077: 1
 4078: 1  0D7C	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4079: 1  0D7E	18		                dec     r0
 4080: 1  0D7F	18		                dec     r0
 4081: 1  0D80	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4082: 1  0D81	FB		                mov     r3,a            ;en verplaatsen
 4083: 1  0D82	18		                dec     r0              ;volgende byte
 4084: 1  0D83	E6		                mov     a,@r0
 4085: 1  0D84	FA		                mov     r2,a
 4086: 1  0D85	18		                dec     r0              ;volgende byte
 4087: 1  0D86	E6		                mov     a,@r0
 4088: 1  0D87	F9		                mov     r1,a
 4089: 1  0D88	18		                dec     r0              ;volgende byte
 4090: 1  0D89	E6		                mov     a,@r0
 4091: 1  0D8A	F8		                mov     r0,a            ;laatste byte verplaatst!
 4092: 1
 4093: 1  0D8B	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4094: 1			                                         ;weer vrijgeven
 4095: 1
 4096: 1
 4097: 1  0D8E	D0 82		div324:         pop     dpl             ;registers herstellen
 4098: 1  0D90	D0 83		                pop     dph
 4099: 1  0D92	D0 F0		                pop     b
 4100: 1  0D94	D0 D0		                pop     psw
 4101: 1  0D96	C3		                clr     c               ;normale deling
 4102: 1  0D97	D0 E0		                pop     acc
 4103: 1  0D99	22		                ret
 4104: 1
 4105: 1			;*******************************************************************************
 4106: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4107: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4108: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4109: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4110: 1			;
 4111: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4112: 1			;
 4113: 1			; input:     r5,r4 = acc1 (low word product)
 4114: 1			;            r7,r6 = acc1 (high word product)
 4115: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4116: 1			;
 4117: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4118: 1			;            r7,r6,r5,r4 = acc1 = rest
 4119: 1			;                          -2147483648 tot +2147483647
 4120: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4121: 1			;             cy=1 bij deling door nul (acc0=0)
 4122: 1			;             cy=0 bij normale deling
 4123: 1			;
 4124: 1			; vernietigt:  niets
 4125: 1			;*******************************************************************************
 4126: 1  0D9A	C0 E0		s_muldiv:       push    acc
 4127: 1  0D9C	C0 D0		                push    psw
 4128: 1  0D9E	E8		                mov     a,r0            ;neem msb van deler
 4129: 1  0D9F	49		                orl     a,r1            ;combineer met lsb's van deler
 4130: 1  0DA0	4A		                orl     a,r2
 4131: 1  0DA1	4B		                orl     a,r3
 4132: 1  0DA2	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4133: 1  0DA4	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4134: 1  0DA6	D0 E0		                pop     acc
 4135: 1  0DA8	D3		                setb    C               ;fout, deling door nul!
 4136: 1  0DA9	22		                ret
 4137: 1
 4138: 1  0DAA	12 08 57	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4139: 1  0DAD	12 08 77	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4140: 1  0DB0	12 0D BF	                lcall    muldiv          ;maak product en daarna de deling
 4141: 1  0DB3	12 07 B1	                lcall    magsig32        ;quotient naar 2's complement
 4142: 1  0DB6	12 07 DB	                lcall    magsig32acc1    ;rest naar 2's complement
 4143: 1  0DB9	D0 D0		                pop     psw
 4144: 1  0DBB	C3		                clr     c                ;deling is ok
 4145: 1  0DBC	D0 E0		                pop    acc
 4146: 1  0DBE	22		                ret
 4147: 1
 4148: 1			;*******************************************************************************
 4149: 1			; muldiv        (2,0ms @16.777216MHz)
 4150: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4151: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4152: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4153: 1			; 32bit rest in acc1.
 4154: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4155: 1			;
 4156: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4157: 1			;
 4158: 1			; input:     r5,r4 = acc1 (low word product)
 4159: 1			;            r7,r6 = acc1 (high word product)
 4160: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4161: 1			;
 4162: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4163: 1			;            r7,r6,r5,r4 = acc1 = rest
 4164: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4165: 1			;             cy=1 bij deling door nul (acc0=0)
 4166: 1			;             cy=0 bij normale deling
 4167: 1			;
 4168: 1			; vernietigt:  niets
 4169: 1			;*******************************************************************************
 4170: 1  0DBF	C0 E0		muldiv:         push    acc
 4171: 1  0DC1	C0 D0		                push    psw
 4172: 1  0DC3	E8		                mov     a,r0            ;neem msb van deler
 4173: 1  0DC4	49		                orl     a,r1            ;combineer met lsb's van deler
 4174: 1  0DC5	4A		                orl     a,r2
 4175: 1  0DC6	4B		                orl     a,r3
 4176: 1  0DC7	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4177: 1  0DC9	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4178: 1  0DCB	D0 E0		                pop     acc
 4179: 1  0DCD	D3		                setb    C               ;fout, deling door nul!
 4180: 1  0DCE	22		                ret
 4181: 1
 4182: 1  0DCF	12 0A C0	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4183: 1  0DD2	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4184: 1  0DD3	C0 E0		                push    acc
 4185: 1  0DD5	ED		                mov     a,r5
 4186: 1  0DD6	C0 E0		                push    acc
 4187: 1  0DD8	EE		                mov     a,r6
 4188: 1  0DD9	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4189: 1  0DDB	EF		                mov     a,r7
 4190: 1  0DDC	C0 E0		                push    acc             ;product staat nu op stack
 4191: 1
 4192: 1  0DDE	E8		                mov     a,r0            ;deler in acc1 stoppen
 4193: 1  0DDF	FC		                mov     r4,a
 4194: 1  0DE0	E9		                mov     a,r1
 4195: 1  0DE1	FD		                mov     r5,a
 4196: 1  0DE2	EA		                mov     a,r2
 4197: 1  0DE3	FE		                mov     r6,a
 4198: 1  0DE4	EB		                mov     a,r3
 4199: 1  0DE5	FF		                mov     r7,a            ;deler zit volledig in acc1
 4200: 1
 4201: 1  0DE6	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4202: 1  0DE8	FB		                mov     r3,a
 4203: 1  0DE9	D0 E0		                pop     acc
 4204: 1  0DEB	FA		                mov     r2,a
 4205: 1  0DEC	D0 E0		                pop     acc
 4206: 1  0DEE	F9		                mov     r1,a
 4207: 1  0DEF	D0 E0		                pop     acc
 4208: 1  0DF1	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4209: 1  0DF2	12 0C 90	                lcall   div32           ;maak deling
 4210: 1
 4211: 1  0DF5	D0 D0		                pop     psw            ;herstel registers
 4212: 1  0DF7	D0 E0		                pop     acc
 4213: 1  0DF9	C3		                clr     C              ;resultaat ok!
 4214: 1  0DFA	22		                ret
 4215: 1
 4216: 1			;*******************************************************************************
 4217: 1			; mul16_pi        (257,1us @16.777216MHz)
 4218: 1			; acc0 = acc0 x pi
 4219: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4220: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4221: 1			;
 4222: 1			; input:     r1,r0 = acc0 (low word)
 4223: 1			;
 4224: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4225: 1			;
 4226: 1			; vernietigt:  niets
 4227: 1			;*******************************************************************************
 4228: 1  0DFB	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4229: 1  0DFD	C0 D0		                push    psw
 4230: 1  0DFF	EC		                mov     a,r4
 4231: 1  0E00	C0 E0		                push    acc
 4232: 1  0E02	ED		                mov     a,r5
 4233: 1  0E03	C0 E0		                push    acc
 4234: 1  0E05	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4235: 1  0E07	7C 0F		                mov     r4,#0fH
 4236: 1  0E09	12 0A 5B	                lcall   mul16           ;acc0 = acc0 x acc1
 4237: 1  0E0C	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4238: 1  0E0E	12 0F F7	                lcall   shiftright32    ;om te delen door 2^14
 4239: 1  0E11	D0 E0		                pop     acc
 4240: 1  0E13	FD		                mov     r5,a
 4241: 1  0E14	D0 E0		                pop     acc
 4242: 1  0E16	FC		                mov     r4,a
 4243: 1  0E17	D0 D0		                pop     psw
 4244: 1  0E19	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4245: 1  0E1B	22		                ret
 4246: 1
 4247: 1			;*******************************************************************************
 4248: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4249: 1			; acc0 = acc0 x 1/pi
 4250: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4251: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4252: 1			;
 4253: 1			; input:     r1,r0 = acc0 (low word)
 4254: 1			;
 4255: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4256: 1			;
 4257: 1			; vernietigt:  niets
 4258: 1			;*******************************************************************************
 4259: 1  0E1C	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4260: 1  0E1E	C0 D0		                push    psw
 4261: 1  0E20	EC		                mov     a,r4
 4262: 1  0E21	C0 E0		                push    acc
 4263: 1  0E23	ED		                mov     a,r5
 4264: 1  0E24	C0 E0		                push    acc
 4265: 1  0E26	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4266: 1  0E28	7C 7D		                mov     r4,#07dH
 4267: 1  0E2A	12 0A 5B	                lcall    mul16          ;acc0 = acc0 x acc1
 4268: 1  0E2D	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4269: 1  0E2F	12 0F F7	                lcall   shiftright32    ;om te delen door 2^16
 4270: 1  0E32	D0 E0		                pop     acc
 4271: 1  0E34	FD		                mov     r5,a
 4272: 1  0E35	D0 E0		                pop     acc
 4273: 1  0E37	FC		                mov     r4,a
 4274: 1  0E38	D0 D0		                pop     psw
 4275: 1  0E3A	D0 E0		                pop     acc
 4276: 1  0E3C	22		                ret
 4277: 1
 4278: 1			;*******************************************************************************
 4279: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4280: 1			; acc0 = acc0 x sqrt2
 4281: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4282: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4283: 1			;
 4284: 1			; input:     r1,r0 = acc0 (low word)
 4285: 1			;
 4286: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4287: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4288: 1			;
 4289: 1			; vernietigt:  niets
 4290: 1			;*******************************************************************************
 4291: 1  0E3D	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4292: 1  0E3F	C0 D0		                push    psw
 4293: 1  0E41	EC		                mov     a,r4
 4294: 1  0E42	C0 E0		                push    acc
 4295: 1  0E44	ED		                mov     a,r5
 4296: 1  0E45	C0 E0		                push    acc
 4297: 1  0E47	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4298: 1  0E49	7C 05		                mov     r4,#005H
 4299: 1  0E4B	12 0A 5B	                lcall   mul16           ;acc0 = acc0 x acc1
 4300: 1  0E4E	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4301: 1  0E50	12 0F F7	                lcall   shiftright32    ;om te delen door 2^15
 4302: 1  0E53	D0 E0		                pop     acc
 4303: 1  0E55	FD		                mov     r5,a
 4304: 1  0E56	D0 E0		                pop     acc
 4305: 1  0E58	FC		                mov     r4,a
 4306: 1  0E59	D0 D0		                pop     psw
 4307: 1  0E5B	D0 E0		                pop     acc
 4308: 1  0E5D	22		                ret
 4309: 1
 4310: 1
 4311: 1
 4312: 1			;*******************************************************************************
 4313: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4314: 1			; acc0 = acc0 x 1/sqrt2
 4315: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4316: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4317: 1			;
 4318: 1			; input:     r1,r0 = acc0 (low word)
 4319: 1			;
 4320: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4321: 1			;
 4322: 1			; vernietigt:  niets
 4323: 1			;*******************************************************************************
 4324: 1  0E5E	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4325: 1  0E60	C0 D0		                push    psw
 4326: 1  0E62	EC		                mov     a,r4
 4327: 1  0E63	C0 E0		                push    acc
 4328: 1  0E65	ED		                mov     a,r5
 4329: 1  0E66	C0 E0		                push    acc
 4330: 1  0E68	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4331: 1  0E6A	7C 05		                mov     r4,#005H
 4332: 1  0E6C	12 0A 5B	                lcall   mul16           ;acc0 = acc0 x acc1
 4333: 1  0E6F	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4334: 1  0E71	12 0F F7	                lcall   shiftright32    ;om te delen door 2^16
 4335: 1  0E74	D0 E0		                pop     acc
 4336: 1  0E76	FD		                mov     r5,a
 4337: 1  0E77	D0 E0		                pop     acc
 4338: 1  0E79	FC		                mov     r4,a
 4339: 1  0E7A	D0 D0		                pop     psw
 4340: 1  0E7C	D0 E0		                pop     acc
 4341: 1  0E7E	22		                ret
 4342: 1
 4343: 1			;*******************************************************************************
 4344: 1			; mul16_10        (98,7us @16.777216MHz)
 4345: 1			; acc0 = acc0 x 10
 4346: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4347: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4348: 1			;
 4349: 1			; input:     r1,r0 = acc0 (low word)
 4350: 1			;
 4351: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4352: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4353: 1			; vernietigt:  niets
 4354: 1			;*******************************************************************************
 4355: 1  0E7F	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4356: 1  0E81	C0 D0		                push    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4357: 1  0E83	EC		                mov     a,r4
 4358: 1  0E84	C0 E0		                push    acc
 4359: 1  0E86	7C 01		                mov     r4,#1           ;acc0 x2
 4360: 1  0E88	12 10 23	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4361: 1  0E8B	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4362: 1  0E8C	C0 E0		                push    acc
 4363: 1  0E8E	EA		                mov     a,r2
 4364: 1  0E8F	C0 E0		                push    acc
 4365: 1  0E91	E9		                mov     a,r1
 4366: 1  0E92	C0 E0		                push    acc
 4367: 1  0E94	E8		                mov     a,r0
 4368: 1  0E95	C0 E0		                push    acc             ;acc0 op stack
 4369: 1  0E97	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4370: 1  0E99	12 10 23	                lcall   shiftleft32     ;acc0 =acc0 x4
 4371: 1  0E9C	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4372: 1  0E9E	28		                add     a,r0            ;tel bij huidige acc0
 4373: 1  0E9F	F8		                mov     r0,a
 4374: 1  0EA0	D0 E0		                pop     acc
 4375: 1  0EA2	39		                addc    a,r1
 4376: 1  0EA3	F9		                mov     r1,a
 4377: 1  0EA4	D0 E0		                pop     acc
 4378: 1  0EA6	3A		                addc    a,r2
 4379: 1  0EA7	FA		                mov     r2,a
 4380: 1  0EA8	D0 E0		                pop     acc
 4381: 1  0EAA	3B		                addc    a,r3
 4382: 1  0EAB	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4383: 1
 4384: 1
 4385: 1  0EAC	D0 E0		                pop     acc
 4386: 1  0EAE	FC		                mov     r4,a
 4387: 1  0EAF	D0 D0		                pop     psw
 4388: 1  0EB1	D0 E0		                pop     acc
 4389: 1  0EB3	22		                ret
 4390: 1
 4391: 1			;*******************************************************************************
 4392: 1			; mul16_100        (169,1us @16.777216MHz)
 4393: 1			; acc0 = acc0 x 100
 4394: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4395: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4396: 1			;
 4397: 1			; input:     r1,r0 = acc0 (low word)
 4398: 1			;
 4399: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4400: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4401: 1			; vernietigt:  niets
 4402: 1			;*******************************************************************************
 4403: 1  0EB4	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4404: 1  0EB6	C0 D0		                push    psw
 4405: 1  0EB8	EC		                mov     a,r4
 4406: 1  0EB9	C0 E0		                push    acc
 4407: 1  0EBB	7C 02		                mov     r4,#2           ;acc0 x4
 4408: 1  0EBD	12 10 23	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4409: 1  0EC0	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4410: 1  0EC1	C0 E0		                push    acc
 4411: 1  0EC3	EA		                mov     a,r2
 4412: 1  0EC4	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4413: 1  0EC6	E9		                mov     a,r1
 4414: 1  0EC7	C0 E0		                push    acc
 4415: 1  0EC9	E8		                mov     a,r0
 4416: 1  0ECA	C0 E0		                push    acc             ;acc0 op stack
 4417: 1
 4418: 1  0ECC	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4419: 1  0ECE	12 10 23	                lcall   shiftleft32     ;acc0 =acc0 x8
 4420: 1  0ED1	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4421: 1  0ED2	C0 E0		                push    acc
 4422: 1  0ED4	EA		                mov     a,r2
 4423: 1  0ED5	C0 E0		                push    acc
 4424: 1  0ED7	E9		                mov     a,r1
 4425: 1  0ED8	C0 E0		                push    acc
 4426: 1  0EDA	E8		                mov     a,r0
 4427: 1  0EDB	C0 E0		                push    acc             ;acc0 op stack
 4428: 1
 4429: 1  0EDD	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4430: 1  0EDF	12 10 23	                lcall   shiftleft32     ;acc0 =acc0 x2
 4431: 1  0EE2	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4432: 1  0EE4	28		                add     a,r0            ;tel bij huidige acc0
 4433: 1  0EE5	F8		                mov     r0,a
 4434: 1  0EE6	D0 E0		                pop     acc
 4435: 1  0EE8	39		                addc    a,r1
 4436: 1  0EE9	F9		                mov     r1,a
 4437: 1  0EEA	D0 E0		                pop     acc
 4438: 1  0EEC	3A		                addc    a,r2
 4439: 1  0EED	FA		                mov     r2,a
 4440: 1  0EEE	D0 E0		                pop     acc
 4441: 1  0EF0	3B		                addc    a,r3
 4442: 1  0EF1	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4443: 1
 4444: 1  0EF2	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4445: 1  0EF4	28		                add     a,r0            ;tel bij huidige acc0
 4446: 1  0EF5	F8		                mov     r0,a
 4447: 1  0EF6	D0 E0		                pop     acc
 4448: 1  0EF8	39		                addc    a,r1
 4449: 1  0EF9	F9		                mov     r1,a
 4450: 1  0EFA	D0 E0		                pop     acc
 4451: 1  0EFC	3A		                addc    a,r2
 4452: 1  0EFD	FA		                mov     r2,a
 4453: 1  0EFE	D0 E0		                pop     acc
 4454: 1  0F00	3B		                addc    a,r3
 4455: 1  0F01	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4456: 1
 4457: 1  0F02	D0 E0		                pop     acc
 4458: 1  0F04	FC		                mov     r4,a
 4459: 1  0F05	D0 D0		                pop     psw
 4460: 1  0F07	D0 E0		                pop     acc
 4461: 1  0F09	22		                ret
 4462: 1
 4463: 1			;*******************************************************************************
 4464: 1			; sqrt32        (2,99ms @16.777216MHz)
 4465: 1			; acc0 = acc0 ^(1/2)
 4466: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4467: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4468: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4469: 1			; input:     r3,r2,r1,r0 = acc0
 4470: 1			;
 4471: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4472: 1			;
 4473: 1			; vernietigt:  niets
 4474: 1			;*******************************************************************************
 4475: 1  0F0A	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4476: 1  0F0C	C0 F0		                push    b
 4477: 1  0F0E	C0 D0		                push    psw
 4478: 1  0F10	C0 82		                push    dpl
 4479: 1  0F12	C0 83		                push    dph
 4480: 1  0F14	EC		                mov     a,r4
 4481: 1  0F15	C0 E0		                push    acc
 4482: 1  0F17	ED		                mov     a,r5
 4483: 1  0F18	C0 E0		                push    acc
 4484: 1  0F1A	EE		                mov     a,r6
 4485: 1  0F1B	C0 E0		                push    acc
 4486: 1  0F1D	EF		                mov     a,r7
 4487: 1  0F1E	C0 E0		                push    acc
 4488: 1
 4489: 1  0F20	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4490: 1  0F22	7D 00		                mov     r5,#0
 4491: 1  0F24	7E 00		                mov     r6,#0
 4492: 1  0F26	7F 00		                mov     r7,#0
 4493: 1  0F28	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4494: 1  0F2B	75 83 00	                mov     dph,#0
 4495: 1  0F2E	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4496: 1			;hier start het algorithme voor het berekenen van de wortel
 4497: 1  0F31	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4498: 1  0F33	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4499: 1  0F36	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4500: 1  0F37	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4501: 1  0F38	33		                rlc     a                ;getest worden om een wortelbit te
 4502: 1  0F39	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4503: 1  0F3A	E9		                mov     a,r1            ;met nullen!
 4504: 1  0F3B	33		                rlc     a
 4505: 1  0F3C	F9		                mov     r1,a
 4506: 1  0F3D	EA		                mov     a,r2
 4507: 1  0F3E	33		                rlc     a
 4508: 1  0F3F	FA		                mov     r2,a
 4509: 1  0F40	EB		                mov     a,r3
 4510: 1  0F41	33		                rlc     a
 4511: 1  0F42	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4512: 1
 4513: 1  0F43	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4514: 1  0F44	33		                rlc     a
 4515: 1  0F45	FC		                mov     r4,a
 4516: 1  0F46	ED		                mov     a,r5
 4517: 1  0F47	33		                rlc     a
 4518: 1  0F48	FD		                mov     r5,a
 4519: 1  0F49	EE		                mov     a,r6
 4520: 1  0F4A	33		                rlc     a
 4521: 1  0F4B	FE		                mov     r6,a
 4522: 1  0F4C	EF		                mov     a,r7
 4523: 1  0F4D	33		                rlc     a
 4524: 1  0F4E	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4525: 1  0F4F	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4526: 1
 4527: 1  0F52	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4528: 1
 4529: 1  0F54	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4530: 1  0F55	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4531: 1  0F57	33		                rlc     a
 4532: 1  0F58	F5 82		                mov     dpl,a
 4533: 1  0F5A	E5 83		                mov     a,dph
 4534: 1  0F5C	33		                rlc     a
 4535: 1  0F5D	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4536: 1
 4537: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4538: 1  0F5F	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4539: 1  0F60	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4540: 1  0F62	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4541: 1  0F63	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4542: 1  0F65	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4543: 1  0F66	C0 E0		                push    acc             ;van acc1
 4544: 1  0F68	EB		                mov     a,r3
 4545: 1  0F69	C0 E0		                push    acc
 4546: 1  0F6B	EC		                mov     a,r4
 4547: 1  0F6C	C0 E0		                push    acc
 4548: 1  0F6E	ED		                mov     a,r5
 4549: 1  0F6F	C0 E0		                push    acc
 4550: 1  0F71	EE		                mov     a,r6
 4551: 1  0F72	C0 E0		                push    acc
 4552: 1  0F74	EF		                mov     a,r7
 4553: 1  0F75	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4554: 1
 4555: 1  0F77	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4556: 1  0F79	AD 83		                mov     r5,dph
 4557: 1  0F7B	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4558: 1  0F7D	AF 83		                mov     r7,dph
 4559: 1  0F7F	12 0A C0	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4560: 1
 4561: 1  0F82	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4562: 1  0F84	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4563: 1  0F85	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4564: 1  0F87	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4565: 1  0F88	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4566: 1  0F8A	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4567: 1  0F8B	D0 E0		                pop     acc             ;de stack...
 4568: 1  0F8D	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4569: 1
 4570: 1  0F8E	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4571: 1  0F8F	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4572: 1  0F90	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4573: 1  0F91	E9		                mov     a,r1            ;in acc1.
 4574: 1  0F92	9D		                subb    a,r5            ;We doen dit door de carry van het
 4575: 1  0F93	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4576: 1  0F94	9E		                subb    a,r6
 4577: 1  0F95	EB		                mov     a,r3
 4578: 1  0F96	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4579: 1  0F97	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4580: 1			                                        ;wortel behouden

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4581: 1  0F99	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4582: 1  0F9B	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4583: 1  0F9D	F5 82		                mov     dpl,a          ;wortel aanpassen
 4584: 1
 4585: 1  0F9F	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4586: 1  0FA1	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4587: 1  0FA3	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4588: 1
 4589: 1  0FA5	D0 E0		                pop     acc            ;haal acc1 weer op
 4590: 1  0FA7	FF		                mov     r7,a
 4591: 1  0FA8	D0 E0		                pop     acc
 4592: 1  0FAA	FE		                mov     r6,a
 4593: 1  0FAB	D0 E0		                pop     acc
 4594: 1  0FAD	FD		                mov     r5,a
 4595: 1  0FAE	D0 E0		                pop     acc
 4596: 1  0FB0	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4597: 1
 4598: 1  0FB1	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4599: 1  0FB3	FB		                mov     r3,a
 4600: 1  0FB4	D0 E0		                pop     acc
 4601: 1  0FB6	FA		                mov     r2,a
 4602: 1  0FB7	D0 E0		                pop     acc
 4603: 1  0FB9	F9		                mov     r1,a
 4604: 1  0FBA	D0 E0		                pop     acc
 4605: 1  0FBC	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4606: 1
 4607: 1  0FBD	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4608: 1  0FC0	80 03		                sjmp    sqrt325
 4609: 1  0FC2	02 0F 31	sqrt324:        ljmp    sqrt320        ;uit acc0
 4610: 1
 4611: 1  0FC5	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4612: 1  0FC7	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4613: 1
 4614: 1  0FC9	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4615: 1  0FCB	FF		                mov     r7,a
 4616: 1  0FCC	D0 E0		                pop     acc
 4617: 1  0FCE	FE		                mov     r6,a
 4618: 1  0FCF	D0 E0		                pop     acc
 4619: 1  0FD1	FD		                mov     r5,a
 4620: 1  0FD2	D0 E0		                pop     acc
 4621: 1  0FD4	FC		                mov     r4,a           ;acc1 is hersteld
 4622: 1  0FD5	D0 83		                pop     dph
 4623: 1  0FD7	D0 82		                pop     dpl
 4624: 1  0FD9	D0 D0		                pop     psw
 4625: 1  0FDB	D0 F0		                pop     b
 4626: 1  0FDD	D0 E0		                pop     acc
 4627: 1
 4628: 1  0FDF	22		                ret                    ;eindelijk klaar...
 4629: 1
 4630: 1			;*******************************************************************************
 4631: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4632: 1			; acc0 = acc0 ^(1/2)
 4633: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4634: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4635: 1			;                           (-2147483648 tot +2147483647)
 4636: 1			; input:     r3,r2,r1,r0 = acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4637: 1			;
 4638: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4639: 1			;            CY = 1 als acc0 negatief is
 4640: 1			; vernietigt:  niets
 4641: 1			;*******************************************************************************
 4642: 1  0FE0	C0 E0		s_sqrt32:       push    acc
 4643: 1  0FE2	C0 D0		                push    psw
 4644: 1  0FE4	EB		                mov     a,r3
 4645: 1  0FE5	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4646: 1  0FE8	D0 D0		                pop     psw
 4647: 1  0FEA	D3		                setb    c                ;als negatief dan error
 4648: 1  0FEB	D0 E0		                pop     acc
 4649: 1  0FED	22		                ret
 4650: 1  0FEE	D0 D0		s_sqrt321:      pop     psw
 4651: 1  0FF0	D0 E0		                pop     acc
 4652: 1  0FF2	12 0F 0A	                lcall   sqrt32            ;wortel trekken
 4653: 1  0FF5	C3		                clr     c                 ;wortel ok
 4654: 1  0FF6	22		                ret                       ;klaar
 4655: 1
 4656: 1			;*******************************************************************************
 4657: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4658: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4659: 1			; (logical shift)
 4660: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4661: 1			;
 4662: 1			; input:     r3,r2,r1,r0 = acc0
 4663: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4664: 1			;
 4665: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4666: 1			;            CY=1 als N>=32
 4667: 1			; vernietigt:  niets
 4668: 1			;*******************************************************************************
 4669: 1  0FF7	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4670: 1  0FF9	C0 D0		                push    psw
 4671: 1  0FFB	EC		                mov     a,r4            ;neem aantal shifts
 4672: 1  0FFC	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4673: 1  0FFF	40 06		shiftright1:    jc      shiftright2
 4674: 1  1001	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4675: 1  1003	D3		                setb    c               ;N buiten bereik
 4676: 1  1004	D0 E0		                pop     acc
 4677: 1  1006	22		                ret
 4678: 1
 4679: 1  1007	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4680: 1  1009	8C F0		                mov     b,r4            ;lusteller initialiseren
 4681: 1  100B	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4682: 1  100C	EB		                mov     a,r3            ;start bij msb
 4683: 1  100D	13		                rrc     a
 4684: 1  100E	FB		                mov     r3,a
 4685: 1  100F	EA		                mov     a,r2
 4686: 1  1010	13		                rrc     a
 4687: 1  1011	FA		                mov     r2,a
 4688: 1  1012	E9		                mov     a,r1
 4689: 1  1013	13		                rrc     a
 4690: 1  1014	F9		                mov     r1,a
 4691: 1  1015	E8		                mov     a,r0
 4692: 1  1016	13		                rrc     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4693: 1  1017	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4694: 1  1018	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4695: 1  101B	D0 F0		                pop     b               ;registers herstellen
 4696: 1  101D	D0 D0		                pop     psw
 4697: 1  101F	C3		                clr     c               ;N is binnen bereik
 4698: 1  1020	D0 E0		                pop     acc
 4699: 1  1022	22		                ret
 4700: 1
 4701: 1			;*******************************************************************************
 4702: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4703: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4704: 1			; (logical shift)
 4705: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4706: 1			;
 4707: 1			; input:     r3,r2,r1,r0 = acc0
 4708: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4709: 1			;
 4710: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4711: 1			;
 4712: 1			; vernietigt:  niets
 4713: 1			;*******************************************************************************
 4714: 1  1023	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4715: 1  1025	C0 D0		                push    psw
 4716: 1  1027	EC		                mov     a,r4            ;neem aantal shifts
 4717: 1  1028	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4718: 1  102B	40 06		shiftleft1:     jc      shiftleft2
 4719: 1  102D	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4720: 1  102F	D3		                setb    c               ;N buiten bereik
 4721: 1  1030	D0 E0		                pop     acc
 4722: 1  1032	22		                ret
 4723: 1
 4724: 1  1033	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4725: 1  1035	8C F0		                mov     b,r4            ;lusteller initialiseren
 4726: 1  1037	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4727: 1  1038	E8		                mov     a,r0            ;start bij lsb
 4728: 1  1039	33		                rlc     a
 4729: 1  103A	F8		                mov     r0,a
 4730: 1  103B	E9		                mov     a,r1
 4731: 1  103C	33		                rlc     a
 4732: 1  103D	F9		                mov     r1,a
 4733: 1  103E	EA		                mov     a,r2
 4734: 1  103F	33		                rlc     a
 4735: 1  1040	FA		                mov     r2,a
 4736: 1  1041	EB		                mov     a,r3
 4737: 1  1042	33		                rlc     a
 4738: 1  1043	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4739: 1  1044	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4740: 1  1047	D0 F0		                pop     b               ;registers herstellen
 4741: 1  1049	D0 D0		                pop     psw
 4742: 1  104B	C3		                clr     c               ;N is binnen bereik
 4743: 1  104C	D0 E0		                pop     acc
 4744: 1  104E	22		                ret
 4745: 1
 4746: 1			;*******************************************************************************
 4747: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4748: 1			; (arithmetic shift)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4749: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4750: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4751: 1			; niet van teken!
 4752: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4753: 1			;                       (-2147483648 tot +2147483647)
 4754: 1			;
 4755: 1			; input:     r3,r2,r1,r0 = acc0
 4756: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4757: 1			;
 4758: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4759: 1			;            CY=1 als N>=31
 4760: 1			; vernietigt:  niets
 4761: 1			;*******************************************************************************
 4762: 1  104F	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 4763: 1  1051	C0 D0		                push    psw
 4764: 1  1053	EC		                mov     a,r4            ;neem aantal shifts
 4765: 1  1054	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4766: 1  1057	40 06		s_shiftright1:  jc      s_shiftright2
 4767: 1  1059	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4768: 1  105B	D3		                setb    c               ;N buiten bereik
 4769: 1  105C	D0 E0		                pop     acc
 4770: 1  105E	22		                ret
 4771: 1
 4772: 1  105F	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4773: 1  1061	8C F0		                mov     b,r4            ;lusteller initialiseren
 4774: 1  1063	EB		                mov     a,r3
 4775: 1  1064	20 E7 04	                jb      acc.7,s_shiftright20
 4776: 1  1067	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4777: 1  1069	80 02		                sjmp    s_shiftright3
 4778: 1  106B	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4779: 1
 4780: 1  106D	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4781: 1  106F	EB		                mov     a,r3            ;start bij msb
 4782: 1  1070	13		                rrc     a
 4783: 1  1071	FB		                mov     r3,a
 4784: 1  1072	EA		                mov     a,r2
 4785: 1  1073	13		                rrc     a
 4786: 1  1074	FA		                mov     r2,a
 4787: 1  1075	E9		                mov     a,r1
 4788: 1  1076	13		                rrc     a
 4789: 1  1077	F9		                mov     r1,a
 4790: 1  1078	E8		                mov     a,r0
 4791: 1  1079	13		                rrc     a
 4792: 1  107A	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4793: 1  107B	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4794: 1  107E	D0 F0		                pop     b               ;registers herstellen
 4795: 1  1080	D0 D0		                pop     psw
 4796: 1  1082	C3		                clr     c               ;N is binnen bereik
 4797: 1  1083	D0 E0		                pop     acc
 4798: 1  1085	22		                ret
 4799: 1
 4800: 1			;*******************************************************************************
 4801: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4802: 1			; (arithmetic shift)
 4803: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4804: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4805: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4806: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4807: 1			;                       (-2147483648 tot +2147483647)
 4808: 1			;
 4809: 1			; input:     r3,r2,r1,r0 = acc0
 4810: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4811: 1			;
 4812: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4813: 1			;            CY=1 als N>=31
 4814: 1			; vernietigt:  niets
 4815: 1			;*******************************************************************************
 4816: 1  1086	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 4817: 1  1088	C0 D0		                push    psw
 4818: 1  108A	EC		                mov     a,r4            ;neem aantal shifts
 4819: 1  108B	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4820: 1  108E	40 06		s_shiftleft1:   jc      s_shiftleft2
 4821: 1  1090	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4822: 1  1092	D3		                setb    c               ;N buiten bereik
 4823: 1  1093	D0 E0		                pop     acc
 4824: 1  1095	22		                ret
 4825: 1
 4826: 1  1096	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4827: 1  1098	8C F0		                mov     b,r4            ;lusteller initialiseren
 4828: 1
 4829: 1
 4830: 1
 4831: 1  109A	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4832: 1  109B	E8		                mov     a,r0             ;start bij lsb
 4833: 1  109C	33		                rlc     a
 4834: 1  109D	F8		                mov     r0,a
 4835: 1  109E	E9		                mov     a,r1
 4836: 1  109F	33		                rlc     a
 4837: 1  10A0	F9		                mov     r1,a
 4838: 1  10A1	EA		                mov     a,r2
 4839: 1  10A2	33		                rlc     a
 4840: 1  10A3	FA		                mov     r2,a
 4841: 1  10A4	EB		                mov     a,r3
 4842: 1  10A5	33		                rlc     a
 4843: 1  10A6	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4844: 1  10A8	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4845: 1  10A9	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4846: 1  10AC	D0 F0		                pop     b                ;registers herstellen
 4847: 1  10AE	D0 D0		                pop     psw
 4848: 1  10B0	C3		                clr     c                ;N is binnen bereik
 4849: 1  10B1	D0 E0		                pop     acc
 4850: 1  10B3	22		                ret
 4851: 1
 4852: 1			;*******************************************************************************
 4853: 1			; s_cmp16    (29,5us @16.777216MHz)
 4854: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4855: 1			;
 4856: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4857: 1			;
 4858: 1			; input:     r1,r0 = acc0
 4859: 1			;            r5,r4 = acc1
 4860: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4861: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4862: 1			;             f0=0,cy=0  als acc0 > acc1
 4863: 1			;             f0=1 cy=0    als acc1 = acc0
 4864: 1			;
 4865: 1			; vernietigt:  niets
 4866: 1			;*******************************************************************************
 4867: 1  10B4	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4868: 1  10B6	C0 D0		                push    psw
 4869: 1  10B8	E8		                mov     a,r0
 4870: 1  10B9	C0 E0		                push    acc
 4871: 1  10BB	E9		                mov     a,r1
 4872: 1  10BC	C0 E0		                push    acc
 4873: 1
 4874: 1  10BE	E9		                mov     a,r1            ;neem msb van acc0
 4875: 1  10BF	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4876: 1  10C0	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4877: 1  10C3	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4878: 1			                                        ;negatief is
 4879: 1  10C4	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4880: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4881: 1
 4882: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4883: 1			;acc0>acc1
 4884: 1  10C7	D0 E0		s_cmp160:       pop     acc
 4885: 1  10C9	F9		                mov     r1,a
 4886: 1  10CA	D0 E0		                pop     acc
 4887: 1  10CC	F8		                mov     r0,a
 4888: 1  10CD	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4889: 1  10CF	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4890: 1  10D1	C3		                clr     c               ;geef dit aan in de outputstatus
 4891: 1  10D2	D0 E0		                pop     acc
 4892: 1  10D4	22		                ret
 4893: 1			;acc0<acc1
 4894: 1  10D5	D0 E0		s_cmp161:       pop     acc
 4895: 1  10D7	F9		                mov     r1,a
 4896: 1  10D8	D0 E0		                pop     acc
 4897: 1  10DA	F8		                mov     r0,a
 4898: 1  10DB	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4899: 1  10DD	D3		                setb    c               ;groter dan acc0
 4900: 1  10DE	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4901: 1  10E0	D0 E0		                pop     acc
 4902: 1  10E2	22		                ret
 4903: 1			;gelijk teken, maak verschil
 4904: 1  10E3	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 4905: 1  10E4	E8		                mov     a,r0            ;acc0-acc1
 4906: 1  10E5	9C		                subb    a,r4
 4907: 1  10E6	F8		                mov     r0,a
 4908: 1  10E7	E9		                mov     a,r1
 4909: 1  10E8	9D		                subb    a,r5
 4910: 1  10E9	F9		                mov     r1,a
 4911: 1  10EA	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 4912: 1  10ED	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 4913: 1  10EE	60 02		                jz      s_cmp163        ;acc0=acc1
 4914: 1  10F0	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 4915: 1			;acc0=acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4916: 1  10F2	D0 E0		s_cmp163:       pop     acc
 4917: 1  10F4	F9		                mov     r1,a
 4918: 1  10F5	D0 E0		                pop     acc
 4919: 1  10F7	F8		                mov     r0,a
 4920: 1  10F8	D0 D0		                pop     psw             ;acc0=acc1
 4921: 1  10FA	C3		                clr     c               ;geef dit aan in de outputstatus
 4922: 1  10FB	D2 D5		                setb    f0
 4923: 1  10FD	D0 E0		                pop     acc
 4924: 1  10FF	22		                ret
 4925: 1
 4926: 1			;*******************************************************************************
 4927: 1			; cmp16            (19,9us @16.777216MHz)
 4928: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 4929: 1			;
 4930: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 4931: 1			;
 4932: 1			; input:     r1,r0 = acc0
 4933: 1			;            r5,r4 = acc1
 4934: 1			;
 4935: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4936: 1			;             f0=0,cy=0  als acc0 > acc1
 4937: 1			;             f0=1 cy=0    als acc1 = acc0
 4938: 1			;
 4939: 1			; vernietigt:  niets
 4940: 1			;*******************************************************************************
 4941: 1  1100	C0 E0		cmp16:          push    acc             ;bewaar registers
 4942: 1  1102	C0 F0		                push    b
 4943: 1  1104	C0 D0		                push    psw
 4944: 1
 4945: 1  1106	C3		                clr     c               ;vergelijk acc0 met acc1
 4946: 1  1107	E9		                mov     a,r1            ;eerst de msb's
 4947: 1  1108	8D F0		                mov     b,r5            ;test r1-r5
 4948: 1  110A	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4949: 1
 4950: 1  110D	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 4951: 1  110E	8C F0		                mov     b,r4            ;test r0-r4
 4952: 1  1110	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4953: 1			;acc0=acc1
 4954: 1  1113	D0 D0		                pop     psw
 4955: 1  1115	D2 D5		                setb    f0
 4956: 1  1117	C3		                clr     c
 4957: 1  1118	D0 F0		                pop     b
 4958: 1  111A	D0 E0		                pop     acc
 4959: 1  111C	22		                ret
 4960: 1  111D	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 4961: 1			;acc0>acc1
 4962: 1  111F	D0 D0		                pop     psw
 4963: 1  1121	C2 D5		                clr     f0
 4964: 1  1123	C3		                clr     c
 4965: 1  1124	D0 F0		                pop     b
 4966: 1  1126	D0 E0		                pop     acc
 4967: 1  1128	22		                ret
 4968: 1			;acc0<acc1
 4969: 1  1129	D0 D0		cmp162:         pop     psw
 4970: 1  112B	D3		                setb    c
 4971: 1  112C	C2 D5		                clr     f0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4972: 1  112E	D0 F0		                pop     b
 4973: 1  1130	D0 E0		                pop     acc
 4974: 1  1132	22		                ret
 4975: 1
 4976: 1			;*******************************************************************************
 4977: 1			; s_cmp32        (44,3us @16.777216MHz)
 4978: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 4979: 1			;
 4980: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4981: 1			;                         -2147483648 tot +2147483647
 4982: 1			; input:     r1,r0 = acc0
 4983: 1			;            r5,r4 = acc1
 4984: 1			;
 4985: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4986: 1			;             f0=0,cy=0  als acc0 > acc1
 4987: 1			;             f0=1 cy=0    als acc1 = acc0
 4988: 1			;
 4989: 1			; vernietigt:  niets
 4990: 1			;*******************************************************************************
 4991: 1  1133	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 4992: 1  1135	C0 D0		                push    psw
 4993: 1  1137	E8		                mov     a,r0
 4994: 1  1138	C0 E0		                push    acc
 4995: 1  113A	E9		                mov     a,r1
 4996: 1  113B	C0 E0		                push    acc
 4997: 1  113D	EA		                mov     a,r2
 4998: 1  113E	C0 E0		                push    acc
 4999: 1  1140	EB		                mov     a,r3
 5000: 1  1141	C0 E0		                push    acc
 5001: 1
 5002: 1  1143	EB		                mov     a,r3            ;neem msb van acc0
 5003: 1  1144	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 5004: 1  1145	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 5005: 1  1147	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 5006: 1  1149	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 5007: 1  114A	A2 E7		                mov     c,acc.7         ;negatief is
 5008: 1  114C	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 5009: 1			                                        ;acc1 positief. Dus acc1>acc0
 5010: 1			;acc0>acc1
 5011: 1  114E	D0 E0		s_cmp320:       pop     acc
 5012: 1  1150	FB		                mov     r3,a
 5013: 1  1151	D0 E0		                pop     acc
 5014: 1  1153	FA		                mov     r2,a
 5015: 1  1154	D0 E0		                pop     acc
 5016: 1  1156	F9		                mov     r1,a
 5017: 1  1157	D0 E0		                pop     acc
 5018: 1  1159	F8		                mov     r0,a
 5019: 1  115A	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5020: 1  115C	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5021: 1  115E	C3		                clr     c               ;geef dit aan in de outputstatus
 5022: 1  115F	D0 E0		                pop     acc
 5023: 1  1161	22		                ret
 5024: 1			;acc0<acc1
 5025: 1  1162	D0 E0		s_cmp321:       pop     acc
 5026: 1  1164	FB		                mov     r3,a
 5027: 1  1165	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5028: 1  1167	FA		                mov     r2,a
 5029: 1  1168	D0 E0		                pop     acc
 5030: 1  116A	F9		                mov     r1,a
 5031: 1  116B	D0 E0		                pop     acc
 5032: 1  116D	F8		                mov     r0,a
 5033: 1  116E	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5034: 1  1170	D3		                setb    c               ;groter dan acc0
 5035: 1  1171	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5036: 1  1173	D0 E0		                pop     acc
 5037: 1  1175	22		                ret
 5038: 1			;gelijk teken, maak verschil
 5039: 1  1176	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5040: 1  1177	E8		                mov     a,r0            ;acc0-acc1
 5041: 1  1178	9C		                subb    a,r4
 5042: 1  1179	F8		                mov     r0,a
 5043: 1  117A	E9		                mov     a,r1
 5044: 1  117B	9D		                subb    a,r5
 5045: 1  117C	F9		                mov     r1,a
 5046: 1  117D	EA		                mov     a,r2
 5047: 1  117E	9E		                subb    a,r6
 5048: 1  117F	FA		                mov     r2,a
 5049: 1  1180	EB		                mov     a,r3
 5050: 1  1181	9F		                subb    a,r7
 5051: 1  1182	FB		                mov     r3,a
 5052: 1  1183	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5053: 1  1186	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5054: 1  1187	49		                orl     a,r1
 5055: 1  1188	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5056: 1  1189	60 02		                jz      s_cmp323        ;acc0=acc1
 5057: 1  118B	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5058: 1			;acc0=acc1
 5059: 1  118D	D0 E0		s_cmp323:       pop     acc
 5060: 1  118F	FB		                mov     r3,a
 5061: 1  1190	D0 E0		                pop     acc
 5062: 1  1192	FA		                mov     r2,a
 5063: 1  1193	D0 E0		                pop     acc
 5064: 1  1195	F9		                mov     r1,a
 5065: 1  1196	D0 E0		                pop     acc
 5066: 1  1198	F8		                mov     r0,a
 5067: 1  1199	D0 D0		                pop     psw             ;acc0=acc1
 5068: 1  119B	C3		                clr     c               ;geef dit aan in de outputstatus
 5069: 1  119C	D2 D5		                setb    f0
 5070: 1  119E	D0 E0		                pop     acc
 5071: 1  11A0	22		                ret
 5072: 1
 5073: 1			;*******************************************************************************
 5074: 1			; cmp32        (27,14us @16.777216MHz)
 5075: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5076: 1			;
 5077: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5078: 1			;
 5079: 1			; input:     r3,r2,r1,r0 = acc0
 5080: 1			;            r7,r6,r5,r4 = acc1
 5081: 1			;
 5082: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5083: 1			;            f0=0,cy=0  als acc0 > acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5084: 1			;            f0=1 cy=0    als acc1 = acc0
 5085: 1			;
 5086: 1			; vernietigt:  niets
 5087: 1			;*******************************************************************************
 5088: 1  11A1	C0 E0		cmp32:          push    acc             ;bewaar registers
 5089: 1  11A3	C0 F0		                push    b
 5090: 1  11A5	C0 D0		                push    psw
 5091: 1
 5092: 1  11A7	C3		                clr     c               ;vergelijk acc0 met acc1
 5093: 1  11A8	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5094: 1  11A9	8F F0		                mov     b,r7            ;test r3-r7
 5095: 1  11AB	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5096: 1
 5097: 1  11AE	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5098: 1  11AF	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5099: 1  11B1	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5100: 1
 5101: 1  11B4	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5102: 1  11B5	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5103: 1  11B7	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5104: 1
 5105: 1  11BA	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5106: 1  11BB	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5107: 1  11BD	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5108: 1			;acc0=acc1
 5109: 1  11C0	D0 D0		                pop     psw
 5110: 1  11C2	D2 D5		                setb    f0
 5111: 1  11C4	C3		                clr     c
 5112: 1  11C5	D0 F0		                pop     b
 5113: 1  11C7	D0 E0		                pop     acc
 5114: 1  11C9	22		                ret
 5115: 1  11CA	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5116: 1			;acc0>acc1, indien cy=0
 5117: 1  11CC	D0 D0		                pop     psw
 5118: 1  11CE	C2 D5		                clr     f0
 5119: 1  11D0	C3		                clr     c
 5120: 1  11D1	D0 F0		                pop     b
 5121: 1  11D3	D0 E0		                pop     acc
 5122: 1  11D5	22		                ret
 5123: 1			;acc0<acc1
 5124: 1  11D6	D0 D0		cmp322:         pop     psw
 5125: 1  11D8	D3		                setb    c
 5126: 1  11D9	C2 D5		                clr     f0
 5127: 1  11DB	D0 F0		                pop     b
 5128: 1  11DD	D0 E0		                pop     acc
 5129: 1  11DF	22		                ret
 5130: 1
 5131: 1
 5132: 1			;*******************************************************************************
 5133: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5134: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5135: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5136: 1			; adres zitten.
 5137: 1			;
 5138: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5139: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5140: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5141: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5142: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5143: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5144: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5145: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5146: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5147: 1			;                cy = 0  lookup is ok
 5148: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5149: 1			; vernietigt:  niets
 5150: 1			;*******************************************************************************
 5151: 1  11E0	C0 E0		table_lu:       push    acc             ;bewaren registers
 5152: 1  11E2	C0 D0		                push    psw
 5153: 1  11E4	C0 82		                push    dpl
 5154: 1  11E6	C0 83		                push    dph
 5155: 1
 5156: 1  11E8	A2 D5		                mov     c,f0            ;byte of word items?
 5157: 1  11EA	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5158: 1			;tabel met byte items
 5159: 1  11EC	E5 82		                mov     a,dpl           ;datapointer plus index
 5160: 1  11EE	28		                add     a,r0
 5161: 1  11EF	F5 82		                mov     dpl,a
 5162: 1  11F1	E5 83		                mov     a,dph
 5163: 1  11F3	39		                addc    a,r1
 5164: 1  11F4	F5 83		                mov     dph,a
 5165: 1  11F6	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5166: 1  11F8	A2 D1		                mov     c,f1            ;code of datageheugen?
 5167: 1  11FA	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5168: 1
 5169: 1			;bytetabel in codegeheugen
 5170: 1  11FC	74 00		                mov     a,#0
 5171: 1  11FE	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5172: 1  11FF	F8		                mov     r0,a            ;en stop in acc0
 5173: 1  1200	79 00		                mov     r1,#0
 5174: 1  1202	02 12 61	                ljmp    table_lu4       ;en klaar
 5175: 1
 5176: 1			;bytetabel in datageheugen
 5177: 1  1205	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5178: 1  1206	F8		                mov     r0,a            ;en stop in acc0
 5179: 1  1207	79 00		                mov     r1,#0
 5180: 1  1209	02 12 61	                ljmp    table_lu4       ;en klaar
 5181: 1
 5182: 1  120C	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5183: 1  120E	D0 82		                pop     dpl
 5184: 1  1210	D0 D0		                pop     psw
 5185: 1  1212	D3		                setb    c              ;foutstatus teruggeven!
 5186: 1  1213	D0 E0		                pop     acc
 5187: 1  1215	22		                ret
 5188: 1
 5189: 1			;tabel met word items
 5190: 1  1216	E8		table_lu2:      mov     a,r0            ;index op stack
 5191: 1  1217	C0 E0		                push    acc
 5192: 1  1219	E9		                mov     a,r1
 5193: 1  121A	C0 E0		                push    acc
 5194: 1
 5195: 1  121C	C3		                clr      c              ;index maal 2 (word items)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5196: 1  121D	E8		                mov     a,r0
 5197: 1  121E	33		                rlc     a
 5198: 1  121F	F8		                mov     r0,a
 5199: 1  1220	E9		                mov     a,r1
 5200: 1  1221	33		                rlc     a
 5201: 1  1222	F9		                mov     r1,a
 5202: 1
 5203: 1  1223	E5 82		                mov     a,dpl           ;datapointer plus index
 5204: 1  1225	28		                add     a,r0
 5205: 1  1226	F5 82		                mov     dpl,a
 5206: 1  1228	E5 83		                mov     a,dph
 5207: 1  122A	39		                addc    a,r1
 5208: 1  122B	F5 83		                mov     dph,a
 5209: 1
 5210: 1  122D	D0 E0		                pop     acc             ;index weer van stack
 5211: 1  122F	F9		                mov     r1,a
 5212: 1  1230	D0 E0		                pop     acc
 5213: 1  1232	F8		                mov     r0,a
 5214: 1
 5215: 1  1233	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5216: 1  1235	A2 D1		                mov     c,f1            ;code of datageheugen?
 5217: 1  1237	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5218: 1			;wordtabel in codegeheugen
 5219: 1  1239	74 00		                mov     a,#0
 5220: 1  123B	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5221: 1  123C	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5222: 1  123D	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5223: 1  123F	24 01		                add     a,#1
 5224: 1  1241	F5 82		                mov     dpl,a
 5225: 1  1243	E5 83		                mov     a,dph
 5226: 1  1245	34 00		                addc    a,#0
 5227: 1  1247	F5 83		                mov     dph,a
 5228: 1  1249	74 00		                mov     a,#0
 5229: 1  124B	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5230: 1  124C	F9		                mov     r1,a            ;msb in acc0 stoppen
 5231: 1  124D	80 12		                sjmp    table_lu4        ;en klaar
 5232: 1			;wordtabel    in datageheugen
 5233: 1  124F	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5234: 1  1250	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5235: 1  1251	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5236: 1  1253	24 01		                add     a,#1
 5237: 1  1255	F5 82		                mov     dpl,a
 5238: 1  1257	E5 83		                mov     a,dph
 5239: 1  1259	34 00		                addc    a,#0
 5240: 1  125B	F5 83		                mov     dph,a
 5241: 1  125D	74 00		                mov     a,#0
 5242: 1  125F	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5243: 1  1260	F9		                mov     r1,a            ;msb in acc0 stoppen
 5244: 1			                                        ;en klaar
 5245: 1
 5246: 1  1261	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5247: 1  1263	D0 82		                pop     dpl
 5248: 1  1265	D0 D0		                pop     psw
 5249: 1  1267	D0 E0		                pop     acc
 5250: 1  1269	22		                ret
 5251: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5252: 1
 5253: 1
 5254: 1			;*******************************************************************************
 5255: 1			; Cordic        (2,11ms @16.777216MHz)
 5256: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5257: 1			; waarde (2's complement) opgegeven hoek.
 5258: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5259: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5260: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5261: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5262: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5263: 1			; als geschaalde getallen ter beschikking komen.
 5264: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5265: 1			;
 5266: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5267: 1			;
 5268: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5269: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5270: 1			;            cy = 0 : hoek binnen bereik
 5271: 1			;            cy = 1 : error, hoek buiten bereik
 5272: 1			;            nauwkeurigheid: 12 msbits
 5273: 1			; vernietigt:  niets
 5274: 1			;*******************************************************************************
 5275: 1  126A	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5276: 1  126C	C0 D0		                push    psw
 5277: 1  126E	C0 83		                push    dph
 5278: 1  1270	C0 82		                push    dpl
 5279: 1  1272	C0 F0		                push    b
 5280: 1
 5281: 1  1274	EF		                mov     a,r7
 5282: 1  1275	C0 E0		                push    acc
 5283: 1  1277	EE		                mov     a,r6
 5284: 1  1278	C0 E0		                push    acc
 5285: 1  127A	ED		                mov     a,r5
 5286: 1  127B	C0 E0		                push    acc
 5287: 1  127D	EC		                mov     a,r4
 5288: 1  127E	C0 E0		                push    acc
 5289: 1
 5290: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5291: 1			;en niet groter dan pi/2 radialen (6478h)
 5292: 1  1280	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5293: 1  1282	7D 64		                mov     r5,#64h
 5294: 1  1284	12 11 00	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5295: 1  1287	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5296: 1  128A	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5297: 1  128C	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5298: 1
 5299: 1  128E	C2 A0		cordic000:      clr     p2.0
 5300: 1  1290	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5301: 1  1292	7D 9B		                mov     r5,#9bh
 5302: 1  1294	12 11 00	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5303: 1  1297	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5304: 1  129A	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5305: 1  129C	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5306: 1
 5307: 1  129E	C2 A1		cordic_error:   clr     p2.1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5308: 1  12A0	02 13 52	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5309: 1
 5310: 1			;Hoek is -pi/2 resultaat gekend
 5311: 1  12A3	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5312: 1  12A5	7A 00		                mov     r2,#000h
 5313: 1  12A7	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5314: 1  12A9	78 00		                mov     r0,#000h
 5315: 1  12AB	C3		                clr     c
 5316: 1  12AC	02 13 52	                ljmp    cordic40        ;en klaar
 5317: 1			;hoek is +pi/2 resultaat gekend
 5318: 1  12AF	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5319: 1  12B1	7A FF		                mov     r2,#0ffh
 5320: 1  12B3	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5321: 1  12B5	78 00		                mov     r0,#000h
 5322: 1  12B7	C3		                clr     c
 5323: 1  12B8	02 13 52	                ljmp    cordic40        ;en klaar
 5324: 1
 5325: 1  12BB	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5326: 1  12BD	7D 00		                mov     r5,#00h
 5327: 1  12BF	12 11 00	                lcall   cmp16            ;vergelijk de hoeken
 5328: 1  12C2	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5329: 1  12C5	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5330: 1			;hoek is 0, resultaat gekend
 5331: 1  12C7	C2 A7		cordic_nul:     clr     p2.7
 5332: 1  12C9	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5333: 1  12CB	7A 00		                mov     r2,#000h
 5334: 1  12CD	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5335: 1  12CF	78 FF		                mov     r0,#0ffh
 5336: 1  12D1	C3		                clr     c
 5337: 1  12D2	02 13 52	                ljmp    cordic40        ;en klaar
 5338: 1
 5339: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5340: 1  12D5	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5341: 1  12D6	C0 E0		                push    acc
 5342: 1  12D8	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5343: 1  12D9	C0 E0		                push    acc
 5344: 1
 5345: 1  12DB	7B 00		                mov     r3,#00h         ;y=0
 5346: 1  12DD	7A 00		                mov     r2,#00h
 5347: 1  12DF	79 26		                mov     r1,#026h        ;x = K * 2^14
 5348: 1  12E1	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5349: 1
 5350: 1  12E3	75 F0 00	                mov     b,#00h          ;loopteller=0
 5351: 1
 5352: 1  12E6	90 13 AA	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5353: 1
 5354: 1  12E9	EB		cordic1:        mov     a,r3            ;sry=y
 5355: 1  12EA	FF		                mov     r7,a
 5356: 1  12EB	EA		                mov     a,r2
 5357: 1  12EC	FE		                mov     r6,a
 5358: 1  12ED	E9		                mov     a,r1            ;srx=x
 5359: 1  12EE	FD		                mov     r5,a
 5360: 1  12EF	E8		                mov     a,r0
 5361: 1  12F0	FC		                mov     r4,a
 5362: 1
 5363: 1  12F1	12 13 71	                lcall   cordic5          ;srx en sry >> loopteller

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5364: 1
 5365: 1  12F4	D0 E0		                pop     acc
 5366: 1  12F6	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5367: 1
 5368: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5369: 1  12F9	C3		                clr     c
 5370: 1  12FA	E8		                mov     a,r0            ;bereken x=x-sry
 5371: 1  12FB	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5372: 1  12FC	F8		                mov     r0,a
 5373: 1  12FD	E9		                mov     a,r1
 5374: 1  12FE	9F		                subb    a,r7
 5375: 1  12FF	F9		                mov     r1,a
 5376: 1
 5377: 1  1300	EA		                mov     a,r2            ;bereken y=y+srx
 5378: 1  1301	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5379: 1  1302	FA		                mov     r2,a
 5380: 1  1303	EB		                mov     a,r3
 5381: 1  1304	3D		                addc    a,r5
 5382: 1  1305	FB		                mov     r3,a
 5383: 1
 5384: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5385: 1  1306	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5386: 1  1308	93		                movc    a,@a+dptr
 5387: 1  1309	A3		                inc     dptr
 5388: 1  130A	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5389: 1  130B	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5390: 1  130D	C3		                clr     c               ;verklein de hoek
 5391: 1  130E	9C		                subb    a,r4
 5392: 1  130F	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5393: 1  1311	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5394: 1
 5395: 1  1313	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5396: 1  1315	93		                movc    a,@a+dptr
 5397: 1  1316	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5398: 1  1317	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5399: 1  1318	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5400: 1  131A	9D		                subb    a,r5            ;verklein de hoek
 5401: 1  131B	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5402: 1
 5403: 1			;loopteller incrementeren en testen op einde van de iteratie
 5404: 1  131D	05 F0		cordic2:        inc     b               ;loopteller++
 5405: 1  131F	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5406: 1  1321	65 F0		                xrl     a,b             ;test op gelijkheid
 5407: 1  1323	60 28		                jz      cordic4         ;ja klaar!
 5408: 1  1325	02 12 E9	                ljmp    cordic1         ;nee, nog even verder...
 5409: 1
 5410: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5411: 1  1328	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5412: 1  1329	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5413: 1  132A	F8		                mov     r0,a
 5414: 1  132B	E9		                mov     a,r1
 5415: 1  132C	3F		                addc    a,r7
 5416: 1  132D	F9		                mov     r1,a
 5417: 1
 5418: 1  132E	C3		                clr     c
 5419: 1  132F	EA		                mov     a,r2            ;bereken y=y-srx

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5420: 1  1330	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5421: 1  1331	FA		                mov     r2,a
 5422: 1  1332	EB		                mov     a,r3
 5423: 1  1333	9D		                subb    a,r5
 5424: 1  1334	FB		                mov     r3,a
 5425: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5426: 1  1335	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5427: 1  1337	93		                movc    a,@a+dptr
 5428: 1  1338	A3		                inc     dptr
 5429: 1  1339	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5430: 1  133A	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5431: 1  133C	2C		                add     a,r4            ;vergroot de hoek
 5432: 1  133D	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5433: 1  133F	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5434: 1
 5435: 1  1341	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5436: 1  1343	93		                movc    a,@a+dptr
 5437: 1  1344	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5438: 1  1345	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5439: 1  1346	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5440: 1  1348	3D		                addc    a,r5            ;vergroot de hoek
 5441: 1  1349	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5442: 1
 5443: 1  134B	80 D0		                sjmp    cordic2
 5444: 1
 5445: 1  134D	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5446: 1  134F	D0 E0		                pop     acc             ;dummy hoek van stack
 5447: 1  1351	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5448: 1
 5449: 1  1352	D0 E0		cordic40:       pop     acc
 5450: 1  1354	FC		                mov     r4,a
 5451: 1  1355	D0 E0		                pop     acc
 5452: 1  1357	FD		                mov     r5,a
 5453: 1  1358	D0 E0		                pop     acc
 5454: 1  135A	FE		                mov     r6,a
 5455: 1  135B	D0 E0		                pop     acc
 5456: 1  135D	FF		                mov     r7,a
 5457: 1  135E	D0 F0		                pop     b
 5458: 1  1360	D0 82		                pop     dpl
 5459: 1  1362	D0 83		                pop     dph
 5460: 1  1364	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5461: 1  1366	D0 D0		                pop     psw
 5462: 1  1368	D0 E0		                pop     acc
 5463: 1  136A	22		                ret
 5464: 1
 5465: 1  136B	D0 D0		cordic41:       pop     psw
 5466: 1  136D	D3		                setb    c
 5467: 1  136E	D0 E0		                pop     acc
 5468: 1  1370	22		                ret
 5469: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5470: 1			;over het aantal posities aangegeven in het B register.
 5471: 1  1371	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5472: 1  1373	74 00		                mov     a,#0            ;test of loopteller=0
 5473: 1  1375	65 F0		                xrl     a,b
 5474: 1  1377	60 2E		                jz      cordic52        ;klaar
 5475: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5476: 1  1379	ED		                mov     a,r5            ;test teken van srx
 5477: 1  137A	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5478: 1  137D	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5479: 1  137F	80 02		                sjmp    cordic50
 5480: 1  1381	D2 D5		cordic5a:       setb    f0
 5481: 1  1383	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5482: 1  1385	ED		                mov     a,r5            ;eerst de msb
 5483: 1  1386	13		                rrc     a
 5484: 1  1387	FD		                mov     r5,a
 5485: 1  1388	EC		                mov     a,r4            ;dan de lsb
 5486: 1  1389	13		                rrc     a
 5487: 1  138A	FC		                mov     r4,a
 5488: 1  138B	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5489: 1  138E	D0 F0		                pop     b               ;haal de loopteller van stack
 5490: 1  1390	C0 F0		                push    b               ;en bewaar hem weer
 5491: 1  1392	EF		                mov     a,r7            ;test teken van sry
 5492: 1  1393	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5493: 1  1396	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5494: 1  1398	80 02		                sjmp    cordic51
 5495: 1  139A	D2 D5		cordic5b:       setb    f0
 5496: 1  139C	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5497: 1  139E	EF		                mov     a,r7            ;eerst de msb
 5498: 1  139F	13		                rrc     a
 5499: 1  13A0	FF		                mov     r7,a
 5500: 1  13A1	EE		                mov     a,r6            ;dan de lsb
 5501: 1  13A2	13		                rrc     a
 5502: 1  13A3	FE		                mov     r6,a
 5503: 1  13A4	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5504: 1
 5505: 1  13A7	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5506: 1  13A9	22		                ret
 5507: 1
 5508: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5509: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5510: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5511: 1  13AA	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5512: 1  13AC	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5513: 1  13AE	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5514: 1  13B0	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5515: 1  13B2	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5516: 1  13B4	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5517: 1  13B6	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5518: 1  13B8	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5519: 1  13BA	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5520: 1  13BC	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5521: 1  13BE	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5522: 1  13C0	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5523: 1  13C2	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5524: 1  13C4	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5525: 1  13C6	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5526: 1
 5527: 1			endif        ;einde van aduc_math
 5528: 1			;******************************************************************************
 5529: 1
 5530: 1			ifdef        aduc_adc    ;A/D conversie routines
 5531: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5532: 1			; ADuCADC_mide
 5533: 1			; Geschreven door [dp] op 5/1/2014
 5534: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5535: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5536: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5537: 1			; bron instellen.
 5538: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5539: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5540: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5541: 1			;
 5542: 1			;*******************************************************************************
 5543: 1
 5544: 1			;*******************************************************************************
 5545: 1			; adc_init
 5546: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5547: 1			; -  4 track&hold clockperiodes
 5548: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5549: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5550: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5551: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5552: 1			;
 5553: 1			; input: R0 =  0  : Interne referentiebron
 5554: 1			;        R0 <> 0  : Externe referentiebron
 5555: 1			;
 5556: 1			; Deze routine vernietigt niets
 5557: 1			;*******************************************************************************
 5558: 1  13C8	C0 E0		adc_init:       push    acc                 ;registers op stack
 5559: 1  13CA	C0 D0		                push    psw
 5560: 1  13CC	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5561: 1  13CF	E8		                mov     a,r0                ;welke referentiebron?
 5562: 1  13D0	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5563: 1  13D2	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5564: 1  13D5	D0 D0		adc_init1:      pop     psw
 5565: 1  13D7	D0 E0		                pop     acc
 5566: 1  13D9	22		                ret
 5567: 1
 5568: 1			;*******************************************************************************
 5569: 1			; adc_single
 5570: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5571: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5572: 1			; (2's complement) formaat van de meetwaarde.
 5573: 1			; _____________________________________________________________
 5574: 1			; resolutie  |     unsigned      |           signed            |
 5575: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5576: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5577: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5578: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5579: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5580: 1			; _____________________________________________________________
 5581: 1			;
 5582: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5583: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5584: 1			; De ingangsparameter wordt doorgegeven via R0.
 5585: 1			;
 5586: 1			; input:
 5587: 1			;             7    6    5    4    3    2    1    0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5588: 1			;           _______________________________________
 5589: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5590: 1			;           ---------------------------------------
 5591: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5592: 1			;                                         1000b = temp.sensor
 5593: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5594: 1			;                                   10b = 12 bits, 11b = 12 bits
 5595: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5596: 1			;
 5597: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5598: 1			;         cy=0  bij conversie ok
 5599: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5600: 1			;
 5601: 1			; Deze routine vernietigt niets
 5602: 1			;*******************************************************************************
 5603: 1  13DA	C0 E0		adc_single:     push    acc                 ;registers op stack
 5604: 1  13DC	C0 D0		                push    psw
 5605: 1  13DE	C0 F0		                push    b
 5606: 1  13E0	E8		                mov     a,r0                ;neem inputparameter
 5607: 1  13E1	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5608: 1  13E3	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5609: 1  13E6	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5610: 1  13E8	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5611: 1  13EA	D2 DC		                setb    sconv               ;start een meting
 5612: 1  13EC	E8		                mov     a,r0                ;neem parameter terug
 5613: 1  13ED	A2 E6		                mov     c,acc.6
 5614: 1  13EF	92 D5		                mov     f0,c                ;bewaar format bit
 5615: 1  13F1	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5616: 1  13F4	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5617: 1  13F7	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5618: 1  13FA	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5619: 1			;*******************************************************************************
 5620: 1			;8 bit resultaat gevraagd
 5621: 1			;*******************************************************************************
 5622: 1  13FD	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5623: 1  13FF	C4		                swap    a                    ;swap nibbles
 5624: 1  1400	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5625: 1  1402	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5626: 1  1404	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5627: 1  1406	C4		                swap    a
 5628: 1  1407	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5629: 1  1409	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5630: 1			;8 bit unsigned formaat
 5631: 1  140C	79 00		                mov     r1,#00h              ;unsigned
 5632: 1  140E	F8		                mov     r0,a
 5633: 1  140F	80 63		                sjmp    adc_single42
 5634: 1			;8 bit signed formaat
 5635: 1  1411	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5636: 1  1414	24 80		                add     a,#80h                ;negatief getal van maken
 5637: 1  1416	F8		                mov     r0,a
 5638: 1  1417	79 FF		                mov     r1,#0ffh
 5639: 1  1419	80 59		                sjmp    adc_single42
 5640: 1  141B	C3		adc_single20:   clr     c
 5641: 1  141C	94 80		                subb    a,#80h                ;positief deel verkleinen
 5642: 1  141E	F8		                mov     r0,a
 5643: 1  141F	79 00		                mov     r1,#00h

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5644: 1  1421	80 51		                sjmp    adc_single42
 5645: 1
 5646: 1  1423	02 14 7C	adc_single21:   ljmp    adc_single43
 5647: 1			;*******************************************************************************
 5648: 1			;10 bit resultaat gevraagd
 5649: 1			;*******************************************************************************
 5650: 1  1426	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5651: 1  1428	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5652: 1  142A	03		                rr     a              ;naar msbits roteren
 5653: 1  142B	03		                rr     a
 5654: 1  142C	F5 F0		                mov    b,a            ;even bewaren
 5655: 1  142E	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5656: 1  1430	03		                rr     a              ;twee plaatsen opschuiven
 5657: 1  1431	03		                rr     a
 5658: 1  1432	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5659: 1  1434	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5660: 1  1436	F5 F0		                mov    b,a            ;low byte even bewaren
 5661: 1  1438	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5662: 1  143A	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5663: 1  143C	03		                rr     a               ;en op hun plaats schuiven
 5664: 1  143D	03		                rr     a
 5665: 1  143E	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5666: 1			;10 bit unsigned formaat
 5667: 1  1441	F9		                mov    r1,a            ;unsigned
 5668: 1  1442	A8 F0		                mov    r0,b
 5669: 1  1444	80 2E		                sjmp   adc_single42
 5670: 1			;10 bit signed formaat
 5671: 1  1446	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5672: 1  1449	24 FE		                add    a,#0feh             ;negatief getal van maken
 5673: 1  144B	F9		                mov    r1,a
 5674: 1  144C	A8 F0		                mov    r0,b
 5675: 1  144E	80 24		                sjmp   adc_single42
 5676: 1  1450	C3		adc_single31:   clr    c
 5677: 1  1451	94 02		                subb   a,#02h              ;positief deel verkleinen
 5678: 1  1453	F9		                mov    r1,a
 5679: 1  1454	A8 F0		                mov    r0,b
 5680: 1  1456	80 1C		                sjmp   adc_single42
 5681: 1
 5682: 1			;*******************************************************************************
 5683: 1			;12 bit resultaat gevraagd
 5684: 1			;*******************************************************************************
 5685: 1  1458	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5686: 1  145A	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5687: 1  145C	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5688: 1			;12 bit unsigned formaat
 5689: 1  145F	A8 D9		                mov    r0,adcdatal           ;unsigned
 5690: 1  1461	F9		                mov    r1,a
 5691: 1  1462	80 10		                sjmp   adc_single42
 5692: 1			;12 bit signed formaat
 5693: 1  1464	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5694: 1  1467	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5695: 1  1469	F9		                mov    r1,a
 5696: 1  146A	A8 D9		                mov    r0,adcdatal
 5697: 1  146C	80 06		                sjmp   adc_single42
 5698: 1  146E	C3		adc_single41:   clr    c
 5699: 1  146F	94 08		                subb   a,#08h                ;positief deel verkleinen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5700: 1  1471	F9		                mov    r1,a
 5701: 1  1472	A8 D9		                mov    r0,adcdatal
 5702: 1  1474	D0 F0		adc_single42:   pop    b
 5703: 1  1476	D0 D0		                pop    psw
 5704: 1  1478	C3		                clr    c
 5705: 1  1479	D0 E0		                pop    acc
 5706: 1  147B	22		                ret
 5707: 1
 5708: 1  147C	D0 F0		adc_single43:   pop    b
 5709: 1  147E	D0 D0		                pop    psw
 5710: 1  1480	D3		                setb   c
 5711: 1  1481	D0 E0		                pop    acc
 5712: 1  1483	22		                ret
 5713: 1
 5714: 1			endif        ;einde van aduc_adc
 5715: 1			;*******************************************************************************
 5716: 1
 5717: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5718: 1			;******************************************************************************
 5719: 1			; ADuCKEY_mide.inc
 5720: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5721: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5722: 1			;
 5723: 1			;     V2.0      V1.1
 5724: 1			;                           |   |   |   |
 5725: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5726: 1			;                   |       |   |   |   |
 5727: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5728: 1			;                   |       |   |   |   |
 5729: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5730: 1			;                   |       |   |   |   |
 5731: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5732: 1			;                   |       |   |   |   |
 5733: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5734: 1			;                   |           |   |   |
 5735: 1			;     P0.5      P3.5|-K2--------|   |   |
 5736: 1			;                   |               |   |
 5737: 1			;     P0.6      P3.6|-K3------------|   |
 5738: 1			;                   |                   |
 5739: 1			;     P0.7      P3.7|-K4----------------|
 5740: 1			;
 5741: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5742: 1			; gebruikt.
 5743: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5744: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5745: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5746: 1			; en als ingang wordt aangeboden.
 5747: 1			;
 5748: 1			;                                  ___                 ___
 5749: 1			;                     ____________|   |  |------------|   |
 5750: 1			;              ____  |   ____     |   |  |   ____     |   |
 5751: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5752: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5753: 1			; '1'= toets  | cl |    | cl |              | cl |
 5754: 1			;  ingedrukt  |____|    |____|              |____|
 5755: 1			;                |         |                   |

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5756: 1			;      CLOCK     |         |                   |
 5757: 1			;         _______|_________|___________________|
 5758: 1			;
 5759: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 5760: 1			;
 5761: 1			;              MAP0      MAP1                 MAP2         MAP3
 5762: 1			;
 5763: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5764: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5765: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5766: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5767: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 5768: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5769: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 5770: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5771: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5772: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5773: 1			;
 5774: 1			;          MAP0    MAP1          MAP2    MAP3
 5775: 1			;         _______________       _______________
 5776: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 5777: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5778: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5779: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5780: 1			;
 5781: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5782: 1			;         | | | | | | | |       | | | | | | | |
 5783: 1			;        K K K K K K K K       K K K K K K K K
 5784: 1			;         O O O O O O O O       O O O O O O O O
 5785: 1			;         L L L L L L L L       L L L L L L L L
 5786: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5787: 1			;
 5788: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 5789: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 5790: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5791: 1			; van bitmaps van voor naar achter.
 5792: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5793: 1			;
 5794: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5795: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5796: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5797: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 5798: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5799: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5800: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5801: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5802: 1			; deze toetswaarde weer.
 5803: 1			;
 5804: 1			;
 5805: 1			;
 5806: 1			;******************************************************************************
 5807: 1
 5808: 1
 5809: 1			;******************************************************************************
 5810: 1			; key_init
 5811: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5812: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5813: 1			; input: niets
 5814: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 5815: 1			;         (map0,map1,map2,map3 =0)
 5816: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5817: 1			; Deze routine vernietigt niets
 5818: 1			;******************************************************************************
 5819: 1
 5820: 1  1484	C0 E0		Key_init:       push    acc          ;bewaar registers
 5821: 1  1486	C0 D0		                push    psw
 5822: 1  1488	E8		                mov     a,r0
 5823: 1  1489	C0 E0		                push    acc
 5824: 1  148B	E9		                mov     a,r1
 5825: 1  148C	C0 E0		                push    acc
 5826: 1  148E	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5827: 1  1490	79 09		                mov     r1,#9        ;9 bytes in de maps
 5828: 1  1492	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5829: 1  1494	08		                inc     r0           ;volgende byte nemen
 5830: 1  1495	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5831: 1  1497	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5832: 1  1499	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 5833: 1  149B	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5834: 1  149E	D0 E0		                pop     acc          ;herstel registers
 5835: 1  14A0	F9		                mov     r1,a
 5836: 1  14A1	D0 E0		                pop     acc
 5837: 1  14A3	F8		                mov     r0,a
 5838: 1  14A4	D0 D0		                pop     psw
 5839: 1  14A6	D0 E0		                pop     acc
 5840: 1  14A8	22		                ret                    ;terug naar caller
 5841: 1			;******************************************************************************
 5842: 1
 5843: 1
 5844: 1			;******************************************************************************
 5845: 1			; toets_flank
 5846: 1			; Deze routine detecteert de indrukflank van een toets.
 5847: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5848: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5849: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5850: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5851: 1			; minder dan 20ms duurt.
 5852: 1			; input : niets
 5853: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5854: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5855: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5856: 1			;
 5857: 1			; Deze routine vernietigt geen registers.
 5858: 1			;******************************************************************************
 5859: 1  14A9	C0 E0		Toets_flank:    push    acc
 5860: 1  14AB	C0 D0		                push    psw
 5861: 1  14AD	12 14 C7	                lcall   Keyscan
 5862: 1  14B0	12 15 43	                lcall   Keyedge
 5863: 1  14B3	D0 D0		                pop     psw
 5864: 1  14B5	D0 E0		                pop     acc
 5865: 1  14B7	22		                ret
 5866: 1
 5867: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5868: 1			; toets_ingedrukt
 5869: 1			; Deze routine detecteert een ingedrukte toets.
 5870: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5871: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5872: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5873: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5874: 1			; minder dan 20ms duurt.
 5875: 1			; input : niets
 5876: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5877: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5878: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5879: 1			;
 5880: 1			; Deze routine vernietigt geen registers.
 5881: 1			;******************************************************************************
 5882: 1  14B8	C0 E0		Toets_ingedrukt:push    acc
 5883: 1  14BA	C0 D0		                push    psw
 5884: 1  14BC	12 14 C7	                lcall   Keyscan
 5885: 1  14BF	12 15 2A	                lcall   Keydown
 5886: 1  14C2	D0 D0		                pop     psw
 5887: 1  14C4	D0 E0		                pop     acc
 5888: 1  14C6	22		                ret
 5889: 1
 5890: 1
 5891: 1			;******************************************************************************
 5892: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5893: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5894: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5895: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5896: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5897: 1			; zoals aangegeven in het blokschema van het algorithme.
 5898: 1			; input : niets
 5899: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5900: 1			;         ervan weergeven
 5901: 1			;
 5902: 1			; Deze routine vernietigt geen registers
 5903: 1			;******************************************************************************
 5904: 1
 5905: 1  14C7	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 5906: 1  14C9	C0 D0		                push    psw
 5907: 1  14CB	C0 F0		                push    b
 5908: 1  14CD	E8		                mov     a,r0
 5909: 1  14CE	C0 E0		                push    acc
 5910: 1  14D0	E9		                mov     a,r1
 5911: 1  14D1	C0 E0		                push    acc
 5912: 1  14D3	EA		                mov     a,r2
 5913: 1  14D4	C0 E0		                push    acc
 5914: 1  14D6	EE		                mov     a,r6
 5915: 1  14D7	C0 E0		                push    acc
 5916: 1
 5917: 1  14D9	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 5918: 1  14DB	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 5919: 1  14DE	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 5920: 1  14E0	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 5921: 1
 5922: 1  14E2			Scanloop:
 5923: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5924: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 5925: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 5926: 1			                mov     p0.0,c
 5927: 1			                mov     c,acc.1
 5928: 1			                mov     p0.1,c
 5929: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 5930: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 5931: 1			endif
 5932: 1
 5933: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 5934: 1  14E2	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 5935: 1			                                      ;een rij-lijn
 5936: 1			endif
 5937: 1
 5938: 1			; Eerst de flipflops implementeren.
 5939: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 5940: 1			; te lezen van de kolomlijnen
 5941: 1  14E4	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 5942: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5943: 1  14E5	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 5944: 1  14E6	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 5945: 1  14E7	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 5946: 1  14E8	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 5947: 1  14EA	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 5948: 1  14EB	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 5949: 1  14EC	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 5950: 1  14EE	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 5951: 1  14EF	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 5952: 1  14F0	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 5953: 1  14F1	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 5954: 1  14F2	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 5955: 1  14F4	FA		                mov     r2,a          ;even bewaren in register
 5956: 1
 5957: 1
 5958: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 5959: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 5960: 1			                                      ;poort3 kolomlijnen
 5961: 1			endif
 5962: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 5963: 1  14F5	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 5964: 1			                                     ;poort0 kolomlijnen
 5965: 1			endif
 5966: 1  14F7	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 5967: 1  14F8	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 5968: 1  14FA	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 5969: 1  14FB	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 5970: 1
 5971: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 5972: 1			; Nu volgen de logische functies uit het blokschema
 5973: 1
 5974: 1  14FC	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 5975: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5976: 1  14FD	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 5977: 1  14FE	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 5978: 1  14FF	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 5979: 1  1500	54 0F		                anl     a,#00001111b ;low nibble houden

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5980: 1  1502	FA		                mov     r2,a         ;resultaat bewaren
 5981: 1  1503	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 5982: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 5983: 1  1504	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 5984: 1  1505	C4		                swap    a            ;map2 naar low nibble schuiven
 5985: 1  1506	5A		                anl     a,r2         ;combineren met output vorige and poort
 5986: 1  1507	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 5987: 1  1509	FA		                mov     r2,a         ;even bewaren
 5988: 1  150A	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 5989: 1  150B	54 F0		                anl     a,#11110000b ;map2 overhouden
 5990: 1  150D	4A		                orl     a,r2         ;en combineren met nieuwe map3
 5991: 1  150E	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 5992: 1
 5993: 1			; We gaan nu de volgende lijn scannen
 5994: 1
 5995: 1  150F	EE		                mov     a,r6         ;scanpatroon nemen
 5996: 1  1510	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 5997: 1  1511	FE		                mov     r6,a         ;scanpatroon bewaren
 5998: 1
 5999: 1  1512	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 6000: 1  1513	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 6001: 1  1514	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 6002: 1  1517	D0 E0		                pop     acc          ;herstel registers
 6003: 1  1519	FE		                mov     r6,a
 6004: 1  151A	D0 E0		                pop     acc
 6005: 1  151C	FA		                mov     r2,a
 6006: 1  151D	D0 E0		                pop     acc
 6007: 1  151F	F9		                mov     r1,a
 6008: 1  1520	D0 E0		                pop     acc
 6009: 1  1522	F8		                mov     r0,a
 6010: 1  1523	D0 F0		                pop     b
 6011: 1  1525	D0 D0		                pop     psw
 6012: 1  1527	D0 E0		                pop     acc
 6013: 1  1529	22		                ret                    ;terug naar caller
 6014: 1			;******************************************************************************
 6015: 1
 6016: 1
 6017: 1			;******************************************************************************
 6018: 1			; Keydown, Keyedge (twee entry's)
 6019: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6020: 1			;
 6021: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6022: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6023: 1			; Er zijn twee detectie-modes:
 6024: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6025: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6026: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6027: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6028: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6029: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6030: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6031: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6032: 1			;
 6033: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6034: 1			; (flankdetectie mode).
 6035: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6036: 1			; (toets ingedrukt mode).
 6037: 1			;
 6038: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6039: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6040: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6041: 1			; geldt voor een standaard 4x4 keypad.
 6042: 1			;
 6043: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6044: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6045: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6046: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6047: 1			;
 6048: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6049: 1			; output: key = gedetecteerde toets
 6050: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6051: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6052: 1			;
 6053: 1			; Deze routine vernietigt geen registers
 6054: 1			;******************************************************************************
 6055: 1
 6056: 1			;'Toets ingedrukt mode' enty van de routine
 6057: 1  152A	C0 E0		Keydown:        push    acc            ;registers bewaren
 6058: 1  152C	C0 D0		                push    psw
 6059: 1  152E	C0 F0		                push    b
 6060: 1  1530	C0 82		                push    dpl
 6061: 1  1532	C0 83		                push    dph
 6062: 1  1534	E8		                mov     a,r0
 6063: 1  1535	C0 E0		                push    acc
 6064: 1  1537	E9		                mov     a,r1
 6065: 1  1538	C0 E0		                push    acc
 6066: 1  153A	EA		                mov     a,r2
 6067: 1  153B	C0 E0		                push    acc
 6068: 1  153D	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6069: 1  153F	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6070: 1  1541	80 15		                sjmp    Key1           ;continue
 6071: 1
 6072: 1			;'Flankdetectiemode' entry van de routine
 6073: 1  1543	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6074: 1  1545	C0 D0		                push    psw
 6075: 1  1547	C0 F0		                push    b
 6076: 1  1549	C0 82		                push    dpl
 6077: 1  154B	C0 83		                push    dph
 6078: 1  154D	E8		                mov     a,r0
 6079: 1  154E	C0 E0		                push    acc
 6080: 1  1550	E9		                mov     a,r1
 6081: 1  1551	C0 E0		                push    acc
 6082: 1  1553	EA		                mov     a,r2
 6083: 1  1554	C0 E0		                push    acc
 6084: 1  1556	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6085: 1  1558	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6086: 1  155A	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6087: 1  155C	E6		                mov     a,@r0         ;map entry ophalen
 6088: 1  155D	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6089: 1  1560	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6090: 1  1562	C4		                swap    a             ;map1 en map0 omwisselen
 6091: 1  1563	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6092: 1  1565	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6093: 1  1566	33		                rlc     a             ;kolombit testen
 6094: 1  1567	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6095: 1  1569	33		                rlc    a              ;nee, dan verder roteren
 6096: 1  156A	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6097: 1  156C	08		                inc     r0            ;rijpointer in maps verder zetten
 6098: 1  156D	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6099: 1  156F	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6100: 1
 6101: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6102: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6103: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6104: 1
 6105: 1  1571	1A		toetsin:        dec     r2            ;rij-1
 6106: 1  1572	19		                dec     r1            ;kolom-1
 6107: 1  1573	EA		                mov     a,r2          ;neem rij-1
 6108: 1  1574	23		                rl      a             ;(rij-1)x2
 6109: 1  1575	23		                rl      a              ;(rij-1)x4
 6110: 1  1576	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6111: 1  1577	90 15 95	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6112: 1  157A	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6113: 1  157B	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6114: 1  157D	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6115: 1  157F	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6116: 1  1581	D0 E0		                pop     acc            ;herstellen registers
 6117: 1  1583	FA		                mov     r2,a
 6118: 1  1584	D0 E0		                pop     acc
 6119: 1  1586	F9		                mov     r1,a
 6120: 1  1587	D0 E0		                pop     acc
 6121: 1  1589	F8		                mov     r0,a
 6122: 1  158A	D0 83		                pop     dph
 6123: 1  158C	D0 82		                pop     dpl
 6124: 1  158E	D0 F0		                pop     b
 6125: 1  1590	D0 D0		                pop     psw
 6126: 1  1592	D0 E0		                pop     acc
 6127: 1  1594	22		                ret                    ;terug naar caller
 6128: 1			;******************************************************************************
 6129: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6130: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6131: 1
 6132: 1  1595	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6133: 1  1596	30		                db    '0'    ;kolom2@rij4 toets
 6134: 1  1597	23		                db    '#'    ;kolom3@rij4 toets
 6135: 1  1598	44		                db    'D'    ;kolom4@rij4 toets
 6136: 1
 6137: 1  1599	37		                db    '7'    ;kolom1@rij3 toets
 6138: 1  159A	38		                db    '8'    ;kolom2@rij3 toets
 6139: 1  159B	39		                db    '9'    ;kolom3@rij3 toets
 6140: 1  159C	43		                db    'C'    ;kolom4@rij3 toets
 6141: 1
 6142: 1  159D	34		                db    '4'    ;kolom1@rij2 toets
 6143: 1  159E	35		                db    '5'    ;kolom2@rij2 toets
 6144: 1  159F	36		                db    '6'    ;kolom3@rij2 toets
 6145: 1  15A0	42		                db    'B'    ;kolom4@rij2 toets
 6146: 1
 6147: 1  15A1	31		                db    '1'    ;kolom1@rij1 toets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6148: 1  15A2	32		                db    '2'    ;kolom2@rij1 toets
 6149: 1  15A3	33		                db    '3'    ;kolom3@rij1 toets
 6150: 1  15A4	41		                db    'A'    ;kolom4@rij1 toets
 6151: 1
 6152: 1			;******************************************************************************
 6153: 1			; switch_init
 6154: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6155: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6156: 1			; input : niets
 6157: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6158: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6159: 1			;
 6160: 1			; Deze routine vernietigt niets
 6161: 1			;******************************************************************************
 6162: 1
 6163: 1  15A5	C0 E0		switch_init:    push    acc
 6164: 1  15A7	C0 D0		                push    psw
 6165: 1  15A9	C0 F0		                push    b
 6166: 1  15AB	E8		                mov     a,r0         ;bewaar registers
 6167: 1  15AC	C0 E0		                push    acc
 6168: 1
 6169: 1  15AE	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6170: 1  15B0	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6171: 1  15B3	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6172: 1  15B5	08		                inc     r0           ;volgende byte nemen
 6173: 1  15B6	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6174: 1  15B9	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6175: 1  15BB	C2 03		                clr     negvalid
 6176: 1  15BD	C2 04		                clr     posvalid
 6177: 1
 6178: 1  15BF	D0 E0		                pop     acc
 6179: 1  15C1	F8		                mov     r0,a
 6180: 1  15C2	D0 F0		                pop     b
 6181: 1  15C4	D0 D0		                pop     psw
 6182: 1  15C6	D0 E0		                pop     acc
 6183: 1  15C8	22		                ret                   ;terug naar caller
 6184: 1
 6185: 1			;******************************************************************************
 6186: 1			; read_switch
 6187: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6188: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6189: 1			; Deze routine werkt volgens onderstaand blokschema.
 6190: 1			;
 6191: 1			;                                  ___                    ___
 6192: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6193: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6194: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6195: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6196: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6197: 1			;             |____|    |____|              |____|  ----o| 3 |
 6198: 1			;                |         |                   |      |  |   |
 6199: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6200: 1			;         _______*_________*___________________|       --|___|---- posedge
 6201: 1			;
 6202: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6203: 1			;                              (swvalid-flag)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6204: 1			;            switch1   switch2    debounce      closed
 6205: 1			;
 6206: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6207: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6208: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6209: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6210: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6211: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6212: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6213: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6214: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6215: 1			; een detector voor positieve flanken (posedge).
 6216: 1			;
 6217: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6218: 1			;         bij aduc832v1.1 :
 6219: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6220: 1			;         bij aduc832v2.0 :
 6221: 1			;         als f0=0 dan: schakelaars op p0
 6222: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6223: 1			;
 6224: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6225: 1			;         geactualiseerd.
 6226: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6227: 1			;                  schakelaars weergeeft
 6228: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6229: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6230: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6231: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6232: 1			;                  werd gedetecteerd op een schakelaar.
 6233: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6234: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6235: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6236: 1			;                  werd gedetecteerd op een schakelaar.
 6237: 1			;
 6238: 1			;
 6239: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6240: 1			; en flags te initialiseren.
 6241: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6242: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6243: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6244: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6245: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6246: 1			; bijhorende flag resetten.
 6247: 1			;
 6248: 1			; Deze routine vernietigt niets
 6249: 1			;******************************************************************************
 6250: 1  15C9	C0 E0		read_switch:    push    acc            ;registers bewaren
 6251: 1  15CB	C0 D0		                push    psw
 6252: 1  15CD	C0 F0		                push    b
 6253: 1			;Flipflops uitvoeren is bytes doorschuiven
 6254: 1  15CF	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6255: 1  15D2	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6256: 1
 6257: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6258: 1			                clr      a
 6259: 1			                mov     c,p0.0        ;lees laagste schakelaars

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6260: 1			                mov     acc.0,c
 6261: 1			                mov     c,p0.1
 6262: 1			                mov     acc.1,c
 6263: 1			                mov     b,a            ;even bewaren
 6264: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6265: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6266: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6267: 1			endif        ;einde aduc832_v1_1
 6268: 1
 6269: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6270: 1  15D5	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6271: 1  15D8	E5 80		                mov     a,p0           ;lees de schakelaars
 6272: 1  15DA	80 04		                sjmp    lowlogic
 6273: 1  15DC	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6274: 1  15DE	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6275: 1			endif        ;einde aduc832_2_0
 6276: 1
 6277: 1  15E0	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6278: 1  15E1	F5 40		                mov     switch1,a      ;en sample opslaan
 6279: 1
 6280: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6281: 1
 6282: 1  15E3	E5 40		                mov     a,switch1      ;neem laatste sample
 6283: 1  15E5	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6284: 1  15E7	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6285: 1  15E9	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6286: 1			;negatieve flankdetectie
 6287: 1  15EB	E5 43		                mov     a,closed      ;neem 3de FF
 6288: 1  15ED	F4		                cpl     a             ;complementeer
 6289: 1  15EE	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6290: 1  15F0	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6291: 1  15F2	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6292: 1  15F4	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6293: 1  15F6	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6294: 1			;positieve flankdetectie
 6295: 1  15F8	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6296: 1  15FA	F4		                cpl     a             ;complementeer
 6297: 1  15FB	55 43		                anl     a,closed      ;combineer met 3de FF
 6298: 1  15FD	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6299: 1  15FF	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6300: 1  1601	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6301: 1  1603	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6302: 1  1605	D0 D0		                pop     psw
 6303: 1  1607	D0 E0		                pop     acc
 6304: 1  1609	22		                ret
 6305: 1
 6306: 1			endif    ;einde van aduc_key
 6307: 1
 6308: 1
 6309:				end





                     register banks used:  ---

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111




                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 148
ACC				  DATA	      E0	  67
ADCCON1				  DATA	      EF	  70
ADCCON2				  DATA	      D8	  63
ADCCON3				  DATA	      F5	  76
ADCDATAH			  DATA	      DA	  65
ADCDATAL			  DATA	      D9	  64
ADCGAINH			  DATA	      F4	  75
ADCGAINL			  DATA	      F3	  74
ADCI				  BIT	      DF	 157
ADCOFSH				  DATA	      F2	  73
ADCOFSL				  DATA	      F1	  72
ADC_INIT			  CODE	    13C8	5558
ADC_INIT1			  CODE	    13D5	5564
ADC_SINGLE			  CODE	    13DA	5603
ADC_SINGLE1			  CODE	    13E6	5609
ADC_SINGLE2			  CODE	    1411	5635
ADC_SINGLE20			  CODE	    141B	5640
ADC_SINGLE21			  CODE	    1423	5646
ADC_SINGLE3			  CODE	    1426	5650
ADC_SINGLE30			  CODE	    1446	5671
ADC_SINGLE31			  CODE	    1450	5676
ADC_SINGLE4			  CODE	    1458	5685
ADC_SINGLE40			  CODE	    1464	5693
ADC_SINGLE41			  CODE	    146E	5698
ADC_SINGLE42			  CODE	    1474	5702
ADC_SINGLE43			  CODE	    147C	5708
ADD16				  CODE	    091F	2910
ADD161				  CODE	    0933	2926
ADD32				  CODE	    0971	3007
ADD321				  CODE	    098B	3031
ADUC832_V2_0			  NUMBER    0001	 216
ADUC_ADC			  NUMBER    0001	 237
ADUC_I2C			  NUMBER    0001	 234
ADUC_KEY			  NUMBER    0001	 238
ADUC_LCD			  NUMBER    0001	 231
ADUC_MATH			  NUMBER    0001	 236
ADUC_SIO			  NUMBER    0001	 235
ASCBINTRANS			  CODE	    05CF	1963
ASCBINTRANS1			  CODE	    05E4	1974
ASCBINTRANS2			  CODE	    05E3	1973
ASCBINTRANS3			  CODE	    05D7	1967
ASCBINTRANS4			  CODE	    05E0	1971
ASCCTR				  CODE	    05A6	1909
ASCCTR1				  CODE	    05A9	1910
ASCCTR2				  CODE	    05AE	1912
ASCCTR3				  CODE	    05B2	1915
ASCII1				  CODE	    05E5	1985

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII2				  CODE	    05EA	1999
ASCII21				  CODE	    05FC	2008
ASCII4				  CODE	    05FF	2022
ASCII41				  CODE	    060E	2029
B				  DATA	      F0	  71
BACKLIGHT			  BIT	      F6	 383
BACKSP				  NUMBER    0008	1608
BARCHARS			  CODE	    028F	1009
BAREINDE			  CODE	    02B6	1052
BARLCD				  CODE	    022A	 930
BARLCD1				  CODE	    0265	 964
BARLCD2				  CODE	    026C	 969
BARLCD3				  CODE	    0275	 977
BARLCD4				  CODE	    027A	 981
BARLCDE				  CODE	    0282	 986
BARLCD_1			  CODE	    0245	 946
BATRANS				  CODE	    05C1	1945
BATRANS1			  CODE	    05C6	1947
BATRANS2			  CODE	    05CA	1949
BCDHEX16			  CODE	    0684	2224
BCDHEX161			  CODE	    0692	2232
BCDHEX1611			  CODE	    069B	2236
BCDHEX1612			  CODE	    06A5	2241
BCDHEX1613			  CODE	    06AE	2245
BCDHEX162			  CODE	    06F9	2299
BCDHEX8				  CODE	    060F	2115
BCDHEX81			  CODE	    061D	2123
BCDHEX811			  CODE	    0626	2127
BCDHEX82			  CODE	    0648	2151
BDELETE				  CODE	    0581	1875
BDELETE1			  CODE	    058F	1883
BDELETE2			  CODE	    05A2	1894
BDELETE3			  CODE	    0593	1885
BEEP				  NUMBER    0007	1609
BLANK				  NUMBER    0020	1603
BUILD				  CODE	    02B7	1084
BUILD1				  CODE	    02CF	1126
BUILD2				  CODE	    02DE	1133
BUILD3				  CODE	    02D2	1127
BUILD_ADR			  CODE	    02C5	1121
BUZZER				  BIT	      F7	 384
CAP2				  BIT	      C8	 134
CCONV				  BIT	      DD	 155
CFG832				  DATA	      AF	  36
CGRAM				  NUMBER    0040	 399
CHIPID				  DATA	      C2	  50
CLEARDISP			  NUMBER    0001	 389
CLOSED				  NUMBER    0043	 303
CMP16				  CODE	    1100	4941
CMP161				  CODE	    111D	4960
CMP162				  CODE	    1129	4969
CMP32				  CODE	    11A1	5088
CMP321				  CODE	    11CA	5115
CMP322				  CODE	    11D6	5124
CNT2				  BIT	      C9	 135
CORDIC				  CODE	    126A	5275

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CORDIC0				  CODE	    12D5	5340
CORDIC00			  CODE	    12BB	5325
CORDIC000			  CODE	    128E	5299
CORDIC1				  CODE	    12E9	5354
CORDIC2				  CODE	    131D	5404
CORDIC3				  CODE	    1328	5411
CORDIC4				  CODE	    134D	5445
CORDIC40			  CODE	    1352	5449
CORDIC41			  CODE	    136B	5465
CORDIC5				  CODE	    1371	5471
CORDIC50			  CODE	    1383	5481
CORDIC51			  CODE	    139C	5496
CORDIC52			  CODE	    13A7	5505
CORDIC5A			  CODE	    1381	5480
CORDIC5B			  CODE	    139A	5495
CORDIC_ATAN			  CODE	    13AA	5511
CORDIC_ERROR			  CODE	    129E	5307
CORDIC_MIN90			  CODE	    12A3	5311
CORDIC_NUL			  CODE	    12C7	5331
CORDIC_PLUS90			  CODE	    12AF	5318
CPHA				  BIT	      FA	 172
CPOL				  BIT	      FB	 173
CR				  NUMBER    000D	1606
CS0				  BIT	      D8	 150
CS1				  BIT	      D9	 151
CS2				  BIT	      DA	 152
CS3				  BIT	      DB	 153
CURSATHOM			  NUMBER    0002	 390
CURSOROFF			  NUMBER    000C	 395
CURSORONB			  NUMBER    000F	 396
CURSORONN			  NUMBER    000E	 397
CY				  BIT	      D7	 149
D0				  BIT	      ED	 159
D0EN				  BIT	      EB	 158
D1				  BIT	      EF	 161
D1EN				  BIT	      EE	 160
DAC0H				  DATA	      FA	  80
DAC0L				  DATA	      F9	  79
DAC1H				  DATA	      FC	  82
DAC1L				  DATA	      FB	  81
DACCON				  DATA	      FD	  83
DCON				  DATA	      E8	  68
DDRAM				  NUMBER    0080	 400
DEBOUNCE			  NUMBER    0042	 302
DELAY2MS			  CODE	    02EC	1150
DELAY2MS1			  CODE	    02F2	1153
DELAY60US			  CODE	    02FD	1170
DELAY60US1			  CODE	    030F	1184
DELAY60US2			  CODE	    030D	1183
DIPSWITCH			  NUMBER    0001	 256
DISPDPTR			  CODE	    04D7	1717
DISPDPTRLCD			  CODE	    00F1	 605
DISPLAYOF			  NUMBER    0008	 394
DISPLAYON			  NUMBER    0001	 393
DIV16				  CODE	    0BE6	3693
DIV160				  CODE	    0BF4	3704

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DIV161				  CODE	    0C12	3727
DIV162				  CODE	    0C25	3743
DIV163				  CODE	    0C41	3768
DIV164				  CODE	    0C53	3786
DIV32				  CODE	    0C90	3857
DIV320				  CODE	    0CA0	3870
DIV320A				  CODE	    0CAA	3881
DIV320B				  CODE	    0CC8	3909
DIV320C				  CODE	    0CED	3937
DIV322				  CODE	    0D12	3971
DIV323				  CODE	    0D5C	4047
DIV324				  CODE	    0D8E	4097
DIV8				  CODE	    0BA3	3620
DIV81				  CODE	    0BBB	3636
DMA				  BIT	      DE	 156
DMAH				  DATA	      D3	  60
DMAL				  DATA	      D2	  59
DMAP				  DATA	      D4	  61
DPCON				  DATA	      A7	  32
DPH				  DATA	      83	   9
DPL				  DATA	      82	   8
DPP				  DATA	      84	  10
E				  BIT	      F1	 381
EA				  BIT	      AF	 109
EADC				  BIT	      AE	 108
EADRH				  DATA	      C7	  52
EADRL				  DATA	      C6	  51
ECON				  DATA	      B9	  44
EDATA1				  DATA	      BC	  45
EDATA2				  DATA	      BD	  46
EDATA3				  DATA	      BE	  47
EDATA4				  DATA	      BF	  48
EIND_TEL			  CODE	    001A	 200
ENDBUF				  NUMBER    007F	1615
ENTRYMODE			  NUMBER    0006	 392
ES				  BIT	      AC	 106
ET0				  BIT	      A9	 103
ET1				  BIT	      AB	 105
ET2				  BIT	      AD	 107
EX0				  BIT	      A8	 102
EX1				  BIT	      AA	 104
EXEN2				  BIT	      CB	 137
EXF2				  BIT	      CE	 140
F0				  BIT	      D5	 147
F1				  BIT	      D1	 143
FF				  NUMBER    000C	1605
FUNCTIONS			  NUMBER    0028	 398
HEXBCD16			  CODE	    0702	2335
HEXBCD161			  CODE	    0710	2342
HEXBCD16_U			  CODE	    0705	2336
HEXBCD8				  CODE	    0651	2176
HEXBCD81			  CODE	    065B	2181
HEXBCD82			  CODE	    0660	2183
HEXBCD83			  CODE	    066A	2189
HEXBUF2LCD			  CODE	    01CD	 871
HEXBUF2LCD1			  CODE	    01F1	 887

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBUF2LCDE			  CODE	    0208	 898
HEXBUFTXT			  CODE	    0216	 907
HOUR				  DATA	      A5	  30
HTHSEC				  DATA	      A2	  27
I2CADD				  DATA	      9B	  22
I2CCON				  DATA	      E8	  69
I2CDAT				  DATA	      9A	  21
I2CI				  BIT	      E8	 162
I2CINBYTEA1			  CODE	    0359	1292
I2CINBYTEACK			  CODE	    0352	1289
I2CINBYTEN1			  CODE	    037A	1316
I2CINBYTENACK			  CODE	    0373	1313
I2CINIT				  CODE	    0317	1234
I2CM				  BIT	      EB	 165
I2COUTBYTE			  CODE	    0332	1266
I2COUTBYTE1			  CODE	    0339	1269
I2CPCF8574			  NUMBER    0040	1225
I2CPCF8574A			  NUMBER    0070	1226
I2CRCVDATA			  CODE	    03D4	1418
I2CRCVDATA1			  CODE	    03F3	1436
I2CRCVDATA2			  CODE	    03FC	1440
I2CRCVDATA3			  CODE	    0403	1445
I2CRCVERROR			  CODE	    040F	1453
I2CRS				  BIT	      EA	 164
I2CSENDDATA			  CODE	    0394	1356
I2CSENDDATA1			  CODE	    03B3	1373
I2CSENDERROR			  CODE	    03C9	1386
I2CSTART			  CODE	    0320	1243
I2CSTOP				  CODE	    0329	1252
I2CTX				  BIT	      E9	 163
IE				  DATA	      A8	  33
IE0				  BIT	      89	  85
IE1				  BIT	      8B	  87
IEIP2				  DATA	      A9	  34
INBUFA				  CODE	    0546	1832
INBUFA1				  CODE	    055D	1849
INBUFA2				  CODE	    054C	1835
INBUFA3				  CODE	    056A	1855
INBUFA4				  CODE	    0563	1851
INBUFA5				  CODE	    057D	1863
INBUFA6				  CODE	    0573	1859
INBUFA7				  CODE	    0565	1852
INBYTE				  CODE	    0526	1800
INBYTE1				  CODE	    0543	1812
INCHAR				  CODE	    051E	1784
INITLCD				  CODE	    0021	 415
INITLCD1			  CODE	    0032	 432
INITSIO				  CODE	    0484	1629
INITSIO1			  CODE	    048D	1633
INITSIOE			  CODE	    04A3	1650
INT0				  BIT	      B2	 112
INT1				  BIT	      B3	 113
INTVAL				  DATA	      A6	  31
INT_HANDLER_INT0		  CODE	    0017	 197
IP				  DATA	      B8	  43
ISPI				  BIT	      FF	 177

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
IT0				  BIT	      88	  84
IT1				  BIT	      8A	  86
KEY				  NUMBER    0038	 289
KEY1				  CODE	    1558	6085
KEY2				  CODE	    1565	6092
KEYDOWN				  CODE	    152A	6057
KEYEDGE				  CODE	    1543	6073
KEYFLAGS			  NUMBER    0020	 264
KEYINIT1			  CODE	    1492	5828
KEYMAP				  NUMBER    0030	 283
KEYMODE				  BIT	      01	 268
KEYSCAN				  CODE	    14C7	5905
KEYVALID			  BIT	      00	 266
KEY_INIT			  CODE	    1484	5820
KOLOMLOOP			  CODE	    1567	6094
LCDBUZOFF			  CODE	    0473	1574
LCDBUZON			  CODE	    0466	1558
LCDLIGHTOFF			  CODE	    0459	1542
LCDLIGHTON			  CODE	    044C	1525
LCDPORT				  NUMBER    00F0	 380
LCDTOPORT			  CODE	    0433	1499
LF				  NUMBER    000A	1607
LOOP				  CODE	    000E	 190
LOWLOGIC			  CODE	    15E0	6277
LOWUPTR				  CODE	    05B4	1929
LOWUPTR1			  CODE	    05B7	1930
LOWUPTR2			  CODE	    05C0	1934
LOWUPTR3			  CODE	    05BC	1932
MAGSIG16			  CODE	    0771	2447
MAGSIG16A			  CODE	    0782	2456
MAGSIG16ACC1			  CODE	    0791	2480
MAGSIG16ACC1A			  CODE	    07A2	2489
MAGSIG16ACC1B			  CODE	    079D	2486
MAGSIG16ACC1C			  CODE	    07AC	2497
MAGSIG16B			  CODE	    077D	2453
MAGSIG16C			  CODE	    078C	2464
MAGSIG32			  CODE	    07B1	2514
MAGSIG32A			  CODE	    07C2	2523
MAGSIG32ACC1			  CODE	    07DB	2559
MAGSIG32ACC1A			  CODE	    07EC	2568
MAGSIG32ACC1B			  CODE	    07E7	2565
MAGSIG32ACC1C			  CODE	    0800	2585
MAGSIG32B			  CODE	    07BD	2520
MAGSIG32C			  CODE	    07D6	2540
MAGSIG8				  CODE	    073D	2388
MAGSIG8A			  CODE	    074E	2397
MAGSIG8ACC1			  CODE	    0757	2418
MAGSIG8ACC1A			  CODE	    0768	2427
MAGSIG8ACC1B			  CODE	    0763	2424
MAGSIG8ACC1C			  CODE	    076C	2431
MAGSIG8B			  CODE	    0749	2394
MAGSIG8C			  CODE	    0752	2401
MAP01PTR			  NUMBER    0030	 285
MAP23PTR			  NUMBER    0034	 288
MATRIX				  NUMBER    0001	 254
MCO				  BIT	      ED	 167

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MDE				  BIT	      EE	 168
MDI				  BIT	      EC	 166
MDO				  BIT	      EF	 169
MIN				  DATA	      A4	  29
MUL16				  CODE	    0A5B	3279
MUL16ACC1			  CODE	    0AC0	3368
MUL16_10			  CODE	    0E7F	4355
MUL16_100			  CODE	    0EB4	4403
MUL16_I_PI			  CODE	    0E1C	4259
MUL16_I_SQRT2			  CODE	    0E5E	4324
MUL16_PI			  CODE	    0DFB	4228
MUL16_SQRT2			  CODE	    0E3D	4291
MUL816				  CODE	    0B48	3515
MULDIV				  CODE	    0DBF	4170
MULDIV1				  CODE	    0DCF	4182
NEGEDGE				  NUMBER    0044	 304
NEGVALID			  BIT	      03	 273
NOKEY				  CODE	    157F	6115
OUTBYTE				  CODE	    04C3	1697
OUTBYTELCD			  CODE	    00E0	 586
OUTC				  CODE	    018D	 792
OUTCHAR				  CODE	    04A7	1664
OUTCHAR1			  CODE	    04A9	1665
OUTCHARLCD			  CODE	    007F	 501
OUTCHARLCD1			  CODE	    0086	 504
OUTCHARLCD2			  CODE	    0090	 508
OUTCHARLCD2_0			  CODE	    008B	 506
OUTCHARLCD3			  CODE	    0099	 518
OUTCHARLCD4			  CODE	    00A0	 522
OUTCHARLCD5			  CODE	    00A7	 526
OUTCHARLCD6			  CODE	    00AE	 530
OUTCHARLCD7			  CODE	    00B5	 534
OUTCHARLCD8			  CODE	    00BC	 542
OUTCHARLCD9			  CODE	    00C1	 550
OUTCHARLCDE			  CODE	    00C4	 551
OUTD				  CODE	    0153	 714
OUTHNIBC			  CODE	    01A3	 834
OUTHNIBD			  CODE	    0163	 762
OUTMSGA				  CODE	    04EA	1736
OUTMSGA1			  CODE	    04FF	1747
OUTMSGA2			  CODE	    04F2	1740
OUTMSGALCD			  CODE	    0104	 629
OUTMSGALCD1			  CODE	    010C	 636
OUTMSGALCDE			  CODE	    0117	 646
OUTNIB				  CODE	    04AF	1678
OUTNIBLCD			  CODE	    00C9	 565
OUTNIBLCD1			  CODE	    00D4	 570
OUTNIBLCDE			  CODE	    00D8	 572
OV				  BIT	      D2	 144
P				  BIT	      D0	 142
P0				  DATA	      80	   6
P1				  DATA	      90	  18
P2				  DATA	      A0	  25
P3				  DATA	      B0	  37
PADC				  BIT	      BE	 124
PCF8574A			  NUMBER    0001	1228

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
PCON				  DATA	      87	  11
PLLCON				  DATA	      D7	  62
PORTTOLCD			  CODE	    041A	1471
POSEDGE				  NUMBER    0045	 305
POSVALID			  BIT	      04	 275
PRE0				  BIT	      C4	 130
PRE1				  BIT	      C5	 131
PRE2				  BIT	      C6	 132
PRE3				  BIT	      C7	 133
PS				  BIT	      BC	 122
PSI				  BIT	      BF	 125
PSMCON				  DATA	      DF	  66
PSW				  DATA	      D0	  58
PT0				  BIT	      B9	 119
PT1				  BIT	      BB	 121
PT2				  BIT	      BD	 123
PWM0H				  DATA	      B2	  39
PWM0L				  DATA	      B1	  38
PWM1H				  DATA	      B4	  41
PWM1L				  DATA	      B3	  40
PWMCON				  DATA	      AE	  35
PX0				  BIT	      B8	 118
PX1				  BIT	      BA	 120
RB8				  BIT	      9A	  96
RCAP2H				  DATA	      CB	  55
RCAP2L				  DATA	      CA	  54
RCLK				  BIT	      CD	 139
RD				  BIT	      B7	 117
READ_PORT3			  CODE	    15DC	6273
READ_SWITCH			  CODE	    15C9	6250
READ_SWITCH1			  CODE	    15F8	6295
READ_SWITCH2			  CODE	    1603	6301
REGTOLCD			  CODE	    0120	 666
REGTOLCD1			  CODE	    0131	 676
REGTOLCD2			  CODE	    013F	 686
REN				  BIT	      9C	  98
RI				  BIT	      98	  94
RIJLOOP				  CODE	    155A	6086
RS				  BIT	      F0	 382
RS0				  BIT	      D3	 145
RS1				  BIT	      D4	 146
RXD				  BIT	      B0	 110
SBUF				  DATA	      99	  20
SCANLOOP			  CODE	    14E2	5922
SCON				  DATA	      98	  19
SCONV				  BIT	      DC	 154
SEC				  DATA	      A3	  28
SHIFTLEFT1			  CODE	    102B	4718
SHIFTLEFT2			  CODE	    1033	4724
SHIFTLEFT3			  CODE	    1037	4726
SHIFTLEFT32			  CODE	    1023	4714
SHIFTRIGHT1			  CODE	    0FFF	4673
SHIFTRIGHT2			  CODE	    1007	4679
SHIFTRIGHT3			  CODE	    100B	4681
SHIFTRIGHT32			  CODE	    0FF7	4669
SIGMAG16ACC0			  CODE	    0837	2658

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SIGMAG16ACC0A			  CODE	    0846	2667
SIGMAG16ACC1			  CODE	    0857	2693
SIGMAG16ACC1A			  CODE	    0866	2702
SIGMAG16ACC1H			  CODE	    0877	2728
SIGMAG16ACC1HA			  CODE	    0886	2737
SIGMAG32ACC0			  CODE	    0897	2765
SIGMAG32ACC0A			  CODE	    08A6	2774
SIGMAG32ACC1			  CODE	    08C1	2809
SIGMAG32ACC1A			  CODE	    08D0	2818
SIGMAG8ACC0			  CODE	    0805	2602
SIGMAG8ACC0A			  CODE	    0814	2610
SIGMAG8ACC1			  CODE	    081E	2630
SIGMAG8ACC1A			  CODE	    082D	2638
SM0				  BIT	      9F	 101
SM1				  BIT	      9E	 100
SM2				  BIT	      9D	  99
SP				  DATA	      81	   7
SPE				  BIT	      FD	 175
SPH				  DATA	      B7	  42
SPICON				  DATA	      F8	  78
SPIDAT				  DATA	      F7	  77
SPIM				  BIT	      FC	 174
SPR0				  BIT	      F8	 170
SPR1				  BIT	      F9	 171
SQRT32				  CODE	    0F0A	4475
SQRT320				  CODE	    0F31	4497
SQRT321				  CODE	    0F36	4499
SQRT322				  CODE	    0F99	4581
SQRT323				  CODE	    0F9F	4585
SQRT324				  CODE	    0FC2	4609
SQRT3240			  CODE	    0FBD	4607
SQRT325				  CODE	    0FC5	4611
STACK_INIT			  NUMBER    007F	 180
START				  CODE	    0006	 187
STRTBUF				  NUMBER    0054	1614
SUB16				  CODE	    09D1	3117
SUB161				  CODE	    09E6	3134
SUB32				  CODE	    0A38	3234
SUB321				  CODE	    0A53	3259
SUBROUT1			  CODE	    0010	 192
SWINIT				  CODE	    15B3	6171
SWITCH1				  NUMBER    0040	 300
SWITCH2				  NUMBER    0041	 301
SWITCHMAP			  NUMBER    0040	 299
SWITCH_INIT			  CODE	    15A5	6163
SWVALID				  BIT	      02	 271
S_ADD16				  CODE	    08EB	2855
S_ADD161			  CODE	    090F	2881
S_ADD162			  CODE	    0913	2883
S_ADD163			  CODE	    0919	2888
S_ADD32				  CODE	    093B	2948
S_ADD321			  CODE	    0963	2979
S_ADD322			  CODE	    0965	2980
S_ADD323			  CODE	    096B	2985
S_CMP16				  CODE	    10B4	4867
S_CMP160			  CODE	    10C7	4884

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_CMP161			  CODE	    10D5	4894
S_CMP162			  CODE	    10E3	4904
S_CMP163			  CODE	    10F2	4916
S_CMP32				  CODE	    1133	4991
S_CMP320			  CODE	    114E	5011
S_CMP321			  CODE	    1162	5025
S_CMP322			  CODE	    1176	5039
S_CMP323			  CODE	    118D	5059
S_DIV16				  CODE	    0BC3	3658
S_DIV161			  CODE	    0BD1	3668
S_DIV32				  CODE	    0C6B	3820
S_DIV321			  CODE	    0C7B	3832
S_DIV8				  CODE	    0B91	3597
S_DIV81				  CODE	    0BA2	3603
S_MAC16				  CODE	    0B6F	3557
S_MAC161			  CODE	    0B8B	3577
S_MUL16				  CODE	    0B21	3459
S_MUL16ACC1			  CODE	    0B2E	3477
S_MUL816			  CODE	    0B3B	3496
S_MULDIV			  CODE	    0D9A	4126
S_MULDIV1			  CODE	    0DAA	4138
S_SHIFTLEFT1			  CODE	    108E	4820
S_SHIFTLEFT2			  CODE	    1096	4826
S_SHIFTLEFT3			  CODE	    109A	4831
S_SHIFTLEFT32			  CODE	    1086	4816
S_SHIFTRIGHT1			  CODE	    1057	4766
S_SHIFTRIGHT2			  CODE	    105F	4772
S_SHIFTRIGHT20			  CODE	    106B	4778
S_SHIFTRIGHT3			  CODE	    106D	4780
S_SHIFTRIGHT32			  CODE	    104F	4762
S_SQRT32			  CODE	    0FE0	4642
S_SQRT321			  CODE	    0FEE	4650
S_SUB16				  CODE	    0993	3053
S_SUB161			  CODE	    09C1	3088
S_SUB162			  CODE	    09C5	3090
S_SUB163			  CODE	    09CB	3095
S_SUB32				  CODE	    09EE	3156
S_SUB321			  CODE	    0A2A	3206
S_SUB322			  CODE	    0A2C	3207
S_SUB323			  CODE	    0A32	3212
T0				  BIT	      B4	 114
T1				  BIT	      B5	 115
T2				  BIT	      90	  92
T2CON				  DATA	      C8	  53
T2EX				  BIT	      91	  93
T3CON				  DATA	      9E	  23
T3FD				  DATA	      9D	  24
TABLE_LU			  CODE	    11E0	5151
TABLE_LU1			  CODE	    1205	5177
TABLE_LU2			  CODE	    1216	5190
TABLE_LU3			  CODE	    124F	5233
TABLE_LU4			  CODE	    1261	5246
TABLE_LU_10			  CODE	    120C	5182
TB8				  BIT	      9B	  97
TCLK				  BIT	      CC	 138
TCON				  DATA	      88	  12

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TELLER				  CODE	    001B	 202
TF0				  BIT	      8D	  89
TF1				  BIT	      8F	  91
TF2				  BIT	      CF	 141
TH0				  DATA	      8C	  16
TH1				  DATA	      8D	  17
TH2				  DATA	      CD	  57
TI				  BIT	      99	  95
TIMECON				  DATA	      A1	  26
TL0				  DATA	      8A	  14
TL1				  DATA	      8B	  15
TL2				  DATA	      CC	  56
TMOD				  DATA	      89	  13
TOETSIN				  CODE	    1571	6105
TOETSTABEL			  CODE	    1595	6132
TOETS_FLANK			  CODE	    14A9	5859
TOETS_INGEDRUKT			  CODE	    14B8	5882
TR0				  BIT	      8C	  88
TR1				  BIT	      8E	  90
TR2				  BIT	      CA	 136
TXD				  BIT	      B1	 111
WCOL				  BIT	      FE	 176
WDCON				  DATA	      C0	  49
WDE				  BIT	      C1	 127
WDIR				  BIT	      C3	 129
WDS				  BIT	      C2	 128
WDWR				  BIT	      C0	 126
WISSEN				  CODE	    0480	1611
WR				  BIT	      B6	 116
XOFF				  NUMBER    0013	1604
XONXOFF				  CODE	    0508	1764
XONXOFF1			  CODE	    0514	1770
XONXOFF2			  CODE	    050F	1767
XONXOFF3			  CODE	    0519	1772
