
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 13.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 13.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 13.lst



 Line  I  Addr  Code            Source

    1:				$nolist
  179:
  180:		N      007F	stack_init	equ	07fh
  181:		N      0000			org	0000h
  182:	  0000	02 00 03			ljmp	start
  183:
  184:		N      0031	msB		equ 	31h
  185:		N      0030	lsB		equ	30h
  186:
  187:	  0003	75 81 7F	start:		mov	sp,#stack_init
  188:	  0006	74 00				mov	a,#0
  189:	  0008	75 31 00			mov	msB,#00h
  190:	  000B	75 30 00			mov     lsB,#00h
  191:	  000E	12 00 50			lcall	initlcd
  192:
  193:	  0011	90 00 4D	loop:		mov	dptr, #text
  194:	  0014	12 01 33			lcall	outmsgalcd
  195:	  0017	E5 31				mov	a,msB
  196:	  0019	12 00 F8			lcall	outniblcd
  197:	  001C	E5 30				mov	a,lsB
  198:	  001E	12 01 0F			lcall	outbytelcd
  199:	  0021	11 37				acall	delay
  200:	  0023	11 27				acall	incr
  201:	  0025	80 EA				sjmp	loop
  202:
  203:	  0027	E4		incr:		clr	a
  204:	  0028	C3				clr	c
  205:	  0029	E5 30				mov	a,lsB
  206:	  002B	04				inc	a
  207:	  002C	D4				da	a
  208:	  002D	F5 30				mov	lsB,a
  209:	  002F	E5 31				mov	a,msB
  210:	  0031	34 00				addc	a,#0
  211:	  0033	D4				da	a
  212:	  0034	F5 31				mov	msB,a
  213:	  0036	22				ret
  214:
  215:	  0037	C0 E0		delay:		push 	acc
  216:	  0039	E5 80				mov 	a,p0
  217:	  003B	70 02				jnz	delay1
  218:	  003D	44 01				orl	a,#00000001b
  219:	  003F	78 14		delay1:		mov	r0,#20
  220:	  0041	79 14		delay2:		mov	r1,#20

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  221:	  0043	D9 FE		delay3:		djnz	r1,delay3
  222:	  0045	D8 FA				djnz	r0,delay2
  223:	  0047	D5 E0 F5			djnz	acc,delay1
  224:	  004A	D0 E0				pop	acc
  225:	  004C	22				ret
  226:
  227:	  004D	80 13 00	text:		db	80h,013h,0
  228:
  229:				$include (c:/aduc800_mideA.inc)
  230: 1			;******************************************************************************
  231: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  232: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  233: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  234: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  235: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  236: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  237: 1			;******************************************************************************
  238: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  239: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  240: 1			;******************************************************************************
  241: 1
  242: 1
  243: 1			;******************************************************************************
  244: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  245: 1			; hebben voor onze toepassing. Door een module te definieren via het
  246: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  247: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  248: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  249: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  250: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  251: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  252: 1			; definities.
  253: 1			;******************************************************************************
  254: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  255: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  256: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  257: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  258: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  259: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  260: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  261: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  262: 1
  263: 1			ifdef    aduc_key
  264: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  265: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  266: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  267: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  268: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  269: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  270: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  271: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  272: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  273: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  274: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  275: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  276: 1			;definities wel gemaakt worden.

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  277: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  278: 1			                            ;anders commentaar van maken!
  279: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  280: 1			                            ;gelezen, anders commentaar van maken!
  281: 1			;******************************************************************************
  282: 1			;Declaraties van de flags voor de aduc_key driver.
  283: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  284: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  285: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  286: 1			;switch_init en read_switch.
  287: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  288: 1			                                ;bereik = 20h-2fh!
  289: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  290: 1			                                   ;een geldige waarde bevat
  291: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  292: 1			                                   ;die de detectie mode aangeeft
  293: 1			;declaratie van de read_switch flags
  294: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  295: 1			                                   ;ontdenderde schakelaars zijn
  296: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  297: 1			                                   ;flanken zijn
  298: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  299: 1			                                   ;flanken zijn
  300: 1			ifdef    matrix        ;matrix keyboard
  301: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  302: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  303: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  304: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  305: 1			;toepassing.
  306: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  307: 1			                                ;geheugenbuffer
  308: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  309: 1			                                ;debounce en de flankdetectie samples stockeren
  310: 1			                                ;de eerste 4 bytes dienen voor debouncing
  311: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  312: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  313: 1			                                ;toetswaarde aangeeft
  314: 1			                                ;bij een geldige keyvalid flag ('1')
  315: 1			endif    ;einde matrix keyboard
  316: 1
  317: 1			ifdef    dipswitch
  318: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  319: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  320: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  321: 1			;toepassing
  322: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  323: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  324: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  325: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  326: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  327: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  328: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  329: 1			endif    ;einde dipswitch
  330: 1			;******************************************************************************
  331: 1			endif    ;einde aduc_key
  332: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  333: 1
  334: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  335: 1
  336: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  337: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  338: 1			endif                               ;dus doen we dit hier nog eens!
  339: 1			;******************************************************************************
  340: 1
  341: 1			;******************************************************************************
  342: 1			;
  343: 1			; ADuc_lcd.inc
  344: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  345: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  346: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  347: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  348: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  349: 1			; het plaatsen van de cursor op een correcte plaats).
  350: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  351: 1			; display gebruiken.
  352: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  353: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  354: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  355: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  356: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  357: 1			;
  358: 1			; Versie ADuC832v1.1:
  359: 1			; Hier is het LCD verbonden met pinnen van poort0
  360: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  361: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  362: 1			;
  363: 1			; Versie ADuC832v2.2:
  364: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  365: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  366: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  367: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  368: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  369: 1			;
  370: 1			;
  371: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  372: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  373: 1			;  aduclcd0.inc
  374: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  375: 1			;  aduclcd1.inc
  376: 1			;    -00dh en 00ah worden door outchar verwerkt
  377: 1			;    -bij de init wordt het display anders opgestart
  378: 1			;
  379: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  380: 1			;  van gebruik en uitgebreid  met :
  381: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  382: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  383: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  384: 1			;    debug doeleinden
  385: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  386: 1			;    user codes aan te maken
  387: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  388: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  389: 1			;
  390: 1			; Beschikbare routines:
  391: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  392: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  393: 1			; build_adr, delay2ms, delay60us
  394: 1			;******************************************************************************
  395: 1
  396: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  397: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  398: 1			e             bit    lcdport.2            ;enable
  399: 1			rs            bit    lcdport.3            ;register select
  400: 1			endif    ;einde aduc832_v1_1
  401: 1
  402: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  403: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  404: 1	B	 F1	e             bit    lcdport.1            ;enable
  405: 1	B	 F0	rs            bit    lcdport.0            ;register select
  406: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  407: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  408: 1			endif    ;einde aduc832_v2_0
  409: 1
  410: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  411: 1			;het uitvoeren van de overeenkomstige commando's.
  412: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  413: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  414: 1
  415: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  416: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  417: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  418: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  419: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  420: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  421: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  422: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  423: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  424: 1
  425: 1			;******************************************************************************
  426: 1			;
  427: 1			; initlcd
  428: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  429: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  430: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  431: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  432: 1			; Na initialisering wordt het scherm leeg gemaakt.
  433: 1			;
  434: 1			; registergebruik: geen
  435: 1			;
  436: 1			;******************************************************************************
  437: 1
  438: 1  0050	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  439: 1  0052	C0 D0		              push   psw
  440: 1  0054	C0 F0		              push   b
  441: 1			ifdef  aduc832_v1_1
  442: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  443: 1			                                   ;let op:twee laagste bits worden
  444: 1			                                   ;niet gebruikt

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  445: 1			endif
  446: 1
  447: 1			ifdef    aduc832_v2_0
  448: 1  0056	12 03 46	              lcall  i2cinit              ;LCD via een I2C bus
  449: 1  0059	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  450: 1			                                          ;buzzer en backlight  op 1 gezet
  451: 1  005C	12 04 49	              lcall  porttolcd            ;data uit b naar het scherm
  452: 1			endif
  453: 1
  454: 1  005F	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  455: 1  0061	12 03 1B	initlcd1:     lcall  delay2ms
  456: 1  0064	D5 E0 FA	              djnz   acc,initlcd1
  457: 1  0067	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  458: 1  0069	12 01 D2	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  459: 1  006C	12 03 1B	              lcall  delay2ms      ;om het display altijd opgestart
  460: 1  006F	74 30		              mov    a,#00110000b  ;te krijgen.
  461: 1  0071	12 01 D2	              lcall  outhnibc
  462: 1  0074	12 03 1B	              lcall  delay2ms
  463: 1  0077	74 30		              mov    a,#00110000b
  464: 1  0079	12 01 D2	              lcall  outhnibc
  465: 1  007C	12 03 1B	              lcall  delay2ms
  466: 1  007F	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  467: 1  0081	12 01 D2	              lcall  outhnibc      ;hoge nibble naar het controleregister
  468: 1  0084	12 03 1B	              lcall  delay2ms      ;niet nodig volgens datasheet
  469: 1  0087	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  470: 1  0089	12 01 BC	              lcall  outc          ;naar display
  471: 1  008C	12 03 1B	              lcall  delay2ms      ;is iets te lang volgens datasheet
  472: 1  008F	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  473: 1  0091	12 01 BC	              lcall  outc
  474: 1  0094	12 03 1B	              lcall  delay2ms      ;ook deze delay is iets te lang
  475: 1  0097	74 01		              mov    a,#displayon  ;clear display and home cursor
  476: 1  0099	12 01 BC	              lcall  outc
  477: 1  009C	12 03 1B	              lcall  delay2ms      ;deze wachttijd is bijna juist
  478: 1  009F	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  479: 1  00A1	12 01 BC	              lcall  outc
  480: 1  00A4	12 03 1B	              lcall  delay2ms      ;wachten weer veel te lang
  481: 1  00A7	D0 F0		              pop    b
  482: 1  00A9	D0 D0		              pop    psw           ;registers terug in orde zetten
  483: 1  00AB	D0 E0		              pop    acc
  484: 1  00AD	22		              ret                  ;einde van de initialisatie
  485: 1
  486: 1			;******************************************************************************
  487: 1			;
  488: 1			; outcharlcd
  489: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  490: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  491: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  492: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  493: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  494: 1			; De controlekarakters komen overeen met volgende acties:
  495: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  496: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  497: 1			;              (line feed+ carriage return!)
  498: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  499: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  500: 1			;      011h   =cursor on, blink mode

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  501: 1			;      012h   =cursor on, no blink mode
  502: 1			;      013h   =cursor off
  503: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  504: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  505: 1			;              van het LCD
  506: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  507: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  508: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  509: 1			; positie 6 (C5H-80H=45H)
  510: 1			;
  511: 1			; Deze routine vernietigt geen registers
  512: 1			;
  513: 1			;******************************************************************************
  514: 1
  515: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  516: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  517: 1			; dataregister van het scherm.
  518: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  519: 1			; controlebyte doorsturen naar het LCD.
  520: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  521: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  522: 1			; naar de LCD sturen.
  523: 1
  524: 1  00AE	C0 E0		outcharlcd:   push   acc           ;registers op stack
  525: 1  00B0	C0 D0		              push   psw
  526: 1  00B2	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  527: 1  00B5	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  528: 1  00B7	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  529: 1  00BA	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  530: 1  00BC	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  531: 1  00BF	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  532: 1
  533: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  534: 1			; Als het een commando is, moeten we het uitvoeren.
  535: 1			; Indien niet, gewoon terug zonder actie!
  536: 1
  537: 1  00C1	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  538: 1  00C4	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  539: 1  00C6	80 28		              sjmp   outcharlcd9          ;afsluiten
  540: 1
  541: 1  00C8	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  542: 1  00CB	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  543: 1  00CD	80 21		              sjmp   outcharlcd9
  544: 1
  545: 1  00CF	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  546: 1  00D2	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  547: 1  00D4	80 1A		              sjmp   outcharlcd9
  548: 1
  549: 1  00D6	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  550: 1  00D9	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  551: 1  00DB	80 13		              sjmp   outcharlcd9
  552: 1
  553: 1  00DD	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  554: 1  00E0	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  555: 1  00E2	80 0C		              sjmp   outcharlcd9
  556: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  557: 1  00E4	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  558: 1  00E7	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  559: 1  00E9	80 05		              sjmp   outcharlcd9
  560: 1
  561: 1
  562: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  563: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  564: 1
  565: 1  00EB	12 01 82	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  566: 1  00EE	80 03		              sjmp   outcharlcde   ;einde routine
  567: 1
  568: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  569: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  570: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  571: 1			; op dat adres te zetten.
  572: 1
  573: 1  00F0	12 01 BC	outcharlcd9:  lcall  outc          ;klaar
  574: 1  00F3	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  575: 1  00F5	D0 E0		              pop    acc
  576: 1  00F7	22		              ret
  577: 1
  578: 1			;******************************************************************************
  579: 1			;
  580: 1			; outniblcd
  581: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  582: 1			; op het lcd scherm.
  583: 1			;
  584: 1			; de routine vernietigt geen registers
  585: 1			;
  586: 1			;******************************************************************************
  587: 1
  588: 1  00F8	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  589: 1  00FA	C0 D0		              push   psw
  590: 1  00FC	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  591: 1  00FE	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  592: 1  0100	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  593: 1  0103	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  594: 1  0105	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  595: 1  0107	12 01 82	outniblcde:   lcall  outd          ;naar het scherm
  596: 1  010A	D0 D0		              pop    psw
  597: 1  010C	D0 E0		              pop    acc
  598: 1  010E	22		              ret
  599: 1
  600: 1			;******************************************************************************
  601: 1			;
  602: 1			; outbytelcd
  603: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  604: 1			;
  605: 1			; de routine vernietigt geen registers
  606: 1			;
  607: 1			;******************************************************************************
  608: 1
  609: 1  010F	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  610: 1  0111	C0 D0		              push   psw
  611: 1  0113	C4		              swap   a             ;bitjes omruilen
  612: 1  0114	12 00 F8	              lcall  outniblcd

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  613: 1  0117	C4		              swap   a             ;nog eens
  614: 1  0118	12 00 F8	              lcall  outniblcd
  615: 1  011B	D0 D0		              pop    psw
  616: 1  011D	D0 E0		              pop    acc
  617: 1  011F	22		              ret
  618: 1
  619: 1			;******************************************************************************
  620: 1			;
  621: 1			; dispdptrlcd
  622: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  623: 1			;
  624: 1			; de routine vernietigt geen registers
  625: 1			;
  626: 1			;******************************************************************************
  627: 1
  628: 1  0120	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  629: 1  0122	C0 D0		              push   psw
  630: 1  0124	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  631: 1  0126	12 01 0F	              lcall  outbytelcd
  632: 1  0129	E5 82		              mov    a,dpl         ;dan het lage deel
  633: 1  012B	12 01 0F	              lcall  outbytelcd
  634: 1  012E	D0 D0		              pop    psw
  635: 1  0130	D0 E0		              pop    acc
  636: 1  0132	22		              ret
  637: 1
  638: 1			;******************************************************************************
  639: 1			;
  640: 1			; outmsgalcd
  641: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  642: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  643: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  644: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  645: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  646: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  647: 1			;
  648: 1			; de routine vernietigt geen registers
  649: 1			;
  650: 1			;******************************************************************************
  651: 1
  652: 1  0133	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  653: 1  0135	C0 D0		              push   psw
  654: 1  0137	C0 83		              push   dph           ;ook de data pointer
  655: 1  0139	C0 82		              push   dpl
  656: 1
  657: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  658: 1
  659: 1  013B	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  660: 1  013C	93		              movc   a,@a+dptr     ;waarde lezen
  661: 1  013D	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  662: 1
  663: 1			; de code is niet 0 dus versturen met outchar
  664: 1
  665: 1  013F	12 00 AE	              lcall  outcharlcd    ;weg er mee
  666: 1  0142	A3		              inc    dptr          ;naar volgende ascii code wijzen
  667: 1  0143	02 01 3B	              ljmp   outmsgalcd1   ;lus sluiten
  668: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  669: 1  0146	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  670: 1  0148	D0 83		              pop    dph
  671: 1  014A	D0 D0		              pop    psw
  672: 1  014C	D0 E0		              pop    acc
  673: 1  014E	22		              ret
  674: 1
  675: 1			;******************************************************************************
  676: 1			;
  677: 1			; regtolcd
  678: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  679: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  680: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  681: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  682: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  683: 1			;
  684: 1			; de routine vernietigt geen registers
  685: 1			;
  686: 1			;******************************************************************************
  687: 1
  688: 1
  689: 1  014F	C0 E0		regtolcd:     push   acc           ;registers op de stack
  690: 1  0151	C0 D0		              push   psw
  691: 1  0153	E8		              mov    a,r0
  692: 1  0154	C0 E0		              push   acc
  693: 1  0156	E9		              mov    a,r1
  694: 1  0157	C0 E0		              push   acc
  695: 1  0159	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  696: 1  015B	12 00 AE	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  697: 1			                                   ;plaats
  698: 1  015E	79 00		              mov    r1,#000h      ;werkt als loopcounter
  699: 1  0160	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  700: 1  0161	12 00 AE	              lcall  outcharlcd    ;weg er mee
  701: 1  0164	08		              inc    r0
  702: 1  0165	09		              inc    r1
  703: 1  0166	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  704: 1			                                          ;nieuwe lijn genomen worden
  705: 1  0169	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  706: 1  016B	12 00 AE	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  707: 1			                                   ;plaats
  708: 1
  709: 1  016E	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  710: 1  016F	12 00 AE	              lcall  outcharlcd    ;weg er mee
  711: 1  0172	08		              inc    r0
  712: 1  0173	09		              inc    r1
  713: 1  0174	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  714: 1  0177	D0 E0		              pop    acc
  715: 1  0179	F9		              mov    r1,a
  716: 1  017A	D0 E0		              pop    acc
  717: 1  017C	F8		              mov    r0,a
  718: 1  017D	D0 D0		              pop    psw           ;registers herstellen
  719: 1  017F	D0 E0		              pop    acc
  720: 1  0181	22		              ret
  721: 1
  722: 1			;******************************************************************************
  723: 1			;
  724: 1			; outd

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  725: 1			; Is een routine die naar het data register van het display een
  726: 1			; volledige byte stuurt.
  727: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  728: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  729: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  730: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  731: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  732: 1			;
  733: 1			; De routine vernietigt geen registers.
  734: 1			;
  735: 1			;******************************************************************************
  736: 1
  737: 1  0182	C0 E0		outd:         push   acc           ;registers op stack zetten
  738: 1  0184	C0 D0		              push   psw
  739: 1  0186	12 01 92	              lcall  outhnibd      ;hoogste vier bits verzenden
  740: 1			ifdef     aduc832_v1_1
  741: 1			              lcall  delay60us     ;niet echt nodig
  742: 1			endif
  743: 1  0189	C4		              swap   a             ;bitjes omruilen
  744: 1  018A	12 01 92	              lcall  outhnibd      ;naar het scherm sturen
  745: 1
  746: 1			ifdef    aduc832_v1_1
  747: 1			              lcall  delay60us     ;altijd goed
  748: 1			endif
  749: 1
  750: 1  018D	D0 D0		              pop    psw           ;registers terug herstellen
  751: 1  018F	D0 E0		              pop    acc
  752: 1  0191	22		              ret
  753: 1
  754: 1			;******************************************************************************
  755: 1			;
  756: 1			; outhnibd
  757: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  758: 1			; lcd scherm.
  759: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  760: 1			; de routine vernietigt geen registers.
  761: 1			;
  762: 1			;******************************************************************************
  763: 1			ifdef     aduc832_v1_1
  764: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  765: 1			              push   psw
  766: 1			              setb   rs            ;controle lijn in orde
  767: 1			              clr    e             ;deselectie display
  768: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  769: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  770: 1			              mov     c,acc.6      ;afblijven!
  771: 1			              mov     lcdport.6,c
  772: 1			              mov     c,acc.5
  773: 1			              mov     lcdport.5,c
  774: 1			              mov     c,acc.4
  775: 1			              mov     lcdport.4,c
  776: 1			              setb   e             ;display enabelen
  777: 1			              nop                  ;450ns is normaal gezien voldoende
  778: 1			              clr    e             ;display deselecteren
  779: 1			              pop    psw           ;registers herstellen
  780: 1			              pop    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  781: 1			              ret
  782: 1			endif
  783: 1
  784: 1			ifdef    aduc832_v2_0
  785: 1  0192	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  786: 1  0194	C0 D0		              push   psw
  787: 1  0196	C0 F0		              push   b             ;werkregister
  788: 1  0198	12 04 62	              lcall  lcdtoport     ;lees de expander naar b register
  789: 1  019B	D2 F0		              setb   rs            ;controle lijn in orde
  790: 1  019D	C2 F1		              clr    e             ;deselectie display
  791: 1  019F	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  792: 1  01A1	03		              rr     a             ;bits op juiste plaats zetten
  793: 1  01A2	03		              rr     a             ;voor b reg
  794: 1  01A3	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  795: 1  01A6	42 F0		              orl    b,a           ;bij elkaar voegen
  796: 1  01A8	12 04 49	              lcall  porttolcd     ;naar expander
  797: 1  01AB	D2 F1		              setb   e             ;display enabelen
  798: 1  01AD	12 04 49	              lcall  porttolcd
  799: 1  01B0	C2 F1		              clr    e             ;display deselecteren
  800: 1  01B2	12 04 49	              lcall  porttolcd
  801: 1  01B5	D0 F0		              pop    b
  802: 1  01B7	D0 D0		              pop    psw           ;registers herstellen
  803: 1  01B9	D0 E0		              pop    acc
  804: 1  01BB	22		              ret
  805: 1			endif
  806: 1			;******************************************************************************
  807: 1			;
  808: 1			; outc
  809: 1			; Is een routine die naar het controleregister van het display een
  810: 1			; volledige byte (commando) stuurt.
  811: 1			; De routine vernietigt geen registers.
  812: 1			;
  813: 1			;******************************************************************************
  814: 1
  815: 1  01BC	C0 E0		outc:         push   acc           ;registers op stack zetten
  816: 1  01BE	C0 D0		              push   psw
  817: 1  01C0	12 01 D2	              lcall  outhnibc      ;hoogste vier bits verzenden
  818: 1  01C3	12 03 1B	              lcall  delay2ms      ;niet echt nodig
  819: 1  01C6	C4		              swap   a             ;bitjes omruilen
  820: 1  01C7	12 01 D2	              lcall  outhnibc      ;naar het scherm sturen
  821: 1  01CA	12 03 1B	              lcall  delay2ms      ;altijd goed voor traagste commando
  822: 1  01CD	D0 D0		              pop    psw           ;registers terug herstellen
  823: 1  01CF	D0 E0		              pop    acc
  824: 1  01D1	22		              ret
  825: 1
  826: 1			;******************************************************************************
  827: 1			;
  828: 1			; outhnibc
  829: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  830: 1			; het lcd scherm.
  831: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  832: 1			; de routine vernietigt geen registers.
  833: 1			;
  834: 1			;******************************************************************************
  835: 1			ifdef     aduc832_v1_1
  836: 1			outhnibc:     push   acc           ;registers op stack plaatsen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  837: 1			              push   psw
  838: 1			              clr    rs            ;controle lijn in orde
  839: 1			              clr    e             ;deselectie display
  840: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  841: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  842: 1			              mov     c,acc.6      ;afblijven!
  843: 1			              mov     lcdport.6,c
  844: 1			              mov     c,acc.5
  845: 1			              mov     lcdport.5,c
  846: 1			              mov     c,acc.4
  847: 1			              mov     lcdport.4,c
  848: 1			              setb   e             ;display enabelen
  849: 1			              nop                  ;450ns is normaal gezien voldoende
  850: 1			              clr    e             ;display deselecteren
  851: 1			              pop    psw           ;registers herstellen
  852: 1			              pop    acc
  853: 1			              ret
  854: 1			endif
  855: 1
  856: 1			ifdef    aduc832_v2_0
  857: 1  01D2	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
  858: 1  01D4	C0 D0		              push   psw
  859: 1  01D6	C0 F0		              push   b             ;werkregister
  860: 1  01D8	12 04 62	              lcall  lcdtoport     ;lees de expander naar b register
  861: 1  01DB	C2 F0		              clr    rs            ;controle lijn in orde
  862: 1  01DD	C2 F1		              clr    e             ;deselectie display
  863: 1  01DF	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  864: 1  01E1	03		              rr     a             ;bits op juiste plaats zetten
  865: 1  01E2	03		              rr     a             ;voor b reg
  866: 1  01E3	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  867: 1  01E6	42 F0		              orl    b,a           ;bij elkaar voegen
  868: 1  01E8	12 04 49	              lcall  porttolcd     ;naar expnder
  869: 1  01EB	D2 F1		              setb   e             ;display enabelen
  870: 1  01ED	12 04 49	              lcall  porttolcd
  871: 1  01F0	C2 F1		              clr    e             ;display deselecteren
  872: 1  01F2	12 04 49	              lcall  porttolcd
  873: 1  01F5	D0 F0		              pop    b
  874: 1  01F7	D0 D0		              pop    psw           ;registers herstellen
  875: 1  01F9	D0 E0		              pop    acc
  876: 1  01FB	22		              ret
  877: 1			endif
  878: 1
  879: 1			;******************************************************************************
  880: 1			; hexbuf2lcd
  881: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  882: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  883: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  884: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  885: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  886: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  887: 1			;
  888: 1			; ADR| HEX DATA  |
  889: 1			; 42 |AF 2D 23 5A|
  890: 1			;
  891: 1			; Deze routine vernietigt geen registers
  892: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  893: 1
  894: 1  01FC	C0 E0		hexbuf2lcd:   push   acc
  895: 1  01FE	C0 F0		              push   b
  896: 1  0200	C0 D0		              push   psw
  897: 1  0202	C0 82		              push   dpl
  898: 1  0204	C0 83		              push   dph
  899: 1  0206	E8		              mov     a,r0
  900: 1  0207	C0 E0		              push   acc
  901: 1  0209	90 02 45	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
  902: 1  020C	12 01 33	              lcall   outmsgalcd
  903: 1  020F	E8		              mov    a,r0            ;neem pointerwaarde
  904: 1  0210	12 01 0F	              lcall  outbytelcd      ;byte afdrukken als startadres
  905: 1  0213	74 20		              mov    a,#' '          ;spatie afdrukken
  906: 1  0215	12 00 AE	              lcall  outcharlcd
  907: 1  0218	74 7C		              mov    a,#'|'          ;pipe afdrukken
  908: 1  021A	12 00 AE	              lcall  outcharlcd
  909: 1  021D	75 F0 04	              mov    b,#4            ;bytecounter=4
  910: 1  0220	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  911: 1  0221	12 01 0F	              lcall  outbytelcd      ;byte naar buiten
  912: 1  0224	74 20		              mov    a,#' '          ;neem whitespace char
  913: 1  0226	12 00 AE	              lcall  outcharlcd       ;druk af
  914: 1  0229	08		              inc    r0              ;volgende byte
  915: 1  022A	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
  916: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  917: 1  022D	74 CF		              mov    a,#0cfh         ;adres laatste char
  918: 1  022F	12 00 AE	              lcall   outcharlcd
  919: 1  0232	74 7C		              mov    a,#'|'          ;neem pipe
  920: 1  0234	12 00 AE	              lcall  outcharlcd      ;ascii code afdrukken
  921: 1  0237	D0 E0		hexbuf2lcde:  pop    acc
  922: 1  0239	F8		              mov   r0,a
  923: 1  023A	D0 83		              pop   dph
  924: 1  023C	D0 82		              pop   dpl
  925: 1  023E	D0 D0		              pop   psw
  926: 1  0240	D0 F0		              pop   b
  927: 1  0242	D0 E0		              pop   acc
  928: 1  0244	22		              ret
  929: 1			                        ;'0123456789abcdef'
  930: 1  0245	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  0249	52 7C 20 48
       1  024D	45 58 20 44
       1  0251	41 54 41 20
       1  0255	20 7C C0 00
  931: 1
  932: 1
  933: 1			;******************************************************************************
  934: 1			; barlcd
  935: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
  936: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
  937: 1			; de inhoud van A
  938: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
  939: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
  940: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
  941: 1			; aangemaakt in de LCD CGRAM.
  942: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
  943: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
  944: 1			;       lcall build

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  945: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
  946: 1			;       mov     a, #42h     ;de startlocatie is 42h
  947: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
  948: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
  949: 1			;
  950: 1			; Deze routine vernietigt geen registers.
  951: 1			;******************************************************************************
  952: 1
  953: 1  0259	C0 82		barlcd:       push   dpl
  954: 1  025B	88 82		              mov     dpl,r0
  955: 1  025D	C0 82		              push   dpl
  956: 1  025F	C0 E0		              push   acc            ;bewaar startlocatie
  957: 1  0261	C0 D0		              push   psw            ;bewaar status
  958: 1  0263	C0 F0		              push   b              ;bewaar aantal bar's
  959: 1  0265	F5 F0		              mov    b,a            ;bewaar startlocatie
  960: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
  961: 1  0267	E8		              mov    a,r0           ;neem maximum aantal bar's
  962: 1  0268	C0 F0		              push   b              ;bewaar startadres
  963: 1  026A	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
  964: 1  026D	84		              div    ab             ;bereken dus het aantal nodige blokjes
  965: 1  026E	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
  966: 1  026F	E5 F0		              mov    a,b            ;neem restbars
  967: 1  0271	60 01		              jz     barlcd_1       ;als nul dan verder
  968: 1  0273	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
  969: 1  0274	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
  970: 1  0276	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
  971: 1  0278	12 00 AE	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
  972: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
  973: 1  027B	74 13		              mov    a,#13h         ;cursor off
  974: 1  027D	12 00 AE	              lcall  outcharlcd     ;stuur naar LCD
  975: 1  0280	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
  976: 1  0282	C0 F0		              push   b              ;en weer bewaren
  977: 1  0284	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
  978: 1  0286	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
  979: 1  0288	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
  980: 1  028B	84		              div    ab             ;A=aantal volle blokjes, B=rest
  981: 1  028C	C0 F0		              push   b              ;bewaar rest
  982: 1  028E	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
  983: 1  0290	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
  984: 1
  985: 1			;Druk de volle 5x8 blokjes af van de bargraph
  986: 1  0292	74 04		              mov    a,#4           ;neem code voor vol blokje
  987: 1  0294	12 01 82	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
  988: 1  0297	18		              dec    r0             ;verminder karaktersteller
  989: 1  0298	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
  990: 1
  991: 1			;Druk het onvolledige blokje (rest) af
  992: 1  029B	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
  993: 1  029D	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
  994: 1  029F	14		              dec    a              ;converteer rest naar code voor de
  995: 1			                                    ;overeenkomende bar's
  996: 1  02A0	12 01 82	              lcall  outd           ;druk resterende bar's af
  997: 1  02A3	18		              dec    r0             ;verminder karakterteller
  998: 1
  999: 1			;Test of we aan het einde van de bargraph zitten..
 1000: 1  02A4	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

 1001: 1  02A7	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
 1002: 1
 1003: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
 1004: 1  02A9	74 20		barlcd4:      mov    a,#' '         ;neem spatie
 1005: 1  02AB	12 01 82	              lcall  outd           ;en druk af
 1006: 1  02AE	18		              dec    r0             ;karakterteller verminderen
 1007: 1  02AF	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
 1008: 1
 1009: 1  02B1	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
 1010: 1  02B3	D0 D0		              pop    psw            ;haal status weer
 1011: 1  02B5	D0 E0		              pop    acc            ;haal startlocatie weer
 1012: 1  02B7	D0 82		              pop    dpl
 1013: 1  02B9	A8 82		              mov    r0,dpl
 1014: 1  02BB	D0 82		              pop    dpl
 1015: 1  02BD	22		              ret
 1016: 1
 1017: 1
 1018: 1
 1019: 1			;******************************************************************************
 1020: 1			; barchars
 1021: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
 1022: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
 1023: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
 1024: 1			; kunnen pas daarna worden gebruikt.
 1025: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
 1026: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
 1027: 1			; (max. 3 extra char's).
 1028: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
 1029: 1			; opgeslagen met MSB=1.
 1030: 1			;******************************************************************************
 1031: 1
 1032: 1  02BE	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1033: 1  02BF	10		              db 00010000b
 1034: 1  02C0	10		              db 00010000b
 1035: 1  02C1	10		              db 00010000b
 1036: 1  02C2	10		              db 00010000b
 1037: 1  02C3	10		              db 00010000b
 1038: 1  02C4	10		              db 00010000b
 1039: 1  02C5	10		              db 00010000b
 1040: 1
 1041: 1  02C6	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1042: 1  02C7	18		              db 00011000b
 1043: 1  02C8	18		              db 00011000b
 1044: 1  02C9	18		              db 00011000b
 1045: 1  02CA	18		              db 00011000b
 1046: 1  02CB	18		              db 00011000b
 1047: 1  02CC	18		              db 00011000b
 1048: 1  02CD	18		              db 00011000b
 1049: 1
 1050: 1  02CE	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1051: 1  02CF	1C		              db 00011100b
 1052: 1  02D0	1C		              db 00011100b
 1053: 1  02D1	1C		              db 00011100b
 1054: 1  02D2	1C		              db 00011100b
 1055: 1  02D3	1C		              db 00011100b
 1056: 1  02D4	1C		              db 00011100b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1057: 1  02D5	1C		              db 00011100b
 1058: 1
 1059: 1  02D6	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1060: 1  02D7	1E		              db 00011110b
 1061: 1  02D8	1E		              db 00011110b
 1062: 1  02D9	1E		              db 00011110b
 1063: 1  02DA	1E		              db 00011110b
 1064: 1  02DB	1E		              db 00011110b
 1065: 1  02DC	1E		              db 00011110b
 1066: 1  02DD	1E		              db 00011110b
 1067: 1
 1068: 1  02DE	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1069: 1  02DF	1F		              db 00011111b
 1070: 1  02E0	1F		              db 00011111b
 1071: 1  02E1	1F		              db 00011111b
 1072: 1  02E2	1F		              db 00011111b
 1073: 1  02E3	1F		              db 00011111b
 1074: 1  02E4	1F		              db 00011111b
 1075: 1  02E5	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1076: 1
 1077: 1			;******************************************************************************
 1078: 1			;
 1079: 1			; build
 1080: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1081: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1082: 1			; overeen komen met de ASCII codes 00h-07h.
 1083: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1084: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1085: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1086: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1087: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1088: 1			;
 1089: 1			; De routine vernietigt geen registers.
 1090: 1			;
 1091: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1092: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1093: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1094: 1			;      lcall  outcharlcd         ; druk de karakter af
 1095: 1			;
 1096: 1			;eigenkarakter:
 1097: 1			;      db 00001110b
 1098: 1			;      db 00001010b
 1099: 1			;      db 00001110b
 1100: 1			;      db 00000100b
 1101: 1			;      db 00011111b
 1102: 1			;      db 00000100b
 1103: 1			;      db 00001010b
 1104: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1105: 1			;******************************************************************************
 1106: 1
 1107: 1  02E6	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1108: 1  02E8	C0 D0		              push   psw
 1109: 1  02EA	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1110: 1  02EC	12 02 F4	              lcall  build_adr
 1111: 1  02EF	D0 D0		              pop    psw
 1112: 1  02F1	D0 E0		              pop    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1113: 1  02F3	22		              ret                  ;terug
 1114: 1
 1115: 1			;******************************************************************************
 1116: 1			; build_adr
 1117: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1118: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1119: 1			; die overeen komen met de ASCII codes 00h-07h.
 1120: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1121: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1122: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1123: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1124: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1125: 1			;
 1126: 1			; De routine vernietigt geen registers.
 1127: 1			;
 1128: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1129: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1130: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1131: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1132: 1			;      lcall  outcharlcd        ; druk de karakter af
 1133: 1			;
 1134: 1			;eigenkarakters:
 1135: 1			;      db 00001110b
 1136: 1			;      db 00001010b
 1137: 1			;      db 00001110b
 1138: 1			;       db 00000100b
 1139: 1			;      db 00011111b
 1140: 1			;      db 00000100b
 1141: 1			;      db 00001010b
 1142: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1143: 1			;******************************************************************************
 1144: 1  02F4	C0 E0		build_adr:      push   acc
 1145: 1  02F6	C0 D0		              push   psw
 1146: 1  02F8	C0 83		              push   dph
 1147: 1  02FA	C0 82		              push   dpl
 1148: 1  02FC	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1149: 1  02FE	12 01 BC	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1150: 1  0301	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1151: 1  0303	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1152: 1  0304	12 01 82	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1153: 1  0307	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1154: 1  030A	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1155: 1  030B	80 F4		              sjmp   build3
 1156: 1  030D	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1157: 1  030F	12 01 BC	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1158: 1  0312	D0 82		              pop    dpl
 1159: 1  0314	D0 83		              pop    dph
 1160: 1  0316	D0 D0		              pop    psw
 1161: 1  0318	D0 E0		              pop    acc
 1162: 1  031A	22		              ret
 1163: 1
 1164: 1			;******************************************************************************
 1165: 1			;
 1166: 1			; delay2ms
 1167: 1			; Is een vertragingsroutine van 2ms.
 1168: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1169: 1			; De routine vernietigt geen registers.
 1170: 1			;
 1171: 1			;******************************************************************************
 1172: 1
 1173: 1  031B	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1174: 1  031D	C0 D0		              push   psw
 1175: 1  031F	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1176: 1  0321	12 03 2C	delay2ms1:    lcall  delay60us
 1177: 1  0324	D5 E0 FA	              djnz   acc,delay2ms1
 1178: 1  0327	D0 D0		              pop    psw           ;registers herstellen
 1179: 1  0329	D0 E0		              pop    acc
 1180: 1  032B	22		              ret
 1181: 1
 1182: 1			;******************************************************************************
 1183: 1			;
 1184: 1			; delay60us.
 1185: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1186: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1187: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1188: 1			;
 1189: 1			; de routine vernietigt geen registers.
 1190: 1			;
 1191: 1			;******************************************************************************
 1192: 1
 1193: 1  032C	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1194: 1  032E	C0 D0		              push   psw
 1195: 1  0330	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1196: 1  0332	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1197: 1
 1198: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1199: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1200: 1
 1201: 1  0334	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1202: 1  0337	D0 E0		              pop    acc           ;registers herstellen
 1203: 1  0339	D0 D0		              pop    psw
 1204: 1  033B	22		              ret
 1205: 1
 1206: 1  033C	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1207: 1  033E	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1208: 1  0341	D0 D0		              pop    psw
 1209: 1  0343	D0 E0		              pop    acc
 1210: 1  0345	22		              ret
 1211: 1
 1212: 1			endif        ;einde van aduc_lcd
 1213: 1
 1214: 1
 1215: 1
 1216: 1
 1217: 1			ifdef aduc_i2c
 1218: 1			;******************************************************************************
 1219: 1			;
 1220: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1221: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1222: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1223: 1			;
 1224: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1225: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1226: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1227: 1			;
 1228: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1229: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1230: 1			;
 1231: 1			; Beschikbare routines:
 1232: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1233: 1			; i2cstart     :verzenden van een start conditie
 1234: 1			; i2cstop      :verzenden van een stop conditie
 1235: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1236: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1237: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1238: 1			;               negende klokpuls
 1239: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1240: 1			;               negende klokpuls
 1241: 1			;
 1242: 1			; Toevoeging [dp]
 1243: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1244: 1			;               een slavedevice
 1245: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1246: 1			;               en plaatst deze in een geheugenbuffer
 1247: 1			;******************************************************************************
 1248: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1249: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1250: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1251: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1252: 1
 1253: 1			;******************************************************************************
 1254: 1			; i2cinit
 1255: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1256: 1			;******************************************************************************
 1257: 1  0346	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1258: 1  0348	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1259: 1  034A	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1260: 1  034C	D2 EB		                setb    i2cm            ;master mode inschakelen
 1261: 1  034E	22		                ret
 1262: 1			;******************************************************************************
 1263: 1			; i2cstart
 1264: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1265: 1			;******************************************************************************
 1266: 1  034F	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1267: 1  0351	C2 EF		                clr     mdo             ;data moet laag worden
 1268: 1  0353	D2 EE		                setb    mde             ;data pin enable
 1269: 1  0355	C2 ED		                clr     mco             ;klok laag maken
 1270: 1  0357	22		                ret
 1271: 1			;******************************************************************************
 1272: 1			; i2cstop
 1273: 1			; Dit is een subroutine die de stop conditie opwekt.
 1274: 1			;******************************************************************************
 1275: 1  0358	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1276: 1  035A	D2 EE		                setb    mde             ;data mag naar buiten
 1277: 1  035C	D2 ED		                setb    mco             ;nu moet de klok omhoog

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1278: 1  035E	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1279: 1  0360	22		                ret
 1280: 1
 1281: 1			;******************************************************************************
 1282: 1			; i2coutbyte
 1283: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1284: 1			; De routine vernietigt geen registers.
 1285: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1286: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1287: 1			;         uitvoeren van de routine.
 1288: 1			;******************************************************************************
 1289: 1  0361	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1290: 1  0363	C0 F0		                push    b
 1291: 1  0365	75 F0 08	                mov     b,#008h         ;loopcounter
 1292: 1  0368	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1293: 1  0369	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1294: 1  036B	D2 EE		                setb    mde             ;pin als output activeren
 1295: 1  036D	D2 ED		                setb    mco             ;klokpukls hoog
 1296: 1  036F	C2 ED		                clr     mco             ;klokpuls laag
 1297: 1  0371	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1298: 1  0374	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1299: 1  0376	D2 ED		                setb    mco             ;klokpuls hoog
 1300: 1  0378	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1301: 1  037A	C2 ED		                clr     mco             ;klokpuls terug laag
 1302: 1  037C	D0 F0		                pop     b
 1303: 1  037E	D0 E0		                pop     acc             ;registers herstellen
 1304: 1  0380	22		                ret
 1305: 1
 1306: 1			;******************************************************************************
 1307: 1			; i2cinbyteack
 1308: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1309: 1			; De routine vernietigt geen registers. De routine zal als
 1310: 1			; negende bit een ack verzenden.
 1311: 1			;******************************************************************************
 1312: 1  0381	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1313: 1  0383	C0 D0		                push    psw
 1314: 1  0385	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1315: 1  0388	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1316: 1  038A	D2 ED		                setb    mco             ;klokpuls hoog
 1317: 1  038C	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1318: 1  038E	C2 ED		                clr     mco             ;klokpuls terug laag
 1319: 1  0390	33		                rlc     a               ;in accu shiften
 1320: 1  0391	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1321: 1  0394	C3		                clr     c               ;ack verzenden
 1322: 1  0395	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1323: 1  0397	D2 EE		                setb    mde             ;pin als output activeren
 1324: 1  0399	D2 ED		                setb    mco             ;klokpukls hoog
 1325: 1  039B	C2 ED		                clr     mco             ;klokpuls laag
 1326: 1  039D	D0 D0		                pop     psw             ;registers herstellen
 1327: 1  039F	D0 F0		                pop     b
 1328: 1  03A1	22		                ret
 1329: 1
 1330: 1			;******************************************************************************
 1331: 1			; i2cinbytenack
 1332: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1333: 1			; De routine vernietigt geen registers. De routine zal als

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1334: 1			; negende bit een nack verzenden.
 1335: 1			;******************************************************************************
 1336: 1  03A2	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1337: 1  03A4	C0 D0		                push    psw
 1338: 1  03A6	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1339: 1  03A9	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1340: 1  03AB	D2 ED		                setb    mco             ;klokpuls hoog
 1341: 1  03AD	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1342: 1  03AF	C2 ED		                clr     mco             ;klokpuls terug laag
 1343: 1  03B1	33		                rlc     a               ;in accu shiften
 1344: 1  03B2	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1345: 1  03B5	D3		                setb    c               ;nack verzenden
 1346: 1  03B6	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1347: 1  03B8	D2 EE		                setb    mde             ;pin als output activeren
 1348: 1  03BA	D2 ED		                setb    mco             ;klokpukls hoog
 1349: 1  03BC	C2 ED		                clr     mco             ;klokpuls laag
 1350: 1  03BE	D0 D0		                pop     psw             ;registers herstellen
 1351: 1  03C0	D0 F0		                pop     b
 1352: 1  03C2	22		                ret
 1353: 1
 1354: 1			;******************************************************************************
 1355: 1			; i2csenddata
 1356: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1357: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1358: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1359: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1360: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1361: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1362: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1363: 1			;
 1364: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1365: 1			; pointer naar deze data.  .
 1366: 1
 1367: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1368: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1369: 1			;         B       = aantal te versturen bytes (minimum 1)
 1370: 1			;         R0      = startadres van te versturen datablok
 1371: 1			;
 1372: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1373: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1374: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1375: 1			;               verzonden byte waarvoor er geen ack kwam.
 1376: 1			;
 1377: 1			; Deze routine vernietigt niets...
 1378: 1			;******************************************************************************
 1379: 1  03C3	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1380: 1  03C5	C0 D0		                    push   psw
 1381: 1  03C7	E8		                    mov    a,r0
 1382: 1  03C8	C0 E0		                    push   acc           ;r0 op stack
 1383: 1
 1384: 1  03CA	12 03 4F	                    lcall  i2cstart      ;genereer startconditie
 1385: 1  03CD	E5 83		                    mov    a,dph         ;neem adresbyte
 1386: 1  03CF	12 03 61	                    lcall  i2coutbyte    ;en verstuur naar slave
 1387: 1  03D2	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1388: 1  03D4	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1389: 1  03D6	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1390: 1  03D8	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1391: 1			;10 bit adressering!
 1392: 1  03DB	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1393: 1  03DD	12 03 61	                    lcall  i2coutbyte    ;en verstuur naar slave
 1394: 1  03E0	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1395: 1			;7 bit adressering!
 1396: 1  03E2	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1397: 1  03E3	12 03 61	                    lcall  i2coutbyte    ;en verstuur naar slave
 1398: 1  03E6	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1399: 1  03E8	08		                    inc    r0            ;volgende byte
 1400: 1  03E9	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1401: 1  03EC	12 03 58	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1402: 1  03EF	D0 E0		                    pop    acc
 1403: 1  03F1	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1404: 1  03F2	D0 D0		                    pop    psw
 1405: 1  03F4	C3		                    clr    c             ;alles is ok!
 1406: 1  03F5	D0 E0		                    pop    acc
 1407: 1  03F7	22		                    ret
 1408: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1409: 1  03F8	12 03 58	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1410: 1  03FB	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1411: 1  03FD	D0 D0		                    pop    psw
 1412: 1  03FF	D3		                    setb   c            ;terug met foutmelding
 1413: 1  0400	D0 E0		                    pop    acc
 1414: 1  0402	22		                    ret
 1415: 1
 1416: 1			;******************************************************************************
 1417: 1			; i2crcvdata
 1418: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1419: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1420: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1421: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1422: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1423: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1424: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1425: 1			;
 1426: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1427: 1			; is een pointer naar de start van dit ontvangen datablok.
 1428: 1			;
 1429: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1430: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1431: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1432: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1433: 1			;
 1434: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1435: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1436: 1			;               het adres, wordt de CY bit geset bij return.
 1437: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1438: 1			;
 1439: 1			; Deze routine vernietigt verder niets...
 1440: 1			;******************************************************************************
 1441: 1  0403	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1442: 1  0405	C0 D0		                    push    psw
 1443: 1  0407	E8		                    mov     a,r0            ;r0 op stack
 1444: 1  0408	C0 E0		                    push    acc
 1445: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1446: 1  040A	12 03 4F	                    lcall   i2cstart        ;genereer startconditie
 1447: 1  040D	E5 83		                    mov     a,dph           ;neem adresbyte
 1448: 1  040F	12 03 61	                    lcall   i2coutbyte      ;en verstuur naar slave
 1449: 1  0412	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1450: 1  0414	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1451: 1  0416	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1452: 1  0418	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1453: 1			;10 bit adressering!
 1454: 1  041B	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1455: 1  041D	12 03 61	                    lcall   i2coutbyte      ;en verstuur naar slave
 1456: 1  0420	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1457: 1			;7 bit adressering!
 1458: 1
 1459: 1  0422	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1460: 1  0425	12 03 A2	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1461: 1  0428	F6		                    mov     @r0,a           ;en deze ook bewaren
 1462: 1  0429	80 07		                    sjmp    i2crcvdata3
 1463: 1  042B	12 03 81	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1464: 1  042E	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1465: 1  042F	08		                    inc     r0              ;pointer verhogen
 1466: 1  0430	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1467: 1
 1468: 1  0432	12 03 58	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1469: 1  0435	D0 E0		                    pop     acc
 1470: 1  0437	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1471: 1  0438	D0 D0		                    pop     psw
 1472: 1  043A	C3		                    clr     c               ;alles is ok!
 1473: 1  043B	D0 E0		                    pop     acc
 1474: 1  043D	22		                    ret
 1475: 1			;fout: geen ack gekregen bij het versturen van het adres
 1476: 1  043E	12 03 58	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1477: 1  0441	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1478: 1  0443	D0 D0		                    pop        psw
 1479: 1  0445	D3		                    setb    c               ;terug met foutmelding
 1480: 1  0446	D0 E0		                    pop        acc
 1481: 1  0448	22		                    ret
 1482: 1
 1483: 1
 1484: 1			;******************************************************************************
 1485: 1			;
 1486: 1			; porttolcd
 1487: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1488: 1			; scherm stuurt via de port expander.
 1489: 1			;
 1490: 1			; Gebruikt geen registers
 1491: 1			;
 1492: 1			;******************************************************************************
 1493: 1
 1494: 1  0449	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1495: 1  044B	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1496: 1  044D	12 03 4F	              lcall  i2cstart      ;vertrokken
 1497: 1			ifdef    pcf8574
 1498: 1			              mov    a,#01000000b  ;schrijven naar expander
 1499: 1			endif
 1500: 1			ifdef    pcf8574A
 1501: 1  0450	74 70		              mov    a,#01110000b  ;schrijven naar expander

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1502: 1			endif
 1503: 1  0452	12 03 61	              lcall  i2coutbyte    ;weg er mee
 1504: 1  0455	E5 F0		              mov    a,b           ;data verzenden
 1505: 1  0457	12 03 61	              lcall  i2coutbyte
 1506: 1  045A	12 03 58	              lcall  i2cstop       ;transactie sluiten
 1507: 1  045D	D0 D0		              pop    psw
 1508: 1  045F	D0 E0		              pop    acc
 1509: 1  0461	22		              ret
 1510: 1
 1511: 1			;******************************************************************************
 1512: 1			;
 1513: 1			; lcdtoport
 1514: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1515: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1516: 1			; aansturen van de buzzer en backlight.
 1517: 1			;
 1518: 1			; output: b register
 1519: 1			;
 1520: 1			;******************************************************************************
 1521: 1
 1522: 1  0462	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1523: 1  0464	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1524: 1  0466	12 03 4F	              lcall  i2cstart      ;vertrokken
 1525: 1			ifdef    pcf8574
 1526: 1			              mov    a,#01000000b  ;schrijven naar expander
 1527: 1			endif
 1528: 1			ifdef    pcf8574A
 1529: 1  0469	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1530: 1			endif
 1531: 1  046B	12 03 61	              lcall  i2coutbyte    ;weg er mee
 1532: 1  046E	12 03 A2	              lcall  i2cinbytenack ;data inlezen
 1533: 1  0471	12 03 58	              lcall  i2cstop
 1534: 1  0474	F5 F0		              mov    b,a
 1535: 1  0476	D0 D0		              pop    psw
 1536: 1  0478	D0 E0		              pop    acc
 1537: 1  047A	22		              ret
 1538: 1
 1539: 1			;******************************************************************************
 1540: 1			;
 1541: 1			; lcdlighton
 1542: 1			; Dit is een subroutine die de backlight inschakeld
 1543: 1			;
 1544: 1			; Gebruikt geen registers
 1545: 1			;
 1546: 1			;******************************************************************************
 1547: 1
 1548: 1  047B	C0 F0		lcdlighton:   push   b
 1549: 1  047D	12 04 62	              lcall  lcdtoport     ;expander lezen
 1550: 1  0480	C2 F6		              clr    b.6           ;licht aan doen
 1551: 1  0482	12 04 49	              lcall  porttolcd     ;expander schrijven
 1552: 1  0485	D0 F0		              pop    b
 1553: 1  0487	22		              ret
 1554: 1
 1555: 1
 1556: 1			;******************************************************************************
 1557: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1558: 1			; lcdlightoff
 1559: 1			; Dit is een subroutine die de backlight uitschakeld
 1560: 1			;
 1561: 1			; Gebruikt geen registers
 1562: 1			;
 1563: 1			;******************************************************************************
 1564: 1
 1565: 1  0488	C0 F0		lcdlightoff:  push   b
 1566: 1  048A	12 04 62	              lcall  lcdtoport     ;expander lezen
 1567: 1  048D	D2 F6		              setb   b.6           ;licht uit doen
 1568: 1  048F	12 04 49	              lcall  porttolcd     ;expander schrijven
 1569: 1  0492	D0 F0		              pop    b
 1570: 1  0494	22		              ret
 1571: 1
 1572: 1			;******************************************************************************
 1573: 1			;
 1574: 1			; lcdbuzon
 1575: 1			; Dit is een subroutine die de buzzer inschakeld
 1576: 1			;
 1577: 1			; Gebruikt geen registers
 1578: 1			;
 1579: 1			;******************************************************************************
 1580: 1
 1581: 1  0495	C0 F0		lcdbuzon:     push   b
 1582: 1  0497	12 04 62	              lcall  lcdtoport     ;expander lezen
 1583: 1  049A	C2 F7		              clr    b.7           ;buzzer aan doen
 1584: 1  049C	12 04 49	              lcall  porttolcd     ;expander schrijven
 1585: 1  049F	D0 F0		              pop    b
 1586: 1  04A1	22		              ret
 1587: 1
 1588: 1			;******************************************************************************
 1589: 1			;
 1590: 1			; lcdbuzoff
 1591: 1			; Dit is een subroutine die de buzzer uitschakeld
 1592: 1			;
 1593: 1			; Gebruikt geen registers
 1594: 1			;
 1595: 1			;******************************************************************************
 1596: 1
 1597: 1  04A2	C0 F0		lcdbuzoff:    push   b
 1598: 1  04A4	12 04 62	              lcall  lcdtoport     ;expander lezen
 1599: 1  04A7	D2 F7		              setb   b.7           ;buzzer aan doen
 1600: 1  04A9	12 04 49	              lcall  porttolcd     ;expander schrijven
 1601: 1  04AC	D0 F0		              pop    b
 1602: 1  04AE	22		              ret
 1603: 1
 1604: 1			endif    ;einde aduc_i2c
 1605: 1			;******************************************************************************
 1606: 1
 1607: 1
 1608: 1
 1609: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1610: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1611: 1			;
 1612: 1			; ADuCsio.inc
 1613: 1			; Is een include file voor de ADuC832 microcontroller.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1614: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1615: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1616: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1617: 1			; afwijking van de standaard routines is de initsio subroutine.
 1618: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1619: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1620: 1			; zijn.
 1621: 1			;
 1622: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1623: 1			;
 1624: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1625: 1
 1626: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1627: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1628: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1629: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1630: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1631: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1632: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1633: 1
 1634: 1  04AF	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1635: 1			                                                        ;van het scherm
 1636: 1
 1637: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1638: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1639: 1
 1640: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1641: 1			;
 1642: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1643: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1644: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1645: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1646: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1647: 1			;
 1648: 1			; de routine gebruikt de psw
 1649: 1			;
 1650: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1651: 1
 1652: 1  04B3	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1653: 1  04B5	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1654: 1  04B7	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1655: 1  04B9	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1656: 1  04BC	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1657: 1
 1658: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1659: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1660: 1
 1661: 1  04BE	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1662: 1  04C1	F4		              cpl    a             ;bitbangen om laten uit te komen
 1663: 1  04C2	C3		              clr    c             ;verder doen
 1664: 1  04C3	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1665: 1  04C5	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1666: 1  04C7	24 80		              add    a,#080h       ;nu alles in orde
 1667: 1  04C9	F5 9E		              mov    t3con,a       ;baud rate klaar
 1668: 1  04CB	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1669: 1  04CE	C3		              clr    c             ;aangeven init ok (overbodige instructie)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1670: 1  04CF	D0 E0		              pop    acc
 1671: 1  04D1	22		              ret
 1672: 1
 1673: 1  04D2	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1674: 1  04D3	D0 E0		              pop    acc
 1675: 1  04D5	22		              ret
 1676: 1
 1677: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1678: 1			;
 1679: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1680: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1681: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1682: 1			;
 1683: 1			; de routine gebruikt geen registers.
 1684: 1			;
 1685: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1686: 1
 1687: 1  04D6	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1688: 1  04D8	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1689: 1  04DB	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1690: 1  04DD	22		              RET
 1691: 1
 1692: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1693: 1			;
 1694: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1695: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1696: 1			;
 1697: 1			; de routine gebruikt geen registers.
 1698: 1			;
 1699: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1700: 1
 1701: 1  04DE	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1702: 1  04E0	C0 D0		              push   psw
 1703: 1  04E2	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1704: 1  04E4	12 05 F0	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1705: 1  04E7	12 04 D6	              LCALL  OUTCHAR       ;VERSTUREN
 1706: 1  04EA	12 05 37	              LCALL  XONXOFF       ;FLOW CONTROL
 1707: 1  04ED	D0 D0		              pop    psw           ;registers herstellen
 1708: 1  04EF	D0 E0		              pop    acc
 1709: 1  04F1	22		              RET
 1710: 1
 1711: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1712: 1			;
 1713: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1714: 1			; WORDT XONXOFF GEBRUIKT.
 1715: 1			;
 1716: 1			; de routine gebruikt geen registers.
 1717: 1			;
 1718: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1719: 1
 1720: 1  04F2	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1721: 1  04F4	C0 D0		              push   psw
 1722: 1  04F6	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1723: 1  04F8	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1724: 1  04F9	12 04 DE	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1725: 1  04FC	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1726: 1  04FE	12 04 DE	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1727: 1  0501	D0 D0		              pop    psw           ;registers herstellen
 1728: 1  0503	D0 E0		              pop    acc
 1729: 1  0505	22		              RET
 1730: 1
 1731: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1732: 1			;
 1733: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1734: 1			; VAN DE CURSOR.
 1735: 1			;
 1736: 1			; de routine gebruikt geen registers.
 1737: 1			;
 1738: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1739: 1
 1740: 1  0506	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1741: 1  0508	C0 D0		              push   psw
 1742: 1  050A	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1743: 1  050C	12 04 F2	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1744: 1  050F	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1745: 1  0511	12 04 F2	              LCALL  OUTBYTE       ;WEG ER MEE
 1746: 1  0514	D0 D0		              pop    psw           ;registers herstellen
 1747: 1  0516	D0 E0		              pop    acc
 1748: 1  0518	22		              RET                  ;EINDE
 1749: 1
 1750: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1751: 1			;
 1752: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1753: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1754: 1			;
 1755: 1			; de routine gebruikt geen registers.
 1756: 1			;
 1757: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1758: 1
 1759: 1  0519	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1760: 1  051B	C0 D0		              push   psw
 1761: 1  051D	C0 82		              push   dpl
 1762: 1  051F	C0 83		              push   dph
 1763: 1  0521	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1764: 1  0522	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1765: 1  0523	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1766: 1  0525	12 04 D6	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1767: 1  0528	12 05 37	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1768: 1  052B	A3		              INC    DPTR          ;DPTR AANPASSEN
 1769: 1  052C	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1770: 1  052E	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1771: 1  0530	D0 82		              pop    dpl
 1772: 1  0532	D0 D0		              pop    psw
 1773: 1  0534	D0 E0		              pop    acc
 1774: 1  0536	22		              RET                  ;EINDE ROUTINE
 1775: 1
 1776: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1777: 1			;
 1778: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1779: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1780: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1781: 1			; VERDER DOORGEGEVEN.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1782: 1			;
 1783: 1			; de routine gebruikt geen registers.
 1784: 1			;
 1785: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1786: 1
 1787: 1  0537	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1788: 1  0539	C0 D0		              push   psw
 1789: 1  053B	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1790: 1  053E	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 1791: 1  0540	D0 E0		              pop    acc
 1792: 1  0542	22		              RET                  ;ANDERS EINDE
 1793: 1  0543	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1794: 1  0545	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1795: 1  0548	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1796: 1  054B	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1797: 1
 1798: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1799: 1			;
 1800: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1801: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1802: 1			;
 1803: 1			; de routine gebruikt de accu.
 1804: 1			;
 1805: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1806: 1
 1807: 1  054D	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 1808: 1  0550	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 1809: 1  0552	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1810: 1  0554	22		              RET
 1811: 1
 1812: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1813: 1			;
 1814: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1815: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1816: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 1817: 1			; DE CARRY OP 1 GEZET WORDEN.
 1818: 1			;
 1819: 1			; De routine gebruikt de accu EN PSW.
 1820: 1			;
 1821: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1822: 1
 1823: 1  0555	C0 F0		INBYTE:       PUSH     B
 1824: 1  0557	12 05 4D	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1825: 1  055A	12 05 E3	              LCALL  LOWUPTR
 1826: 1  055D	12 05 FE	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1827: 1  0560	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1828: 1  0562	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1829: 1  0563	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1830: 1  0565	12 05 4D	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1831: 1  0568	12 05 E3	              LCALL  LOWUPTR
 1832: 1  056B	12 05 FE	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1833: 1  056E	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1834: 1  0570	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1835: 1  0572	D0 F0		INBYTE1:      POP     B
 1836: 1  0574	22		              RET
 1837: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1838: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1839: 1			;
 1840: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1841: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1842: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1843: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1844: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1845: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1846: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 1847: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1848: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1849: 1			; bepalen.
 1850: 1			;
 1851: 1			; De routine gebruikt  r0 .
 1852: 1			;
 1853: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1854: 1
 1855: 1  0575	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1856: 1  0577	C0 D0		              push   psw
 1857: 1  0579	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1858: 1  057B	12 05 4D	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 1859: 1  057E	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1860: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 1861: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1862: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1863: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 1864: 1			; GEVOERD.
 1865: 1  0580	12 05 E3	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1866: 1  0583	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1867: 1  0586	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1868: 1  0587	D0 D0		              pop    psw                  ;registers herstellen
 1869: 1  0589	D0 E0		              pop    acc
 1870: 1  058B	22		              RET                         ;EINDE VAN DE ROUTINE
 1871: 1
 1872: 1  058C	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 1873: 1  058F	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1874: 1  0592	74 07		INBUFA4:      MOV    A,#BEEP
 1875: 1  0594	12 04 D6	INBUFA7:      LCALL  OUTCHAR
 1876: 1  0597	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1877: 1
 1878: 1  0599	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1879: 1  059A	90 04 AF	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1880: 1  059D	12 05 19	              LCALL  OUTMSGA
 1881: 1  05A0	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 1882: 1  05A2	12 05 D5	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1883: 1  05A5	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1884: 1  05A7	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1885: 1  05AA	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1886: 1  05AC	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1887: 1  05AD	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1888: 1  05AE	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1889: 1
 1890: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1891: 1			;
 1892: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1893: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1894: 1			; De routine gebruikt niets.
 1895: 1			;
 1896: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1897: 1
 1898: 1  05B0	C0 E0		BDELETE:      PUSH     ACC
 1899: 1  05B2	C0 D0		              PUSH     PSW
 1900: 1  05B4	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1901: 1  05B5	C0 E0		              PUSH     ACC
 1902: 1  05B7	E9		              MOV     A,R1
 1903: 1  05B8	C0 E0		              PUSH     ACC
 1904: 1  05BA	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1905: 1  05BC	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1906: 1  05BE	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1907: 1  05BF	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1908: 1  05C2	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1909: 1  05C3	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1910: 1  05C6	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1911: 1  05C8	F9		              MOV     R1,A
 1912: 1  05C9	D0 E0		              POP     ACC
 1913: 1  05CB	F8		              MOV     R0,A
 1914: 1  05CC	D0 D0		              POP     PSW
 1915: 1  05CE	D0 E0		              POP     ACC
 1916: 1  05D0	22		              RET                         ;EINDE VAN DE ROUTINE
 1917: 1  05D1	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1918: 1  05D2	09		              INC    R1
 1919: 1  05D3	80 ED		              SJMP   BDELETE3
 1920: 1
 1921: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1922: 1			;
 1923: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1924: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1925: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1926: 1			; AANZIEN.
 1927: 1			;
 1928: 1			; De routine gebruikt de accu en de psw.
 1929: 1			;
 1930: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1931: 1
 1932: 1  05D5	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 1933: 1  05D8	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 1934: 1  05DA	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 1935: 1  05DD	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 1936: 1  05DF	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 1937: 1  05E0	22		              RET
 1938: 1  05E1	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 1939: 1  05E2	22		              RET
 1940: 1
 1941: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1942: 1			;
 1943: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 1944: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 1945: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 1946: 1			; AANGEPAST WORDEN.
 1947: 1			;
 1948: 1			; De routine gebruikt de accu en psw .
 1949: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1950: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1951: 1
 1952: 1  05E3	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 1953: 1  05E6	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 1954: 1  05E8	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 1955: 1  05EB	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 1956: 1  05ED	94 20		              SUBB   A,#020H              ;OMZETTING
 1957: 1  05EF	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 1958: 1
 1959: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1960: 1			;
 1961: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 1962: 1			; ASCII CODE.
 1963: 1			;
 1964: 1			; De routine gebruikt de accu .
 1965: 1			;
 1966: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1967: 1
 1968: 1  05F0	C0 D0		BATRANS:      PUSH   PSW
 1969: 1  05F2	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 1970: 1  05F5	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 1971: 1  05F7	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 1972: 1  05F9	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 1973: 1  05FB	D0 D0		              POP     PSW
 1974: 1  05FD	22		              RET
 1975: 1
 1976: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1977: 1			;
 1978: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 1979: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 1980: 1			; GEVAL WORDT DE CARRY GEZET.
 1981: 1			;
 1982: 1			; De routine gebruikt de accu en de psw.
 1983: 1			;
 1984: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1985: 1
 1986: 1  05FE	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 1987: 1  05FF	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 1988: 1  0601	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 1989: 1  0603	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 1990: 1  0606	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 1991: 1  0608	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 1992: 1  060A	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 1993: 1  060C	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 1994: 1  060F	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 1995: 1  0610	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 1996: 1  0612	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 1997: 1  0613	22		ASCBINTRANS1: RET
 1998: 1
 1999: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2000: 1			;
 2001: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 2002: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 2003: 1			;
 2004: 1			; De routine gebruikt de accu en de psw.
 2005: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2006: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2007: 1
 2008: 1  0614	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 2009: 1  0615	12 05 FE	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 2010: 1  0618	22		              RET                         ;EINDE OMZETTING
 2011: 1
 2012: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2013: 1			;
 2014: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 2015: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 2016: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 2017: 1			;
 2018: 1			; De routine gebruikt de accu, r0.
 2019: 1			;
 2020: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2021: 1
 2022: 1  0619	C0 F0		ASCII2:       PUSH   B
 2023: 1  061B	12 06 14	              LCALL  ASCII1               ;OMZETTEN
 2024: 1  061E	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 2025: 1  0620	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 2026: 1  0621	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 2027: 1  0623	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 2028: 1  0624	12 06 14	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 2029: 1  0627	40 02		              JC     ASCII21               ;WEG ALS C=1
 2030: 1  0629	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 2031: 1  062B	D0 F0		ASCII21:      POP     B
 2032: 1  062D	22		              RET
 2033: 1
 2034: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2035: 1			;
 2036: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2037: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2038: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2039: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2040: 1			;
 2041: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2042: 1			;
 2043: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2044: 1
 2045: 1  062E	12 06 19	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2046: 1  0631	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2047: 1  0633	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2048: 1  0635	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2049: 1  0636	12 06 19	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2050: 1  0639	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2051: 1  063B	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2052: 1  063D	22		ASCII41:      RET
 2053: 1
 2054: 1			endif        ;einde van aduc_sio
 2055: 1			;*******************************************************************************
 2056: 1
 2057: 1
 2058: 1			ifdef        aduc_math    ;rekenkundige routines
 2059: 1			;*******************************************************************************
 2060: 1			; aduc_math
 2061: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2062: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2063: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2064: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2065: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2066: 1			; zoals aangegeven:
 2067: 1			;
 2068: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2069: 1			;        ---------------------------
 2070: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2071: 1			;        ---------------------------                             statusbit = f0
 2072: 1			;        ---------------------------
 2073: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2074: 1			;        ---------------------------
 2075: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2076: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2077: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2078: 1			; return en moeten hiervoor worden gereserveerd.
 2079: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2080: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2081: 1			; en unsigned getallen.
 2082: 1			;
 2083: 1			; Beschikbare routines:
 2084: 1			;
 2085: 1			; Conversie routines:
 2086: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2087: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2088: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2089: 1			;
 2090: 1			; Som:
 2091: 1			; s_add16, add16, s_add32, add32
 2092: 1			;
 2093: 1			; Verschil:
 2094: 1			; s_sub16, sub16, s_sub32, sub32
 2095: 1			;
 2096: 1			; Vermenigvuldigen:
 2097: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2098: 1			;
 2099: 1			; Delen:
 2100: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2101: 1			;
 2102: 1			; Vemenigvuldig met factor:
 2103: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2104: 1			;
 2105: 1			; Vierkantswortel:
 2106: 1			; sqrt32, s_sqrt32
 2107: 1			;
 2108: 1			; Schuiven:
 2109: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2110: 1			;
 2111: 1			; Vergelijken:
 2112: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2113: 1			;
 2114: 1			; Tabel lookup:
 2115: 1			; table_lu
 2116: 1			;
 2117: 1			; Gonemetrische functies:

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2118: 1			; Cordic = sinus,cosinus
 2119: 1			;
 2120: 1			;*******************************************************************************
 2121: 1
 2122: 1			;*******************************************************************************
 2123: 1			;
 2124: 1			; bcdhex8     (45,77us @16.777216MHz)
 2125: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2126: 1			; naar een 2's complement hex getal.
 2127: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2128: 1			; een waarde 00h tot 63h.
 2129: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2130: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2131: 1			; input:      R0 = waarde tussen 00h en 99h.
 2132: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2133: 1			; output:     R0 = 2's complement waarde
 2134: 1			;             cy=1 bij out of range van r0
 2135: 1			;             cy=0 bij conversie ok
 2136: 1			; vernietigt: niets
 2137: 1			;*******************************************************************************
 2138: 1  063E	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2139: 1  0640	C0 D0		              push   psw
 2140: 1  0642	C0 F0		              push   b
 2141: 1
 2142: 1  0644	E8		              mov    a,r0                 ;neem te converteren waarde
 2143: 1  0645	F5 F0		              mov    b,a
 2144: 1  0647	54 0F		              anl    a,#0fh
 2145: 1  0649	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2146: 1  064C	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2147: 1  064E	E5 F0		              mov    a,b
 2148: 1  0650	54 F0		              anl    a,#0f0h
 2149: 1  0652	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2150: 1  0655	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2151: 1
 2152: 1  0657	E8		              mov    a,r0
 2153: 1  0658	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2154: 1  065A	C4		              swap   a
 2155: 1  065B	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2156: 1  065E	A4		              mul    ab
 2157: 1  065F	F5 F0		              mov    b,a                  ;bewaar dit product even
 2158: 1  0661	E8		              mov    a,r0
 2159: 1  0662	54 0F		              anl    a,#00fh
 2160: 1  0664	F8		              mov    r0,a
 2161: 1  0665	E5 F0		              mov    a,b
 2162: 1  0667	28		              add    a,r0                 ;eenheden er bijtellen
 2163: 1  0668	F8		              mov    r0,a
 2164: 1
 2165: 1  0669	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2166: 1  066B	12 07 6C	              lcall  magsig8              ;omzetten naar 2's complement
 2167: 1
 2168: 1  066E	D0 F0		              pop    b
 2169: 1  0670	D0 D0		              pop    psw
 2170: 1  0672	C2 D7		              clr    cy                   ;geen fout
 2171: 1  0674	D0 E0		              pop    acc
 2172: 1  0676	22		              ret
 2173: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2174: 1  0677	D0 F0		bcdhex82:     pop    b
 2175: 1  0679	D0 D0		              pop    psw
 2176: 1  067B	D2 D7		              setb   cy                   ;fout! r0 out of range
 2177: 1  067D	D0 E0		              pop    acc
 2178: 1  067F	22		              ret
 2179: 1
 2180: 1			;*******************************************************************************
 2181: 1			;
 2182: 1			; hexbcd8     (38,4us @16.777216MHz)
 2183: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2184: 1			; naar een 8bit bcd getal.
 2185: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2186: 1			; bcdgetal van 00h tot +99h.
 2187: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2188: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2189: 1			; bcdgetal 00h tot -99h
 2190: 1			;
 2191: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2192: 1			;
 2193: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2194: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2195: 1			;             cy=1 bij out of range van r0
 2196: 1			;             cy=0 bij conversie ok
 2197: 1			; vernietigt: niets
 2198: 1			;*******************************************************************************
 2199: 1  0680	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2200: 1  0682	C0 D0		                push    psw
 2201: 1  0684	C0 F0		                push    b
 2202: 1  0686	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2203: 1  0687	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2204: 1  068A	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2205: 1  068C	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2206: 1  068F	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2207: 1  0691	D0 F0		                pop     b
 2208: 1  0693	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2209: 1  0695	D3		                setb    c
 2210: 1  0696	D0 E0		                pop     acc
 2211: 1  0698	22		                ret
 2212: 1  0699	12 08 34	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2213: 1  069C	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2214: 1  069D	75 F0 0A	                mov     b,#10
 2215: 1  06A0	84		                div     ab
 2216: 1  06A1	C4		                swap    a
 2217: 1  06A2	25 F0		                add     a,b
 2218: 1  06A4	F8		                mov     r0,a
 2219: 1  06A5	D0 F0		                pop     b               ;registers herstellen
 2220: 1  06A7	D0 E0		                pop     acc             ;psw van stack halen
 2221: 1  06A9	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2222: 1  06AB	92 E5		                mov     acc.5,c
 2223: 1  06AD	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2224: 1  06AF	C3		                clr     c               ;status: conversie ok
 2225: 1  06B0	D0 E0		                pop     acc
 2226: 1  06B2	22		                ret
 2227: 1
 2228: 1
 2229: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2230: 1			;*******************************************************************************
 2231: 1			;
 2232: 1			; bcdhex16    (86,6us @16.777216MHz)
 2233: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2234: 1			; omzetten naar een 2's complement hex getal.
 2235: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2236: 1			; naareen waarde 0000h tot 270fh.
 2237: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2238: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2239: 1			; van -270fh).
 2240: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2241: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2242: 1			; output:     R1,R0 = 2's complement waarde
 2243: 1			;             cy=1 bij out of range van r1,r0
 2244: 1			;             cy=0 bij conversie ok
 2245: 1			; vernietigt: niets
 2246: 1			;*******************************************************************************
 2247: 1  06B3	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2248: 1  06B5	C0 D0		              push   psw
 2249: 1  06B7	C0 F0		              push   b
 2250: 1
 2251: 1  06B9	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2252: 1  06BA	F5 F0		              mov    b,a
 2253: 1  06BC	54 0F		              anl    a,#0fh
 2254: 1  06BE	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2255: 1  06C1	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2256: 1  06C3	E5 F0		              mov    a,b
 2257: 1  06C5	54 F0		              anl    a,#0f0h
 2258: 1  06C7	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2259: 1  06CA	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2260: 1  06CC	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2261: 1  06CD	F5 F0		              mov    b,a
 2262: 1  06CF	54 0F		              anl    a,#0fh
 2263: 1  06D1	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2264: 1  06D4	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2265: 1  06D6	E5 F0		              mov    a,b
 2266: 1  06D8	54 F0		              anl    a,#0f0h
 2267: 1  06DA	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2268: 1  06DD	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2269: 1
 2270: 1  06DF	E8		              mov    a,r0                  ;neem low byte voor conversie
 2271: 1  06E0	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2272: 1  06E2	C0 E0		              push   acc                   ;en even bewaren
 2273: 1
 2274: 1  06E4	E8		              mov    a,r0
 2275: 1  06E5	C4		              swap   a
 2276: 1  06E6	54 0F		              anl    a,#00fh              ;tientallen
 2277: 1  06E8	75 F0 0A	              mov    b,#00ah              ;maal tien
 2278: 1  06EB	A4		              mul    ab                   ;
 2279: 1  06EC	D0 F0		              pop    b                    ;neem eenheden
 2280: 1  06EE	25 F0		              add    a,b                  ;tel bij tientallen
 2281: 1  06F0	C0 E0		              push   acc                  ;weer bewaren
 2282: 1
 2283: 1  06F2	E9		              mov    a,r1                 ;neem high byte voor conversie
 2284: 1  06F3	54 F0		              anl    a,#0f0h
 2285: 1  06F5	C4		              swap   a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2286: 1  06F6	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2287: 1
 2288: 1  06F8	E9		              mov    a,r1                  ;neem high byte voor conversie
 2289: 1  06F9	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2290: 1  06FB	75 F0 64	              mov    b,#100d              ;en maal honderd
 2291: 1  06FE	A4		              mul    ab
 2292: 1  06FF	A9 F0		              mov    r1,b
 2293: 1  0701	F8		              mov    r0,a
 2294: 1
 2295: 1  0702	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2296: 1  0704	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2297: 1  0707	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2298: 1  0708	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2299: 1  070B	A4		              mul    ab
 2300: 1  070C	28		              add    a,r0                 ;tel honderdtallen bij de
 2301: 1  070D	F8		              mov    r0,a                 ;duizendtallen
 2302: 1  070E	E9		              mov    a,r1
 2303: 1  070F	35 F0		              addc   a,b
 2304: 1  0711	F9		              mov    r1,a
 2305: 1
 2306: 1  0712	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2307: 1  0714	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2308: 1  0715	F8		              mov    r0,a                 ;duizendtallen
 2309: 1  0716	74 00		              mov    a,#000h
 2310: 1  0718	39		              addc   a,r1
 2311: 1  0719	F9		              mov    r1,a                 ;omzetting klaar
 2312: 1
 2313: 1  071A	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2314: 1  071C	12 07 A0	              lcall  magsig16             ;omzetten naar 2's complement
 2315: 1
 2316: 1  071F	D0 F0		              pop    b
 2317: 1  0721	D0 D0		              pop    psw
 2318: 1  0723	C2 D7		              clr    cy                   ;geen fout
 2319: 1  0725	D0 E0		              pop    acc
 2320: 1  0727	22		              ret
 2321: 1
 2322: 1  0728	D0 F0		bcdhex162:    pop    b
 2323: 1  072A	D0 D0		              pop    psw
 2324: 1  072C	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2325: 1  072E	D0 E0		              pop    acc
 2326: 1  0730	22		              ret
 2327: 1
 2328: 1			;*******************************************************************************
 2329: 1			;
 2330: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2331: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2332: 1			; naar een 24bit bcd getal.
 2333: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2334: 1			; bcdgetal van 000000h tot +032767h.
 2335: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2336: 1			; naar een bcdgetal 000000h tot -032768h
 2337: 1			;
 2338: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2339: 1			;
 2340: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2341: 1			;              F0 = tekenbit, 1=negatief, 0=positief.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2342: 1			;
 2343: 1			; vernietigt: niets
 2344: 1			;*******************************************************************************
 2345: 1			;
 2346: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2347: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2348: 1			; naar een 24bit bcd getal.
 2349: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2350: 1			; bcdgetal van 000000h tot 065535h.
 2351: 1			;
 2352: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2353: 1			;
 2354: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2355: 1			;
 2356: 1			; vernietigt: niets
 2357: 1			;*******************************************************************************
 2358: 1  0731	12 08 66	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2359: 1  0734	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2360: 1  0736	C0 D0		                push   psw
 2361: 1  0738	C0 F0		                push   b
 2362: 1  073A	C0 82		                push   dpl
 2363: 1
 2364: 1  073C	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2365: 1  073F	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2366: 1  0741	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2367: 1  0743	12 0C 15	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2368: 1  0746	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2369: 1  0747	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2370: 1			                                        ;dus eerst eenheden, dan tientallen
 2371: 1			                                        ;honderdtallen, duizendtallen en
 2372: 1			                                        ;tienduizendtallen
 2373: 1  0749	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2374: 1
 2375: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2376: 1
 2377: 1  074C	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2378: 1  074E	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2379: 1  074F	D0 E0		                pop    acc              ;duizendtallen ophalen
 2380: 1  0751	C4		                swap   a                ;en combineren met de
 2381: 1  0752	F5 82		                mov    dpl,a
 2382: 1  0754	D0 E0		                pop    acc              ;honderdtallen van de stack
 2383: 1  0756	25 82		                add    a,dpl
 2384: 1  0758	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2385: 1  0759	D0 E0		                pop    acc              ;tientallen van de stack halen
 2386: 1  075B	C4		                swap   a
 2387: 1  075C	F5 82		                mov    dpl,a
 2388: 1  075E	D0 E0		                pop    acc              ;en combineren met de eenheden
 2389: 1  0760	25 82		                add    a,dpl
 2390: 1  0762	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2391: 1
 2392: 1  0763	D0 82		                pop    dpl              ;registers herstellen
 2393: 1  0765	D0 F0		                pop    b
 2394: 1  0767	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2395: 1  0769	D0 E0		                pop    acc
 2396: 1  076B	22		                ret
 2397: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2398: 1			;*******************************************************************************
 2399: 1			; magsig8        (13,6us @16.777216MHz)
 2400: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2401: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2402: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2403: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2404: 1			;           (f0 en f1 zijn 1 als negatief)
 2405: 1			;
 2406: 1			; output:   r0 = 2's complement
 2407: 1			;
 2408: 1			; vernietigt: niets
 2409: 1			;*******************************************************************************
 2410: 1
 2411: 1  076C	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2412: 1  076E	C0 D0		               push   psw
 2413: 1  0770	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2414: 1  0773	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2415: 1  0776	80 09		               sjmp   magsig8c
 2416: 1
 2417: 1  0778	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2418: 1  077B	80 04		               sjmp   magsig8c
 2419: 1
 2420: 1  077D	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2421: 1  077E	F4		               cpl    a                  ;complementeer abs waarde
 2422: 1  077F	04		               inc    a                  ;r0 = complement(r0)+1
 2423: 1  0780	F8		               mov    r0,a               ;bewaar in 2's complement
 2424: 1  0781	D0 D0		magsig8c:      pop    psw
 2425: 1  0783	D0 E0		               pop    acc
 2426: 1  0785	22		               ret                        ;klaar
 2427: 1
 2428: 1			;*******************************************************************************
 2429: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2430: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2431: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2432: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2433: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2434: 1			;           (f0 en f1 zijn 1 als negatief)
 2435: 1			;
 2436: 1			; output:   r4 = 2's complement
 2437: 1			;
 2438: 1			; vernietigt: niets
 2439: 1			;*******************************************************************************
 2440: 1
 2441: 1  0786	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2442: 1  0788	C0 D0		               push    psw
 2443: 1  078A	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2444: 1  078D	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2445: 1  0790	80 EF		               sjmp    magsig8c
 2446: 1
 2447: 1  0792	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2448: 1  0795	80 04		               sjmp    magsig8acc1c
 2449: 1
 2450: 1  0797	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2451: 1  0798	F4		               cpl     a                 ;complementeer abs waarde
 2452: 1  0799	04		               inc     a                 ;r4 = complement(r0)+1
 2453: 1  079A	FC		               mov     r4,a              ;bewaar in 2's complement

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2454: 1  079B	D0 D0		magsig8acc1c:  pop     psw
 2455: 1  079D	D0 E0		               pop     acc
 2456: 1  079F	22		               ret                       ;klaar
 2457: 1
 2458: 1			;*******************************************************************************
 2459: 1			; magsig16        (16,6us @16.777216MHz)
 2460: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2461: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2462: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2463: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2464: 1			;           (f0 en f1 zijn 1 als negatief)
 2465: 1			;
 2466: 1			; output:   r1,r0 = 2's complement
 2467: 1			;
 2468: 1			; vernietigt: niets
 2469: 1			;*******************************************************************************
 2470: 1  07A0	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2471: 1  07A2	C0 D0		               push    psw
 2472: 1  07A4	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2473: 1  07A7	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2474: 1  07AA	80 0F		               sjmp    magsig16c
 2475: 1
 2476: 1  07AC	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2477: 1  07AF	80 0A		               sjmp    magsig16c
 2478: 1
 2479: 1  07B1	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2480: 1  07B2	F4		               cpl     a                ;complementeer het dan
 2481: 1  07B3	24 01		               add     a, #1            ;en tel er 1 bij
 2482: 1  07B5	F8		               mov     r0,a
 2483: 1  07B6	E9		               mov     a,r1             ;neem volgende byte
 2484: 1  07B7	F4		               cpl     a                ;complementeer en tel carry erbij
 2485: 1  07B8	34 00		               addc    a,#0
 2486: 1  07BA	F9		               mov     r1,a
 2487: 1  07BB	D0 D0		magsig16c:     pop     psw
 2488: 1  07BD	D0 E0		               pop     acc
 2489: 1  07BF	22		               ret
 2490: 1
 2491: 1			;*******************************************************************************
 2492: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2493: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2494: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2495: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2496: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2497: 1			;           (f0 en f1 zijn 1 als negatief)
 2498: 1			;
 2499: 1			; output:   r5,r4 = 2's complement
 2500: 1			;
 2501: 1			; vernietigt: niets
 2502: 1			;*******************************************************************************
 2503: 1  07C0	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2504: 1  07C2	C0 D0		                push    psw
 2505: 1  07C4	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2506: 1  07C7	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2507: 1  07CA	80 0F		                sjmp    magsig16acc1c
 2508: 1
 2509: 1  07CC	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2510: 1  07CF	80 0A		                sjmp    magsig16acc1c
 2511: 1
 2512: 1  07D1	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2513: 1  07D2	F4		                cpl     a                   ;complementeer het dan
 2514: 1  07D3	24 01		                add     a,#1                ;en tel er 1 bij
 2515: 1  07D5	FC		                mov     r4,a
 2516: 1  07D6	ED		                mov     a,r5                ;neem volgende byte
 2517: 1  07D7	F4		                cpl     a                   ;complementeer en tel carry erbij
 2518: 1  07D8	34 00		                addc    a,#0
 2519: 1  07DA	FD		                mov     r5,a
 2520: 1  07DB	D0 D0		magsig16acc1c:  pop     psw
 2521: 1  07DD	D0 E0		                pop     acc
 2522: 1  07DF	22		                ret
 2523: 1
 2524: 1			;*******************************************************************************
 2525: 1			; magsig32        (22,2us @16.777216MHz)
 2526: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2527: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2528: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2529: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2530: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2531: 1			;           (f0 en f1 zijn 1 als negatief)
 2532: 1			;
 2533: 1			; output:   r3,r2,r1,r0 = 2's complement
 2534: 1			;
 2535: 1			; vernietigt: niets
 2536: 1			;*******************************************************************************
 2537: 1  07E0	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2538: 1  07E2	C0 D0		               push    psw
 2539: 1  07E4	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2540: 1  07E7	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2541: 1  07EA	80 19		               sjmp    magsig32c
 2542: 1
 2543: 1  07EC	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2544: 1  07EF	80 14		               sjmp    magsig32c
 2545: 1
 2546: 1  07F1	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2547: 1  07F2	F4		               cpl     a                 ;complementeer het dan
 2548: 1  07F3	24 01		               add     a,#1             ;en tel er 1 bij
 2549: 1  07F5	F8		               mov     r0,a
 2550: 1  07F6	E9		               mov     a,r1             ;neem volgende byte
 2551: 1  07F7	F4		               cpl     a                 ;complementeer en tel carry erbij
 2552: 1  07F8	34 00		               addc    a,#0
 2553: 1  07FA	F9		               mov     r1,a
 2554: 1  07FB	EA		               mov     a,r2            ;neem volgende byte
 2555: 1  07FC	F4		               cpl     a                ;complementeer en tel carry erbij
 2556: 1  07FD	34 00		               addc    a,#0
 2557: 1  07FF	FA		               mov     r2,a
 2558: 1  0800	EB		               mov     a,r3            ;neem volgende byte
 2559: 1  0801	F4		               cpl     a                ;complementeer en tel carry erbij
 2560: 1  0802	34 00		               addc    a,#0
 2561: 1  0804	FB		               mov     r3,a
 2562: 1
 2563: 1  0805	D0 D0		magsig32c:     pop     psw
 2564: 1  0807	D0 E0		               pop     acc
 2565: 1  0809	22		               ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2566: 1
 2567: 1
 2568: 1
 2569: 1			;*******************************************************************************
 2570: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2571: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2572: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2573: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2574: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2575: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2576: 1			;           (f0 en f1 zijn 1 als negatief)
 2577: 1			;
 2578: 1			; output:   r7,r6,r5,r4 = 2's complement
 2579: 1			;
 2580: 1			; vernietigt: niets
 2581: 1			;*******************************************************************************
 2582: 1  080A	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2583: 1  080C	C0 D0		               push    psw
 2584: 1  080E	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2585: 1  0811	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2586: 1  0814	80 19		               sjmp    magsig32acc1c
 2587: 1
 2588: 1  0816	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2589: 1  0819	80 14		               sjmp    magsig32acc1c
 2590: 1
 2591: 1  081B	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2592: 1  081C	F4		               cpl     a                 ;complementeer het dan
 2593: 1  081D	24 01		               add     a,#1             ;en tel er 1 bij
 2594: 1  081F	FC		               mov     r4,a
 2595: 1  0820	ED		               mov     a,r5             ;neem volgende byte
 2596: 1  0821	F4		               cpl     a                 ;complementeer en tel carry erbij
 2597: 1  0822	34 00		               addc    a,#0
 2598: 1  0824	FD		               mov     r5,a
 2599: 1  0825	EE		               mov     a,r6             ;neem volgende byte
 2600: 1  0826	F4		               cpl     a                 ;complementeer en tel carry erbij
 2601: 1  0827	34 00		               addc    a,#0
 2602: 1  0829	FE		               mov     r6,a
 2603: 1  082A	EF		               mov     a,r7             ;neem volgende byte
 2604: 1  082B	F4		               cpl     a                ;complementeer en tel carry erbij
 2605: 1  082C	34 00		               addc    a,#0
 2606: 1  082E	FF		               mov     r7,a
 2607: 1
 2608: 1  082F	D0 D0		magsig32acc1c: pop     psw
 2609: 1  0831	D0 E0		               pop     acc
 2610: 1  0833	22		               ret
 2611: 1
 2612: 1
 2613: 1			;*******************************************************************************
 2614: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2615: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2616: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2617: 1			; input:     r0 = 2's complement byte in acc0
 2618: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2619: 1			; output:    r0 = absolute waarde
 2620: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2621: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2622: 1			; vernietigt: niets
 2623: 1			;*******************************************************************************
 2624: 1
 2625: 1  0834	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2626: 1  0836	C0 D0		                push    psw
 2627: 1  0838	E8		                mov     a,r0               ;neem lsb van acc0
 2628: 1  0839	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2629: 1  083C	D0 D0		                pop     psw
 2630: 1  083E	C2 D5		                clr     f0                 ;nee, positief...klaar
 2631: 1  0840	D0 E0		                pop     acc
 2632: 1  0842	22		                ret
 2633: 1  0843	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2634: 1  0844	04		                inc     a                   ;een erbij
 2635: 1  0845	F8		                mov     r0,a               ;bewaar
 2636: 1  0846	D0 D0		                pop     psw
 2637: 1  0848	D2 D5		                setb    f0                 ;f0=1 als negatief
 2638: 1  084A	D0 E0		                pop     acc
 2639: 1  084C	22		                ret
 2640: 1
 2641: 1			;*******************************************************************************
 2642: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2643: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2644: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2645: 1			; input:     r4 = 2's complement byte in acc1
 2646: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2647: 1			; output:    r4 = absolute waarde
 2648: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2649: 1			;
 2650: 1			; vernietigt: niets
 2651: 1			;*******************************************************************************
 2652: 1
 2653: 1  084D	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2654: 1  084F	C0 D0		                push    psw
 2655: 1  0851	EC		                mov     a,r4               ;neem lsb van acc0
 2656: 1  0852	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2657: 1  0855	D0 D0		                pop     psw
 2658: 1  0857	C2 D1		                clr     f1                 ;nee, positief...klaar
 2659: 1  0859	D0 E0		                pop     acc
 2660: 1  085B	22		                ret
 2661: 1  085C	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2662: 1  085D	04		                inc     a                   ;een erbij
 2663: 1  085E	FC		                mov     r4,a               ;bewaar
 2664: 1  085F	D0 D0		                pop     psw
 2665: 1  0861	D2 D1		                setb    f1                 ;f0=1 als negatief
 2666: 1  0863	D0 E0		                pop     acc
 2667: 1  0865	22		                ret
 2668: 1
 2669: 1			;*******************************************************************************
 2670: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2671: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2672: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2673: 1			; input:     r1,r0 = 2's complement word in acc0
 2674: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2675: 1			; output:    r1,r0 = absolute waarde
 2676: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2677: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2678: 1			; vernietigt: niets
 2679: 1			;*******************************************************************************
 2680: 1
 2681: 1  0866	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2682: 1  0868	C0 D0		                push    psw
 2683: 1  086A	E9		                mov     a,r1               ; neem msb van acc0
 2684: 1  086B	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2685: 1  086E	D0 D0		                pop     psw
 2686: 1  0870	C2 D5		                clr     f0                 ;f0=0 als positief
 2687: 1  0872	D0 E0		                pop     acc
 2688: 1  0874	22		                ret                        ;klaar
 2689: 1
 2690: 1  0875	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2691: 1  0876	F4		                cpl     a                  ;complementeren
 2692: 1  0877	24 01		                add     a,#1               ;en een bijtellen
 2693: 1  0879	F8		                mov     r0,a
 2694: 1  087A	E9		                mov     a,r1
 2695: 1  087B	F4		                cpl     a                  ;complement eer volgende byte
 2696: 1  087C	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2697: 1  087E	F9		                mov     r1,a
 2698: 1  087F	D0 D0		                pop     psw
 2699: 1  0881	D2 D5		                setb    f0                 ;f0=1 als negatief
 2700: 1  0883	D0 E0		                pop     acc
 2701: 1  0885	22		                ret
 2702: 1
 2703: 1
 2704: 1			;*******************************************************************************
 2705: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2706: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2707: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2708: 1			; input:     r5,r4 = 2's complement word in acc1
 2709: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2710: 1			; output:    r5,r4 = absolute waarde
 2711: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2712: 1			;
 2713: 1			; vernietigt: niets
 2714: 1			;*******************************************************************************
 2715: 1
 2716: 1  0886	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2717: 1  0888	C0 D0		                push    psw
 2718: 1  088A	ED		                mov     a,r5               ;neem msb van acc1
 2719: 1  088B	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2720: 1  088E	D0 D0		                pop     psw
 2721: 1  0890	C2 D1		                clr     f1                 ;f1=0 als positief
 2722: 1  0892	D0 E0		                pop    acc
 2723: 1  0894	22		                ret                        ;klaar
 2724: 1
 2725: 1  0895	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2726: 1  0896	F4		                cpl     a                   ;complementeren
 2727: 1  0897	24 01		                add     a,#1               ;en een bijtellen
 2728: 1  0899	FC		                mov     r4,a
 2729: 1  089A	ED		                mov     a,r5
 2730: 1  089B	F4		                cpl     a                  ;complementeer volgende byte
 2731: 1  089C	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2732: 1  089E	FD		                mov     r5,a
 2733: 1  089F	D0 D0		                pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2734: 1  08A1	D2 D1		                setb    f1                ;f1=1 als negatief
 2735: 1  08A3	D0 E0		                pop     acc
 2736: 1  08A5	22		                ret
 2737: 1
 2738: 1
 2739: 1			;*******************************************************************************
 2740: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2741: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2742: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2743: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2744: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2745: 1			; output:    r7,r6 = absolute waarde
 2746: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2747: 1			;
 2748: 1			; vernietigt: niets
 2749: 1			;*******************************************************************************
 2750: 1
 2751: 1  08A6	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2752: 1  08A8	C0 D0		                push    psw
 2753: 1  08AA	EF		                mov     a,r7                ; neem msb van acc1 high
 2754: 1  08AB	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2755: 1  08AE	D0 D0		                pop     psw
 2756: 1  08B0	C2 D5		                clr     f0                  ;f0=0 als positief
 2757: 1  08B2	D0 E0		                pop     acc
 2758: 1  08B4	22		                ret                         ;klaar
 2759: 1
 2760: 1  08B5	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2761: 1  08B6	F4		                cpl     a                   ;complementeren
 2762: 1  08B7	24 01		                add     a,#1               ;en een bijtellen
 2763: 1  08B9	FE		                mov     r6,a
 2764: 1  08BA	EF		                mov     a,r7
 2765: 1  08BB	F4		                cpl     a                  ;complementeer volgende byte
 2766: 1  08BC	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2767: 1  08BE	FF		                mov     r7,a
 2768: 1  08BF	D0 D0		                pop     psw
 2769: 1  08C1	D2 D5		                setb    f0                ;f0=1 als negatief
 2770: 1  08C3	D0 E0		                pop     acc
 2771: 1  08C5	22		                ret
 2772: 1
 2773: 1
 2774: 1			;*******************************************************************************
 2775: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2776: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2777: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 2778: 1			;
 2779: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2780: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2781: 1			;            (-2147483648 tot +2147483647)
 2782: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2783: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2784: 1			;
 2785: 1			; vernietigt: niets
 2786: 1			;*******************************************************************************
 2787: 1
 2788: 1  08C6	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2789: 1  08C8	C0 D0		                push    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2790: 1  08CA	EB		                mov     a,r3               ;neem msb van acc0
 2791: 1  08CB	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2792: 1  08CE	D0 D0		                pop     psw                ;nee, positief
 2793: 1  08D0	C2 D5		                clr     f0
 2794: 1  08D2	D0 E0		                pop     acc
 2795: 1  08D4	22		                ret                        ;klaar
 2796: 1
 2797: 1  08D5	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2798: 1  08D6	F4		                cpl     a                  ;complementeren
 2799: 1  08D7	24 01		                add     a,#1               ;en een bijtellen
 2800: 1  08D9	F8		                mov     r0,a
 2801: 1  08DA	E9		                mov     a,r1               ;neem volgende byte
 2802: 1  08DB	F4		                cpl     a                  ;complementeer volgende byte
 2803: 1  08DC	34 00		                addc    a,#0
 2804: 1  08DE	F9		                mov     r1,a
 2805: 1  08DF	EA		                mov     a,r2               ;neem volgende byte
 2806: 1  08E0	F4		                cpl     a                  ;complementeer volgende byte
 2807: 1  08E1	34 00		                addc    a,#0
 2808: 1  08E3	FA		                mov     r2,a
 2809: 1  08E4	EB		                mov     a,r3               ;neem volgende byte
 2810: 1  08E5	F4		                cpl     a                  ;complementeer volgende byte
 2811: 1  08E6	34 00		                addc    a,#0
 2812: 1  08E8	FB		                mov     r3,a
 2813: 1  08E9	D0 D0		                pop     psw
 2814: 1  08EB	D2 D5		                setb    f0                 ;negatief: f0=1
 2815: 1  08ED	D0 E0		                pop     acc
 2816: 1  08EF	22		                ret                        ;klaar
 2817: 1
 2818: 1			;*******************************************************************************
 2819: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2820: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2821: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2822: 1			;
 2823: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2824: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2825: 1			;            (-2147483648 tot +2147483647)
 2826: 1			; output:    r7,r6,r5,r4 = absolute waarde
 2827: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2828: 1			;
 2829: 1			; vernietigt: niets
 2830: 1			;*******************************************************************************
 2831: 1
 2832: 1  08F0	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2833: 1  08F2	C0 D0		                push    psw
 2834: 1  08F4	EF		                mov     a,r7               ;neem msb van acc0
 2835: 1  08F5	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2836: 1  08F8	D0 D0		                pop     psw                ;nee, positief
 2837: 1  08FA	C2 D1		                clr     f1
 2838: 1  08FC	D0 E0		                pop     acc
 2839: 1  08FE	22		                ret                        ;klaar
 2840: 1
 2841: 1  08FF	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2842: 1  0900	F4		                cpl     a                   ;complementeren
 2843: 1  0901	24 01		                add     a,#1               ;en een bijtellen
 2844: 1  0903	FC		                mov     r4,a
 2845: 1  0904	ED		                mov     a,r5               ;neem volgende byte

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2846: 1  0905	F4		                cpl     a                  ;complementeer volgende byte
 2847: 1  0906	34 00		                addc    a,#0
 2848: 1  0908	FD		                mov     r5,a
 2849: 1  0909	EE		                mov     a,r6               ;neem volgende byte
 2850: 1  090A	F4		                cpl     a                  ;complementeer volgende byte
 2851: 1  090B	34 00		                addc    a,#0
 2852: 1  090D	FE		                mov     r6,a
 2853: 1  090E	EF		                mov     a,r7               ;neem volgende byte
 2854: 1  090F	F4		                cpl     a                  ;complementeer volgende byte
 2855: 1  0910	34 00		                addc    a,#0
 2856: 1  0912	FF		                mov     r7,a
 2857: 1  0913	D0 D0		                pop     psw
 2858: 1  0915	D2 D1		                setb    f1                 ;negatief: f0=1
 2859: 1  0917	D0 E0		                pop     acc
 2860: 1  0919	22		                ret                        ;klaar
 2861: 1
 2862: 1
 2863: 1			;*******************************************************************************
 2864: 1			; s_add16        (19,35us @16.777216MHz)
 2865: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2866: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2867: 1			; input:     r1,r0 = acc0
 2868: 1			;            r5,r4 = acc1
 2869: 1			;
 2870: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2871: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2872: 1			;                  gebruik van r3,r2 is niet nodig
 2873: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2874: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2875: 1			;
 2876: 1			; vernietigt:  niets
 2877: 1			;*******************************************************************************
 2878: 1  091A	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2879: 1  091C	C0 D0		               push    psw
 2880: 1
 2881: 1  091E	E8		               mov     a,r0           ;tel de soft accumulators op
 2882: 1  091F	2C		               add     a,r4           ;low byte eerst
 2883: 1  0920	F8		               mov     r0,a           ;resultaat bewaren
 2884: 1  0921	E9		               mov     a,r1           ;nu de high bytes
 2885: 1  0922	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2886: 1  0923	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2887: 1
 2888: 1  0924	92 D5		               mov     f0,c
 2889: 1  0926	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 2890: 1  0928	92 D1		               mov     f1,c
 2891: 1  092A	A2 D5		               mov     c,f0           ;herstel carrybit
 2892: 1
 2893: 1  092C	74 00		               mov     a,#00h
 2894: 1  092E	34 00		               addc    a,#00h
 2895: 1  0930	FA		               mov     r2,a            ;24bit resultaat klaar
 2896: 1
 2897: 1  0931	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2898: 1
 2899: 1  0934	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2900: 1  0935	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2901: 1  0938	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2902: 1  093A	7B FF		               mov     r3,#0ffh
 2903: 1  093C	80 04		               sjmp    s_add162
 2904: 1  093E	7A 00		s_add161:      mov     r2,#00h
 2905: 1  0940	7B 00		               mov     r3,#00h
 2906: 1  0942	D0 D0		s_add162:      pop     psw
 2907: 1  0944	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2908: 1  0945	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2909: 1  0947	22		               ret
 2910: 1
 2911: 1  0948	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2912: 1  094A	C3		               clr     c
 2913: 1  094B	D0 E0		               pop     acc
 2914: 1  094D	22		               ret
 2915: 1
 2916: 1			;*******************************************************************************
 2917: 1			; add16        (13,6us @16.777216MHz)
 2918: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2919: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2920: 1			; input:     r1,r0 = acc0
 2921: 1			;            r5,r4 = acc1
 2922: 1			;
 2923: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2924: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 2925: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2926: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 2927: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 2928: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 2929: 1			;
 2930: 1			; vernietigt:  niets
 2931: 1			;*******************************************************************************
 2932: 1
 2933: 1  094E	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 2934: 1  0950	C0 D0		               push    psw
 2935: 1  0952	E8		               mov     a,r0           ;tel de soft accumulators op
 2936: 1  0953	2C		               add     a,r4           ;low byte eerst
 2937: 1  0954	F8		               mov     r0,a           ;resultaat bewaren
 2938: 1  0955	E9		               mov     a,r1           ;nu de high bytes
 2939: 1  0956	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2940: 1  0957	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2941: 1  0958	50 08		               jnc     add161          ;geen 24 bit resultaat
 2942: 1
 2943: 1  095A	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 2944: 1  095C	D0 D0		               pop     psw
 2945: 1  095E	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2946: 1  095F	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 2947: 1  0961	22		               ret
 2948: 1
 2949: 1  0962	7A 00		add161:        mov     r2,#00h
 2950: 1  0964	D0 D0		               pop     psw
 2951: 1  0966	C3		               clr     c               ;aangeven aan de gebruiker dat het
 2952: 1  0967	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 2953: 1  0969	22		               ret
 2954: 1
 2955: 1			;*******************************************************************************
 2956: 1			; s_add32        (28,0us @16.777216MHz)
 2957: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2958: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 2959: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2960: 1			; input:     r3,r2,r1,r0 = acc0
 2961: 1			;            r7,r6,r5,r4 = acc1
 2962: 1			;
 2963: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2964: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2965: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 2966: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 2967: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 2968: 1			;
 2969: 1			; vernietigt:  niets
 2970: 1			;*******************************************************************************
 2971: 1  096A	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 2972: 1  096C	C0 D0		               push    psw
 2973: 1
 2974: 1  096E	E8		               mov     a,r0           ;tel de soft accumulators op
 2975: 1  096F	2C		               add     a,r4           ;low byte eerst
 2976: 1  0970	F8		               mov     r0,a           ;resultaat bewaren
 2977: 1  0971	E9		               mov     a,r1           ;nu de hogere bytes
 2978: 1  0972	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2979: 1  0973	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2980: 1
 2981: 1  0974	EA		               mov     a,r2           ;derde bytes optellen
 2982: 1  0975	3E		               addc    a,r6           ;optellen met eventuele overdracht
 2983: 1  0976	FA		               mov     r2,a           ;24bit resultaat is klaar
 2984: 1  0977	EB		               mov     a,r3           ;nu de ms bytes
 2985: 1  0978	3F		               addc    a,r7           ;optellen met eventuele overdracht
 2986: 1  0979	FB		               mov     r3,a           ;32 bit resultaat is klaar
 2987: 1
 2988: 1  097A	92 D5		               mov     f0,c
 2989: 1  097C	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 2990: 1  097E	92 D1		               mov     f1,c
 2991: 1  0980	A2 D5		               mov     c,f0           ;herstel carrybit
 2992: 1
 2993: 1  0982	74 00		               mov     a,#00h
 2994: 1  0984	34 00		               addc    a,#00h
 2995: 1  0986	FC		               mov     r4,a            ;40bit resultaat klaar
 2996: 1
 2997: 1  0987	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 2998: 1  098A	EC		               mov     a,r4            ;ja, sign extention toepassen!
 2999: 1  098B	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 3000: 1  098E	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3001: 1  0990	80 02		               sjmp    s_add322
 3002: 1  0992	7C 00		s_add321:      mov     r4,#00h
 3003: 1  0994	D0 D0		s_add322:      pop     psw
 3004: 1  0996	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3005: 1  0997	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 3006: 1  0999	22		               ret
 3007: 1
 3008: 1  099A	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 3009: 1  099C	C3		               clr     c
 3010: 1  099D	D0 E0		               pop     acc
 3011: 1  099F	22		               ret
 3012: 1
 3013: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3014: 1			;*******************************************************************************
 3015: 1			; add32        (18,0us @16.777216MHz)
 3016: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 3017: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3018: 1			; input:     r3,r2,r1,r0 = acc0
 3019: 1			;            r7,r6,r5,r4 = acc1
 3020: 1			;
 3021: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 3022: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3023: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3024: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 3025: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3026: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3027: 1			;
 3028: 1			; vernietigt:  niets
 3029: 1			;*******************************************************************************
 3030: 1  09A0	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 3031: 1  09A2	C0 D0		               push    psw
 3032: 1  09A4	E8		               mov     a,r0           ;tel de soft accumulators op
 3033: 1  09A5	2C		               add     a,r4           ;low byte eerst
 3034: 1  09A6	F8		               mov     r0,a           ;resultaat bewaren
 3035: 1  09A7	E9		               mov     a,r1           ;nu de hogere bytes
 3036: 1  09A8	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3037: 1  09A9	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3038: 1
 3039: 1  09AA	EA		               mov     a,r2           ;derde bytes optellen
 3040: 1  09AB	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3041: 1  09AC	FA		               mov     r2,a           ;24bit resultaat is klaar
 3042: 1  09AD	EB		               mov     a,r3           ;nu de ms bytes
 3043: 1  09AE	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3044: 1  09AF	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3045: 1
 3046: 1  09B0	50 08		               jnc     add321          ;geen 40 bit resultaat
 3047: 1
 3048: 1  09B2	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3049: 1  09B4	D0 D0		               pop     psw
 3050: 1  09B6	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3051: 1  09B7	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3052: 1  09B9	22		               ret
 3053: 1
 3054: 1  09BA	7C 00		add321:        mov     r4,#00h
 3055: 1  09BC	D0 D0		               pop     psw
 3056: 1  09BE	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3057: 1  09BF	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3058: 1  09C1	22		               ret
 3059: 1
 3060: 1
 3061: 1			;*******************************************************************************
 3062: 1			; s_sub16        (24,4us @16.777216MHz)
 3063: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3064: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3065: 1			; input:     r1,r0 = acc0
 3066: 1			;            r5,r4 = acc1
 3067: 1			;
 3068: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3069: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3070: 1			;                  gebruik van r3,r2 is niet nodig
 3071: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3072: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3073: 1			;
 3074: 1			; vernietigt:  niets
 3075: 1			;*******************************************************************************
 3076: 1  09C2	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3077: 1  09C4	C0 D0		                push    psw
 3078: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3079: 1
 3080: 1  09C6	EC		                mov   	a,r4            ;verander het teken van acc1
 3081: 1  09C7	F4		                cpl    	a               ;door het 2's complement te nemen
 3082: 1  09C8	24 01		                add   	a,#1
 3083: 1  09CA	FC		                mov    	r4,a
 3084: 1  09CB	ED		                mov    	a,r5
 3085: 1  09CC	F4		                cpl    	a
 3086: 1  09CD	34 00		                addc	a,#0
 3087: 1  09CF	FD		                mov    	r5,a
 3088: 1			;acc0+acc1
 3089: 1  09D0	E8						mov		a,r0
 3090: 1  09D1	2C						add		a,r4
 3091: 1  09D2	F8						mov		r0,a
 3092: 1  09D3	E9						mov		a,r1
 3093: 1  09D4	3D						addc	a,r5
 3094: 1  09D5	F9						mov		r1,a
 3095: 1
 3096: 1  09D6	92 D5		                mov    f0,c
 3097: 1  09D8	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3098: 1  09DA	92 D1		                mov    f1,c
 3099: 1  09DC	A2 D5		                mov    c,f0            ;herstel carrybit
 3100: 1
 3101: 1  09DE	74 00		                mov    a,#00h
 3102: 1  09E0	34 00		                addc   a,#00h
 3103: 1  09E2	FA		                mov    r2,a            ;24bit resultaat klaar
 3104: 1
 3105: 1  09E3	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3106: 1  09E6	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3107: 1  09E7	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3108: 1  09EA	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3109: 1  09EC	7B FF		                mov    r3,#0ffh
 3110: 1  09EE	80 04		                sjmp   s_sub162
 3111: 1  09F0	7A 00		s_sub161:       mov    r2,#00h
 3112: 1  09F2	7B 00		                mov    r3,#00h
 3113: 1  09F4	D0 D0		s_sub162:       pop    psw
 3114: 1  09F6	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3115: 1  09F7	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3116: 1  09F9	22		                ret
 3117: 1
 3118: 1  09FA	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3119: 1  09FC	C3		                clr    c
 3120: 1  09FD	D0 E0		                pop    acc
 3121: 1  09FF	22		                ret
 3122: 1
 3123: 1			;*******************************************************************************
 3124: 1			; sub16            (14,4us @16.777216MHz)
 3125: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3126: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3127: 1			; input:     r1,r0 = acc0
 3128: 1			;            r5,r4 = acc1
 3129: 1			;
 3130: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3131: 1			;            bij een underflow r2 op ffh zetten
 3132: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3133: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3134: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3135: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3136: 1			;
 3137: 1			; vernietigt:  niets
 3138: 1			;*******************************************************************************
 3139: 1
 3140: 1  0A00	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3141: 1  0A02	C0 D0		                push    psw
 3142: 1  0A04	C3		                clr     c
 3143: 1  0A05	E8		                mov     a,r0            ;tel de soft accumulators op
 3144: 1  0A06	9C		                subb    a,r4            ;low byte eerst
 3145: 1  0A07	F8		                mov     r0,a            ;resultaat bewaren
 3146: 1  0A08	E9		                mov     a,r1            ;nu de high bytes
 3147: 1  0A09	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3148: 1  0A0A	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3149: 1  0A0B	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3150: 1
 3151: 1  0A0D	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3152: 1  0A0F	D0 D0		                pop     psw
 3153: 1  0A11	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3154: 1  0A12	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3155: 1  0A14	22		                ret
 3156: 1
 3157: 1  0A15	7A 00		sub161:         mov     r2,#00h
 3158: 1  0A17	D0 D0		                pop     psw
 3159: 1  0A19	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3160: 1  0A1A	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3161: 1  0A1C	22		                ret
 3162: 1
 3163: 1			;*******************************************************************************
 3164: 1			; s_sub32        (27,2us @16.777216MHz)
 3165: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3166: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3167: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3168: 1			; input:     r3,r2,r1,r0 = acc0
 3169: 1			;            r7,r6,r5,r4 = acc1
 3170: 1			;
 3171: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3172: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3173: 1			;                  gebruik van r4 is niet nodig
 3174: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3175: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3176: 1			;
 3177: 1			; vernietigt:  niets
 3178: 1			;*******************************************************************************
 3179: 1  0A1D	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3180: 1  0A1F	C0 D0		                push   psw
 3181: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3182: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3183: 1
 3184: 1  0A21	EC		                mov    	a,r4            ;verander het teken van acc1
 3185: 1  0A22	F4		                cpl    	a               ;door het 2's complement te nemen
 3186: 1  0A23	24 01		                add    	a,#1
 3187: 1  0A25	FC		                mov    	r4,a
 3188: 1  0A26	ED		                mov    	a,r5
 3189: 1  0A27	F4		                cpl    	a
 3190: 1  0A28	34 00		                addc	a,#0
 3191: 1  0A2A	FD		                mov    	r5,a
 3192: 1  0A2B	EE		                mov    	a,r6
 3193: 1  0A2C	F4		                cpl    	a
 3194: 1  0A2D	34 00		                addc   	a,#0
 3195: 1  0A2F	FE		                mov    	r6,a
 3196: 1  0A30	EF		                mov    	a,r7
 3197: 1  0A31	F4		                cpl    	a
 3198: 1  0A32	34 00		                addc   	a,#0
 3199: 1  0A34	FF		                mov    	r7,a
 3200: 1			;acc0+acc1
 3201: 1  0A35	E8						mov		a,r0
 3202: 1  0A36	2C						add		a,r4
 3203: 1  0A37	F8						mov		r0,a
 3204: 1  0A38	E9						mov		a,r1
 3205: 1  0A39	3D						addc	a,r5
 3206: 1  0A3A	F9						mov		r1,a
 3207: 1  0A3B	EA						mov		a,r2
 3208: 1  0A3C	3E						addc	a,r6
 3209: 1  0A3D	FA						mov		r2,a
 3210: 1  0A3E	EB						mov		a,r3
 3211: 1  0A3F	3F						addc	a,r7
 3212: 1  0A40	FB						mov		r3,a
 3213: 1
 3214: 1  0A41	92 D5		                mov   f0,c
 3215: 1  0A43	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3216: 1  0A45	92 D1		                mov   f1,c
 3217: 1  0A47	A2 D5		                mov   c,f0            ;herstel carrybit
 3218: 1
 3219: 1  0A49	74 00		                mov   a,#00h
 3220: 1  0A4B	34 00		                addc  a,#00h
 3221: 1  0A4D	FC		                mov   r4,a            ;40bit resultaat klaar
 3222: 1
 3223: 1  0A4E	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3224: 1
 3225: 1  0A51	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3226: 1  0A52	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3227: 1  0A55	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3228: 1  0A57	80 02		                sjmp   s_sub322
 3229: 1  0A59	7C 00		s_sub321:       mov   r4,#00h
 3230: 1  0A5B	D0 D0		s_sub322:       pop   psw
 3231: 1  0A5D	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3232: 1  0A5E	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3233: 1  0A60	22		                ret
 3234: 1
 3235: 1  0A61	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3236: 1  0A63	C3		                clr   c
 3237: 1  0A64	D0 E0		                pop   acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3238: 1  0A66	22		                ret
 3239: 1
 3240: 1
 3241: 1			;*******************************************************************************
 3242: 1			; sub32        (18,7us @16.777216MHz)
 3243: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3244: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3245: 1			; input:     r3,r2,r1,r0 = acc0
 3246: 1			;            r7,r6,r5,r4 = acc1
 3247: 1			;
 3248: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3249: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3250: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3251: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3252: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3253: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3254: 1			;
 3255: 1			; vernietigt:  niets
 3256: 1			;*******************************************************************************
 3257: 1  0A67	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3258: 1  0A69	C0 D0		               push    psw
 3259: 1  0A6B	C3		               clr       c
 3260: 1  0A6C	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3261: 1  0A6D	9C		               subb    a,r4           ;low byte eerst
 3262: 1  0A6E	F8		               mov     r0,a           ;resultaat bewaren
 3263: 1  0A6F	E9		               mov     a,r1           ;nu de hogere bytes
 3264: 1  0A70	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3265: 1  0A71	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3266: 1
 3267: 1  0A72	EA		               mov     a,r2           ;derde bytes optellen
 3268: 1  0A73	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3269: 1  0A74	FA		               mov     r2,a           ;24bit resultaat is klaar
 3270: 1  0A75	EB		               mov     a,r3           ;nu de ms bytes
 3271: 1  0A76	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3272: 1  0A77	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3273: 1
 3274: 1  0A78	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3275: 1
 3276: 1  0A7A	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3277: 1  0A7C	D0 D0		               pop     psw
 3278: 1  0A7E	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3279: 1  0A7F	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3280: 1  0A81	22		               ret
 3281: 1
 3282: 1  0A82	7C 00		sub321:        mov     r4,#00h
 3283: 1  0A84	D0 D0		               pop     psw
 3284: 1  0A86	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3285: 1  0A87	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3286: 1  0A89	22		               ret
 3287: 1
 3288: 1
 3289: 1
 3290: 1			;*******************************************************************************
 3291: 1			; mul16        (71,2us @16.777216MHz)
 3292: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3293: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3294: 1			; input:     r1,r0 = acc0
 3295: 1			;            r5,r4 = acc1
 3296: 1			;
 3297: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3298: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3299: 1			;
 3300: 1			; vernietigt:  niets
 3301: 1			;*******************************************************************************
 3302: 1  0A8A	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3303: 1  0A8C	C0 D0		                push    psw
 3304: 1  0A8E	C0 F0		                push    b
 3305: 1  0A90	C0 82		                push    dpl
 3306: 1  0A92	C0 83		                push    dph
 3307: 1
 3308: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3309: 1
 3310: 1  0A94	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3311: 1  0A96	89 83		                mov     dph,r1
 3312: 1  0A98	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3313: 1  0A9A	08		                inc     r0              ;pointer naar eerste vrije plaats
 3314: 1  0A9B	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3315: 1  0A9D	E5 81		                mov     a,sp            ;plaats alloceren
 3316: 1  0A9F	24 03		                add     a,#3            ;3 bytes nodig
 3317: 1  0AA1	F5 81		                mov     sp,a            ;stackpointer verzetten
 3318: 1
 3319: 1  0AA3	E5 82		                mov     a,dpl            ;acc0 lsb
 3320: 1  0AA5	8C F0		                mov     b,r4            ;acc1 lsb
 3321: 1  0AA7	A4		                mul     ab
 3322: 1  0AA8	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3323: 1  0AA9	08		                inc     r0
 3324: 1  0AAA	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3325: 1
 3326: 1  0AAC	E5 83		                mov     a,dph            ;acc0 msb
 3327: 1  0AAE	8C F0		                mov     b,r4            ;acc1 lsb
 3328: 1  0AB0	A4		                mul     ab
 3329: 1
 3330: 1  0AB1	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3331: 1  0AB2	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3332: 1  0AB3	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3333: 1  0AB5	34 00		                addc    a,#0
 3334: 1  0AB7	08		                inc     r0               ;bewaar als tussenresultaat
 3335: 1  0AB8	F6		                mov     @r0,a
 3336: 1
 3337: 1  0AB9	E5 82		                mov     a,dpl            ;acc0 lsb
 3338: 1  0ABB	8D F0		                mov     b,r5             ;acc1 msb
 3339: 1  0ABD	A4		                mul     ab
 3340: 1  0ABE	18		                dec     r0
 3341: 1  0ABF	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3342: 1  0AC0	F6		                mov     @r0,a            ;en bewaar weer
 3343: 1  0AC1	08		                inc     r0
 3344: 1  0AC2	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3345: 1  0AC4	36		                addc    a,@r0
 3346: 1  0AC5	F6		                mov     @r0,a            ;en bewaar weer
 3347: 1  0AC6	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3348: 1
 3349: 1  0AC8	E5 83		                mov     a,dph            ;acc0 msb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3350: 1  0ACA	8D F0		                mov     b,r5             ;acc1 msb
 3351: 1  0ACC	A4		                mul     AB
 3352: 1  0ACD	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3353: 1  0ACE	FA		                mov     r2,a
 3354: 1  0ACF	E5 F0		                mov     a,b
 3355: 1  0AD1	34 00		                addc    a,#0
 3356: 1
 3357: 1  0AD3	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3358: 1  0AD5	34 00		                addc    a,#0
 3359: 1
 3360: 1  0AD7	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3361: 1  0AD8	18		                dec     r0
 3362: 1  0AD9	86 83		                mov     dph,@r0
 3363: 1  0ADB	18		                dec     r0
 3364: 1  0ADC	86 82		                mov     dpl,@r0
 3365: 1
 3366: 1  0ADE	89 81		                mov     sp,r1            ;zet stackpointer terug
 3367: 1  0AE0	A9 83		                mov     r1,dph
 3368: 1  0AE2	A8 82		                mov     r0,dpl
 3369: 1
 3370: 1  0AE4	D0 83		                pop     dph              ;herstel de bewaarde registers
 3371: 1  0AE6	D0 82		                pop     dpl
 3372: 1  0AE8	D0 F0		                pop     b
 3373: 1  0AEA	D0 D0		                pop     psw
 3374: 1  0AEC	D0 E0		                pop     acc
 3375: 1  0AEE	22		                ret
 3376: 1
 3377: 1
 3378: 1
 3379: 1			;*******************************************************************************
 3380: 1			; mul16acc1        (71,2us @16.777216MHz)
 3381: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3382: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3383: 1			; input:     r5,r4 = acc1 low
 3384: 1			;            r7,r6 = acc1 high
 3385: 1			;
 3386: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3387: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3388: 1			;
 3389: 1			; vernietigt:  niets
 3390: 1			;*******************************************************************************
 3391: 1  0AEF	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3392: 1  0AF1	C0 D0		                push    psw
 3393: 1  0AF3	C0 F0		                push    b
 3394: 1  0AF5	C0 82		                push    dpl
 3395: 1  0AF7	C0 83		                push    dph
 3396: 1
 3397: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3398: 1
 3399: 1  0AF9	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3400: 1  0AFB	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3401: 1
 3402: 1  0AFD	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3403: 1  0AFF	08		                inc     r0               ;pointer naar eerste vrije plaats
 3404: 1  0B00	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3405: 1  0B02	E5 81		                mov     a,sp             ;plaats alloceren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3406: 1  0B04	24 03		                add     a,#3             ;3 bytes nodig
 3407: 1  0B06	F5 81		                mov     sp,a             ;stackpointer verzetten
 3408: 1
 3409: 1  0B08	EC		                mov     a,r4             ;acc1 low lsb
 3410: 1  0B09	8E F0		                mov     b,r6             ;acc1 high lsb
 3411: 1  0B0B	A4		                mul     ab
 3412: 1  0B0C	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3413: 1  0B0D	08		                inc     r0
 3414: 1  0B0E	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3415: 1
 3416: 1  0B10	ED		                mov     a,r5             ;acc1 low msb
 3417: 1  0B11	8E F0		                mov     b,r6             ;acc1 high lsb
 3418: 1  0B13	A4		                mul     ab
 3419: 1
 3420: 1  0B14	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3421: 1  0B15	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3422: 1  0B16	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3423: 1  0B18	34 00		                addc    a,#0
 3424: 1  0B1A	08		                inc     r0               ;bewaar als tussenresultaat
 3425: 1  0B1B	F6		                mov     @r0,a
 3426: 1
 3427: 1  0B1C	EC		                mov     a,r4             ;acc1 low lsb
 3428: 1  0B1D	8F F0		                mov     b,r7             ;acc1 high msb
 3429: 1  0B1F	A4		                mul     ab
 3430: 1  0B20	18		                dec     r0
 3431: 1  0B21	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3432: 1  0B22	F6		                mov     @r0,a            ;en bewaar weer
 3433: 1  0B23	08		                inc     r0
 3434: 1  0B24	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3435: 1  0B26	36		                addc    a,@r0
 3436: 1  0B27	F6		                mov     @r0,a            ;en bewaar weer
 3437: 1  0B28	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3438: 1
 3439: 1  0B2A	ED		                mov     a,r5             ;acc1 low msb
 3440: 1  0B2B	8F F0		                mov     b,r7             ;acc1 high msb
 3441: 1  0B2D	A4		                mul     AB
 3442: 1
 3443: 1  0B2E	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3444: 1  0B2F	FE		                mov     r6,a             ;deze byte van product is al klaar
 3445: 1  0B30	E5 F0		                mov     a,b
 3446: 1  0B32	34 00		                addc    a,#0
 3447: 1  0B34	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3448: 1  0B36	34 00		                addc    a,#0
 3449: 1
 3450: 1  0B38	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3451: 1  0B39	18		                dec     r0
 3452: 1  0B3A	E6		                mov     a,@r0
 3453: 1  0B3B	FD		                mov     r5,a
 3454: 1  0B3C	18		                dec     r0
 3455: 1  0B3D	E6		                mov     a,@r0
 3456: 1  0B3E	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3457: 1
 3458: 1  0B3F	89 81		                mov     sp,r1            ;zet stackpointer terug
 3459: 1  0B41	A9 83		                mov     r1,dph
 3460: 1  0B43	A8 82		                mov     r0,dpl
 3461: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3462: 1  0B45	D0 83		                pop     dph              ;herstel de bewaarde registers
 3463: 1  0B47	D0 82		                pop     dpl
 3464: 1  0B49	D0 F0		                pop     b
 3465: 1  0B4B	D0 D0		                pop     psw
 3466: 1  0B4D	D0 E0		                pop     acc
 3467: 1  0B4F	22		                ret
 3468: 1
 3469: 1			;*******************************************************************************
 3470: 1			; s_mul16        (121,1us @16.777216MHz)
 3471: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3472: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3473: 1			; input:     r1,r0 = acc0
 3474: 1			;            r5,r4 = acc1
 3475: 1			;
 3476: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3477: 1			;                                  -1073709056 tot +1073741824
 3478: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3479: 1			;
 3480: 1			; vernietigt:  niets
 3481: 1			;*******************************************************************************
 3482: 1  0B50	12 08 66	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3483: 1  0B53	12 08 86	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3484: 1  0B56	12 0A 8A	                lcall    mul16           ;maak product
 3485: 1  0B59	12 07 E0	                lcall    magsig32        ;maak 2's complement formaat
 3486: 1  0B5C	22		                ret                      ;klaar
 3487: 1
 3488: 1			;*******************************************************************************
 3489: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3490: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3491: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3492: 1			; input:     r5,r4 = acc1 low
 3493: 1			;            r7,r6 = acc1 high
 3494: 1			;
 3495: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3496: 1			;                                  -1073709056 tot +1073741824
 3497: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3498: 1			; vernietigt:  niets
 3499: 1			;*******************************************************************************
 3500: 1  0B5D	12 08 86	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3501: 1  0B60	12 08 A6	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3502: 1  0B63	12 0A EF	                lcall    mul16acc1       ;maak product
 3503: 1  0B66	12 08 0A	                lcall    magsig32acc1    ;maak 2's complement formaat
 3504: 1  0B69	22		                ret                      ;klaar
 3505: 1
 3506: 1			;*******************************************************************************
 3507: 1			; s_mul816        (83,5us @16.777216MHz)
 3508: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3509: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3510: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3511: 1			; input:     r1,r0 = acc0
 3512: 1			;               r4 = acc1
 3513: 1			;
 3514: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3515: 1			;                                  -4194176 tot +4194304
 3516: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3517: 1			; vernietigt:  niets
 3518: 1			;*******************************************************************************
 3519: 1  0B6A	12 08 66	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3520: 1  0B6D	12 08 4D	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3521: 1  0B70	12 0B 77	                lcall    mul816          ;8bit x 16 bit product
 3522: 1  0B73	12 07 E0	                lcall    magsig32        ;abs. waarde naar 2's complement
 3523: 1  0B76	22		                ret
 3524: 1
 3525: 1			;*******************************************************************************
 3526: 1			; mul816        (29,4us @16.777216MHz)
 3527: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3528: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3529: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3530: 1			; input:     r1,r0 = acc0
 3531: 1			;               r4 = acc1
 3532: 1			;
 3533: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3534: 1			;                           0..16711425 (000000h..feff01h)
 3535: 1			;
 3536: 1			; vernietigt:  niets
 3537: 1			;*******************************************************************************
 3538: 1  0B77	C0 E0		mul816:         push    acc             ;bewaar registers
 3539: 1  0B79	C0 F0		                push    b
 3540: 1  0B7B	C0 D0		                push    psw
 3541: 1  0B7D	EC		                mov     a,r4            ;neem acc1
 3542: 1  0B7E	88 F0		                mov     b,r0            ;neem lsb van acc0
 3543: 1  0B80	A4		                mul     ab              ;maak product
 3544: 1  0B81	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3545: 1  0B82	C0 F0		                push    b               ;bewaar lsb van het product
 3546: 1  0B84	EC		                mov     a,r4            ;neem acc1
 3547: 1  0B85	89 F0		                mov     b,r1            ;neem msb can acc0
 3548: 1  0B87	A4		                mul     ab              ;maak product
 3549: 1  0B88	AA F0		                mov     r2,b            ;bewaar msb van product even
 3550: 1  0B8A	F5 F0		                mov     b,a             ;verplaats lsb van product
 3551: 1  0B8C	D0 E0		                pop     acc             ;neem msb van vorig product
 3552: 1  0B8E	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3553: 1  0B90	F9		                mov     r1,a            ;de middenste byte is klaar
 3554: 1  0B91	EA		                mov     a,r2            ;tel nu de eventuele
 3555: 1  0B92	34 00		                addc    a,#0            ;carry bij de msb
 3556: 1  0B94	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3557: 1  0B95	7B 00		                mov     r3,#0
 3558: 1  0B97	D0 D0		                pop     psw
 3559: 1  0B99	D0 F0		                pop     b
 3560: 1  0B9B	D0 E0		                pop     acc
 3561: 1  0B9D	22		                ret
 3562: 1
 3563: 1			;*******************************************************************************
 3564: 1			; s_mac16        (145,1us @16.777216MHz)
 3565: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3566: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3567: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3568: 1			; input:     r7,r6 = acc1 (high word)
 3569: 1			;            r5,r4 = acc1 (low  word)
 3570: 1			;
 3571: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3572: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3573: 1			;                          -2147483648 tot +2147483647
 3574: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3575: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3576: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3577: 1			;
 3578: 1			; vernietigt:  niets
 3579: 1			;*******************************************************************************
 3580: 1  0B9E	12 0B 5D	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3581: 1  0BA1	C0 E0		                push    acc
 3582: 1  0BA3	C0 D0		                push    psw
 3583: 1  0BA5	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3584: 1  0BA6	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3585: 1  0BA7	F8		                mov     r0,a
 3586: 1  0BA8	ED		                mov     a,r5
 3587: 1  0BA9	39		                addc    a,r1
 3588: 1  0BAA	F9		                mov     r1,a
 3589: 1  0BAB	EE		                mov     a,r6
 3590: 1  0BAC	3A		                addc    a,r2
 3591: 1  0BAD	FA		                mov     r2,a
 3592: 1  0BAE	EF		                mov     a,r7
 3593: 1  0BAF	3B		                addc    a,r3
 3594: 1  0BB0	FB		                mov     r3,a
 3595: 1  0BB1	20 D2 06	                jb      ov,s_mac161
 3596: 1  0BB4	D0 D0		                pop     psw
 3597: 1  0BB6	C3		                clr     c                ;ok, 32bit som binnen bereik
 3598: 1  0BB7	D0 E0		                pop     acc
 3599: 1  0BB9	22		                ret
 3600: 1  0BBA	D0 D0		s_mac161:       pop     psw
 3601: 1  0BBC	D3		                setb    c                ;fout! 32bit som buiten bereik
 3602: 1  0BBD	D0 E0		                pop     acc
 3603: 1  0BBF	22		                ret
 3604: 1
 3605: 1
 3606: 1			;*******************************************************************************
 3607: 1			; s_div8        (78us @16.777216MHz)
 3608: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3609: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3610: 1			; input:    r0 = acc0 deeltal (2's compl)
 3611: 1			;           r4 = acc1 deler   (2's compl)
 3612: 1			;
 3613: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3614: 1			;           r4 = rest (2's compl)
 3615: 1			;           cy=1 bij acc1=0 (deling door nul)
 3616: 1			;            cy=0 in andere gevallen
 3617: 1			;
 3618: 1			; vernietigt: niets
 3619: 1			;*******************************************************************************
 3620: 1  0BC0	12 08 34	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3621: 1  0BC3	12 08 4D	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3622: 1  0BC6	12 0B D2	                lcall   div8
 3623: 1  0BC9	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3624: 1  0BCB	12 07 6C	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3625: 1  0BCE	12 07 86	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3626: 1  0BD1	22		s_div81:        ret
 3627: 1
 3628: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3629: 1			; div8        (19,4us @16.777216MHz)
 3630: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3631: 1			; absolute waarde
 3632: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3633: 1			; input:    r0 = acc0 deeltal
 3634: 1			;           r4 = acc1 deler
 3635: 1			;
 3636: 1			; output:   r0 = quotient van deling acc0/acc1
 3637: 1			;           r4 = rest
 3638: 1			;           cy=1 bij acc1=0 (deling door nul)
 3639: 1			;            cy=0 in andere gevallen
 3640: 1			;
 3641: 1			; vernietigt: niets
 3642: 1			;*******************************************************************************
 3643: 1  0BD2	C0 E0		div8:           push    acc             ;bewaar registers
 3644: 1  0BD4	C0 F0		                push    b
 3645: 1  0BD6	C0 D0		                push    psw
 3646: 1  0BD8	EC		                mov     a,r4            ;neem deler
 3647: 1  0BD9	60 0F		                jz      div81           ;deling door nul?
 3648: 1  0BDB	E8		                mov     a,r0            ;nee, neem deeltal
 3649: 1  0BDC	8C F0		                mov     b,r4            ;en deler
 3650: 1  0BDE	84		                div     ab              ;en maak deling
 3651: 1  0BDF	F8		                mov     r0,a            ;bewaar quotient in acc0
 3652: 1  0BE0	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3653: 1  0BE2	D0 D0		                pop     psw             ;herstel registers
 3654: 1  0BE4	D0 F0		                pop     b
 3655: 1  0BE6	D0 E0		                pop     acc
 3656: 1  0BE8	C3		                clr     c                ;geen deling door nul
 3657: 1  0BE9	22		                ret
 3658: 1
 3659: 1  0BEA	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3660: 1  0BEC	D0 F0		                pop     b
 3661: 1  0BEE	D0 E0		                pop     acc
 3662: 1  0BF0	D3		                setb    c
 3663: 1  0BF1	22		                ret
 3664: 1
 3665: 1
 3666: 1			;*******************************************************************************
 3667: 1			; s_div16        (469,1us @16.777216MHz)
 3668: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3669: 1			; 2's Complement Format
 3670: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3671: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3672: 1			;           r5, r4 = acc1 deler   (2's compl)
 3673: 1			;
 3674: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3675: 1			;           r5, r4 = rest
 3676: 1			;           cy=1 bij acc1=0 (deling door nul)
 3677: 1			;            cy=0 in andere gevallen
 3678: 1			;
 3679: 1			; vernietigt: niets
 3680: 1			;*******************************************************************************
 3681: 1  0BF2	C0 E0		s_div16:        push    acc
 3682: 1  0BF4	C0 D0		                push    psw
 3683: 1  0BF6	ED		                mov     a,r5            ;neem msb van deler
 3684: 1  0BF7	4C		                orl     a,r4            ;combineer met lsb van deler

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3685: 1  0BF8	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3686: 1  0BFA	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3687: 1  0BFC	D0 E0		                pop     acc
 3688: 1  0BFE	D3		                setb    C               ;fout, deling door nul!
 3689: 1  0BFF	22		                ret
 3690: 1
 3691: 1  0C00	12 08 66	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3692: 1  0C03	12 08 86	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3693: 1  0C06	12 0C 15	                lcall   div16
 3694: 1  0C09	12 07 A0	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3695: 1  0C0C	12 07 C0	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3696: 1  0C0F	D0 D0		                pop     psw
 3697: 1  0C11	C3		                clr     C               ;delig ok
 3698: 1  0C12	D0 E0		                pop     acc
 3699: 1  0C14	22		                ret                     ;klaar
 3700: 1
 3701: 1			;*******************************************************************************
 3702: 1			; div16            (405,1us @16.777216MHz)
 3703: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3704: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3705: 1			; input:    r1, r0 = Deeltal (acc0)
 3706: 1			;           r5, r4 = Deler   (acc1)
 3707: 1			;
 3708: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3709: 1			;           r5, r4 = rest van de deling acc0/acc1
 3710: 1			;            cy=1 bij deling door nul (acc1=0)
 3711: 1			;            cy=0 bij normale deling
 3712: 1			;
 3713: 1			; vernietigt: niets
 3714: 1			;*******************************************************************************
 3715: 1
 3716: 1  0C15	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3717: 1  0C17	C0 D0		                push    psw
 3718: 1			;check voor deling door nul
 3719: 1  0C19	EC		                mov     a,r4           ;neem lsb deler
 3720: 1  0C1A	4D		                orl     a,r5           ;combineer met msb van deler
 3721: 1  0C1B	70 06		                jnz     div160         ;niet nul, dan verder werken
 3722: 1  0C1D	D0 D0		                pop     psw            ;als nul, dikke snul
 3723: 1  0C1F	D3		                setb    c              ;terug met errorstatus
 3724: 1  0C20	D0 E0		                pop     acc
 3725: 1  0C22	22		                ret
 3726: 1
 3727: 1  0C23	C0 F0		div160:         push    b              ;registers verder bewaren
 3728: 1  0C25	EF		                mov     a,r7
 3729: 1  0C26	C0 E0		                push    acc            ;push r7 op stack
 3730: 1  0C28	EE		                mov     a,r6
 3731: 1  0C29	C0 E0		                push    acc            ;push r6 op stack
 3732: 1  0C2B	EB		                mov     a,r3
 3733: 1  0C2C	C0 E0		                push    acc            ;push r3 op stack
 3734: 1  0C2E	EA		                mov     a,r2
 3735: 1  0C2F	C0 E0		                push    acc            ;push r2 op stack
 3736: 1  0C31	C0 83		                push    dph
 3737: 1  0C33	C0 82		                push    dpl
 3738: 1
 3739: 1  0C35	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3740: 1  0C37	7B 00		                mov     r3,#0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3741: 1  0C39	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3742: 1  0C3B	7E 00		                mov     r6,#0
 3743: 1  0C3D	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3744: 1
 3745: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3746: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3747: 1			;het aantal significante bits af in de lusteller b
 3748: 1
 3749: 1  0C40	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3750: 1  0C41	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3751: 1  0C44	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3752: 1  0C45	E8		                mov     a,r0            ;lsb van deeltal nemen
 3753: 1  0C46	33		                rlc     a                ;en opschuiven
 3754: 1  0C47	F8		                mov     r0,a
 3755: 1  0C48	E9		                mov     a,r1            ;msb van deeltal nemen
 3756: 1  0C49	33		                rlc     a
 3757: 1  0C4A	F9		                mov     r1,a
 3758: 1  0C4B	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3759: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3760: 1  0C4E	7C 00		                mov     r4,#0
 3761: 1  0C50	7D 00		                mov     r5,#0
 3762: 1  0C52	80 2E		                sjmp    div164          ;klaar!
 3763: 1
 3764: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3765: 1
 3766: 1  0C54	C3		div162:            clr     C            ;start met carry op nul
 3767: 1  0C55	E8		                mov     a,r0            ;schuif deeltal naar links
 3768: 1  0C56	33		                rlc     a
 3769: 1  0C57	F8		                mov     r0,a
 3770: 1  0C58	E9		                mov     a,r1
 3771: 1  0C59	33		                rlc     a
 3772: 1  0C5A	F9		                mov     r1,a
 3773: 1  0C5B	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3774: 1  0C5C	33		                rlc     a               ;gedeeltelijke rest
 3775: 1  0C5D	FE		                mov     r6,a
 3776: 1  0C5E	EF		                mov     a,r7
 3777: 1  0C5F	33		                rlc     a
 3778: 1  0C60	FF		                mov     r7,a
 3779: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3780: 1  0C61	EE		                mov     a,r6
 3781: 1  0C62	C3		                clr     C
 3782: 1  0C63	9C		                subb    a,r4
 3783: 1  0C64	F5 82		                mov     dpl,a
 3784: 1  0C66	EF		                mov     a,r7
 3785: 1  0C67	9D		                subb    a,r5
 3786: 1  0C68	F5 83		                mov     dph,a
 3787: 1  0C6A	40 04		                jc      div163
 3788: 1  0C6C	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3789: 1  0C6E	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3790: 1
 3791: 1  0C70	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3792: 1  0C71	EA		                mov     a,r2            ;binnenschuiven
 3793: 1  0C72	33		                rlc     a
 3794: 1  0C73	FA		                mov     r2,a
 3795: 1  0C74	EB		                mov     a,r3
 3796: 1  0C75	33		                rlc     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3797: 1  0C76	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 3798: 1  0C77	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3799: 1
 3800: 1  0C7A	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3801: 1  0C7B	F9		                mov     r1,a
 3802: 1  0C7C	EA		                mov     a,r2
 3803: 1  0C7D	F8		                mov     r0,a
 3804: 1  0C7E	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3805: 1  0C7F	FD		                mov     r5,a
 3806: 1  0C80	EE		                mov     a,r6
 3807: 1  0C81	FC		                mov     r4,a
 3808: 1
 3809: 1  0C82	D0 82		div164:         pop     dpl             ;registers herstellen
 3810: 1  0C84	D0 83		                pop     dph
 3811: 1  0C86	D0 E0		                pop     acc
 3812: 1  0C88	FA		                mov     r2,a            ;r2 van stack halen
 3813: 1  0C89	D0 E0		                pop     acc
 3814: 1  0C8B	FB		                mov     r3,a            ;r3 van stack halen
 3815: 1  0C8C	D0 E0		                pop     acc
 3816: 1  0C8E	FE		                mov     r6,a            ;r6 van stack halen
 3817: 1  0C8F	D0 E0		                pop     acc
 3818: 1  0C91	FF		                mov     r7,a            ;r7 van stack halen
 3819: 1  0C92	D0 F0		                pop     b
 3820: 1  0C94	D0 D0		                pop     psw
 3821: 1  0C96	C3		                clr     c               ;deling ok
 3822: 1  0C97	D0 E0		                pop     acc
 3823: 1  0C99	22		                ret
 3824: 1
 3825: 1
 3826: 1			;*******************************************************************************
 3827: 1			; s_div32        (2,15ms @16.777216MHz)
 3828: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3829: 1			; 2's Complement Format
 3830: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3831: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3832: 1			;
 3833: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 3834: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3835: 1			;
 3836: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3837: 1			;           r7,r6,r5, r4 = rest
 3838: 1			;           cy=1 bij acc1=0 (deling door nul)
 3839: 1			;            cy=0 in andere gevallen
 3840: 1			;
 3841: 1			; vernietigt: niets
 3842: 1			;*******************************************************************************
 3843: 1  0C9A	C0 E0		s_div32:        push    acc
 3844: 1  0C9C	C0 D0		                push    psw
 3845: 1  0C9E	EF		                mov     a,r7            ;neem msb van deler
 3846: 1  0C9F	4E		                orl     a,r6            ;combineer met lsb's van deler
 3847: 1  0CA0	4D		                orl     a,r5
 3848: 1  0CA1	4C		                orl     a,r4
 3849: 1  0CA2	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3850: 1  0CA4	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3851: 1  0CA6	D0 E0		                pop     acc
 3852: 1  0CA8	D3		                setb    C                ;fout, deling door nul!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3853: 1  0CA9	22		                ret
 3854: 1
 3855: 1  0CAA	12 08 C6	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3856: 1  0CAD	12 08 F0	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3857: 1  0CB0	12 0C BF	                lcall   div32            ;deel 32bit/32bit
 3858: 1  0CB3	12 07 E0	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3859: 1  0CB6	12 08 0A	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3860: 1  0CB9	D0 D0		                pop     psw
 3861: 1  0CBB	C3		                clr     C                ;delig ok
 3862: 1  0CBC	D0 E0		                pop     acc
 3863: 1  0CBE	22		                ret                        ;klaar
 3864: 1
 3865: 1
 3866: 1			;*******************************************************************************
 3867: 1			; div32        (2,09ms @16.777216MHz)
 3868: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3869: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3870: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3871: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3872: 1			;
 3873: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 3874: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3875: 1			;            cy=1 bij deling door nul (acc1=0)
 3876: 1			;            cy=0 bij normale deling
 3877: 1			;
 3878: 1			; vernietigt: niets
 3879: 1			;*******************************************************************************
 3880: 1  0CBF	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3881: 1  0CC1	C0 D0		                push    psw
 3882: 1			;check voor deling door nul
 3883: 1  0CC3	EF		                mov     a,r7            ;neem msb van deler
 3884: 1  0CC4	4E		                orl     a,r6            ;combineer met lsb's van deler
 3885: 1  0CC5	4D		                orl     a,r5
 3886: 1  0CC6	4C		                orl     a,r4
 3887: 1  0CC7	70 06		                jnz     div320          ;niet nul, dan verder werken
 3888: 1  0CC9	D0 D0		                pop     psw             ;als nul, dikke snul
 3889: 1  0CCB	D3		                setb    c               ;terug met errorstatus
 3890: 1  0CCC	D0 E0		                pop     acc
 3891: 1  0CCE	22		                ret
 3892: 1
 3893: 1  0CCF	C0 F0		div320:         push    b                ;registers verder bewaren
 3894: 1  0CD1	C0 83		                push    dph
 3895: 1  0CD3	C0 82		                push    dpl
 3896: 1
 3897: 1  0CD5	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3898: 1
 3899: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3900: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3901: 1			;het aantal significante bits af in de lusteller b
 3902: 1
 3903: 1  0CD8	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3904: 1  0CD9	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3905: 1  0CDC	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3906: 1  0CDD	E8		                mov     a,r0            ;lsb van deeltal nemen
 3907: 1  0CDE	33		                rlc     a               ;en opschuiven
 3908: 1  0CDF	F8		                mov     r0,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3909: 1  0CE0	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 3910: 1  0CE1	33		                rlc     a
 3911: 1  0CE2	F9		                mov     r1,a
 3912: 1  0CE3	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3913: 1  0CE4	33		                rlc     a
 3914: 1  0CE5	FA		                mov     r2,a
 3915: 1  0CE6	EB		                mov     a,r3           ;lsb van deeltal nemen
 3916: 1  0CE7	33		                rlc     a
 3917: 1  0CE8	FB		                mov     r3,a
 3918: 1  0CE9	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3919: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3920: 1  0CEC	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3921: 1  0CEE	7E 00		                mov     r6,#0
 3922: 1  0CF0	7D 00		                mov     r5,#0
 3923: 1  0CF2	7C 00		                mov     r4,#0
 3924: 1  0CF4	02 0D BD	                ljmp    div324           ;klaar!
 3925: 1
 3926: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 3927: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 3928: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 3929: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 3930: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 3931: 1
 3932: 1  0CF7			div320b:
 3933: 1  0CF7	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 3934: 1
 3935: 1  0CFA	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 3936: 1  0CFC	24 0C		                add     a,#12           ;met 12 plaatsen
 3937: 1  0CFE	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 3938: 1
 3939: 1  0D00	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 3940: 1  0D01	C0 E0		                push    acc
 3941: 1  0D03	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 3942: 1  0D04	C0 E0		                push    acc
 3943: 1
 3944: 1  0D06	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 3945: 1  0D08	08		                inc     r0              ;de deler
 3946: 1  0D09	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 3947: 1  0D0B	24 05		                add     a,#5            ;het tijdelijk verschil X
 3948: 1  0D0D	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 3949: 1  0D0E	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 3950: 1  0D10	24 09		                add     a,#9            ;quotient
 3951: 1  0D12	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 3952: 1
 3953: 1			;Eenmalig de variabelen op stack initaliseren
 3954: 1			;Tijdelijk quotient op nul zetten
 3955: 1
 3956: 1  0D14	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 3957: 1  0D16	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 3958: 1  0D17	C0 F0		                push    b                ;loopteller deling bewaren
 3959: 1  0D19	75 F0 04	                mov     b,#4
 3960: 1  0D1C	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 3961: 1  0D1E	09		                inc     r1
 3962: 1  0D1F	D5 F0 FA	                djnz    b,div320c
 3963: 1  0D22	D0 F0		                pop     b                ;loopteller deling ophalen
 3964: 1  0D24	19		                dec     r1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3965: 1  0D25	19		                dec     r1
 3966: 1  0D26	19		                dec     r1
 3967: 1  0D27	19		                dec     r1               ;pointer weer op startadres quotient
 3968: 1  0D28	C9		                xch     a,r1             ;weer omwisselen
 3969: 1  0D29	C5 82		                xch     a,dpl
 3970: 1
 3971: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 3972: 1  0D2B	EC		                mov     a,r4
 3973: 1  0D2C	F6		                mov     @r0,a
 3974: 1  0D2D	08		                inc     r0
 3975: 1  0D2E	ED		                mov     a,r5
 3976: 1  0D2F	F6		                mov     @r0,a
 3977: 1  0D30	08		                inc     r0
 3978: 1  0D31	EE		                mov     a,r6
 3979: 1  0D32	F6		                mov     @r0,a
 3980: 1  0D33	08		                inc     r0
 3981: 1  0D34	EF		                mov     a,r7
 3982: 1  0D35	F6		                mov     @r0,a
 3983: 1  0D36	18		                dec     r0             ;pointer herstellen naar lsb van deler
 3984: 1  0D37	18		                dec     r0
 3985: 1  0D38	18		                dec     r0
 3986: 1
 3987: 1  0D39	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 3988: 1  0D3B	7E 00		                mov     r6,#0
 3989: 1  0D3D	7D 00		                mov     r5,#0
 3990: 1  0D3F	7C 00		                mov     r4,#0
 3991: 1
 3992: 1
 3993: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 3994: 1  0D41	C3		div322:         clr     C               ;start met carry op nul
 3995: 1
 3996: 1  0D42	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 3997: 1  0D44	33		                rlc     a
 3998: 1  0D45	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 3999: 1  0D47	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 4000: 1  0D49	D0 E0		                pop     acc             ;r1 van deeltal van stack
 4001: 1  0D4B	33		                rlc     a
 4002: 1  0D4C	C0 E0		                push    acc             ;en weer bewaren
 4003: 1  0D4E	05 81		                inc     sp              ;stackpointer weer corrigeren
 4004: 1
 4005: 1  0D50	EA		                mov     a,r2
 4006: 1  0D51	33		                rlc     a
 4007: 1  0D52	FA		                mov     r2,a
 4008: 1  0D53	EB		                mov     a,r3
 4009: 1  0D54	33		                rlc     a
 4010: 1  0D55	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 4011: 1
 4012: 1  0D56	EC		                mov     a,r4            ;schuif carry van deeltal in de
 4013: 1  0D57	33		                rlc     a               ;gedeeltelijke rest r7..r4
 4014: 1  0D58	FC		                mov     r4,a
 4015: 1  0D59	ED		                mov     a,r5
 4016: 1  0D5A	33		                rlc     a
 4017: 1  0D5B	FD		                mov     r5,a
 4018: 1  0D5C	EE		                mov     a,r6
 4019: 1  0D5D	33		                rlc     a
 4020: 1  0D5E	FE		                mov     r6,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4021: 1  0D5F	EF		                mov     a,r7
 4022: 1  0D60	33		                rlc     a
 4023: 1  0D61	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 4024: 1
 4025: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 4026: 1
 4027: 1  0D62	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 4028: 1  0D63	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 4029: 1  0D64	96		                subb    a,@r0           ;trek er de lsb deler af
 4030: 1  0D65	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4031: 1  0D66	08		                inc     r0              ;pointers aanpassen
 4032: 1  0D67	09		                inc     r1
 4033: 1  0D68	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4034: 1  0D69	96		                subb    a,@r0           ;trek er volgende byte deler af
 4035: 1  0D6A	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4036: 1  0D6B	08		                inc     r0              ;pointers aanpassen
 4037: 1  0D6C	09		                inc     r1
 4038: 1  0D6D	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4039: 1  0D6E	96		                subb    a,@r0           ;trek er volgende byte deler af
 4040: 1  0D6F	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4041: 1  0D70	08		                inc     r0              ;pointers aanpassen
 4042: 1  0D71	09		                inc     r1
 4043: 1  0D72	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4044: 1  0D73	96		                subb    a,@r0           ;trek er msb deler af
 4045: 1  0D74	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4046: 1  0D75	18		                dec     r0              ;pointers herstellen naar lsb's
 4047: 1  0D76	18		                dec     r0
 4048: 1  0D77	18		                dec     r0
 4049: 1  0D78	19		                dec     r1
 4050: 1  0D79	19		                dec     r1
 4051: 1  0D7A	19		                dec     r1
 4052: 1
 4053: 1  0D7B	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4054: 1  0D7D	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4055: 1  0D7E	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4056: 1  0D7F	09		                inc     r1
 4057: 1  0D80	E7		                mov     a,@r1
 4058: 1  0D81	FD		                mov     r5,a
 4059: 1  0D82	09		                inc     r1
 4060: 1  0D83	E7		                mov     a,@r1
 4061: 1  0D84	FE		                mov     r6,a
 4062: 1  0D85	09		                inc     r1
 4063: 1  0D86	E7		                mov     a,@r1
 4064: 1  0D87	FF		                mov     r7,a
 4065: 1  0D88	19		                dec     r1              ;met pointer weer naar lsb van
 4066: 1  0D89	19		                dec     r1              ;het tijdelijk verschil wijzen
 4067: 1  0D8A	19		                dec     r1
 4068: 1
 4069: 1
 4070: 1  0D8B	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4071: 1  0D8C	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4072: 1  0D8E	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4073: 1  0D8F	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4074: 1  0D91	E7		                mov     a,@r1           ;neem lsb van qoutient
 4075: 1  0D92	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4076: 1  0D93	F7		                mov     @r1,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4077: 1  0D94	09		                inc     r1              ;volgende byte
 4078: 1  0D95	E7		                mov     a,@r1
 4079: 1  0D96	33		                rlc     a
 4080: 1  0D97	F7		                mov     @r1,a
 4081: 1  0D98	09		                inc     r1              ;volgende byte
 4082: 1  0D99	E7		                mov     a,@r1
 4083: 1  0D9A	33		                rlc     a
 4084: 1  0D9B	F7		                mov     @r1,a
 4085: 1  0D9C	09		                inc     r1              ;volgende byte
 4086: 1  0D9D	E7		                mov     a,@r1
 4087: 1  0D9E	33		                rlc     a
 4088: 1  0D9F	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4089: 1  0DA0	19		                dec     r1
 4090: 1  0DA1	19		                dec     r1
 4091: 1  0DA2	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4092: 1  0DA3	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4093: 1  0DA5	C9		                xch     a,r1            ;r1=pointer naar verschil
 4094: 1  0DA6	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4095: 1
 4096: 1  0DA8	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4097: 1
 4098: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4099: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4100: 1
 4101: 1  0DAB	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4102: 1  0DAD	18		                dec     r0
 4103: 1  0DAE	18		                dec     r0
 4104: 1  0DAF	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4105: 1  0DB0	FB		                mov     r3,a            ;en verplaatsen
 4106: 1  0DB1	18		                dec     r0              ;volgende byte
 4107: 1  0DB2	E6		                mov     a,@r0
 4108: 1  0DB3	FA		                mov     r2,a
 4109: 1  0DB4	18		                dec     r0              ;volgende byte
 4110: 1  0DB5	E6		                mov     a,@r0
 4111: 1  0DB6	F9		                mov     r1,a
 4112: 1  0DB7	18		                dec     r0              ;volgende byte
 4113: 1  0DB8	E6		                mov     a,@r0
 4114: 1  0DB9	F8		                mov     r0,a            ;laatste byte verplaatst!
 4115: 1
 4116: 1  0DBA	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4117: 1			                                         ;weer vrijgeven
 4118: 1
 4119: 1
 4120: 1  0DBD	D0 82		div324:         pop     dpl             ;registers herstellen
 4121: 1  0DBF	D0 83		                pop     dph
 4122: 1  0DC1	D0 F0		                pop     b
 4123: 1  0DC3	D0 D0		                pop     psw
 4124: 1  0DC5	C3		                clr     c               ;normale deling
 4125: 1  0DC6	D0 E0		                pop     acc
 4126: 1  0DC8	22		                ret
 4127: 1
 4128: 1			;*******************************************************************************
 4129: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4130: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4131: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4132: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4133: 1			;
 4134: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4135: 1			;
 4136: 1			; input:     r5,r4 = acc1 (low word product)
 4137: 1			;            r7,r6 = acc1 (high word product)
 4138: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4139: 1			;
 4140: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4141: 1			;            r7,r6,r5,r4 = acc1 = rest
 4142: 1			;                          -2147483648 tot +2147483647
 4143: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4144: 1			;             cy=1 bij deling door nul (acc0=0)
 4145: 1			;             cy=0 bij normale deling
 4146: 1			;
 4147: 1			; vernietigt:  niets
 4148: 1			;*******************************************************************************
 4149: 1  0DC9	C0 E0		s_muldiv:       push    acc
 4150: 1  0DCB	C0 D0		                push    psw
 4151: 1  0DCD	E8		                mov     a,r0            ;neem msb van deler
 4152: 1  0DCE	49		                orl     a,r1            ;combineer met lsb's van deler
 4153: 1  0DCF	4A		                orl     a,r2
 4154: 1  0DD0	4B		                orl     a,r3
 4155: 1  0DD1	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4156: 1  0DD3	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4157: 1  0DD5	D0 E0		                pop     acc
 4158: 1  0DD7	D3		                setb    C               ;fout, deling door nul!
 4159: 1  0DD8	22		                ret
 4160: 1
 4161: 1  0DD9	12 08 86	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4162: 1  0DDC	12 08 A6	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4163: 1  0DDF	12 0D EE	                lcall    muldiv          ;maak product en daarna de deling
 4164: 1  0DE2	12 07 E0	                lcall    magsig32        ;quotient naar 2's complement
 4165: 1  0DE5	12 08 0A	                lcall    magsig32acc1    ;rest naar 2's complement
 4166: 1  0DE8	D0 D0		                pop     psw
 4167: 1  0DEA	C3		                clr     c                ;deling is ok
 4168: 1  0DEB	D0 E0		                pop    acc
 4169: 1  0DED	22		                ret
 4170: 1
 4171: 1			;*******************************************************************************
 4172: 1			; muldiv        (2,0ms @16.777216MHz)
 4173: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4174: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4175: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4176: 1			; 32bit rest in acc1.
 4177: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4178: 1			;
 4179: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4180: 1			;
 4181: 1			; input:     r5,r4 = acc1 (low word product)
 4182: 1			;            r7,r6 = acc1 (high word product)
 4183: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4184: 1			;
 4185: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4186: 1			;            r7,r6,r5,r4 = acc1 = rest
 4187: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4188: 1			;             cy=1 bij deling door nul (acc0=0)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4189: 1			;             cy=0 bij normale deling
 4190: 1			;
 4191: 1			; vernietigt:  niets
 4192: 1			;*******************************************************************************
 4193: 1  0DEE	C0 E0		muldiv:         push    acc
 4194: 1  0DF0	C0 D0		                push    psw
 4195: 1  0DF2	E8		                mov     a,r0            ;neem msb van deler
 4196: 1  0DF3	49		                orl     a,r1            ;combineer met lsb's van deler
 4197: 1  0DF4	4A		                orl     a,r2
 4198: 1  0DF5	4B		                orl     a,r3
 4199: 1  0DF6	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4200: 1  0DF8	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4201: 1  0DFA	D0 E0		                pop     acc
 4202: 1  0DFC	D3		                setb    C               ;fout, deling door nul!
 4203: 1  0DFD	22		                ret
 4204: 1
 4205: 1  0DFE	12 0A EF	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4206: 1  0E01	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4207: 1  0E02	C0 E0		                push    acc
 4208: 1  0E04	ED		                mov     a,r5
 4209: 1  0E05	C0 E0		                push    acc
 4210: 1  0E07	EE		                mov     a,r6
 4211: 1  0E08	C0 E0		                push    acc
 4212: 1  0E0A	EF		                mov     a,r7
 4213: 1  0E0B	C0 E0		                push    acc             ;product staat nu op stack
 4214: 1
 4215: 1  0E0D	E8		                mov     a,r0            ;deler in acc1 stoppen
 4216: 1  0E0E	FC		                mov     r4,a
 4217: 1  0E0F	E9		                mov     a,r1
 4218: 1  0E10	FD		                mov     r5,a
 4219: 1  0E11	EA		                mov     a,r2
 4220: 1  0E12	FE		                mov     r6,a
 4221: 1  0E13	EB		                mov     a,r3
 4222: 1  0E14	FF		                mov     r7,a            ;deler zit volledig in acc1
 4223: 1
 4224: 1  0E15	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4225: 1  0E17	FB		                mov     r3,a
 4226: 1  0E18	D0 E0		                pop     acc
 4227: 1  0E1A	FA		                mov     r2,a
 4228: 1  0E1B	D0 E0		                pop     acc
 4229: 1  0E1D	F9		                mov     r1,a
 4230: 1  0E1E	D0 E0		                pop     acc
 4231: 1  0E20	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4232: 1  0E21	12 0C BF	                lcall   div32           ;maak deling
 4233: 1
 4234: 1  0E24	D0 D0		                pop     psw            ;herstel registers
 4235: 1  0E26	D0 E0		                pop     acc
 4236: 1  0E28	C3		                clr     C              ;resultaat ok!
 4237: 1  0E29	22		                ret
 4238: 1
 4239: 1			;*******************************************************************************
 4240: 1			; mul16_pi        (257,1us @16.777216MHz)
 4241: 1			; acc0 = acc0 x pi
 4242: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4243: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4244: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4245: 1			; input:     r1,r0 = acc0 (low word)
 4246: 1			;
 4247: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4248: 1			;
 4249: 1			; vernietigt:  niets
 4250: 1			;*******************************************************************************
 4251: 1  0E2A	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4252: 1  0E2C	C0 D0		                push    psw
 4253: 1  0E2E	EC		                mov     a,r4
 4254: 1  0E2F	C0 E0		                push    acc
 4255: 1  0E31	ED		                mov     a,r5
 4256: 1  0E32	C0 E0		                push    acc
 4257: 1  0E34	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4258: 1  0E36	7C 0F		                mov     r4,#0fH
 4259: 1  0E38	12 0A 8A	                lcall   mul16           ;acc0 = acc0 x acc1
 4260: 1  0E3B	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4261: 1  0E3D	12 10 26	                lcall   shiftright32    ;om te delen door 2^14
 4262: 1  0E40	D0 E0		                pop     acc
 4263: 1  0E42	FD		                mov     r5,a
 4264: 1  0E43	D0 E0		                pop     acc
 4265: 1  0E45	FC		                mov     r4,a
 4266: 1  0E46	D0 D0		                pop     psw
 4267: 1  0E48	D0 E0		                pop     acc
 4268: 1  0E4A	22		                ret
 4269: 1
 4270: 1			;*******************************************************************************
 4271: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4272: 1			; acc0 = acc0 x 1/pi
 4273: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4274: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4275: 1			;
 4276: 1			; input:     r1,r0 = acc0 (low word)
 4277: 1			;
 4278: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4279: 1			;
 4280: 1			; vernietigt:  niets
 4281: 1			;*******************************************************************************
 4282: 1  0E4B	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4283: 1  0E4D	C0 D0		                push    psw
 4284: 1  0E4F	EC		                mov     a,r4
 4285: 1  0E50	C0 E0		                push    acc
 4286: 1  0E52	ED		                mov     a,r5
 4287: 1  0E53	C0 E0		                push    acc
 4288: 1  0E55	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4289: 1  0E57	7C 7D		                mov     r4,#07dH
 4290: 1  0E59	12 0A 8A	                lcall    mul16          ;acc0 = acc0 x acc1
 4291: 1  0E5C	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4292: 1  0E5E	12 10 26	                lcall   shiftright32    ;om te delen door 2^16
 4293: 1  0E61	D0 E0		                pop     acc
 4294: 1  0E63	FD		                mov     r5,a
 4295: 1  0E64	D0 E0		                pop     acc
 4296: 1  0E66	FC		                mov     r4,a
 4297: 1  0E67	D0 D0		                pop     psw
 4298: 1  0E69	D0 E0		                pop     acc
 4299: 1  0E6B	22		                ret
 4300: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4301: 1			;*******************************************************************************
 4302: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4303: 1			; acc0 = acc0 x sqrt2
 4304: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4305: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4306: 1			;
 4307: 1			; input:     r1,r0 = acc0 (low word)
 4308: 1			;
 4309: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4310: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4311: 1			;
 4312: 1			; vernietigt:  niets
 4313: 1			;*******************************************************************************
 4314: 1  0E6C	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4315: 1  0E6E	C0 D0		                push    psw
 4316: 1  0E70	EC		                mov     a,r4
 4317: 1  0E71	C0 E0		                push    acc
 4318: 1  0E73	ED		                mov     a,r5
 4319: 1  0E74	C0 E0		                push    acc
 4320: 1  0E76	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4321: 1  0E78	7C 05		                mov     r4,#005H
 4322: 1  0E7A	12 0A 8A	                lcall   mul16           ;acc0 = acc0 x acc1
 4323: 1  0E7D	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4324: 1  0E7F	12 10 26	                lcall   shiftright32    ;om te delen door 2^15
 4325: 1  0E82	D0 E0		                pop     acc
 4326: 1  0E84	FD		                mov     r5,a
 4327: 1  0E85	D0 E0		                pop     acc
 4328: 1  0E87	FC		                mov     r4,a
 4329: 1  0E88	D0 D0		                pop     psw
 4330: 1  0E8A	D0 E0		                pop     acc
 4331: 1  0E8C	22		                ret
 4332: 1
 4333: 1
 4334: 1
 4335: 1			;*******************************************************************************
 4336: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4337: 1			; acc0 = acc0 x 1/sqrt2
 4338: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4339: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4340: 1			;
 4341: 1			; input:     r1,r0 = acc0 (low word)
 4342: 1			;
 4343: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4344: 1			;
 4345: 1			; vernietigt:  niets
 4346: 1			;*******************************************************************************
 4347: 1  0E8D	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4348: 1  0E8F	C0 D0		                push    psw
 4349: 1  0E91	EC		                mov     a,r4
 4350: 1  0E92	C0 E0		                push    acc
 4351: 1  0E94	ED		                mov     a,r5
 4352: 1  0E95	C0 E0		                push    acc
 4353: 1  0E97	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4354: 1  0E99	7C 05		                mov     r4,#005H
 4355: 1  0E9B	12 0A 8A	                lcall   mul16           ;acc0 = acc0 x acc1
 4356: 1  0E9E	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4357: 1  0EA0	12 10 26	                lcall   shiftright32    ;om te delen door 2^16
 4358: 1  0EA3	D0 E0		                pop     acc
 4359: 1  0EA5	FD		                mov     r5,a
 4360: 1  0EA6	D0 E0		                pop     acc
 4361: 1  0EA8	FC		                mov     r4,a
 4362: 1  0EA9	D0 D0		                pop     psw
 4363: 1  0EAB	D0 E0		                pop     acc
 4364: 1  0EAD	22		                ret
 4365: 1
 4366: 1			;*******************************************************************************
 4367: 1			; mul16_10        (98,7us @16.777216MHz)
 4368: 1			; acc0 = acc0 x 10
 4369: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4370: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4371: 1			;
 4372: 1			; input:     r1,r0 = acc0 (low word)
 4373: 1			;
 4374: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4375: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4376: 1			; vernietigt:  niets
 4377: 1			;*******************************************************************************
 4378: 1  0EAE	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4379: 1  0EB0	C0 D0		                push    psw
 4380: 1  0EB2	EC		                mov     a,r4
 4381: 1  0EB3	C0 E0		                push    acc
 4382: 1  0EB5	7C 01		                mov     r4,#1           ;acc0 x2
 4383: 1  0EB7	12 10 52	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4384: 1  0EBA	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4385: 1  0EBB	C0 E0		                push    acc
 4386: 1  0EBD	EA		                mov     a,r2
 4387: 1  0EBE	C0 E0		                push    acc
 4388: 1  0EC0	E9		                mov     a,r1
 4389: 1  0EC1	C0 E0		                push    acc
 4390: 1  0EC3	E8		                mov     a,r0
 4391: 1  0EC4	C0 E0		                push    acc             ;acc0 op stack
 4392: 1  0EC6	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4393: 1  0EC8	12 10 52	                lcall   shiftleft32     ;acc0 =acc0 x4
 4394: 1  0ECB	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4395: 1  0ECD	28		                add     a,r0            ;tel bij huidige acc0
 4396: 1  0ECE	F8		                mov     r0,a
 4397: 1  0ECF	D0 E0		                pop     acc
 4398: 1  0ED1	39		                addc    a,r1
 4399: 1  0ED2	F9		                mov     r1,a
 4400: 1  0ED3	D0 E0		                pop     acc
 4401: 1  0ED5	3A		                addc    a,r2
 4402: 1  0ED6	FA		                mov     r2,a
 4403: 1  0ED7	D0 E0		                pop     acc
 4404: 1  0ED9	3B		                addc    a,r3
 4405: 1  0EDA	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4406: 1
 4407: 1
 4408: 1  0EDB	D0 E0		                pop     acc
 4409: 1  0EDD	FC		                mov     r4,a
 4410: 1  0EDE	D0 D0		                pop     psw
 4411: 1  0EE0	D0 E0		                pop     acc
 4412: 1  0EE2	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4413: 1
 4414: 1			;*******************************************************************************
 4415: 1			; mul16_100        (169,1us @16.777216MHz)
 4416: 1			; acc0 = acc0 x 100
 4417: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4418: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4419: 1			;
 4420: 1			; input:     r1,r0 = acc0 (low word)
 4421: 1			;
 4422: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4423: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4424: 1			; vernietigt:  niets
 4425: 1			;*******************************************************************************
 4426: 1  0EE3	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4427: 1  0EE5	C0 D0		                push    psw
 4428: 1  0EE7	EC		                mov     a,r4
 4429: 1  0EE8	C0 E0		                push    acc
 4430: 1  0EEA	7C 02		                mov     r4,#2           ;acc0 x4
 4431: 1  0EEC	12 10 52	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4432: 1  0EEF	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4433: 1  0EF0	C0 E0		                push    acc
 4434: 1  0EF2	EA		                mov     a,r2
 4435: 1  0EF3	C0 E0		                push    acc
 4436: 1  0EF5	E9		                mov     a,r1
 4437: 1  0EF6	C0 E0		                push    acc
 4438: 1  0EF8	E8		                mov     a,r0
 4439: 1  0EF9	C0 E0		                push    acc             ;acc0 op stack
 4440: 1
 4441: 1  0EFB	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4442: 1  0EFD	12 10 52	                lcall   shiftleft32     ;acc0 =acc0 x8
 4443: 1  0F00	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4444: 1  0F01	C0 E0		                push    acc
 4445: 1  0F03	EA		                mov     a,r2
 4446: 1  0F04	C0 E0		                push    acc
 4447: 1  0F06	E9		                mov     a,r1
 4448: 1  0F07	C0 E0		                push    acc
 4449: 1  0F09	E8		                mov     a,r0
 4450: 1  0F0A	C0 E0		                push    acc             ;acc0 op stack
 4451: 1
 4452: 1  0F0C	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4453: 1  0F0E	12 10 52	                lcall   shiftleft32     ;acc0 =acc0 x2
 4454: 1  0F11	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4455: 1  0F13	28		                add     a,r0            ;tel bij huidige acc0
 4456: 1  0F14	F8		                mov     r0,a
 4457: 1  0F15	D0 E0		                pop     acc
 4458: 1  0F17	39		                addc    a,r1
 4459: 1  0F18	F9		                mov     r1,a
 4460: 1  0F19	D0 E0		                pop     acc
 4461: 1  0F1B	3A		                addc    a,r2
 4462: 1  0F1C	FA		                mov     r2,a
 4463: 1  0F1D	D0 E0		                pop     acc
 4464: 1  0F1F	3B		                addc    a,r3
 4465: 1  0F20	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4466: 1
 4467: 1  0F21	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4468: 1  0F23	28		                add     a,r0            ;tel bij huidige acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4469: 1  0F24	F8		                mov     r0,a
 4470: 1  0F25	D0 E0		                pop     acc
 4471: 1  0F27	39		                addc    a,r1
 4472: 1  0F28	F9		                mov     r1,a
 4473: 1  0F29	D0 E0		                pop     acc
 4474: 1  0F2B	3A		                addc    a,r2
 4475: 1  0F2C	FA		                mov     r2,a
 4476: 1  0F2D	D0 E0		                pop     acc
 4477: 1  0F2F	3B		                addc    a,r3
 4478: 1  0F30	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4479: 1
 4480: 1  0F31	D0 E0		                pop     acc
 4481: 1  0F33	FC		                mov     r4,a
 4482: 1  0F34	D0 D0		                pop     psw
 4483: 1  0F36	D0 E0		                pop     acc
 4484: 1  0F38	22		                ret
 4485: 1
 4486: 1			;*******************************************************************************
 4487: 1			; sqrt32        (2,99ms @16.777216MHz)
 4488: 1			; acc0 = acc0 ^(1/2)
 4489: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4490: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4491: 1			;
 4492: 1			; input:     r3,r2,r1,r0 = acc0
 4493: 1			;
 4494: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4495: 1			;
 4496: 1			; vernietigt:  niets
 4497: 1			;*******************************************************************************
 4498: 1  0F39	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4499: 1  0F3B	C0 F0		                push    b
 4500: 1  0F3D	C0 D0		                push    psw
 4501: 1  0F3F	C0 82		                push    dpl
 4502: 1  0F41	C0 83		                push    dph
 4503: 1  0F43	EC		                mov     a,r4
 4504: 1  0F44	C0 E0		                push    acc
 4505: 1  0F46	ED		                mov     a,r5
 4506: 1  0F47	C0 E0		                push    acc
 4507: 1  0F49	EE		                mov     a,r6
 4508: 1  0F4A	C0 E0		                push    acc
 4509: 1  0F4C	EF		                mov     a,r7
 4510: 1  0F4D	C0 E0		                push    acc
 4511: 1
 4512: 1  0F4F	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4513: 1  0F51	7D 00		                mov     r5,#0
 4514: 1  0F53	7E 00		                mov     r6,#0
 4515: 1  0F55	7F 00		                mov     r7,#0
 4516: 1  0F57	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4517: 1  0F5A	75 83 00	                mov     dph,#0
 4518: 1  0F5D	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4519: 1			;hier start het algorithme voor het berekenen van de wortel
 4520: 1  0F60	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4521: 1  0F62	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4522: 1  0F65	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4523: 1  0F66	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4524: 1  0F67	33		                rlc     a                ;getest worden om een wortelbit te

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4525: 1  0F68	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4526: 1  0F69	E9		                mov     a,r1            ;met nullen!
 4527: 1  0F6A	33		                rlc     a
 4528: 1  0F6B	F9		                mov     r1,a
 4529: 1  0F6C	EA		                mov     a,r2
 4530: 1  0F6D	33		                rlc     a
 4531: 1  0F6E	FA		                mov     r2,a
 4532: 1  0F6F	EB		                mov     a,r3
 4533: 1  0F70	33		                rlc     a
 4534: 1  0F71	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4535: 1
 4536: 1  0F72	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4537: 1  0F73	33		                rlc     a
 4538: 1  0F74	FC		                mov     r4,a
 4539: 1  0F75	ED		                mov     a,r5
 4540: 1  0F76	33		                rlc     a
 4541: 1  0F77	FD		                mov     r5,a
 4542: 1  0F78	EE		                mov     a,r6
 4543: 1  0F79	33		                rlc     a
 4544: 1  0F7A	FE		                mov     r6,a
 4545: 1  0F7B	EF		                mov     a,r7
 4546: 1  0F7C	33		                rlc     a
 4547: 1  0F7D	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4548: 1  0F7E	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4549: 1
 4550: 1  0F81	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4551: 1
 4552: 1  0F83	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4553: 1  0F84	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4554: 1  0F86	33		                rlc     a
 4555: 1  0F87	F5 82		                mov     dpl,a
 4556: 1  0F89	E5 83		                mov     a,dph
 4557: 1  0F8B	33		                rlc     a
 4558: 1  0F8C	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4559: 1
 4560: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4561: 1  0F8E	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4562: 1  0F8F	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4563: 1  0F91	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4564: 1  0F92	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4565: 1  0F94	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4566: 1  0F95	C0 E0		                push    acc             ;van acc1
 4567: 1  0F97	EB		                mov     a,r3
 4568: 1  0F98	C0 E0		                push    acc
 4569: 1  0F9A	EC		                mov     a,r4
 4570: 1  0F9B	C0 E0		                push    acc
 4571: 1  0F9D	ED		                mov     a,r5
 4572: 1  0F9E	C0 E0		                push    acc
 4573: 1  0FA0	EE		                mov     a,r6
 4574: 1  0FA1	C0 E0		                push    acc
 4575: 1  0FA3	EF		                mov     a,r7
 4576: 1  0FA4	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4577: 1
 4578: 1  0FA6	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4579: 1  0FA8	AD 83		                mov     r5,dph
 4580: 1  0FAA	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4581: 1  0FAC	AF 83		                mov     r7,dph
 4582: 1  0FAE	12 0A EF	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4583: 1
 4584: 1  0FB1	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4585: 1  0FB3	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4586: 1  0FB4	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4587: 1  0FB6	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4588: 1  0FB7	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4589: 1  0FB9	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4590: 1  0FBA	D0 E0		                pop     acc             ;de stack...
 4591: 1  0FBC	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4592: 1
 4593: 1  0FBD	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4594: 1  0FBE	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4595: 1  0FBF	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4596: 1  0FC0	E9		                mov     a,r1            ;in acc1.
 4597: 1  0FC1	9D		                subb    a,r5            ;We doen dit door de carry van het
 4598: 1  0FC2	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4599: 1  0FC3	9E		                subb    a,r6
 4600: 1  0FC4	EB		                mov     a,r3
 4601: 1  0FC5	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4602: 1  0FC6	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4603: 1			                                        ;wortel behouden
 4604: 1  0FC8	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4605: 1  0FCA	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4606: 1  0FCC	F5 82		                mov     dpl,a          ;wortel aanpassen
 4607: 1
 4608: 1  0FCE	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4609: 1  0FD0	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4610: 1  0FD2	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4611: 1
 4612: 1  0FD4	D0 E0		                pop     acc            ;haal acc1 weer op
 4613: 1  0FD6	FF		                mov     r7,a
 4614: 1  0FD7	D0 E0		                pop     acc
 4615: 1  0FD9	FE		                mov     r6,a
 4616: 1  0FDA	D0 E0		                pop     acc
 4617: 1  0FDC	FD		                mov     r5,a
 4618: 1  0FDD	D0 E0		                pop     acc
 4619: 1  0FDF	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4620: 1
 4621: 1  0FE0	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4622: 1  0FE2	FB		                mov     r3,a
 4623: 1  0FE3	D0 E0		                pop     acc
 4624: 1  0FE5	FA		                mov     r2,a
 4625: 1  0FE6	D0 E0		                pop     acc
 4626: 1  0FE8	F9		                mov     r1,a
 4627: 1  0FE9	D0 E0		                pop     acc
 4628: 1  0FEB	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4629: 1
 4630: 1  0FEC	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4631: 1  0FEF	80 03		                sjmp    sqrt325
 4632: 1  0FF1	02 0F 60	sqrt324:        ljmp    sqrt320        ;uit acc0
 4633: 1
 4634: 1  0FF4	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4635: 1  0FF6	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4636: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4637: 1  0FF8	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4638: 1  0FFA	FF		                mov     r7,a
 4639: 1  0FFB	D0 E0		                pop     acc
 4640: 1  0FFD	FE		                mov     r6,a
 4641: 1  0FFE	D0 E0		                pop     acc
 4642: 1  1000	FD		                mov     r5,a
 4643: 1  1001	D0 E0		                pop     acc
 4644: 1  1003	FC		                mov     r4,a           ;acc1 is hersteld
 4645: 1  1004	D0 83		                pop     dph
 4646: 1  1006	D0 82		                pop     dpl
 4647: 1  1008	D0 D0		                pop     psw
 4648: 1  100A	D0 F0		                pop     b
 4649: 1  100C	D0 E0		                pop     acc
 4650: 1
 4651: 1  100E	22		                ret                    ;eindelijk klaar...
 4652: 1
 4653: 1			;*******************************************************************************
 4654: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4655: 1			; acc0 = acc0 ^(1/2)
 4656: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4657: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4658: 1			;                           (-2147483648 tot +2147483647)
 4659: 1			; input:     r3,r2,r1,r0 = acc0
 4660: 1			;
 4661: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4662: 1			;            CY = 1 als acc0 negatief is
 4663: 1			; vernietigt:  niets
 4664: 1			;*******************************************************************************
 4665: 1  100F	C0 E0		s_sqrt32:       push    acc
 4666: 1  1011	C0 D0		                push    psw
 4667: 1  1013	EB		                mov     a,r3
 4668: 1  1014	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4669: 1  1017	D0 D0		                pop     psw
 4670: 1  1019	D3		                setb    c                ;als negatief dan error
 4671: 1  101A	D0 E0		                pop     acc
 4672: 1  101C	22		                ret
 4673: 1  101D	D0 D0		s_sqrt321:      pop     psw
 4674: 1  101F	D0 E0		                pop     acc
 4675: 1  1021	12 0F 39	                lcall   sqrt32            ;wortel trekken
 4676: 1  1024	C3		                clr     c                 ;wortel ok
 4677: 1  1025	22		                ret                       ;klaar
 4678: 1
 4679: 1			;*******************************************************************************
 4680: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4681: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4682: 1			; (logical shift)
 4683: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4684: 1			;
 4685: 1			; input:     r3,r2,r1,r0 = acc0
 4686: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4687: 1			;
 4688: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4689: 1			;            CY=1 als N>=32
 4690: 1			; vernietigt:  niets
 4691: 1			;*******************************************************************************
 4692: 1  1026	C0 E0		shiftright32:   push    acc             ;bewaren van de registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4693: 1  1028	C0 D0		                push    psw
 4694: 1  102A	EC		                mov     a,r4            ;neem aantal shifts
 4695: 1  102B	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4696: 1  102E	40 06		shiftright1:    jc      shiftright2
 4697: 1  1030	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4698: 1  1032	D3		                setb    c               ;N buiten bereik
 4699: 1  1033	D0 E0		                pop     acc
 4700: 1  1035	22		                ret
 4701: 1
 4702: 1  1036	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4703: 1  1038	8C F0		                mov     b,r4            ;lusteller initialiseren
 4704: 1  103A	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4705: 1  103B	EB		                mov     a,r3            ;start bij msb
 4706: 1  103C	13		                rrc     a
 4707: 1  103D	FB		                mov     r3,a
 4708: 1  103E	EA		                mov     a,r2
 4709: 1  103F	13		                rrc     a
 4710: 1  1040	FA		                mov     r2,a
 4711: 1  1041	E9		                mov     a,r1
 4712: 1  1042	13		                rrc     a
 4713: 1  1043	F9		                mov     r1,a
 4714: 1  1044	E8		                mov     a,r0
 4715: 1  1045	13		                rrc     a
 4716: 1  1046	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4717: 1  1047	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4718: 1  104A	D0 F0		                pop     b               ;registers herstellen
 4719: 1  104C	D0 D0		                pop     psw
 4720: 1  104E	C3		                clr     c               ;N is binnen bereik
 4721: 1  104F	D0 E0		                pop     acc
 4722: 1  1051	22		                ret
 4723: 1
 4724: 1			;*******************************************************************************
 4725: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4726: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4727: 1			; (logical shift)
 4728: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4729: 1			;
 4730: 1			; input:     r3,r2,r1,r0 = acc0
 4731: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4732: 1			;
 4733: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4734: 1			;
 4735: 1			; vernietigt:  niets
 4736: 1			;*******************************************************************************
 4737: 1  1052	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4738: 1  1054	C0 D0		                push    psw
 4739: 1  1056	EC		                mov     a,r4            ;neem aantal shifts
 4740: 1  1057	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4741: 1  105A	40 06		shiftleft1:     jc      shiftleft2
 4742: 1  105C	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4743: 1  105E	D3		                setb    c               ;N buiten bereik
 4744: 1  105F	D0 E0		                pop     acc
 4745: 1  1061	22		                ret
 4746: 1
 4747: 1  1062	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4748: 1  1064	8C F0		                mov     b,r4            ;lusteller initialiseren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4749: 1  1066	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4750: 1  1067	E8		                mov     a,r0            ;start bij lsb
 4751: 1  1068	33		                rlc     a
 4752: 1  1069	F8		                mov     r0,a
 4753: 1  106A	E9		                mov     a,r1
 4754: 1  106B	33		                rlc     a
 4755: 1  106C	F9		                mov     r1,a
 4756: 1  106D	EA		                mov     a,r2
 4757: 1  106E	33		                rlc     a
 4758: 1  106F	FA		                mov     r2,a
 4759: 1  1070	EB		                mov     a,r3
 4760: 1  1071	33		                rlc     a
 4761: 1  1072	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4762: 1  1073	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4763: 1  1076	D0 F0		                pop     b               ;registers herstellen
 4764: 1  1078	D0 D0		                pop     psw
 4765: 1  107A	C3		                clr     c               ;N is binnen bereik
 4766: 1  107B	D0 E0		                pop     acc
 4767: 1  107D	22		                ret
 4768: 1
 4769: 1			;*******************************************************************************
 4770: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4771: 1			; (arithmetic shift)
 4772: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4773: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4774: 1			; niet van teken!
 4775: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4776: 1			;                       (-2147483648 tot +2147483647)
 4777: 1			;
 4778: 1			; input:     r3,r2,r1,r0 = acc0
 4779: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4780: 1			;
 4781: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4782: 1			;            CY=1 als N>=31
 4783: 1			; vernietigt:  niets
 4784: 1			;*******************************************************************************
 4785: 1  107E	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 4786: 1  1080	C0 D0		                push    psw
 4787: 1  1082	EC		                mov     a,r4            ;neem aantal shifts
 4788: 1  1083	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4789: 1  1086	40 06		s_shiftright1:  jc      s_shiftright2
 4790: 1  1088	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4791: 1  108A	D3		                setb    c               ;N buiten bereik
 4792: 1  108B	D0 E0		                pop     acc
 4793: 1  108D	22		                ret
 4794: 1
 4795: 1  108E	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4796: 1  1090	8C F0		                mov     b,r4            ;lusteller initialiseren
 4797: 1  1092	EB		                mov     a,r3
 4798: 1  1093	20 E7 04	                jb      acc.7,s_shiftright20
 4799: 1  1096	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4800: 1  1098	80 02		                sjmp    s_shiftright3
 4801: 1  109A	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4802: 1
 4803: 1  109C	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4804: 1  109E	EB		                mov     a,r3            ;start bij msb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4805: 1  109F	13		                rrc     a
 4806: 1  10A0	FB		                mov     r3,a
 4807: 1  10A1	EA		                mov     a,r2
 4808: 1  10A2	13		                rrc     a
 4809: 1  10A3	FA		                mov     r2,a
 4810: 1  10A4	E9		                mov     a,r1
 4811: 1  10A5	13		                rrc     a
 4812: 1  10A6	F9		                mov     r1,a
 4813: 1  10A7	E8		                mov     a,r0
 4814: 1  10A8	13		                rrc     a
 4815: 1  10A9	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4816: 1  10AA	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4817: 1  10AD	D0 F0		                pop     b               ;registers herstellen
 4818: 1  10AF	D0 D0		                pop     psw
 4819: 1  10B1	C3		                clr     c               ;N is binnen bereik
 4820: 1  10B2	D0 E0		                pop     acc
 4821: 1  10B4	22		                ret
 4822: 1
 4823: 1			;*******************************************************************************
 4824: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4825: 1			; (arithmetic shift)
 4826: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4827: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 4828: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4829: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4830: 1			;                       (-2147483648 tot +2147483647)
 4831: 1			;
 4832: 1			; input:     r3,r2,r1,r0 = acc0
 4833: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4834: 1			;
 4835: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4836: 1			;            CY=1 als N>=31
 4837: 1			; vernietigt:  niets
 4838: 1			;*******************************************************************************
 4839: 1  10B5	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 4840: 1  10B7	C0 D0		                push    psw
 4841: 1  10B9	EC		                mov     a,r4            ;neem aantal shifts
 4842: 1  10BA	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4843: 1  10BD	40 06		s_shiftleft1:   jc      s_shiftleft2
 4844: 1  10BF	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4845: 1  10C1	D3		                setb    c               ;N buiten bereik
 4846: 1  10C2	D0 E0		                pop     acc
 4847: 1  10C4	22		                ret
 4848: 1
 4849: 1  10C5	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4850: 1  10C7	8C F0		                mov     b,r4            ;lusteller initialiseren
 4851: 1
 4852: 1
 4853: 1
 4854: 1  10C9	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4855: 1  10CA	E8		                mov     a,r0             ;start bij lsb
 4856: 1  10CB	33		                rlc     a
 4857: 1  10CC	F8		                mov     r0,a
 4858: 1  10CD	E9		                mov     a,r1
 4859: 1  10CE	33		                rlc     a
 4860: 1  10CF	F9		                mov     r1,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4861: 1  10D0	EA		                mov     a,r2
 4862: 1  10D1	33		                rlc     a
 4863: 1  10D2	FA		                mov     r2,a
 4864: 1  10D3	EB		                mov     a,r3
 4865: 1  10D4	33		                rlc     a
 4866: 1  10D5	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4867: 1  10D7	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4868: 1  10D8	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4869: 1  10DB	D0 F0		                pop     b                ;registers herstellen
 4870: 1  10DD	D0 D0		                pop     psw
 4871: 1  10DF	C3		                clr     c                ;N is binnen bereik
 4872: 1  10E0	D0 E0		                pop     acc
 4873: 1  10E2	22		                ret
 4874: 1
 4875: 1			;*******************************************************************************
 4876: 1			; s_cmp16    (29,5us @16.777216MHz)
 4877: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4878: 1			;
 4879: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4880: 1			;
 4881: 1			; input:     r1,r0 = acc0
 4882: 1			;            r5,r4 = acc1
 4883: 1			;
 4884: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4885: 1			;             f0=0,cy=0  als acc0 > acc1
 4886: 1			;             f0=1 cy=0    als acc1 = acc0
 4887: 1			;
 4888: 1			; vernietigt:  niets
 4889: 1			;*******************************************************************************
 4890: 1  10E3	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4891: 1  10E5	C0 D0		                push    psw
 4892: 1  10E7	E8		                mov     a,r0
 4893: 1  10E8	C0 E0		                push    acc
 4894: 1  10EA	E9		                mov     a,r1
 4895: 1  10EB	C0 E0		                push    acc
 4896: 1
 4897: 1  10ED	E9		                mov     a,r1            ;neem msb van acc0
 4898: 1  10EE	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4899: 1  10EF	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4900: 1  10F2	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4901: 1			                                        ;negatief is
 4902: 1  10F3	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4903: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4904: 1
 4905: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4906: 1			;acc0>acc1
 4907: 1  10F6	D0 E0		s_cmp160:       pop     acc
 4908: 1  10F8	F9		                mov     r1,a
 4909: 1  10F9	D0 E0		                pop     acc
 4910: 1  10FB	F8		                mov     r0,a
 4911: 1  10FC	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4912: 1  10FE	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4913: 1  1100	C3		                clr     c               ;geef dit aan in de outputstatus
 4914: 1  1101	D0 E0		                pop     acc
 4915: 1  1103	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4916: 1			;acc0<acc1
 4917: 1  1104	D0 E0		s_cmp161:       pop     acc
 4918: 1  1106	F9		                mov     r1,a
 4919: 1  1107	D0 E0		                pop     acc
 4920: 1  1109	F8		                mov     r0,a
 4921: 1  110A	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4922: 1  110C	D3		                setb    c               ;groter dan acc0
 4923: 1  110D	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4924: 1  110F	D0 E0		                pop     acc
 4925: 1  1111	22		                ret
 4926: 1			;gelijk teken, maak verschil
 4927: 1  1112	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 4928: 1  1113	E8		                mov     a,r0            ;acc0-acc1
 4929: 1  1114	9C		                subb    a,r4
 4930: 1  1115	F8		                mov     r0,a
 4931: 1  1116	E9		                mov     a,r1
 4932: 1  1117	9D		                subb    a,r5
 4933: 1  1118	F9		                mov     r1,a
 4934: 1  1119	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 4935: 1  111C	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 4936: 1  111D	60 02		                jz      s_cmp163        ;acc0=acc1
 4937: 1  111F	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 4938: 1			;acc0=acc1
 4939: 1  1121	D0 E0		s_cmp163:       pop     acc
 4940: 1  1123	F9		                mov     r1,a
 4941: 1  1124	D0 E0		                pop     acc
 4942: 1  1126	F8		                mov     r0,a
 4943: 1  1127	D0 D0		                pop     psw             ;acc0=acc1
 4944: 1  1129	C3		                clr     c               ;geef dit aan in de outputstatus
 4945: 1  112A	D2 D5		                setb    f0
 4946: 1  112C	D0 E0		                pop     acc
 4947: 1  112E	22		                ret
 4948: 1
 4949: 1			;*******************************************************************************
 4950: 1			; cmp16            (19,9us @16.777216MHz)
 4951: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 4952: 1			;
 4953: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 4954: 1			;
 4955: 1			; input:     r1,r0 = acc0
 4956: 1			;            r5,r4 = acc1
 4957: 1			;
 4958: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4959: 1			;             f0=0,cy=0  als acc0 > acc1
 4960: 1			;             f0=1 cy=0    als acc1 = acc0
 4961: 1			;
 4962: 1			; vernietigt:  niets
 4963: 1			;*******************************************************************************
 4964: 1  112F	C0 E0		cmp16:          push    acc             ;bewaar registers
 4965: 1  1131	C0 F0		                push    b
 4966: 1  1133	C0 D0		                push    psw
 4967: 1
 4968: 1  1135	C3		                clr     c               ;vergelijk acc0 met acc1
 4969: 1  1136	E9		                mov     a,r1            ;eerst de msb's
 4970: 1  1137	8D F0		                mov     b,r5            ;test r1-r5
 4971: 1  1139	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4972: 1
 4973: 1  113C	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 4974: 1  113D	8C F0		                mov     b,r4            ;test r0-r4
 4975: 1  113F	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4976: 1			;acc0=acc1
 4977: 1  1142	D0 D0		                pop     psw
 4978: 1  1144	D2 D5		                setb    f0
 4979: 1  1146	C3		                clr     c
 4980: 1  1147	D0 F0		                pop     b
 4981: 1  1149	D0 E0		                pop     acc
 4982: 1  114B	22		                ret
 4983: 1  114C	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 4984: 1			;acc0>acc1
 4985: 1  114E	D0 D0		                pop     psw
 4986: 1  1150	C2 D5		                clr     f0
 4987: 1  1152	C3		                clr     c
 4988: 1  1153	D0 F0		                pop     b
 4989: 1  1155	D0 E0		                pop     acc
 4990: 1  1157	22		                ret
 4991: 1			;acc0<acc1
 4992: 1  1158	D0 D0		cmp162:         pop     psw
 4993: 1  115A	D3		                setb    c
 4994: 1  115B	C2 D5		                clr     f0
 4995: 1  115D	D0 F0		                pop     b
 4996: 1  115F	D0 E0		                pop     acc
 4997: 1  1161	22		                ret
 4998: 1
 4999: 1			;*******************************************************************************
 5000: 1			; s_cmp32        (44,3us @16.777216MHz)
 5001: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 5002: 1			;
 5003: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 5004: 1			;                         -2147483648 tot +2147483647
 5005: 1			; input:     r1,r0 = acc0
 5006: 1			;            r5,r4 = acc1
 5007: 1			;
 5008: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5009: 1			;             f0=0,cy=0  als acc0 > acc1
 5010: 1			;             f0=1 cy=0    als acc1 = acc0
 5011: 1			;
 5012: 1			; vernietigt:  niets
 5013: 1			;*******************************************************************************
 5014: 1  1162	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 5015: 1  1164	C0 D0		                push    psw
 5016: 1  1166	E8		                mov     a,r0
 5017: 1  1167	C0 E0		                push    acc
 5018: 1  1169	E9		                mov     a,r1
 5019: 1  116A	C0 E0		                push    acc
 5020: 1  116C	EA		                mov     a,r2
 5021: 1  116D	C0 E0		                push    acc
 5022: 1  116F	EB		                mov     a,r3
 5023: 1  1170	C0 E0		                push    acc
 5024: 1
 5025: 1  1172	EB		                mov     a,r3            ;neem msb van acc0
 5026: 1  1173	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 5027: 1  1174	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5028: 1  1176	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 5029: 1  1178	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 5030: 1  1179	A2 E7		                mov     c,acc.7         ;negatief is
 5031: 1  117B	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 5032: 1			                                        ;acc1 positief. Dus acc1>acc0
 5033: 1			;acc0>acc1
 5034: 1  117D	D0 E0		s_cmp320:       pop     acc
 5035: 1  117F	FB		                mov     r3,a
 5036: 1  1180	D0 E0		                pop     acc
 5037: 1  1182	FA		                mov     r2,a
 5038: 1  1183	D0 E0		                pop     acc
 5039: 1  1185	F9		                mov     r1,a
 5040: 1  1186	D0 E0		                pop     acc
 5041: 1  1188	F8		                mov     r0,a
 5042: 1  1189	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5043: 1  118B	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5044: 1  118D	C3		                clr     c               ;geef dit aan in de outputstatus
 5045: 1  118E	D0 E0		                pop     acc
 5046: 1  1190	22		                ret
 5047: 1			;acc0<acc1
 5048: 1  1191	D0 E0		s_cmp321:       pop     acc
 5049: 1  1193	FB		                mov     r3,a
 5050: 1  1194	D0 E0		                pop     acc
 5051: 1  1196	FA		                mov     r2,a
 5052: 1  1197	D0 E0		                pop     acc
 5053: 1  1199	F9		                mov     r1,a
 5054: 1  119A	D0 E0		                pop     acc
 5055: 1  119C	F8		                mov     r0,a
 5056: 1  119D	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5057: 1  119F	D3		                setb    c               ;groter dan acc0
 5058: 1  11A0	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5059: 1  11A2	D0 E0		                pop     acc
 5060: 1  11A4	22		                ret
 5061: 1			;gelijk teken, maak verschil
 5062: 1  11A5	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5063: 1  11A6	E8		                mov     a,r0            ;acc0-acc1
 5064: 1  11A7	9C		                subb    a,r4
 5065: 1  11A8	F8		                mov     r0,a
 5066: 1  11A9	E9		                mov     a,r1
 5067: 1  11AA	9D		                subb    a,r5
 5068: 1  11AB	F9		                mov     r1,a
 5069: 1  11AC	EA		                mov     a,r2
 5070: 1  11AD	9E		                subb    a,r6
 5071: 1  11AE	FA		                mov     r2,a
 5072: 1  11AF	EB		                mov     a,r3
 5073: 1  11B0	9F		                subb    a,r7
 5074: 1  11B1	FB		                mov     r3,a
 5075: 1  11B2	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5076: 1  11B5	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5077: 1  11B6	49		                orl     a,r1
 5078: 1  11B7	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5079: 1  11B8	60 02		                jz      s_cmp323        ;acc0=acc1
 5080: 1  11BA	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5081: 1			;acc0=acc1
 5082: 1  11BC	D0 E0		s_cmp323:       pop     acc
 5083: 1  11BE	FB		                mov     r3,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5084: 1  11BF	D0 E0		                pop     acc
 5085: 1  11C1	FA		                mov     r2,a
 5086: 1  11C2	D0 E0		                pop     acc
 5087: 1  11C4	F9		                mov     r1,a
 5088: 1  11C5	D0 E0		                pop     acc
 5089: 1  11C7	F8		                mov     r0,a
 5090: 1  11C8	D0 D0		                pop     psw             ;acc0=acc1
 5091: 1  11CA	C3		                clr     c               ;geef dit aan in de outputstatus
 5092: 1  11CB	D2 D5		                setb    f0
 5093: 1  11CD	D0 E0		                pop     acc
 5094: 1  11CF	22		                ret
 5095: 1
 5096: 1			;*******************************************************************************
 5097: 1			; cmp32        (27,14us @16.777216MHz)
 5098: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5099: 1			;
 5100: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5101: 1			;
 5102: 1			; input:     r3,r2,r1,r0 = acc0
 5103: 1			;            r7,r6,r5,r4 = acc1
 5104: 1			;
 5105: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5106: 1			;            f0=0,cy=0  als acc0 > acc1
 5107: 1			;            f0=1 cy=0    als acc1 = acc0
 5108: 1			;
 5109: 1			; vernietigt:  niets
 5110: 1			;*******************************************************************************
 5111: 1  11D0	C0 E0		cmp32:          push    acc             ;bewaar registers
 5112: 1  11D2	C0 F0		                push    b
 5113: 1  11D4	C0 D0		                push    psw
 5114: 1
 5115: 1  11D6	C3		                clr     c               ;vergelijk acc0 met acc1
 5116: 1  11D7	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5117: 1  11D8	8F F0		                mov     b,r7            ;test r3-r7
 5118: 1  11DA	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5119: 1
 5120: 1  11DD	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5121: 1  11DE	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5122: 1  11E0	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5123: 1
 5124: 1  11E3	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5125: 1  11E4	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5126: 1  11E6	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5127: 1
 5128: 1  11E9	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5129: 1  11EA	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5130: 1  11EC	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5131: 1			;acc0=acc1
 5132: 1  11EF	D0 D0		                pop     psw
 5133: 1  11F1	D2 D5		                setb    f0
 5134: 1  11F3	C3		                clr     c
 5135: 1  11F4	D0 F0		                pop     b
 5136: 1  11F6	D0 E0		                pop     acc
 5137: 1  11F8	22		                ret
 5138: 1  11F9	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5139: 1			;acc0>acc1, indien cy=0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5140: 1  11FB	D0 D0		                pop     psw
 5141: 1  11FD	C2 D5		                clr     f0
 5142: 1  11FF	C3		                clr     c
 5143: 1  1200	D0 F0		                pop     b
 5144: 1  1202	D0 E0		                pop     acc
 5145: 1  1204	22		                ret
 5146: 1			;acc0<acc1
 5147: 1  1205	D0 D0		cmp322:         pop     psw
 5148: 1  1207	D3		                setb    c
 5149: 1  1208	C2 D5		                clr     f0
 5150: 1  120A	D0 F0		                pop     b
 5151: 1  120C	D0 E0		                pop     acc
 5152: 1  120E	22		                ret
 5153: 1
 5154: 1
 5155: 1			;*******************************************************************************
 5156: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5157: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5158: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5159: 1			; adres zitten.
 5160: 1			;
 5161: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5162: 1			;
 5163: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5164: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5165: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5166: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5167: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5168: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5169: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5170: 1			;                cy = 0  lookup is ok
 5171: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5172: 1			; vernietigt:  niets
 5173: 1			;*******************************************************************************
 5174: 1  120F	C0 E0		table_lu:       push    acc             ;bewaren registers
 5175: 1  1211	C0 D0		                push    psw
 5176: 1  1213	C0 82		                push    dpl
 5177: 1  1215	C0 83		                push    dph
 5178: 1
 5179: 1  1217	A2 D5		                mov     c,f0            ;byte of word items?
 5180: 1  1219	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5181: 1			;tabel met byte items
 5182: 1  121B	E5 82		                mov     a,dpl           ;datapointer plus index
 5183: 1  121D	28		                add     a,r0
 5184: 1  121E	F5 82		                mov     dpl,a
 5185: 1  1220	E5 83		                mov     a,dph
 5186: 1  1222	39		                addc    a,r1
 5187: 1  1223	F5 83		                mov     dph,a
 5188: 1  1225	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5189: 1  1227	A2 D1		                mov     c,f1            ;code of datageheugen?
 5190: 1  1229	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5191: 1
 5192: 1			;bytetabel in codegeheugen
 5193: 1  122B	74 00		                mov     a,#0
 5194: 1  122D	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5195: 1  122E	F8		                mov     r0,a            ;en stop in acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5196: 1  122F	79 00		                mov     r1,#0
 5197: 1  1231	02 12 90	                ljmp    table_lu4       ;en klaar
 5198: 1
 5199: 1			;bytetabel in datageheugen
 5200: 1  1234	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5201: 1  1235	F8		                mov     r0,a            ;en stop in acc0
 5202: 1  1236	79 00		                mov     r1,#0
 5203: 1  1238	02 12 90	                ljmp    table_lu4       ;en klaar
 5204: 1
 5205: 1  123B	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5206: 1  123D	D0 82		                pop     dpl
 5207: 1  123F	D0 D0		                pop     psw
 5208: 1  1241	D3		                setb    c              ;foutstatus teruggeven!
 5209: 1  1242	D0 E0		                pop     acc
 5210: 1  1244	22		                ret
 5211: 1
 5212: 1			;tabel met word items
 5213: 1  1245	E8		table_lu2:      mov     a,r0            ;index op stack
 5214: 1  1246	C0 E0		                push    acc
 5215: 1  1248	E9		                mov     a,r1
 5216: 1  1249	C0 E0		                push    acc
 5217: 1
 5218: 1  124B	C3		                clr      c              ;index maal 2 (word items)
 5219: 1  124C	E8		                mov     a,r0
 5220: 1  124D	33		                rlc     a
 5221: 1  124E	F8		                mov     r0,a
 5222: 1  124F	E9		                mov     a,r1
 5223: 1  1250	33		                rlc     a
 5224: 1  1251	F9		                mov     r1,a
 5225: 1
 5226: 1  1252	E5 82		                mov     a,dpl           ;datapointer plus index
 5227: 1  1254	28		                add     a,r0
 5228: 1  1255	F5 82		                mov     dpl,a
 5229: 1  1257	E5 83		                mov     a,dph
 5230: 1  1259	39		                addc    a,r1
 5231: 1  125A	F5 83		                mov     dph,a
 5232: 1
 5233: 1  125C	D0 E0		                pop     acc             ;index weer van stack
 5234: 1  125E	F9		                mov     r1,a
 5235: 1  125F	D0 E0		                pop     acc
 5236: 1  1261	F8		                mov     r0,a
 5237: 1
 5238: 1  1262	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5239: 1  1264	A2 D1		                mov     c,f1            ;code of datageheugen?
 5240: 1  1266	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5241: 1			;wordtabel in codegeheugen
 5242: 1  1268	74 00		                mov     a,#0
 5243: 1  126A	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5244: 1  126B	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5245: 1  126C	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5246: 1  126E	24 01		                add     a,#1
 5247: 1  1270	F5 82		                mov     dpl,a
 5248: 1  1272	E5 83		                mov     a,dph
 5249: 1  1274	34 00		                addc    a,#0
 5250: 1  1276	F5 83		                mov     dph,a
 5251: 1  1278	74 00		                mov     a,#0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5252: 1  127A	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5253: 1  127B	F9		                mov     r1,a            ;msb in acc0 stoppen
 5254: 1  127C	80 12		                sjmp    table_lu4        ;en klaar
 5255: 1			;wordtabel    in datageheugen
 5256: 1  127E	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5257: 1  127F	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5258: 1  1280	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5259: 1  1282	24 01		                add     a,#1
 5260: 1  1284	F5 82		                mov     dpl,a
 5261: 1  1286	E5 83		                mov     a,dph
 5262: 1  1288	34 00		                addc    a,#0
 5263: 1  128A	F5 83		                mov     dph,a
 5264: 1  128C	74 00		                mov     a,#0
 5265: 1  128E	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5266: 1  128F	F9		                mov     r1,a            ;msb in acc0 stoppen
 5267: 1			                                        ;en klaar
 5268: 1
 5269: 1  1290	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5270: 1  1292	D0 82		                pop     dpl
 5271: 1  1294	D0 D0		                pop     psw
 5272: 1  1296	D0 E0		                pop     acc
 5273: 1  1298	22		                ret
 5274: 1
 5275: 1
 5276: 1
 5277: 1			;*******************************************************************************
 5278: 1			; Cordic        (2,11ms @16.777216MHz)
 5279: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5280: 1			; waarde (2's complement) opgegeven hoek.
 5281: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5282: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5283: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5284: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5285: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5286: 1			; als geschaalde getallen ter beschikking komen.
 5287: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5288: 1			;
 5289: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5290: 1			;
 5291: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5292: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5293: 1			;            cy = 0 : hoek binnen bereik
 5294: 1			;            cy = 1 : error, hoek buiten bereik
 5295: 1			;            nauwkeurigheid: 12 msbits
 5296: 1			; vernietigt:  niets
 5297: 1			;*******************************************************************************
 5298: 1  1299	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5299: 1  129B	C0 D0		                push    psw
 5300: 1  129D	C0 83		                push    dph
 5301: 1  129F	C0 82		                push    dpl
 5302: 1  12A1	C0 F0		                push    b
 5303: 1
 5304: 1  12A3	EF		                mov     a,r7
 5305: 1  12A4	C0 E0		                push    acc
 5306: 1  12A6	EE		                mov     a,r6
 5307: 1  12A7	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5308: 1  12A9	ED		                mov     a,r5
 5309: 1  12AA	C0 E0		                push    acc
 5310: 1  12AC	EC		                mov     a,r4
 5311: 1  12AD	C0 E0		                push    acc
 5312: 1
 5313: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5314: 1			;en niet groter dan pi/2 radialen (6478h)
 5315: 1  12AF	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5316: 1  12B1	7D 64		                mov     r5,#64h
 5317: 1  12B3	12 11 2F	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5318: 1  12B6	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5319: 1  12B9	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5320: 1  12BB	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5321: 1
 5322: 1  12BD	C2 A0		cordic000:      clr     p2.0
 5323: 1  12BF	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5324: 1  12C1	7D 9B		                mov     r5,#9bh
 5325: 1  12C3	12 11 2F	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5326: 1  12C6	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5327: 1  12C9	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5328: 1  12CB	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5329: 1
 5330: 1  12CD	C2 A1		cordic_error:   clr     p2.1
 5331: 1  12CF	02 13 81	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5332: 1
 5333: 1			;Hoek is -pi/2 resultaat gekend
 5334: 1  12D2	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5335: 1  12D4	7A 00		                mov     r2,#000h
 5336: 1  12D6	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5337: 1  12D8	78 00		                mov     r0,#000h
 5338: 1  12DA	C3		                clr     c
 5339: 1  12DB	02 13 81	                ljmp    cordic40        ;en klaar
 5340: 1			;hoek is +pi/2 resultaat gekend
 5341: 1  12DE	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5342: 1  12E0	7A FF		                mov     r2,#0ffh
 5343: 1  12E2	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5344: 1  12E4	78 00		                mov     r0,#000h
 5345: 1  12E6	C3		                clr     c
 5346: 1  12E7	02 13 81	                ljmp    cordic40        ;en klaar
 5347: 1
 5348: 1  12EA	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5349: 1  12EC	7D 00		                mov     r5,#00h
 5350: 1  12EE	12 11 2F	                lcall   cmp16            ;vergelijk de hoeken
 5351: 1  12F1	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5352: 1  12F4	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5353: 1			;hoek is 0, resultaat gekend
 5354: 1  12F6	C2 A7		cordic_nul:     clr     p2.7
 5355: 1  12F8	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5356: 1  12FA	7A 00		                mov     r2,#000h
 5357: 1  12FC	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5358: 1  12FE	78 FF		                mov     r0,#0ffh
 5359: 1  1300	C3		                clr     c
 5360: 1  1301	02 13 81	                ljmp    cordic40        ;en klaar
 5361: 1
 5362: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5363: 1  1304	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5364: 1  1305	C0 E0		                push    acc
 5365: 1  1307	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5366: 1  1308	C0 E0		                push    acc
 5367: 1
 5368: 1  130A	7B 00		                mov     r3,#00h         ;y=0
 5369: 1  130C	7A 00		                mov     r2,#00h
 5370: 1  130E	79 26		                mov     r1,#026h        ;x = K * 2^14
 5371: 1  1310	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5372: 1
 5373: 1  1312	75 F0 00	                mov     b,#00h          ;loopteller=0
 5374: 1
 5375: 1  1315	90 13 D9	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5376: 1
 5377: 1  1318	EB		cordic1:        mov     a,r3            ;sry=y
 5378: 1  1319	FF		                mov     r7,a
 5379: 1  131A	EA		                mov     a,r2
 5380: 1  131B	FE		                mov     r6,a
 5381: 1  131C	E9		                mov     a,r1            ;srx=x
 5382: 1  131D	FD		                mov     r5,a
 5383: 1  131E	E8		                mov     a,r0
 5384: 1  131F	FC		                mov     r4,a
 5385: 1
 5386: 1  1320	12 13 A0	                lcall   cordic5          ;srx en sry >> loopteller
 5387: 1
 5388: 1  1323	D0 E0		                pop     acc
 5389: 1  1325	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5390: 1
 5391: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5392: 1  1328	C3		                clr     c
 5393: 1  1329	E8		                mov     a,r0            ;bereken x=x-sry
 5394: 1  132A	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5395: 1  132B	F8		                mov     r0,a
 5396: 1  132C	E9		                mov     a,r1
 5397: 1  132D	9F		                subb    a,r7
 5398: 1  132E	F9		                mov     r1,a
 5399: 1
 5400: 1  132F	EA		                mov     a,r2            ;bereken y=y+srx
 5401: 1  1330	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5402: 1  1331	FA		                mov     r2,a
 5403: 1  1332	EB		                mov     a,r3
 5404: 1  1333	3D		                addc    a,r5
 5405: 1  1334	FB		                mov     r3,a
 5406: 1
 5407: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5408: 1  1335	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5409: 1  1337	93		                movc    a,@a+dptr
 5410: 1  1338	A3		                inc     dptr
 5411: 1  1339	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5412: 1  133A	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5413: 1  133C	C3		                clr     c               ;verklein de hoek
 5414: 1  133D	9C		                subb    a,r4
 5415: 1  133E	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5416: 1  1340	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5417: 1
 5418: 1  1342	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5419: 1  1344	93		                movc    a,@a+dptr

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5420: 1  1345	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5421: 1  1346	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5422: 1  1347	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5423: 1  1349	9D		                subb    a,r5            ;verklein de hoek
 5424: 1  134A	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5425: 1
 5426: 1			;loopteller incrementeren en testen op einde van de iteratie
 5427: 1  134C	05 F0		cordic2:        inc     b               ;loopteller++
 5428: 1  134E	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5429: 1  1350	65 F0		                xrl     a,b             ;test op gelijkheid
 5430: 1  1352	60 28		                jz      cordic4         ;ja klaar!
 5431: 1  1354	02 13 18	                ljmp    cordic1         ;nee, nog even verder...
 5432: 1
 5433: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5434: 1  1357	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5435: 1  1358	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5436: 1  1359	F8		                mov     r0,a
 5437: 1  135A	E9		                mov     a,r1
 5438: 1  135B	3F		                addc    a,r7
 5439: 1  135C	F9		                mov     r1,a
 5440: 1
 5441: 1  135D	C3		                clr     c
 5442: 1  135E	EA		                mov     a,r2            ;bereken y=y-srx
 5443: 1  135F	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5444: 1  1360	FA		                mov     r2,a
 5445: 1  1361	EB		                mov     a,r3
 5446: 1  1362	9D		                subb    a,r5
 5447: 1  1363	FB		                mov     r3,a
 5448: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5449: 1  1364	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5450: 1  1366	93		                movc    a,@a+dptr
 5451: 1  1367	A3		                inc     dptr
 5452: 1  1368	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5453: 1  1369	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5454: 1  136B	2C		                add     a,r4            ;vergroot de hoek
 5455: 1  136C	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5456: 1  136E	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5457: 1
 5458: 1  1370	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5459: 1  1372	93		                movc    a,@a+dptr
 5460: 1  1373	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5461: 1  1374	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5462: 1  1375	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5463: 1  1377	3D		                addc    a,r5            ;vergroot de hoek
 5464: 1  1378	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5465: 1
 5466: 1  137A	80 D0		                sjmp    cordic2
 5467: 1
 5468: 1  137C	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5469: 1  137E	D0 E0		                pop     acc             ;dummy hoek van stack
 5470: 1  1380	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5471: 1
 5472: 1  1381	D0 E0		cordic40:       pop     acc
 5473: 1  1383	FC		                mov     r4,a
 5474: 1  1384	D0 E0		                pop     acc
 5475: 1  1386	FD		                mov     r5,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5476: 1  1387	D0 E0		                pop     acc
 5477: 1  1389	FE		                mov     r6,a
 5478: 1  138A	D0 E0		                pop     acc
 5479: 1  138C	FF		                mov     r7,a
 5480: 1  138D	D0 F0		                pop     b
 5481: 1  138F	D0 82		                pop     dpl
 5482: 1  1391	D0 83		                pop     dph
 5483: 1  1393	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5484: 1  1395	D0 D0		                pop     psw
 5485: 1  1397	D0 E0		                pop     acc
 5486: 1  1399	22		                ret
 5487: 1
 5488: 1  139A	D0 D0		cordic41:       pop     psw
 5489: 1  139C	D3		                setb    c
 5490: 1  139D	D0 E0		                pop     acc
 5491: 1  139F	22		                ret
 5492: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5493: 1			;over het aantal posities aangegeven in het B register.
 5494: 1  13A0	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5495: 1  13A2	74 00		                mov     a,#0            ;test of loopteller=0
 5496: 1  13A4	65 F0		                xrl     a,b
 5497: 1  13A6	60 2E		                jz      cordic52        ;klaar
 5498: 1
 5499: 1  13A8	ED		                mov     a,r5            ;test teken van srx
 5500: 1  13A9	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5501: 1  13AC	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5502: 1  13AE	80 02		                sjmp    cordic50
 5503: 1  13B0	D2 D5		cordic5a:       setb    f0
 5504: 1  13B2	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5505: 1  13B4	ED		                mov     a,r5            ;eerst de msb
 5506: 1  13B5	13		                rrc     a
 5507: 1  13B6	FD		                mov     r5,a
 5508: 1  13B7	EC		                mov     a,r4            ;dan de lsb
 5509: 1  13B8	13		                rrc     a
 5510: 1  13B9	FC		                mov     r4,a
 5511: 1  13BA	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5512: 1  13BD	D0 F0		                pop     b               ;haal de loopteller van stack
 5513: 1  13BF	C0 F0		                push    b               ;en bewaar hem weer
 5514: 1  13C1	EF		                mov     a,r7            ;test teken van sry
 5515: 1  13C2	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5516: 1  13C5	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5517: 1  13C7	80 02		                sjmp    cordic51
 5518: 1  13C9	D2 D5		cordic5b:       setb    f0
 5519: 1  13CB	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5520: 1  13CD	EF		                mov     a,r7            ;eerst de msb
 5521: 1  13CE	13		                rrc     a
 5522: 1  13CF	FF		                mov     r7,a
 5523: 1  13D0	EE		                mov     a,r6            ;dan de lsb
 5524: 1  13D1	13		                rrc     a
 5525: 1  13D2	FE		                mov     r6,a
 5526: 1  13D3	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5527: 1
 5528: 1  13D6	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5529: 1  13D8	22		                ret
 5530: 1
 5531: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5532: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5533: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5534: 1  13D9	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5535: 1  13DB	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5536: 1  13DD	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5537: 1  13DF	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5538: 1  13E1	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5539: 1  13E3	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5540: 1  13E5	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5541: 1  13E7	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5542: 1  13E9	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5543: 1  13EB	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5544: 1  13ED	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5545: 1  13EF	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5546: 1  13F1	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5547: 1  13F3	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5548: 1  13F5	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5549: 1
 5550: 1			endif        ;einde van aduc_math
 5551: 1			;******************************************************************************
 5552: 1
 5553: 1			ifdef        aduc_adc    ;A/D conversie routines
 5554: 1			;*******************************************************************************
 5555: 1			; ADuCADC_mide
 5556: 1			; Geschreven door [dp] op 5/1/2014
 5557: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5558: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5559: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5560: 1			; bron instellen.
 5561: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5562: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5563: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5564: 1			;
 5565: 1			;*******************************************************************************
 5566: 1
 5567: 1			;*******************************************************************************
 5568: 1			; adc_init
 5569: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5570: 1			; -  4 track&hold clockperiodes
 5571: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5572: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5573: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5574: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5575: 1			;
 5576: 1			; input: R0 =  0  : Interne referentiebron
 5577: 1			;        R0 <> 0  : Externe referentiebron
 5578: 1			;
 5579: 1			; Deze routine vernietigt niets
 5580: 1			;*******************************************************************************
 5581: 1  13F7	C0 E0		adc_init:       push    acc                 ;registers op stack
 5582: 1  13F9	C0 D0		                push    psw
 5583: 1  13FB	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5584: 1  13FE	E8		                mov     a,r0                ;welke referentiebron?
 5585: 1  13FF	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5586: 1  1401	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5587: 1  1404	D0 D0		adc_init1:      pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5588: 1  1406	D0 E0		                pop     acc
 5589: 1  1408	22		                ret
 5590: 1
 5591: 1			;*******************************************************************************
 5592: 1			; adc_single
 5593: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5594: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5595: 1			; (2's complement) formaat van de meetwaarde.
 5596: 1			; _____________________________________________________________
 5597: 1			; resolutie  |     unsigned      |           signed            |
 5598: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5599: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5600: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5601: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5602: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5603: 1			; _____________________________________________________________
 5604: 1			;
 5605: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5606: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5607: 1			; De ingangsparameter wordt doorgegeven via R0.
 5608: 1			;
 5609: 1			; input:
 5610: 1			;             7    6    5    4    3    2    1    0
 5611: 1			;           _______________________________________
 5612: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5613: 1			;           ---------------------------------------
 5614: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5615: 1			;                                         1000b = temp.sensor
 5616: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5617: 1			;                                   10b = 12 bits, 11b = 12 bits
 5618: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5619: 1			;
 5620: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5621: 1			;         cy=0  bij conversie ok
 5622: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5623: 1			;
 5624: 1			; Deze routine vernietigt niets
 5625: 1			;*******************************************************************************
 5626: 1  1409	C0 E0		adc_single:     push    acc                 ;registers op stack
 5627: 1  140B	C0 D0		                push    psw
 5628: 1  140D	C0 F0		                push    b
 5629: 1  140F	E8		                mov     a,r0                ;neem inputparameter
 5630: 1  1410	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5631: 1  1412	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5632: 1  1415	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5633: 1  1417	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5634: 1  1419	D2 DC		                setb    sconv               ;start een meting
 5635: 1  141B	E8		                mov     a,r0                ;neem parameter terug
 5636: 1  141C	A2 E6		                mov     c,acc.6
 5637: 1  141E	92 D5		                mov     f0,c                ;bewaar format bit
 5638: 1  1420	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5639: 1  1423	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5640: 1  1426	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5641: 1  1429	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5642: 1			;*******************************************************************************
 5643: 1			;8 bit resultaat gevraagd

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5644: 1			;*******************************************************************************
 5645: 1  142C	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5646: 1  142E	C4		                swap    a                    ;swap nibbles
 5647: 1  142F	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5648: 1  1431	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5649: 1  1433	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5650: 1  1435	C4		                swap    a
 5651: 1  1436	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5652: 1  1438	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5653: 1			;8 bit unsigned formaat
 5654: 1  143B	79 00		                mov     r1,#00h              ;unsigned
 5655: 1  143D	F8		                mov     r0,a
 5656: 1  143E	80 63		                sjmp    adc_single42
 5657: 1			;8 bit signed formaat
 5658: 1  1440	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5659: 1  1443	24 80		                add     a,#80h                ;negatief getal van maken
 5660: 1  1445	F8		                mov     r0,a
 5661: 1  1446	79 FF		                mov     r1,#0ffh
 5662: 1  1448	80 59		                sjmp    adc_single42
 5663: 1  144A	C3		adc_single20:   clr     c
 5664: 1  144B	94 80		                subb    a,#80h                ;positief deel verkleinen
 5665: 1  144D	F8		                mov     r0,a
 5666: 1  144E	79 00		                mov     r1,#00h
 5667: 1  1450	80 51		                sjmp    adc_single42
 5668: 1
 5669: 1  1452	02 14 AB	adc_single21:   ljmp    adc_single43
 5670: 1			;*******************************************************************************
 5671: 1			;10 bit resultaat gevraagd
 5672: 1			;*******************************************************************************
 5673: 1  1455	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5674: 1  1457	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5675: 1  1459	03		                rr     a              ;naar msbits roteren
 5676: 1  145A	03		                rr     a
 5677: 1  145B	F5 F0		                mov    b,a            ;even bewaren
 5678: 1  145D	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5679: 1  145F	03		                rr     a              ;twee plaatsen opschuiven
 5680: 1  1460	03		                rr     a
 5681: 1  1461	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5682: 1  1463	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5683: 1  1465	F5 F0		                mov    b,a            ;low byte even bewaren
 5684: 1  1467	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5685: 1  1469	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5686: 1  146B	03		                rr     a               ;en op hun plaats schuiven
 5687: 1  146C	03		                rr     a
 5688: 1  146D	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5689: 1			;10 bit unsigned formaat
 5690: 1  1470	F9		                mov    r1,a            ;unsigned
 5691: 1  1471	A8 F0		                mov    r0,b
 5692: 1  1473	80 2E		                sjmp   adc_single42
 5693: 1			;10 bit signed formaat
 5694: 1  1475	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5695: 1  1478	24 FE		                add    a,#0feh             ;negatief getal van maken
 5696: 1  147A	F9		                mov    r1,a
 5697: 1  147B	A8 F0		                mov    r0,b
 5698: 1  147D	80 24		                sjmp   adc_single42
 5699: 1  147F	C3		adc_single31:   clr    c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5700: 1  1480	94 02		                subb   a,#02h              ;positief deel verkleinen
 5701: 1  1482	F9		                mov    r1,a
 5702: 1  1483	A8 F0		                mov    r0,b
 5703: 1  1485	80 1C		                sjmp   adc_single42
 5704: 1
 5705: 1			;*******************************************************************************
 5706: 1			;12 bit resultaat gevraagd
 5707: 1			;*******************************************************************************
 5708: 1  1487	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5709: 1  1489	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5710: 1  148B	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5711: 1			;12 bit unsigned formaat
 5712: 1  148E	A8 D9		                mov    r0,adcdatal           ;unsigned
 5713: 1  1490	F9		                mov    r1,a
 5714: 1  1491	80 10		                sjmp   adc_single42
 5715: 1			;12 bit signed formaat
 5716: 1  1493	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5717: 1  1496	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5718: 1  1498	F9		                mov    r1,a
 5719: 1  1499	A8 D9		                mov    r0,adcdatal
 5720: 1  149B	80 06		                sjmp   adc_single42
 5721: 1  149D	C3		adc_single41:   clr    c
 5722: 1  149E	94 08		                subb   a,#08h                ;positief deel verkleinen
 5723: 1  14A0	F9		                mov    r1,a
 5724: 1  14A1	A8 D9		                mov    r0,adcdatal
 5725: 1  14A3	D0 F0		adc_single42:   pop    b
 5726: 1  14A5	D0 D0		                pop    psw
 5727: 1  14A7	C3		                clr    c
 5728: 1  14A8	D0 E0		                pop    acc
 5729: 1  14AA	22		                ret
 5730: 1
 5731: 1  14AB	D0 F0		adc_single43:   pop    b
 5732: 1  14AD	D0 D0		                pop    psw
 5733: 1  14AF	D3		                setb   c
 5734: 1  14B0	D0 E0		                pop    acc
 5735: 1  14B2	22		                ret
 5736: 1
 5737: 1			endif        ;einde van aduc_adc
 5738: 1			;*******************************************************************************
 5739: 1
 5740: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5741: 1			;******************************************************************************
 5742: 1			; ADuCKEY_mide.inc
 5743: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5744: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5745: 1			;
 5746: 1			;     V2.0      V1.1
 5747: 1			;                           |   |   |   |
 5748: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5749: 1			;                   |       |   |   |   |
 5750: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5751: 1			;                   |       |   |   |   |
 5752: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5753: 1			;                   |       |   |   |   |
 5754: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5755: 1			;                   |       |   |   |   |

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5756: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5757: 1			;                   |           |   |   |
 5758: 1			;     P0.5      P3.5|-K2--------|   |   |
 5759: 1			;                   |               |   |
 5760: 1			;     P0.6      P3.6|-K3------------|   |
 5761: 1			;                   |                   |
 5762: 1			;     P0.7      P3.7|-K4----------------|
 5763: 1			;
 5764: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5765: 1			; gebruikt.
 5766: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5767: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5768: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5769: 1			; en als ingang wordt aangeboden.
 5770: 1			;
 5771: 1			;                                  ___                 ___
 5772: 1			;                     ____________|   |  |------------|   |
 5773: 1			;              ____  |   ____     |   |  |   ____     |   |
 5774: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5775: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5776: 1			; '1'= toets  | cl |    | cl |              | cl |
 5777: 1			;  ingedrukt  |____|    |____|              |____|
 5778: 1			;                |         |                   |
 5779: 1			;      CLOCK     |         |                   |
 5780: 1			;         _______|_________|___________________|
 5781: 1			;
 5782: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 5783: 1			;
 5784: 1			;              MAP0      MAP1                 MAP2         MAP3
 5785: 1			;
 5786: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5787: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5788: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5789: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5790: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 5791: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5792: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 5793: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5794: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5795: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5796: 1			;
 5797: 1			;          MAP0    MAP1          MAP2    MAP3
 5798: 1			;         _______________       _______________
 5799: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 5800: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5801: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5802: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5803: 1			;
 5804: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5805: 1			;         | | | | | | | |       | | | | | | | |
 5806: 1			;        K K K K K K K K       K K K K K K K K
 5807: 1			;         O O O O O O O O       O O O O O O O O
 5808: 1			;         L L L L L L L L       L L L L L L L L
 5809: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5810: 1			;
 5811: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5812: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 5813: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5814: 1			; van bitmaps van voor naar achter.
 5815: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5816: 1			;
 5817: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5818: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5819: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5820: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 5821: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5822: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5823: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5824: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5825: 1			; deze toetswaarde weer.
 5826: 1			;
 5827: 1			;
 5828: 1			;
 5829: 1			;******************************************************************************
 5830: 1
 5831: 1
 5832: 1			;******************************************************************************
 5833: 1			; key_init
 5834: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 5835: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5836: 1			; input: niets
 5837: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 5838: 1			;         (map0,map1,map2,map3 =0)
 5839: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5840: 1			; Deze routine vernietigt niets
 5841: 1			;******************************************************************************
 5842: 1
 5843: 1  14B3	C0 E0		Key_init:       push    acc          ;bewaar registers
 5844: 1  14B5	C0 D0		                push    psw
 5845: 1  14B7	E8		                mov     a,r0
 5846: 1  14B8	C0 E0		                push    acc
 5847: 1  14BA	E9		                mov     a,r1
 5848: 1  14BB	C0 E0		                push    acc
 5849: 1  14BD	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5850: 1  14BF	79 09		                mov     r1,#9        ;9 bytes in de maps
 5851: 1  14C1	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5852: 1  14C3	08		                inc     r0           ;volgende byte nemen
 5853: 1  14C4	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5854: 1  14C6	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5855: 1  14C8	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 5856: 1  14CA	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5857: 1  14CD	D0 E0		                pop     acc          ;herstel registers
 5858: 1  14CF	F9		                mov     r1,a
 5859: 1  14D0	D0 E0		                pop     acc
 5860: 1  14D2	F8		                mov     r0,a
 5861: 1  14D3	D0 D0		                pop     psw
 5862: 1  14D5	D0 E0		                pop     acc
 5863: 1  14D7	22		                ret                    ;terug naar caller
 5864: 1			;******************************************************************************
 5865: 1
 5866: 1
 5867: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5868: 1			; toets_flank
 5869: 1			; Deze routine detecteert de indrukflank van een toets.
 5870: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5871: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5872: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5873: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5874: 1			; minder dan 20ms duurt.
 5875: 1			; input : niets
 5876: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5877: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5878: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5879: 1			;
 5880: 1			; Deze routine vernietigt geen registers.
 5881: 1			;******************************************************************************
 5882: 1  14D8	C0 E0		Toets_flank:    push    acc
 5883: 1  14DA	C0 D0		                push    psw
 5884: 1  14DC	12 14 F6	                lcall   Keyscan
 5885: 1  14DF	12 15 72	                lcall   Keyedge
 5886: 1  14E2	D0 D0		                pop     psw
 5887: 1  14E4	D0 E0		                pop     acc
 5888: 1  14E6	22		                ret
 5889: 1
 5890: 1			;******************************************************************************
 5891: 1			; toets_ingedrukt
 5892: 1			; Deze routine detecteert een ingedrukte toets.
 5893: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5894: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5895: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5896: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5897: 1			; minder dan 20ms duurt.
 5898: 1			; input : niets
 5899: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5900: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5901: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5902: 1			;
 5903: 1			; Deze routine vernietigt geen registers.
 5904: 1			;******************************************************************************
 5905: 1  14E7	C0 E0		Toets_ingedrukt:push    acc
 5906: 1  14E9	C0 D0		                push    psw
 5907: 1  14EB	12 14 F6	                lcall   Keyscan
 5908: 1  14EE	12 15 59	                lcall   Keydown
 5909: 1  14F1	D0 D0		                pop     psw
 5910: 1  14F3	D0 E0		                pop     acc
 5911: 1  14F5	22		                ret
 5912: 1
 5913: 1
 5914: 1			;******************************************************************************
 5915: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5916: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5917: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5918: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5919: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5920: 1			; zoals aangegeven in het blokschema van het algorithme.
 5921: 1			; input : niets
 5922: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5923: 1			;         ervan weergeven

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5924: 1			;
 5925: 1			; Deze routine vernietigt geen registers
 5926: 1			;******************************************************************************
 5927: 1
 5928: 1  14F6	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 5929: 1  14F8	C0 D0		                push    psw
 5930: 1  14FA	C0 F0		                push    b
 5931: 1  14FC	E8		                mov     a,r0
 5932: 1  14FD	C0 E0		                push    acc
 5933: 1  14FF	E9		                mov     a,r1
 5934: 1  1500	C0 E0		                push    acc
 5935: 1  1502	EA		                mov     a,r2
 5936: 1  1503	C0 E0		                push    acc
 5937: 1  1505	EE		                mov     a,r6
 5938: 1  1506	C0 E0		                push    acc
 5939: 1
 5940: 1  1508	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 5941: 1  150A	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 5942: 1  150D	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 5943: 1  150F	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 5944: 1
 5945: 1  1511			Scanloop:
 5946: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 5947: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 5948: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 5949: 1			                mov     p0.0,c
 5950: 1			                mov     c,acc.1
 5951: 1			                mov     p0.1,c
 5952: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 5953: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 5954: 1			endif
 5955: 1
 5956: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 5957: 1  1511	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 5958: 1			                                      ;een rij-lijn
 5959: 1			endif
 5960: 1
 5961: 1			; Eerst de flipflops implementeren.
 5962: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 5963: 1			; te lezen van de kolomlijnen
 5964: 1  1513	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 5965: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5966: 1  1514	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 5967: 1  1515	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 5968: 1  1516	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 5969: 1  1517	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 5970: 1  1519	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 5971: 1  151A	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 5972: 1  151B	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 5973: 1  151D	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 5974: 1  151E	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 5975: 1  151F	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 5976: 1  1520	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 5977: 1  1521	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 5978: 1  1523	FA		                mov     r2,a          ;even bewaren in register
 5979: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5980: 1
 5981: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 5982: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 5983: 1			                                      ;poort3 kolomlijnen
 5984: 1			endif
 5985: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 5986: 1  1524	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 5987: 1			                                     ;poort0 kolomlijnen
 5988: 1			endif
 5989: 1  1526	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 5990: 1  1527	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 5991: 1  1529	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 5992: 1  152A	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 5993: 1
 5994: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 5995: 1			; Nu volgen de logische functies uit het blokschema
 5996: 1
 5997: 1  152B	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 5998: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5999: 1  152C	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 6000: 1  152D	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 6001: 1  152E	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 6002: 1  152F	54 0F		                anl     a,#00001111b ;low nibble houden
 6003: 1  1531	FA		                mov     r2,a         ;resultaat bewaren
 6004: 1  1532	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 6005: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 6006: 1  1533	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 6007: 1  1534	C4		                swap    a            ;map2 naar low nibble schuiven
 6008: 1  1535	5A		                anl     a,r2         ;combineren met output vorige and poort
 6009: 1  1536	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 6010: 1  1538	FA		                mov     r2,a         ;even bewaren
 6011: 1  1539	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 6012: 1  153A	54 F0		                anl     a,#11110000b ;map2 overhouden
 6013: 1  153C	4A		                orl     a,r2         ;en combineren met nieuwe map3
 6014: 1  153D	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 6015: 1
 6016: 1			; We gaan nu de volgende lijn scannen
 6017: 1
 6018: 1  153E	EE		                mov     a,r6         ;scanpatroon nemen
 6019: 1  153F	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 6020: 1  1540	FE		                mov     r6,a         ;scanpatroon bewaren
 6021: 1
 6022: 1  1541	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 6023: 1  1542	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 6024: 1  1543	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 6025: 1  1546	D0 E0		                pop     acc          ;herstel registers
 6026: 1  1548	FE		                mov     r6,a
 6027: 1  1549	D0 E0		                pop     acc
 6028: 1  154B	FA		                mov     r2,a
 6029: 1  154C	D0 E0		                pop     acc
 6030: 1  154E	F9		                mov     r1,a
 6031: 1  154F	D0 E0		                pop     acc
 6032: 1  1551	F8		                mov     r0,a
 6033: 1  1552	D0 F0		                pop     b
 6034: 1  1554	D0 D0		                pop     psw
 6035: 1  1556	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6036: 1  1558	22		                ret                    ;terug naar caller
 6037: 1			;******************************************************************************
 6038: 1
 6039: 1
 6040: 1			;******************************************************************************
 6041: 1			; Keydown, Keyedge (twee entry's)
 6042: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6043: 1			;
 6044: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6045: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6046: 1			; Er zijn twee detectie-modes:
 6047: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6048: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6049: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6050: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6051: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6052: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6053: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6054: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6055: 1			;
 6056: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6057: 1			; (flankdetectie mode).
 6058: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6059: 1			; (toets ingedrukt mode).
 6060: 1			;
 6061: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6062: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6063: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6064: 1			; geldt voor een standaard 4x4 keypad.
 6065: 1			;
 6066: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6067: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6068: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6069: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6070: 1			;
 6071: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6072: 1			; output: key = gedetecteerde toets
 6073: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6074: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6075: 1			;
 6076: 1			; Deze routine vernietigt geen registers
 6077: 1			;******************************************************************************
 6078: 1
 6079: 1			;'Toets ingedrukt mode' enty van de routine
 6080: 1  1559	C0 E0		Keydown:        push    acc            ;registers bewaren
 6081: 1  155B	C0 D0		                push    psw
 6082: 1  155D	C0 F0		                push    b
 6083: 1  155F	C0 82		                push    dpl
 6084: 1  1561	C0 83		                push    dph
 6085: 1  1563	E8		                mov     a,r0
 6086: 1  1564	C0 E0		                push    acc
 6087: 1  1566	E9		                mov     a,r1
 6088: 1  1567	C0 E0		                push    acc
 6089: 1  1569	EA		                mov     a,r2
 6090: 1  156A	C0 E0		                push    acc
 6091: 1  156C	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6092: 1  156E	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6093: 1  1570	80 15		                sjmp    Key1           ;continue
 6094: 1
 6095: 1			;'Flankdetectiemode' entry van de routine
 6096: 1  1572	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6097: 1  1574	C0 D0		                push    psw
 6098: 1  1576	C0 F0		                push    b
 6099: 1  1578	C0 82		                push    dpl
 6100: 1  157A	C0 83		                push    dph
 6101: 1  157C	E8		                mov     a,r0
 6102: 1  157D	C0 E0		                push    acc
 6103: 1  157F	E9		                mov     a,r1
 6104: 1  1580	C0 E0		                push    acc
 6105: 1  1582	EA		                mov     a,r2
 6106: 1  1583	C0 E0		                push    acc
 6107: 1  1585	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6108: 1  1587	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6109: 1  1589	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6110: 1  158B	E6		                mov     a,@r0         ;map entry ophalen
 6111: 1  158C	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6112: 1  158F	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6113: 1  1591	C4		                swap    a             ;map1 en map0 omwisselen
 6114: 1  1592	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6115: 1  1594	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6116: 1  1595	33		                rlc     a             ;kolombit testen
 6117: 1  1596	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6118: 1  1598	33		                rlc    a              ;nee, dan verder roteren
 6119: 1  1599	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6120: 1  159B	08		                inc     r0            ;rijpointer in maps verder zetten
 6121: 1  159C	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6122: 1  159E	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6123: 1
 6124: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6125: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6126: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6127: 1
 6128: 1  15A0	1A		toetsin:        dec     r2            ;rij-1
 6129: 1  15A1	19		                dec     r1            ;kolom-1
 6130: 1  15A2	EA		                mov     a,r2          ;neem rij-1
 6131: 1  15A3	23		                rl      a             ;(rij-1)x2
 6132: 1  15A4	23		                rl      a              ;(rij-1)x4
 6133: 1  15A5	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6134: 1  15A6	90 15 C4	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6135: 1  15A9	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6136: 1  15AA	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6137: 1  15AC	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6138: 1  15AE	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6139: 1  15B0	D0 E0		                pop     acc            ;herstellen registers
 6140: 1  15B2	FA		                mov     r2,a
 6141: 1  15B3	D0 E0		                pop     acc
 6142: 1  15B5	F9		                mov     r1,a
 6143: 1  15B6	D0 E0		                pop     acc
 6144: 1  15B8	F8		                mov     r0,a
 6145: 1  15B9	D0 83		                pop     dph
 6146: 1  15BB	D0 82		                pop     dpl
 6147: 1  15BD	D0 F0		                pop     b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6148: 1  15BF	D0 D0		                pop     psw
 6149: 1  15C1	D0 E0		                pop     acc
 6150: 1  15C3	22		                ret                    ;terug naar caller
 6151: 1			;******************************************************************************
 6152: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6153: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6154: 1
 6155: 1  15C4	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6156: 1  15C5	30		                db    '0'    ;kolom2@rij4 toets
 6157: 1  15C6	23		                db    '#'    ;kolom3@rij4 toets
 6158: 1  15C7	44		                db    'D'    ;kolom4@rij4 toets
 6159: 1
 6160: 1  15C8	37		                db    '7'    ;kolom1@rij3 toets
 6161: 1  15C9	38		                db    '8'    ;kolom2@rij3 toets
 6162: 1  15CA	39		                db    '9'    ;kolom3@rij3 toets
 6163: 1  15CB	43		                db    'C'    ;kolom4@rij3 toets
 6164: 1
 6165: 1  15CC	34		                db    '4'    ;kolom1@rij2 toets
 6166: 1  15CD	35		                db    '5'    ;kolom2@rij2 toets
 6167: 1  15CE	36		                db    '6'    ;kolom3@rij2 toets
 6168: 1  15CF	42		                db    'B'    ;kolom4@rij2 toets
 6169: 1
 6170: 1  15D0	31		                db    '1'    ;kolom1@rij1 toets
 6171: 1  15D1	32		                db    '2'    ;kolom2@rij1 toets
 6172: 1  15D2	33		                db    '3'    ;kolom3@rij1 toets
 6173: 1  15D3	41		                db    'A'    ;kolom4@rij1 toets
 6174: 1
 6175: 1			;******************************************************************************
 6176: 1			; switch_init
 6177: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6178: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6179: 1			; input : niets
 6180: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6181: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6182: 1			;
 6183: 1			; Deze routine vernietigt niets
 6184: 1			;******************************************************************************
 6185: 1
 6186: 1  15D4	C0 E0		switch_init:    push    acc
 6187: 1  15D6	C0 D0		                push    psw
 6188: 1  15D8	C0 F0		                push    b
 6189: 1  15DA	E8		                mov     a,r0         ;bewaar registers
 6190: 1  15DB	C0 E0		                push    acc
 6191: 1
 6192: 1  15DD	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6193: 1  15DF	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6194: 1  15E2	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6195: 1  15E4	08		                inc     r0           ;volgende byte nemen
 6196: 1  15E5	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6197: 1  15E8	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6198: 1  15EA	C2 03		                clr     negvalid
 6199: 1  15EC	C2 04		                clr     posvalid
 6200: 1
 6201: 1  15EE	D0 E0		                pop     acc
 6202: 1  15F0	F8		                mov     r0,a
 6203: 1  15F1	D0 F0		                pop     b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6204: 1  15F3	D0 D0		                pop     psw
 6205: 1  15F5	D0 E0		                pop     acc
 6206: 1  15F7	22		                ret                   ;terug naar caller
 6207: 1
 6208: 1			;******************************************************************************
 6209: 1			; read_switch
 6210: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6211: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6212: 1			; Deze routine werkt volgens onderstaand blokschema.
 6213: 1			;
 6214: 1			;                                  ___                    ___
 6215: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6216: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6217: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6218: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6219: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6220: 1			;             |____|    |____|              |____|  ----o| 3 |
 6221: 1			;                |         |                   |      |  |   |
 6222: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6223: 1			;         _______*_________*___________________|       --|___|---- posedge
 6224: 1			;
 6225: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6226: 1			;                              (swvalid-flag)
 6227: 1			;            switch1   switch2    debounce      closed
 6228: 1			;
 6229: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6230: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6231: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6232: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6233: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6234: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6235: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6236: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6237: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6238: 1			; een detector voor positieve flanken (posedge).
 6239: 1			;
 6240: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6241: 1			;         bij aduc832v1.1 :
 6242: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6243: 1			;         bij aduc832v2.0 :
 6244: 1			;         als f0=0 dan: schakelaars op p0
 6245: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6246: 1			;
 6247: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6248: 1			;         geactualiseerd.
 6249: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6250: 1			;                  schakelaars weergeeft
 6251: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6252: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6253: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6254: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6255: 1			;                  werd gedetecteerd op een schakelaar.
 6256: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6257: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6258: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6259: 1			;                  werd gedetecteerd op een schakelaar.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6260: 1			;
 6261: 1			;
 6262: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6263: 1			; en flags te initialiseren.
 6264: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6265: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6266: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6267: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6268: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6269: 1			; bijhorende flag resetten.
 6270: 1			;
 6271: 1			; Deze routine vernietigt niets
 6272: 1			;******************************************************************************
 6273: 1  15F8	C0 E0		read_switch:    push    acc            ;registers bewaren
 6274: 1  15FA	C0 D0		                push    psw
 6275: 1  15FC	C0 F0		                push    b
 6276: 1			;Flipflops uitvoeren is bytes doorschuiven
 6277: 1  15FE	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6278: 1  1601	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6279: 1
 6280: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6281: 1			                clr      a
 6282: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6283: 1			                mov     acc.0,c
 6284: 1			                mov     c,p0.1
 6285: 1			                mov     acc.1,c
 6286: 1			                mov     b,a            ;even bewaren
 6287: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6288: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6289: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6290: 1			endif        ;einde aduc832_v1_1
 6291: 1
 6292: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6293: 1  1604	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6294: 1  1607	E5 80		                mov     a,p0           ;lees de schakelaars
 6295: 1  1609	80 04		                sjmp    lowlogic
 6296: 1  160B	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6297: 1  160D	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6298: 1			endif        ;einde aduc832_2_0
 6299: 1
 6300: 1  160F	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6301: 1  1610	F5 40		                mov     switch1,a      ;en sample opslaan
 6302: 1
 6303: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6304: 1
 6305: 1  1612	E5 40		                mov     a,switch1      ;neem laatste sample
 6306: 1  1614	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6307: 1  1616	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6308: 1  1618	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6309: 1			;negatieve flankdetectie
 6310: 1  161A	E5 43		                mov     a,closed      ;neem 3de FF
 6311: 1  161C	F4		                cpl     a             ;complementeer
 6312: 1  161D	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6313: 1  161F	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6314: 1  1621	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6315: 1  1623	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111



 Line  I  Addr  Code            Source

 6316: 1  1625	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6317: 1			;positieve flankdetectie
 6318: 1  1627	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6319: 1  1629	F4		                cpl     a             ;complementeer
 6320: 1  162A	55 43		                anl     a,closed      ;combineer met 3de FF
 6321: 1  162C	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6322: 1  162E	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6323: 1  1630	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6324: 1  1632	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6325: 1  1634	D0 D0		                pop     psw
 6326: 1  1636	D0 E0		                pop     acc
 6327: 1  1638	22		                ret
 6328: 1
 6329: 1			endif    ;einde van aduc_key
 6330: 1
 6331: 1
 6332:				end





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 148
ACC				  DATA	      E0	  67
ADCCON1				  DATA	      EF	  70
ADCCON2				  DATA	      D8	  63
ADCCON3				  DATA	      F5	  76
ADCDATAH			  DATA	      DA	  65
ADCDATAL			  DATA	      D9	  64
ADCGAINH			  DATA	      F4	  75
ADCGAINL			  DATA	      F3	  74
ADCI				  BIT	      DF	 157
ADCOFSH				  DATA	      F2	  73
ADCOFSL				  DATA	      F1	  72
ADC_INIT			  CODE	    13F7	5581
ADC_INIT1			  CODE	    1404	5587
ADC_SINGLE			  CODE	    1409	5626
ADC_SINGLE1			  CODE	    1415	5632
ADC_SINGLE2			  CODE	    1440	5658
ADC_SINGLE20			  CODE	    144A	5663
ADC_SINGLE21			  CODE	    1452	5669
ADC_SINGLE3			  CODE	    1455	5673
ADC_SINGLE30			  CODE	    1475	5694
ADC_SINGLE31			  CODE	    147F	5699
ADC_SINGLE4			  CODE	    1487	5708
ADC_SINGLE40			  CODE	    1493	5716
ADC_SINGLE41			  CODE	    149D	5721
ADC_SINGLE42			  CODE	    14A3	5725
ADC_SINGLE43			  CODE	    14AB	5731
ADD16				  CODE	    094E	2933
ADD161				  CODE	    0962	2949
ADD32				  CODE	    09A0	3030
ADD321				  CODE	    09BA	3054
ADUC832_V2_0			  NUMBER    0001	 239
ADUC_ADC			  NUMBER    0001	 260
ADUC_I2C			  NUMBER    0001	 257
ADUC_KEY			  NUMBER    0001	 261
ADUC_LCD			  NUMBER    0001	 254
ADUC_MATH			  NUMBER    0001	 259
ADUC_SIO			  NUMBER    0001	 258
ASCBINTRANS			  CODE	    05FE	1986
ASCBINTRANS1			  CODE	    0613	1997
ASCBINTRANS2			  CODE	    0612	1996
ASCBINTRANS3			  CODE	    0606	1990
ASCBINTRANS4			  CODE	    060F	1994
ASCCTR				  CODE	    05D5	1932
ASCCTR1				  CODE	    05D8	1933
ASCCTR2				  CODE	    05DD	1935
ASCCTR3				  CODE	    05E1	1938
ASCII1				  CODE	    0614	2008

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII2				  CODE	    0619	2022
ASCII21				  CODE	    062B	2031
ASCII4				  CODE	    062E	2045
ASCII41				  CODE	    063D	2052
B				  DATA	      F0	  71
BACKLIGHT			  BIT	      F6	 406
BACKSP				  NUMBER    0008	1631
BARCHARS			  CODE	    02BE	1032
BAREINDE			  CODE	    02E5	1075
BARLCD				  CODE	    0259	 953
BARLCD1				  CODE	    0294	 987
BARLCD2				  CODE	    029B	 992
BARLCD3				  CODE	    02A4	1000
BARLCD4				  CODE	    02A9	1004
BARLCDE				  CODE	    02B1	1009
BARLCD_1			  CODE	    0274	 969
BATRANS				  CODE	    05F0	1968
BATRANS1			  CODE	    05F5	1970
BATRANS2			  CODE	    05F9	1972
BCDHEX16			  CODE	    06B3	2247
BCDHEX161			  CODE	    06C1	2255
BCDHEX1611			  CODE	    06CA	2259
BCDHEX1612			  CODE	    06D4	2264
BCDHEX1613			  CODE	    06DD	2268
BCDHEX162			  CODE	    0728	2322
BCDHEX8				  CODE	    063E	2138
BCDHEX81			  CODE	    064C	2146
BCDHEX811			  CODE	    0655	2150
BCDHEX82			  CODE	    0677	2174
BDELETE				  CODE	    05B0	1898
BDELETE1			  CODE	    05BE	1906
BDELETE2			  CODE	    05D1	1917
BDELETE3			  CODE	    05C2	1908
BEEP				  NUMBER    0007	1632
BLANK				  NUMBER    0020	1626
BUILD				  CODE	    02E6	1107
BUILD1				  CODE	    02FE	1149
BUILD2				  CODE	    030D	1156
BUILD3				  CODE	    0301	1150
BUILD_ADR			  CODE	    02F4	1144
BUZZER				  BIT	      F7	 407
CAP2				  BIT	      C8	 134
CCONV				  BIT	      DD	 155
CFG832				  DATA	      AF	  36
CGRAM				  NUMBER    0040	 422
CHIPID				  DATA	      C2	  50
CLEARDISP			  NUMBER    0001	 412
CLOSED				  NUMBER    0043	 326
CMP16				  CODE	    112F	4964
CMP161				  CODE	    114C	4983
CMP162				  CODE	    1158	4992
CMP32				  CODE	    11D0	5111
CMP321				  CODE	    11F9	5138
CMP322				  CODE	    1205	5147
CNT2				  BIT	      C9	 135
CORDIC				  CODE	    1299	5298

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CORDIC0				  CODE	    1304	5363
CORDIC00			  CODE	    12EA	5348
CORDIC000			  CODE	    12BD	5322
CORDIC1				  CODE	    1318	5377
CORDIC2				  CODE	    134C	5427
CORDIC3				  CODE	    1357	5434
CORDIC4				  CODE	    137C	5468
CORDIC40			  CODE	    1381	5472
CORDIC41			  CODE	    139A	5488
CORDIC5				  CODE	    13A0	5494
CORDIC50			  CODE	    13B2	5504
CORDIC51			  CODE	    13CB	5519
CORDIC52			  CODE	    13D6	5528
CORDIC5A			  CODE	    13B0	5503
CORDIC5B			  CODE	    13C9	5518
CORDIC_ATAN			  CODE	    13D9	5534
CORDIC_ERROR			  CODE	    12CD	5330
CORDIC_MIN90			  CODE	    12D2	5334
CORDIC_NUL			  CODE	    12F6	5354
CORDIC_PLUS90			  CODE	    12DE	5341
CPHA				  BIT	      FA	 172
CPOL				  BIT	      FB	 173
CR				  NUMBER    000D	1629
CS0				  BIT	      D8	 150
CS1				  BIT	      D9	 151
CS2				  BIT	      DA	 152
CS3				  BIT	      DB	 153
CURSATHOM			  NUMBER    0002	 413
CURSOROFF			  NUMBER    000C	 418
CURSORONB			  NUMBER    000F	 419
CURSORONN			  NUMBER    000E	 420
CY				  BIT	      D7	 149
D0				  BIT	      ED	 159
D0EN				  BIT	      EB	 158
D1				  BIT	      EF	 161
D1EN				  BIT	      EE	 160
DAC0H				  DATA	      FA	  80
DAC0L				  DATA	      F9	  79
DAC1H				  DATA	      FC	  82
DAC1L				  DATA	      FB	  81
DACCON				  DATA	      FD	  83
DCON				  DATA	      E8	  68
DDRAM				  NUMBER    0080	 423
DEBOUNCE			  NUMBER    0042	 325
DELAY				  CODE	    0037	 215
DELAY1				  CODE	    003F	 219
DELAY2				  CODE	    0041	 220
DELAY2MS			  CODE	    031B	1173
DELAY2MS1			  CODE	    0321	1176
DELAY3				  CODE	    0043	 221
DELAY60US			  CODE	    032C	1193
DELAY60US1			  CODE	    033E	1207
DELAY60US2			  CODE	    033C	1206
DIPSWITCH			  NUMBER    0001	 279
DISPDPTR			  CODE	    0506	1740
DISPDPTRLCD			  CODE	    0120	 628

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DISPLAYOF			  NUMBER    0008	 417
DISPLAYON			  NUMBER    0001	 416
DIV16				  CODE	    0C15	3716
DIV160				  CODE	    0C23	3727
DIV161				  CODE	    0C41	3750
DIV162				  CODE	    0C54	3766
DIV163				  CODE	    0C70	3791
DIV164				  CODE	    0C82	3809
DIV32				  CODE	    0CBF	3880
DIV320				  CODE	    0CCF	3893
DIV320A				  CODE	    0CD9	3904
DIV320B				  CODE	    0CF7	3932
DIV320C				  CODE	    0D1C	3960
DIV322				  CODE	    0D41	3994
DIV323				  CODE	    0D8B	4070
DIV324				  CODE	    0DBD	4120
DIV8				  CODE	    0BD2	3643
DIV81				  CODE	    0BEA	3659
DMA				  BIT	      DE	 156
DMAH				  DATA	      D3	  60
DMAL				  DATA	      D2	  59
DMAP				  DATA	      D4	  61
DPCON				  DATA	      A7	  32
DPH				  DATA	      83	   9
DPL				  DATA	      82	   8
DPP				  DATA	      84	  10
E				  BIT	      F1	 404
EA				  BIT	      AF	 109
EADC				  BIT	      AE	 108
EADRH				  DATA	      C7	  52
EADRL				  DATA	      C6	  51
ECON				  DATA	      B9	  44
EDATA1				  DATA	      BC	  45
EDATA2				  DATA	      BD	  46
EDATA3				  DATA	      BE	  47
EDATA4				  DATA	      BF	  48
ENDBUF				  NUMBER    007F	1638
ENTRYMODE			  NUMBER    0006	 415
ES				  BIT	      AC	 106
ET0				  BIT	      A9	 103
ET1				  BIT	      AB	 105
ET2				  BIT	      AD	 107
EX0				  BIT	      A8	 102
EX1				  BIT	      AA	 104
EXEN2				  BIT	      CB	 137
EXF2				  BIT	      CE	 140
F0				  BIT	      D5	 147
F1				  BIT	      D1	 143
FF				  NUMBER    000C	1628
FUNCTIONS			  NUMBER    0028	 421
HEXBCD16			  CODE	    0731	2358
HEXBCD161			  CODE	    073F	2365
HEXBCD16_U			  CODE	    0734	2359
HEXBCD8				  CODE	    0680	2199
HEXBCD81			  CODE	    068A	2204
HEXBCD82			  CODE	    068F	2206

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBCD83			  CODE	    0699	2212
HEXBUF2LCD			  CODE	    01FC	 894
HEXBUF2LCD1			  CODE	    0220	 910
HEXBUF2LCDE			  CODE	    0237	 921
HEXBUFTXT			  CODE	    0245	 930
HOUR				  DATA	      A5	  30
HTHSEC				  DATA	      A2	  27
I2CADD				  DATA	      9B	  22
I2CCON				  DATA	      E8	  69
I2CDAT				  DATA	      9A	  21
I2CI				  BIT	      E8	 162
I2CINBYTEA1			  CODE	    0388	1315
I2CINBYTEACK			  CODE	    0381	1312
I2CINBYTEN1			  CODE	    03A9	1339
I2CINBYTENACK			  CODE	    03A2	1336
I2CINIT				  CODE	    0346	1257
I2CM				  BIT	      EB	 165
I2COUTBYTE			  CODE	    0361	1289
I2COUTBYTE1			  CODE	    0368	1292
I2CPCF8574			  NUMBER    0040	1248
I2CPCF8574A			  NUMBER    0070	1249
I2CRCVDATA			  CODE	    0403	1441
I2CRCVDATA1			  CODE	    0422	1459
I2CRCVDATA2			  CODE	    042B	1463
I2CRCVDATA3			  CODE	    0432	1468
I2CRCVERROR			  CODE	    043E	1476
I2CRS				  BIT	      EA	 164
I2CSENDDATA			  CODE	    03C3	1379
I2CSENDDATA1			  CODE	    03E2	1396
I2CSENDERROR			  CODE	    03F8	1409
I2CSTART			  CODE	    034F	1266
I2CSTOP				  CODE	    0358	1275
I2CTX				  BIT	      E9	 163
IE				  DATA	      A8	  33
IE0				  BIT	      89	  85
IE1				  BIT	      8B	  87
IEIP2				  DATA	      A9	  34
INBUFA				  CODE	    0575	1855
INBUFA1				  CODE	    058C	1872
INBUFA2				  CODE	    057B	1858
INBUFA3				  CODE	    0599	1878
INBUFA4				  CODE	    0592	1874
INBUFA5				  CODE	    05AC	1886
INBUFA6				  CODE	    05A2	1882
INBUFA7				  CODE	    0594	1875
INBYTE				  CODE	    0555	1823
INBYTE1				  CODE	    0572	1835
INCHAR				  CODE	    054D	1807
INCR				  CODE	    0027	 203
INITLCD				  CODE	    0050	 438
INITLCD1			  CODE	    0061	 455
INITSIO				  CODE	    04B3	1652
INITSIO1			  CODE	    04BC	1656
INITSIOE			  CODE	    04D2	1673
INT0				  BIT	      B2	 112
INT1				  BIT	      B3	 113

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
INTVAL				  DATA	      A6	  31
IP				  DATA	      B8	  43
ISPI				  BIT	      FF	 177
IT0				  BIT	      88	  84
IT1				  BIT	      8A	  86
KEY				  NUMBER    0038	 312
KEY1				  CODE	    1587	6108
KEY2				  CODE	    1594	6115
KEYDOWN				  CODE	    1559	6080
KEYEDGE				  CODE	    1572	6096
KEYFLAGS			  NUMBER    0020	 287
KEYINIT1			  CODE	    14C1	5851
KEYMAP				  NUMBER    0030	 306
KEYMODE				  BIT	      01	 291
KEYSCAN				  CODE	    14F6	5928
KEYVALID			  BIT	      00	 289
KEY_INIT			  CODE	    14B3	5843
KOLOMLOOP			  CODE	    1596	6117
LCDBUZOFF			  CODE	    04A2	1597
LCDBUZON			  CODE	    0495	1581
LCDLIGHTOFF			  CODE	    0488	1565
LCDLIGHTON			  CODE	    047B	1548
LCDPORT				  NUMBER    00F0	 403
LCDTOPORT			  CODE	    0462	1522
LF				  NUMBER    000A	1630
LOOP				  CODE	    0011	 193
LOWLOGIC			  CODE	    160F	6300
LOWUPTR				  CODE	    05E3	1952
LOWUPTR1			  CODE	    05E6	1953
LOWUPTR2			  CODE	    05EF	1957
LOWUPTR3			  CODE	    05EB	1955
LSB				  NUMBER    0030	 185
MAGSIG16			  CODE	    07A0	2470
MAGSIG16A			  CODE	    07B1	2479
MAGSIG16ACC1			  CODE	    07C0	2503
MAGSIG16ACC1A			  CODE	    07D1	2512
MAGSIG16ACC1B			  CODE	    07CC	2509
MAGSIG16ACC1C			  CODE	    07DB	2520
MAGSIG16B			  CODE	    07AC	2476
MAGSIG16C			  CODE	    07BB	2487
MAGSIG32			  CODE	    07E0	2537
MAGSIG32A			  CODE	    07F1	2546
MAGSIG32ACC1			  CODE	    080A	2582
MAGSIG32ACC1A			  CODE	    081B	2591
MAGSIG32ACC1B			  CODE	    0816	2588
MAGSIG32ACC1C			  CODE	    082F	2608
MAGSIG32B			  CODE	    07EC	2543
MAGSIG32C			  CODE	    0805	2563
MAGSIG8				  CODE	    076C	2411
MAGSIG8A			  CODE	    077D	2420
MAGSIG8ACC1			  CODE	    0786	2441
MAGSIG8ACC1A			  CODE	    0797	2450
MAGSIG8ACC1B			  CODE	    0792	2447
MAGSIG8ACC1C			  CODE	    079B	2454
MAGSIG8B			  CODE	    0778	2417
MAGSIG8C			  CODE	    0781	2424

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MAP01PTR			  NUMBER    0030	 308
MAP23PTR			  NUMBER    0034	 311
MATRIX				  NUMBER    0001	 277
MCO				  BIT	      ED	 167
MDE				  BIT	      EE	 168
MDI				  BIT	      EC	 166
MDO				  BIT	      EF	 169
MIN				  DATA	      A4	  29
MSB				  NUMBER    0031	 184
MUL16				  CODE	    0A8A	3302
MUL16ACC1			  CODE	    0AEF	3391
MUL16_10			  CODE	    0EAE	4378
MUL16_100			  CODE	    0EE3	4426
MUL16_I_PI			  CODE	    0E4B	4282
MUL16_I_SQRT2			  CODE	    0E8D	4347
MUL16_PI			  CODE	    0E2A	4251
MUL16_SQRT2			  CODE	    0E6C	4314
MUL816				  CODE	    0B77	3538
MULDIV				  CODE	    0DEE	4193
MULDIV1				  CODE	    0DFE	4205
NEGEDGE				  NUMBER    0044	 327
NEGVALID			  BIT	      03	 296
NOKEY				  CODE	    15AE	6138
OUTBYTE				  CODE	    04F2	1720
OUTBYTELCD			  CODE	    010F	 609
OUTC				  CODE	    01BC	 815
OUTCHAR				  CODE	    04D6	1687
OUTCHAR1			  CODE	    04D8	1688
OUTCHARLCD			  CODE	    00AE	 524
OUTCHARLCD1			  CODE	    00B5	 527
OUTCHARLCD2			  CODE	    00BF	 531
OUTCHARLCD2_0			  CODE	    00BA	 529
OUTCHARLCD3			  CODE	    00C8	 541
OUTCHARLCD4			  CODE	    00CF	 545
OUTCHARLCD5			  CODE	    00D6	 549
OUTCHARLCD6			  CODE	    00DD	 553
OUTCHARLCD7			  CODE	    00E4	 557
OUTCHARLCD8			  CODE	    00EB	 565
OUTCHARLCD9			  CODE	    00F0	 573
OUTCHARLCDE			  CODE	    00F3	 574
OUTD				  CODE	    0182	 737
OUTHNIBC			  CODE	    01D2	 857
OUTHNIBD			  CODE	    0192	 785
OUTMSGA				  CODE	    0519	1759
OUTMSGA1			  CODE	    052E	1770
OUTMSGA2			  CODE	    0521	1763
OUTMSGALCD			  CODE	    0133	 652
OUTMSGALCD1			  CODE	    013B	 659
OUTMSGALCDE			  CODE	    0146	 669
OUTNIB				  CODE	    04DE	1701
OUTNIBLCD			  CODE	    00F8	 588
OUTNIBLCD1			  CODE	    0103	 593
OUTNIBLCDE			  CODE	    0107	 595
OV				  BIT	      D2	 144
P				  BIT	      D0	 142
P0				  DATA	      80	   6

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
P1				  DATA	      90	  18
P2				  DATA	      A0	  25
P3				  DATA	      B0	  37
PADC				  BIT	      BE	 124
PCF8574A			  NUMBER    0001	1251
PCON				  DATA	      87	  11
PLLCON				  DATA	      D7	  62
PORTTOLCD			  CODE	    0449	1494
POSEDGE				  NUMBER    0045	 328
POSVALID			  BIT	      04	 298
PRE0				  BIT	      C4	 130
PRE1				  BIT	      C5	 131
PRE2				  BIT	      C6	 132
PRE3				  BIT	      C7	 133
PS				  BIT	      BC	 122
PSI				  BIT	      BF	 125
PSMCON				  DATA	      DF	  66
PSW				  DATA	      D0	  58
PT0				  BIT	      B9	 119
PT1				  BIT	      BB	 121
PT2				  BIT	      BD	 123
PWM0H				  DATA	      B2	  39
PWM0L				  DATA	      B1	  38
PWM1H				  DATA	      B4	  41
PWM1L				  DATA	      B3	  40
PWMCON				  DATA	      AE	  35
PX0				  BIT	      B8	 118
PX1				  BIT	      BA	 120
RB8				  BIT	      9A	  96
RCAP2H				  DATA	      CB	  55
RCAP2L				  DATA	      CA	  54
RCLK				  BIT	      CD	 139
RD				  BIT	      B7	 117
READ_PORT3			  CODE	    160B	6296
READ_SWITCH			  CODE	    15F8	6273
READ_SWITCH1			  CODE	    1627	6318
READ_SWITCH2			  CODE	    1632	6324
REGTOLCD			  CODE	    014F	 689
REGTOLCD1			  CODE	    0160	 699
REGTOLCD2			  CODE	    016E	 709
REN				  BIT	      9C	  98
RI				  BIT	      98	  94
RIJLOOP				  CODE	    1589	6109
RS				  BIT	      F0	 405
RS0				  BIT	      D3	 145
RS1				  BIT	      D4	 146
RXD				  BIT	      B0	 110
SBUF				  DATA	      99	  20
SCANLOOP			  CODE	    1511	5945
SCON				  DATA	      98	  19
SCONV				  BIT	      DC	 154
SEC				  DATA	      A3	  28
SHIFTLEFT1			  CODE	    105A	4741
SHIFTLEFT2			  CODE	    1062	4747
SHIFTLEFT3			  CODE	    1066	4749
SHIFTLEFT32			  CODE	    1052	4737

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SHIFTRIGHT1			  CODE	    102E	4696
SHIFTRIGHT2			  CODE	    1036	4702
SHIFTRIGHT3			  CODE	    103A	4704
SHIFTRIGHT32			  CODE	    1026	4692
SIGMAG16ACC0			  CODE	    0866	2681
SIGMAG16ACC0A			  CODE	    0875	2690
SIGMAG16ACC1			  CODE	    0886	2716
SIGMAG16ACC1A			  CODE	    0895	2725
SIGMAG16ACC1H			  CODE	    08A6	2751
SIGMAG16ACC1HA			  CODE	    08B5	2760
SIGMAG32ACC0			  CODE	    08C6	2788
SIGMAG32ACC0A			  CODE	    08D5	2797
SIGMAG32ACC1			  CODE	    08F0	2832
SIGMAG32ACC1A			  CODE	    08FF	2841
SIGMAG8ACC0			  CODE	    0834	2625
SIGMAG8ACC0A			  CODE	    0843	2633
SIGMAG8ACC1			  CODE	    084D	2653
SIGMAG8ACC1A			  CODE	    085C	2661
SM0				  BIT	      9F	 101
SM1				  BIT	      9E	 100
SM2				  BIT	      9D	  99
SP				  DATA	      81	   7
SPE				  BIT	      FD	 175
SPH				  DATA	      B7	  42
SPICON				  DATA	      F8	  78
SPIDAT				  DATA	      F7	  77
SPIM				  BIT	      FC	 174
SPR0				  BIT	      F8	 170
SPR1				  BIT	      F9	 171
SQRT32				  CODE	    0F39	4498
SQRT320				  CODE	    0F60	4520
SQRT321				  CODE	    0F65	4522
SQRT322				  CODE	    0FC8	4604
SQRT323				  CODE	    0FCE	4608
SQRT324				  CODE	    0FF1	4632
SQRT3240			  CODE	    0FEC	4630
SQRT325				  CODE	    0FF4	4634
STACK_INIT			  NUMBER    007F	 180
START				  CODE	    0003	 187
STRTBUF				  NUMBER    0054	1637
SUB16				  CODE	    0A00	3140
SUB161				  CODE	    0A15	3157
SUB32				  CODE	    0A67	3257
SUB321				  CODE	    0A82	3282
SWINIT				  CODE	    15E2	6194
SWITCH1				  NUMBER    0040	 323
SWITCH2				  NUMBER    0041	 324
SWITCHMAP			  NUMBER    0040	 322
SWITCH_INIT			  CODE	    15D4	6186
SWVALID				  BIT	      02	 294
S_ADD16				  CODE	    091A	2878
S_ADD161			  CODE	    093E	2904
S_ADD162			  CODE	    0942	2906
S_ADD163			  CODE	    0948	2911
S_ADD32				  CODE	    096A	2971
S_ADD321			  CODE	    0992	3002

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_ADD322			  CODE	    0994	3003
S_ADD323			  CODE	    099A	3008
S_CMP16				  CODE	    10E3	4890
S_CMP160			  CODE	    10F6	4907
S_CMP161			  CODE	    1104	4917
S_CMP162			  CODE	    1112	4927
S_CMP163			  CODE	    1121	4939
S_CMP32				  CODE	    1162	5014
S_CMP320			  CODE	    117D	5034
S_CMP321			  CODE	    1191	5048
S_CMP322			  CODE	    11A5	5062
S_CMP323			  CODE	    11BC	5082
S_DIV16				  CODE	    0BF2	3681
S_DIV161			  CODE	    0C00	3691
S_DIV32				  CODE	    0C9A	3843
S_DIV321			  CODE	    0CAA	3855
S_DIV8				  CODE	    0BC0	3620
S_DIV81				  CODE	    0BD1	3626
S_MAC16				  CODE	    0B9E	3580
S_MAC161			  CODE	    0BBA	3600
S_MUL16				  CODE	    0B50	3482
S_MUL16ACC1			  CODE	    0B5D	3500
S_MUL816			  CODE	    0B6A	3519
S_MULDIV			  CODE	    0DC9	4149
S_MULDIV1			  CODE	    0DD9	4161
S_SHIFTLEFT1			  CODE	    10BD	4843
S_SHIFTLEFT2			  CODE	    10C5	4849
S_SHIFTLEFT3			  CODE	    10C9	4854
S_SHIFTLEFT32			  CODE	    10B5	4839
S_SHIFTRIGHT1			  CODE	    1086	4789
S_SHIFTRIGHT2			  CODE	    108E	4795
S_SHIFTRIGHT20			  CODE	    109A	4801
S_SHIFTRIGHT3			  CODE	    109C	4803
S_SHIFTRIGHT32			  CODE	    107E	4785
S_SQRT32			  CODE	    100F	4665
S_SQRT321			  CODE	    101D	4673
S_SUB16				  CODE	    09C2	3076
S_SUB161			  CODE	    09F0	3111
S_SUB162			  CODE	    09F4	3113
S_SUB163			  CODE	    09FA	3118
S_SUB32				  CODE	    0A1D	3179
S_SUB321			  CODE	    0A59	3229
S_SUB322			  CODE	    0A5B	3230
S_SUB323			  CODE	    0A61	3235
T0				  BIT	      B4	 114
T1				  BIT	      B5	 115
T2				  BIT	      90	  92
T2CON				  DATA	      C8	  53
T2EX				  BIT	      91	  93
T3CON				  DATA	      9E	  23
T3FD				  DATA	      9D	  24
TABLE_LU			  CODE	    120F	5174
TABLE_LU1			  CODE	    1234	5200
TABLE_LU2			  CODE	    1245	5213
TABLE_LU3			  CODE	    127E	5256
TABLE_LU4			  CODE	    1290	5269

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TABLE_LU_10			  CODE	    123B	5205
TB8				  BIT	      9B	  97
TCLK				  BIT	      CC	 138
TCON				  DATA	      88	  12
TEXT				  CODE	    004D	 227
TF0				  BIT	      8D	  89
TF1				  BIT	      8F	  91
TF2				  BIT	      CF	 141
TH0				  DATA	      8C	  16
TH1				  DATA	      8D	  17
TH2				  DATA	      CD	  57
TI				  BIT	      99	  95
TIMECON				  DATA	      A1	  26
TL0				  DATA	      8A	  14
TL1				  DATA	      8B	  15
TL2				  DATA	      CC	  56
TMOD				  DATA	      89	  13
TOETSIN				  CODE	    15A0	6128
TOETSTABEL			  CODE	    15C4	6155
TOETS_FLANK			  CODE	    14D8	5882
TOETS_INGEDRUKT			  CODE	    14E7	5905
TR0				  BIT	      8C	  88
TR1				  BIT	      8E	  90
TR2				  BIT	      CA	 136
TXD				  BIT	      B1	 111
WCOL				  BIT	      FE	 176
WDCON				  DATA	      C0	  49
WDE				  BIT	      C1	 127
WDIR				  BIT	      C3	 129
WDS				  BIT	      C2	 128
WDWR				  BIT	      C0	 126
WISSEN				  CODE	    04AF	1634
WR				  BIT	      B6	 116
XOFF				  NUMBER    0013	1627
XONXOFF				  CODE	    0537	1787
XONXOFF1			  CODE	    0543	1793
XONXOFF2			  CODE	    053E	1790
XONXOFF3			  CODE	    0548	1795
