
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 19.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 19.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 19.lst



 Line  I  Addr  Code            Source

    1:				;Anton Peeters en Pieter-Jan Steeman
    2:
    3:				$nolist
  181:
  182:		N      007F	stack_init	equ	07fh
  183:		N      0000			org	0000h
  184:
  185:	  0000	02 00 0E			ljmp	start
  186:		N      000B			org	000bh
  187:	  000B	02 00 29			ljmp	int0_rout
  188:
  189:	  000E	75 81 7F	start:		mov	sp,#stack_init
  190:	  0011	90 00 45			mov	dptr, #seq1
  191:	  0014	75 CA B2			mov	rcap2l,#0B2h
  192:	  0017	75 CB E4			mov	rcap2h,#0E4h
  193:	  001A	75 D7 00			mov	PLLCON,#00h
  194:	  001D	D2 CA				setb	TR2
  195:	  001F	D2 AF				setb	ea
  196:	  0021	D2 AD				setb	et2
  197:	  0023	C2 CB				clr	exen2
  198:	  0025	78 08				mov	r0,#8
  199:	  0027	80 FE		loop:		sjmp	loop
  200:
  201:	  0029	75 CD E4	int0_rout:	mov	th2,#0E4h
  202:	  002C	75 CC B2			mov	tl2,#0B2h
  203:	  002F	74 00				mov	a,#0
  204:	  0031	93				movc	a,@a+dptr
  205:	  0032	F5 A0				mov	p2,a
  206:	  0034	A3				inc	dptr
  207:
  208:	  0035	C0 E0				push	acc
  209:	  0037	18				dec	r0
  210:	  0038	E8				mov	a,r0
  211:	  0039	70 05				jnz	pjenis
  212:	  003B	78 08				mov	r0,#8
  213:	  003D	90 00 45			mov	dptr, #seq1
  214:
  215:	  0040	D0 E0		pjenis:		pop	acc
  216:	  0042	C2 CF				clr	tf2
  217:	  0044	32				reti
  218:
  219:	  0045	FE		seq1:		DB	11111110b
  220:	  0046	FA				DB	11111010b

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  221:	  0047	FB				DB	11111011b
  222:	  0048	F9				DB	11111001b
  223:	  0049	FD				DB	11111101b
  224:	  004A	F5				DB	11110101b
  225:	  004B	F7				DB	11110111b
  226:	  004C	F6				DB	11110110b
  227:
  228:				$include (c:/aduc800_mideA.inc)
  229: 1			;******************************************************************************
  230: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  231: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  232: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  233: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  234: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  235: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  236: 1			;******************************************************************************
  237: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  238: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  239: 1			;******************************************************************************
  240: 1
  241: 1
  242: 1			;******************************************************************************
  243: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  244: 1			; hebben voor onze toepassing. Door een module te definieren via het
  245: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  246: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  247: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  248: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  249: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  250: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  251: 1			; definities.
  252: 1			;******************************************************************************
  253: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  254: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  255: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  256: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  257: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  258: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  259: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  260: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  261: 1
  262: 1			ifdef    aduc_key
  263: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  264: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  265: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  266: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  267: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  268: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  269: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  270: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  271: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  272: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  273: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  274: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  275: 1			;definities wel gemaakt worden.
  276: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  277: 1			                            ;anders commentaar van maken!
  278: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  279: 1			                            ;gelezen, anders commentaar van maken!
  280: 1			;******************************************************************************
  281: 1			;Declaraties van de flags voor de aduc_key driver.
  282: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  283: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  284: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  285: 1			;switch_init en read_switch.
  286: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  287: 1			                                ;bereik = 20h-2fh!
  288: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  289: 1			                                   ;een geldige waarde bevat
  290: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  291: 1			                                   ;die de detectie mode aangeeft
  292: 1			;declaratie van de read_switch flags
  293: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  294: 1			                                   ;ontdenderde schakelaars zijn
  295: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  296: 1			                                   ;flanken zijn
  297: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  298: 1			                                   ;flanken zijn
  299: 1			ifdef    matrix        ;matrix keyboard
  300: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  301: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  302: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  303: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  304: 1			;toepassing.
  305: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  306: 1			                                ;geheugenbuffer
  307: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  308: 1			                                ;debounce en de flankdetectie samples stockeren
  309: 1			                                ;de eerste 4 bytes dienen voor debouncing
  310: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  311: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  312: 1			                                ;toetswaarde aangeeft
  313: 1			                                ;bij een geldige keyvalid flag ('1')
  314: 1			endif    ;einde matrix keyboard
  315: 1
  316: 1			ifdef    dipswitch
  317: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  318: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  319: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  320: 1			;toepassing
  321: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  322: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  323: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  324: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  325: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  326: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  327: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  328: 1			endif    ;einde dipswitch
  329: 1			;******************************************************************************
  330: 1			endif    ;einde aduc_key
  331: 1
  332: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  333: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  334: 1
  335: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  336: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  337: 1			endif                               ;dus doen we dit hier nog eens!
  338: 1			;******************************************************************************
  339: 1
  340: 1			;******************************************************************************
  341: 1			;
  342: 1			; ADuc_lcd.inc
  343: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  344: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  345: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  346: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  347: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  348: 1			; het plaatsen van de cursor op een correcte plaats).
  349: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  350: 1			; display gebruiken.
  351: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  352: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  353: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  354: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  355: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  356: 1			;
  357: 1			; Versie ADuC832v1.1:
  358: 1			; Hier is het LCD verbonden met pinnen van poort0
  359: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  360: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  361: 1			;
  362: 1			; Versie ADuC832v2.2:
  363: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  364: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  365: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  366: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  367: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  368: 1			;
  369: 1			;
  370: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  371: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  372: 1			;  aduclcd0.inc
  373: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  374: 1			;  aduclcd1.inc
  375: 1			;    -00dh en 00ah worden door outchar verwerkt
  376: 1			;    -bij de init wordt het display anders opgestart
  377: 1			;
  378: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  379: 1			;  van gebruik en uitgebreid  met :
  380: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  381: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  382: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  383: 1			;    debug doeleinden
  384: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  385: 1			;    user codes aan te maken
  386: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  387: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  388: 1			;

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  389: 1			; Beschikbare routines:
  390: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  391: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  392: 1			; build_adr, delay2ms, delay60us
  393: 1			;******************************************************************************
  394: 1
  395: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  396: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  397: 1			e             bit    lcdport.2            ;enable
  398: 1			rs            bit    lcdport.3            ;register select
  399: 1			endif    ;einde aduc832_v1_1
  400: 1
  401: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  402: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  403: 1	B	 F1	e             bit    lcdport.1            ;enable
  404: 1	B	 F0	rs            bit    lcdport.0            ;register select
  405: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  406: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  407: 1			endif    ;einde aduc832_v2_0
  408: 1
  409: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  410: 1			;het uitvoeren van de overeenkomstige commando's.
  411: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  412: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  413: 1
  414: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  415: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  416: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  417: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  418: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  419: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  420: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  421: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  422: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  423: 1
  424: 1			;******************************************************************************
  425: 1			;
  426: 1			; initlcd
  427: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  428: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  429: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  430: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  431: 1			; Na initialisering wordt het scherm leeg gemaakt.
  432: 1			;
  433: 1			; registergebruik: geen
  434: 1			;
  435: 1			;******************************************************************************
  436: 1
  437: 1  004D	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  438: 1  004F	C0 D0		              push   psw
  439: 1  0051	C0 F0		              push   b
  440: 1			ifdef  aduc832_v1_1
  441: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  442: 1			                                   ;let op:twee laagste bits worden
  443: 1			                                   ;niet gebruikt
  444: 1			endif

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  445: 1
  446: 1			ifdef    aduc832_v2_0
  447: 1  0053	12 03 43	              lcall  i2cinit              ;LCD via een I2C bus
  448: 1  0056	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  449: 1			                                          ;buzzer en backlight  op 1 gezet
  450: 1  0059	12 04 46	              lcall  porttolcd            ;data uit b naar het scherm
  451: 1			endif
  452: 1
  453: 1  005C	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  454: 1  005E	12 03 18	initlcd1:     lcall  delay2ms
  455: 1  0061	D5 E0 FA	              djnz   acc,initlcd1
  456: 1  0064	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  457: 1  0066	12 01 CF	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  458: 1  0069	12 03 18	              lcall  delay2ms      ;om het display altijd opgestart
  459: 1  006C	74 30		              mov    a,#00110000b  ;te krijgen.
  460: 1  006E	12 01 CF	              lcall  outhnibc
  461: 1  0071	12 03 18	              lcall  delay2ms
  462: 1  0074	74 30		              mov    a,#00110000b
  463: 1  0076	12 01 CF	              lcall  outhnibc
  464: 1  0079	12 03 18	              lcall  delay2ms
  465: 1  007C	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  466: 1  007E	12 01 CF	              lcall  outhnibc      ;hoge nibble naar het controleregister
  467: 1  0081	12 03 18	              lcall  delay2ms      ;niet nodig volgens datasheet
  468: 1  0084	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  469: 1  0086	12 01 B9	              lcall  outc          ;naar display
  470: 1  0089	12 03 18	              lcall  delay2ms      ;is iets te lang volgens datasheet
  471: 1  008C	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  472: 1  008E	12 01 B9	              lcall  outc
  473: 1  0091	12 03 18	              lcall  delay2ms      ;ook deze delay is iets te lang
  474: 1  0094	74 01		              mov    a,#displayon  ;clear display and home cursor
  475: 1  0096	12 01 B9	              lcall  outc
  476: 1  0099	12 03 18	              lcall  delay2ms      ;deze wachttijd is bijna juist
  477: 1  009C	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  478: 1  009E	12 01 B9	              lcall  outc
  479: 1  00A1	12 03 18	              lcall  delay2ms      ;wachten weer veel te lang
  480: 1  00A4	D0 F0		              pop    b
  481: 1  00A6	D0 D0		              pop    psw           ;registers terug in orde zetten
  482: 1  00A8	D0 E0		              pop    acc
  483: 1  00AA	22		              ret                  ;einde van de initialisatie
  484: 1
  485: 1			;******************************************************************************
  486: 1			;
  487: 1			; outcharlcd
  488: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  489: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  490: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  491: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  492: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  493: 1			; De controlekarakters komen overeen met volgende acties:
  494: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  495: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  496: 1			;              (line feed+ carriage return!)
  497: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  498: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  499: 1			;      011h   =cursor on, blink mode
  500: 1			;      012h   =cursor on, no blink mode

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  501: 1			;      013h   =cursor off
  502: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  503: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  504: 1			;              van het LCD
  505: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  506: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  507: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  508: 1			; positie 6 (C5H-80H=45H)
  509: 1			;
  510: 1			; Deze routine vernietigt geen registers
  511: 1			;
  512: 1			;******************************************************************************
  513: 1
  514: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  515: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  516: 1			; dataregister van het scherm.
  517: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  518: 1			; controlebyte doorsturen naar het LCD.
  519: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  520: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  521: 1			; naar de LCD sturen.
  522: 1
  523: 1  00AB	C0 E0		outcharlcd:   push   acc           ;registers op stack
  524: 1  00AD	C0 D0		              push   psw
  525: 1  00AF	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  526: 1  00B2	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  527: 1  00B4	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  528: 1  00B7	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  529: 1  00B9	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  530: 1  00BC	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  531: 1
  532: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  533: 1			; Als het een commando is, moeten we het uitvoeren.
  534: 1			; Indien niet, gewoon terug zonder actie!
  535: 1
  536: 1  00BE	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  537: 1  00C1	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  538: 1  00C3	80 28		              sjmp   outcharlcd9          ;afsluiten
  539: 1
  540: 1  00C5	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  541: 1  00C8	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  542: 1  00CA	80 21		              sjmp   outcharlcd9
  543: 1
  544: 1  00CC	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  545: 1  00CF	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  546: 1  00D1	80 1A		              sjmp   outcharlcd9
  547: 1
  548: 1  00D3	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  549: 1  00D6	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  550: 1  00D8	80 13		              sjmp   outcharlcd9
  551: 1
  552: 1  00DA	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  553: 1  00DD	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  554: 1  00DF	80 0C		              sjmp   outcharlcd9
  555: 1
  556: 1  00E1	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  557: 1  00E4	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  558: 1  00E6	80 05		              sjmp   outcharlcd9
  559: 1
  560: 1
  561: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  562: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  563: 1
  564: 1  00E8	12 01 7F	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  565: 1  00EB	80 03		              sjmp   outcharlcde   ;einde routine
  566: 1
  567: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  568: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  569: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  570: 1			; op dat adres te zetten.
  571: 1
  572: 1  00ED	12 01 B9	outcharlcd9:  lcall  outc          ;klaar
  573: 1  00F0	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  574: 1  00F2	D0 E0		              pop    acc
  575: 1  00F4	22		              ret
  576: 1
  577: 1			;******************************************************************************
  578: 1			;
  579: 1			; outniblcd
  580: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  581: 1			; op het lcd scherm.
  582: 1			;
  583: 1			; de routine vernietigt geen registers
  584: 1			;
  585: 1			;******************************************************************************
  586: 1
  587: 1  00F5	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  588: 1  00F7	C0 D0		              push   psw
  589: 1  00F9	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  590: 1  00FB	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  591: 1  00FD	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  592: 1  0100	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  593: 1  0102	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  594: 1  0104	12 01 7F	outniblcde:   lcall  outd          ;naar het scherm
  595: 1  0107	D0 D0		              pop    psw
  596: 1  0109	D0 E0		              pop    acc
  597: 1  010B	22		              ret
  598: 1
  599: 1			;******************************************************************************
  600: 1			;
  601: 1			; outbytelcd
  602: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  603: 1			;
  604: 1			; de routine vernietigt geen registers
  605: 1			;
  606: 1			;******************************************************************************
  607: 1
  608: 1  010C	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  609: 1  010E	C0 D0		              push   psw
  610: 1  0110	C4		              swap   a             ;bitjes omruilen
  611: 1  0111	12 00 F5	              lcall  outniblcd
  612: 1  0114	C4		              swap   a             ;nog eens

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  613: 1  0115	12 00 F5	              lcall  outniblcd
  614: 1  0118	D0 D0		              pop    psw
  615: 1  011A	D0 E0		              pop    acc
  616: 1  011C	22		              ret
  617: 1
  618: 1			;******************************************************************************
  619: 1			;
  620: 1			; dispdptrlcd
  621: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  622: 1			;
  623: 1			; de routine vernietigt geen registers
  624: 1			;
  625: 1			;******************************************************************************
  626: 1
  627: 1  011D	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  628: 1  011F	C0 D0		              push   psw
  629: 1  0121	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  630: 1  0123	12 01 0C	              lcall  outbytelcd
  631: 1  0126	E5 82		              mov    a,dpl         ;dan het lage deel
  632: 1  0128	12 01 0C	              lcall  outbytelcd
  633: 1  012B	D0 D0		              pop    psw
  634: 1  012D	D0 E0		              pop    acc
  635: 1  012F	22		              ret
  636: 1
  637: 1			;******************************************************************************
  638: 1			;
  639: 1			; outmsgalcd
  640: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  641: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  642: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  643: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  644: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  645: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  646: 1			;
  647: 1			; de routine vernietigt geen registers
  648: 1			;
  649: 1			;******************************************************************************
  650: 1
  651: 1  0130	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  652: 1  0132	C0 D0		              push   psw
  653: 1  0134	C0 83		              push   dph           ;ook de data pointer
  654: 1  0136	C0 82		              push   dpl
  655: 1
  656: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  657: 1
  658: 1  0138	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  659: 1  0139	93		              movc   a,@a+dptr     ;waarde lezen
  660: 1  013A	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  661: 1
  662: 1			; de code is niet 0 dus versturen met outchar
  663: 1
  664: 1  013C	12 00 AB	              lcall  outcharlcd    ;weg er mee
  665: 1  013F	A3		              inc    dptr          ;naar volgende ascii code wijzen
  666: 1  0140	02 01 38	              ljmp   outmsgalcd1   ;lus sluiten
  667: 1
  668: 1  0143	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  669: 1  0145	D0 83		              pop    dph
  670: 1  0147	D0 D0		              pop    psw
  671: 1  0149	D0 E0		              pop    acc
  672: 1  014B	22		              ret
  673: 1
  674: 1			;******************************************************************************
  675: 1			;
  676: 1			; regtolcd
  677: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  678: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  679: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  680: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  681: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  682: 1			;
  683: 1			; de routine vernietigt geen registers
  684: 1			;
  685: 1			;******************************************************************************
  686: 1
  687: 1
  688: 1  014C	C0 E0		regtolcd:     push   acc           ;registers op de stack
  689: 1  014E	C0 D0		              push   psw
  690: 1  0150	E8		              mov    a,r0
  691: 1  0151	C0 E0		              push   acc
  692: 1  0153	E9		              mov    a,r1
  693: 1  0154	C0 E0		              push   acc
  694: 1  0156	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  695: 1  0158	12 00 AB	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  696: 1			                                   ;plaats
  697: 1  015B	79 00		              mov    r1,#000h      ;werkt als loopcounter
  698: 1  015D	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  699: 1  015E	12 00 AB	              lcall  outcharlcd    ;weg er mee
  700: 1  0161	08		              inc    r0
  701: 1  0162	09		              inc    r1
  702: 1  0163	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  703: 1			                                          ;nieuwe lijn genomen worden
  704: 1  0166	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  705: 1  0168	12 00 AB	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  706: 1			                                   ;plaats
  707: 1
  708: 1  016B	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  709: 1  016C	12 00 AB	              lcall  outcharlcd    ;weg er mee
  710: 1  016F	08		              inc    r0
  711: 1  0170	09		              inc    r1
  712: 1  0171	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  713: 1  0174	D0 E0		              pop    acc
  714: 1  0176	F9		              mov    r1,a
  715: 1  0177	D0 E0		              pop    acc
  716: 1  0179	F8		              mov    r0,a
  717: 1  017A	D0 D0		              pop    psw           ;registers herstellen
  718: 1  017C	D0 E0		              pop    acc
  719: 1  017E	22		              ret
  720: 1
  721: 1			;******************************************************************************
  722: 1			;
  723: 1			; outd
  724: 1			; Is een routine die naar het data register van het display een

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  725: 1			; volledige byte stuurt.
  726: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  727: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  728: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  729: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  730: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  731: 1			;
  732: 1			; De routine vernietigt geen registers.
  733: 1			;
  734: 1			;******************************************************************************
  735: 1
  736: 1  017F	C0 E0		outd:         push   acc           ;registers op stack zetten
  737: 1  0181	C0 D0		              push   psw
  738: 1  0183	12 01 8F	              lcall  outhnibd      ;hoogste vier bits verzenden
  739: 1			ifdef     aduc832_v1_1
  740: 1			              lcall  delay60us     ;niet echt nodig
  741: 1			endif
  742: 1  0186	C4		              swap   a             ;bitjes omruilen
  743: 1  0187	12 01 8F	              lcall  outhnibd      ;naar het scherm sturen
  744: 1
  745: 1			ifdef    aduc832_v1_1
  746: 1			              lcall  delay60us     ;altijd goed
  747: 1			endif
  748: 1
  749: 1  018A	D0 D0		              pop    psw           ;registers terug herstellen
  750: 1  018C	D0 E0		              pop    acc
  751: 1  018E	22		              ret
  752: 1
  753: 1			;******************************************************************************
  754: 1			;
  755: 1			; outhnibd
  756: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  757: 1			; lcd scherm.
  758: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  759: 1			; de routine vernietigt geen registers.
  760: 1			;
  761: 1			;******************************************************************************
  762: 1			ifdef     aduc832_v1_1
  763: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  764: 1			              push   psw
  765: 1			              setb   rs            ;controle lijn in orde
  766: 1			              clr    e             ;deselectie display
  767: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  768: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  769: 1			              mov     c,acc.6      ;afblijven!
  770: 1			              mov     lcdport.6,c
  771: 1			              mov     c,acc.5
  772: 1			              mov     lcdport.5,c
  773: 1			              mov     c,acc.4
  774: 1			              mov     lcdport.4,c
  775: 1			              setb   e             ;display enabelen
  776: 1			              nop                  ;450ns is normaal gezien voldoende
  777: 1			              clr    e             ;display deselecteren
  778: 1			              pop    psw           ;registers herstellen
  779: 1			              pop    acc
  780: 1			              ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  781: 1			endif
  782: 1
  783: 1			ifdef    aduc832_v2_0
  784: 1  018F	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  785: 1  0191	C0 D0		              push   psw
  786: 1  0193	C0 F0		              push   b             ;werkregister
  787: 1  0195	12 04 5F	              lcall  lcdtoport     ;lees de expander naar b register
  788: 1  0198	D2 F0		              setb   rs            ;controle lijn in orde
  789: 1  019A	C2 F1		              clr    e             ;deselectie display
  790: 1  019C	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  791: 1  019E	03		              rr     a             ;bits op juiste plaats zetten
  792: 1  019F	03		              rr     a             ;voor b reg
  793: 1  01A0	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  794: 1  01A3	42 F0		              orl    b,a           ;bij elkaar voegen
  795: 1  01A5	12 04 46	              lcall  porttolcd     ;naar expander
  796: 1  01A8	D2 F1		              setb   e             ;display enabelen
  797: 1  01AA	12 04 46	              lcall  porttolcd
  798: 1  01AD	C2 F1		              clr    e             ;display deselecteren
  799: 1  01AF	12 04 46	              lcall  porttolcd
  800: 1  01B2	D0 F0		              pop    b
  801: 1  01B4	D0 D0		              pop    psw           ;registers herstellen
  802: 1  01B6	D0 E0		              pop    acc
  803: 1  01B8	22		              ret
  804: 1			endif
  805: 1			;******************************************************************************
  806: 1			;
  807: 1			; outc
  808: 1			; Is een routine die naar het controleregister van het display een
  809: 1			; volledige byte (commando) stuurt.
  810: 1			; De routine vernietigt geen registers.
  811: 1			;
  812: 1			;******************************************************************************
  813: 1
  814: 1  01B9	C0 E0		outc:         push   acc           ;registers op stack zetten
  815: 1  01BB	C0 D0		              push   psw
  816: 1  01BD	12 01 CF	              lcall  outhnibc      ;hoogste vier bits verzenden
  817: 1  01C0	12 03 18	              lcall  delay2ms      ;niet echt nodig
  818: 1  01C3	C4		              swap   a             ;bitjes omruilen
  819: 1  01C4	12 01 CF	              lcall  outhnibc      ;naar het scherm sturen
  820: 1  01C7	12 03 18	              lcall  delay2ms      ;altijd goed voor traagste commando
  821: 1  01CA	D0 D0		              pop    psw           ;registers terug herstellen
  822: 1  01CC	D0 E0		              pop    acc
  823: 1  01CE	22		              ret
  824: 1
  825: 1			;******************************************************************************
  826: 1			;
  827: 1			; outhnibc
  828: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  829: 1			; het lcd scherm.
  830: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  831: 1			; de routine vernietigt geen registers.
  832: 1			;
  833: 1			;******************************************************************************
  834: 1			ifdef     aduc832_v1_1
  835: 1			outhnibc:     push   acc           ;registers op stack plaatsen
  836: 1			              push   psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  837: 1			              clr    rs            ;controle lijn in orde
  838: 1			              clr    e             ;deselectie display
  839: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  840: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  841: 1			              mov     c,acc.6      ;afblijven!
  842: 1			              mov     lcdport.6,c
  843: 1			              mov     c,acc.5
  844: 1			              mov     lcdport.5,c
  845: 1			              mov     c,acc.4
  846: 1			              mov     lcdport.4,c
  847: 1			              setb   e             ;display enabelen
  848: 1			              nop                  ;450ns is normaal gezien voldoende
  849: 1			              clr    e             ;display deselecteren
  850: 1			              pop    psw           ;registers herstellen
  851: 1			              pop    acc
  852: 1			              ret
  853: 1			endif
  854: 1
  855: 1			ifdef    aduc832_v2_0
  856: 1  01CF	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
  857: 1  01D1	C0 D0		              push   psw
  858: 1  01D3	C0 F0		              push   b             ;werkregister
  859: 1  01D5	12 04 5F	              lcall  lcdtoport     ;lees de expander naar b register
  860: 1  01D8	C2 F0		              clr    rs            ;controle lijn in orde
  861: 1  01DA	C2 F1		              clr    e             ;deselectie display
  862: 1  01DC	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  863: 1  01DE	03		              rr     a             ;bits op juiste plaats zetten
  864: 1  01DF	03		              rr     a             ;voor b reg
  865: 1  01E0	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  866: 1  01E3	42 F0		              orl    b,a           ;bij elkaar voegen
  867: 1  01E5	12 04 46	              lcall  porttolcd     ;naar expnder
  868: 1  01E8	D2 F1		              setb   e             ;display enabelen
  869: 1  01EA	12 04 46	              lcall  porttolcd
  870: 1  01ED	C2 F1		              clr    e             ;display deselecteren
  871: 1  01EF	12 04 46	              lcall  porttolcd
  872: 1  01F2	D0 F0		              pop    b
  873: 1  01F4	D0 D0		              pop    psw           ;registers herstellen
  874: 1  01F6	D0 E0		              pop    acc
  875: 1  01F8	22		              ret
  876: 1			endif
  877: 1
  878: 1			;******************************************************************************
  879: 1			; hexbuf2lcd
  880: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  881: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  882: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  883: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  884: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  885: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  886: 1			;
  887: 1			; ADR| HEX DATA  |
  888: 1			; 42 |AF 2D 23 5A|
  889: 1			;
  890: 1			; Deze routine vernietigt geen registers
  891: 1			;******************************************************************************
  892: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  893: 1  01F9	C0 E0		hexbuf2lcd:   push   acc
  894: 1  01FB	C0 F0		              push   b
  895: 1  01FD	C0 D0		              push   psw
  896: 1  01FF	C0 82		              push   dpl
  897: 1  0201	C0 83		              push   dph
  898: 1  0203	E8		              mov     a,r0
  899: 1  0204	C0 E0		              push   acc
  900: 1  0206	90 02 42	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
  901: 1  0209	12 01 30	              lcall   outmsgalcd
  902: 1  020C	E8		              mov    a,r0            ;neem pointerwaarde
  903: 1  020D	12 01 0C	              lcall  outbytelcd      ;byte afdrukken als startadres
  904: 1  0210	74 20		              mov    a,#' '          ;spatie afdrukken
  905: 1  0212	12 00 AB	              lcall  outcharlcd
  906: 1  0215	74 7C		              mov    a,#'|'          ;pipe afdrukken
  907: 1  0217	12 00 AB	              lcall  outcharlcd
  908: 1  021A	75 F0 04	              mov    b,#4            ;bytecounter=4
  909: 1  021D	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  910: 1  021E	12 01 0C	              lcall  outbytelcd      ;byte naar buiten
  911: 1  0221	74 20		              mov    a,#' '          ;neem whitespace char
  912: 1  0223	12 00 AB	              lcall  outcharlcd       ;druk af
  913: 1  0226	08		              inc    r0              ;volgende byte
  914: 1  0227	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
  915: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  916: 1  022A	74 CF		              mov    a,#0cfh         ;adres laatste char
  917: 1  022C	12 00 AB	              lcall   outcharlcd
  918: 1  022F	74 7C		              mov    a,#'|'          ;neem pipe
  919: 1  0231	12 00 AB	              lcall  outcharlcd      ;ascii code afdrukken
  920: 1  0234	D0 E0		hexbuf2lcde:  pop    acc
  921: 1  0236	F8		              mov   r0,a
  922: 1  0237	D0 83		              pop   dph
  923: 1  0239	D0 82		              pop   dpl
  924: 1  023B	D0 D0		              pop   psw
  925: 1  023D	D0 F0		              pop   b
  926: 1  023F	D0 E0		              pop   acc
  927: 1  0241	22		              ret
  928: 1			                        ;'0123456789abcdef'
  929: 1  0242	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  0246	52 7C 20 48
       1  024A	45 58 20 44
       1  024E	41 54 41 20
       1  0252	20 7C C0 00
  930: 1
  931: 1
  932: 1			;******************************************************************************
  933: 1			; barlcd
  934: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
  935: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
  936: 1			; de inhoud van A
  937: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
  938: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
  939: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
  940: 1			; aangemaakt in de LCD CGRAM.
  941: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
  942: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
  943: 1			;       lcall build
  944: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  945: 1			;       mov     a, #42h     ;de startlocatie is 42h
  946: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
  947: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
  948: 1			;
  949: 1			; Deze routine vernietigt geen registers.
  950: 1			;******************************************************************************
  951: 1
  952: 1  0256	C0 82		barlcd:       push   dpl
  953: 1  0258	88 82		              mov     dpl,r0
  954: 1  025A	C0 82		              push   dpl
  955: 1  025C	C0 E0		              push   acc            ;bewaar startlocatie
  956: 1  025E	C0 D0		              push   psw            ;bewaar status
  957: 1  0260	C0 F0		              push   b              ;bewaar aantal bar's
  958: 1  0262	F5 F0		              mov    b,a            ;bewaar startlocatie
  959: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
  960: 1  0264	E8		              mov    a,r0           ;neem maximum aantal bar's
  961: 1  0265	C0 F0		              push   b              ;bewaar startadres
  962: 1  0267	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
  963: 1  026A	84		              div    ab             ;bereken dus het aantal nodige blokjes
  964: 1  026B	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
  965: 1  026C	E5 F0		              mov    a,b            ;neem restbars
  966: 1  026E	60 01		              jz     barlcd_1       ;als nul dan verder
  967: 1  0270	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
  968: 1  0271	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
  969: 1  0273	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
  970: 1  0275	12 00 AB	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
  971: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
  972: 1  0278	74 13		              mov    a,#13h         ;cursor off
  973: 1  027A	12 00 AB	              lcall  outcharlcd     ;stuur naar LCD
  974: 1  027D	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
  975: 1  027F	C0 F0		              push   b              ;en weer bewaren
  976: 1  0281	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
  977: 1  0283	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
  978: 1  0285	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
  979: 1  0288	84		              div    ab             ;A=aantal volle blokjes, B=rest
  980: 1  0289	C0 F0		              push   b              ;bewaar rest
  981: 1  028B	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
  982: 1  028D	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
  983: 1
  984: 1			;Druk de volle 5x8 blokjes af van de bargraph
  985: 1  028F	74 04		              mov    a,#4           ;neem code voor vol blokje
  986: 1  0291	12 01 7F	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
  987: 1  0294	18		              dec    r0             ;verminder karaktersteller
  988: 1  0295	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
  989: 1
  990: 1			;Druk het onvolledige blokje (rest) af
  991: 1  0298	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
  992: 1  029A	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
  993: 1  029C	14		              dec    a              ;converteer rest naar code voor de
  994: 1			                                    ;overeenkomende bar's
  995: 1  029D	12 01 7F	              lcall  outd           ;druk resterende bar's af
  996: 1  02A0	18		              dec    r0             ;verminder karakterteller
  997: 1
  998: 1			;Test of we aan het einde van de bargraph zitten..
  999: 1  02A1	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
 1000: 1  02A4	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

 1001: 1
 1002: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
 1003: 1  02A6	74 20		barlcd4:      mov    a,#' '         ;neem spatie
 1004: 1  02A8	12 01 7F	              lcall  outd           ;en druk af
 1005: 1  02AB	18		              dec    r0             ;karakterteller verminderen
 1006: 1  02AC	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
 1007: 1
 1008: 1  02AE	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
 1009: 1  02B0	D0 D0		              pop    psw            ;haal status weer
 1010: 1  02B2	D0 E0		              pop    acc            ;haal startlocatie weer
 1011: 1  02B4	D0 82		              pop    dpl
 1012: 1  02B6	A8 82		              mov    r0,dpl
 1013: 1  02B8	D0 82		              pop    dpl
 1014: 1  02BA	22		              ret
 1015: 1
 1016: 1
 1017: 1
 1018: 1			;******************************************************************************
 1019: 1			; barchars
 1020: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
 1021: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
 1022: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
 1023: 1			; kunnen pas daarna worden gebruikt.
 1024: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
 1025: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
 1026: 1			; (max. 3 extra char's).
 1027: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
 1028: 1			; opgeslagen met MSB=1.
 1029: 1			;******************************************************************************
 1030: 1
 1031: 1  02BB	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1032: 1  02BC	10		              db 00010000b
 1033: 1  02BD	10		              db 00010000b
 1034: 1  02BE	10		              db 00010000b
 1035: 1  02BF	10		              db 00010000b
 1036: 1  02C0	10		              db 00010000b
 1037: 1  02C1	10		              db 00010000b
 1038: 1  02C2	10		              db 00010000b
 1039: 1
 1040: 1  02C3	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1041: 1  02C4	18		              db 00011000b
 1042: 1  02C5	18		              db 00011000b
 1043: 1  02C6	18		              db 00011000b
 1044: 1  02C7	18		              db 00011000b
 1045: 1  02C8	18		              db 00011000b
 1046: 1  02C9	18		              db 00011000b
 1047: 1  02CA	18		              db 00011000b
 1048: 1
 1049: 1  02CB	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1050: 1  02CC	1C		              db 00011100b
 1051: 1  02CD	1C		              db 00011100b
 1052: 1  02CE	1C		              db 00011100b
 1053: 1  02CF	1C		              db 00011100b
 1054: 1  02D0	1C		              db 00011100b
 1055: 1  02D1	1C		              db 00011100b
 1056: 1  02D2	1C		              db 00011100b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1057: 1
 1058: 1  02D3	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1059: 1  02D4	1E		              db 00011110b
 1060: 1  02D5	1E		              db 00011110b
 1061: 1  02D6	1E		              db 00011110b
 1062: 1  02D7	1E		              db 00011110b
 1063: 1  02D8	1E		              db 00011110b
 1064: 1  02D9	1E		              db 00011110b
 1065: 1  02DA	1E		              db 00011110b
 1066: 1
 1067: 1  02DB	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1068: 1  02DC	1F		              db 00011111b
 1069: 1  02DD	1F		              db 00011111b
 1070: 1  02DE	1F		              db 00011111b
 1071: 1  02DF	1F		              db 00011111b
 1072: 1  02E0	1F		              db 00011111b
 1073: 1  02E1	1F		              db 00011111b
 1074: 1  02E2	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1075: 1
 1076: 1			;******************************************************************************
 1077: 1			;
 1078: 1			; build
 1079: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1080: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1081: 1			; overeen komen met de ASCII codes 00h-07h.
 1082: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1083: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1084: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1085: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1086: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1087: 1			;
 1088: 1			; De routine vernietigt geen registers.
 1089: 1			;
 1090: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1091: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1092: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1093: 1			;      lcall  outcharlcd         ; druk de karakter af
 1094: 1			;
 1095: 1			;eigenkarakter:
 1096: 1			;      db 00001110b
 1097: 1			;      db 00001010b
 1098: 1			;      db 00001110b
 1099: 1			;      db 00000100b
 1100: 1			;      db 00011111b
 1101: 1			;      db 00000100b
 1102: 1			;      db 00001010b
 1103: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1104: 1			;******************************************************************************
 1105: 1
 1106: 1  02E3	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1107: 1  02E5	C0 D0		              push   psw
 1108: 1  02E7	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1109: 1  02E9	12 02 F1	              lcall  build_adr
 1110: 1  02EC	D0 D0		              pop    psw
 1111: 1  02EE	D0 E0		              pop    acc
 1112: 1  02F0	22		              ret                  ;terug

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1113: 1
 1114: 1			;******************************************************************************
 1115: 1			; build_adr
 1116: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1117: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1118: 1			; die overeen komen met de ASCII codes 00h-07h.
 1119: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1120: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1121: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1122: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1123: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1124: 1			;
 1125: 1			; De routine vernietigt geen registers.
 1126: 1			;
 1127: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1128: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1129: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1130: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1131: 1			;      lcall  outcharlcd        ; druk de karakter af
 1132: 1			;
 1133: 1			;eigenkarakters:
 1134: 1			;      db 00001110b
 1135: 1			;      db 00001010b
 1136: 1			;      db 00001110b
 1137: 1			;       db 00000100b
 1138: 1			;      db 00011111b
 1139: 1			;      db 00000100b
 1140: 1			;      db 00001010b
 1141: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1142: 1			;******************************************************************************
 1143: 1  02F1	C0 E0		build_adr:      push   acc
 1144: 1  02F3	C0 D0		              push   psw
 1145: 1  02F5	C0 83		              push   dph
 1146: 1  02F7	C0 82		              push   dpl
 1147: 1  02F9	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1148: 1  02FB	12 01 B9	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1149: 1  02FE	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1150: 1  0300	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1151: 1  0301	12 01 7F	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1152: 1  0304	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1153: 1  0307	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1154: 1  0308	80 F4		              sjmp   build3
 1155: 1  030A	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1156: 1  030C	12 01 B9	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1157: 1  030F	D0 82		              pop    dpl
 1158: 1  0311	D0 83		              pop    dph
 1159: 1  0313	D0 D0		              pop    psw
 1160: 1  0315	D0 E0		              pop    acc
 1161: 1  0317	22		              ret
 1162: 1
 1163: 1			;******************************************************************************
 1164: 1			;
 1165: 1			; delay2ms
 1166: 1			; Is een vertragingsroutine van 2ms.
 1167: 1			;
 1168: 1			; De routine vernietigt geen registers.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1169: 1			;
 1170: 1			;******************************************************************************
 1171: 1
 1172: 1  0318	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1173: 1  031A	C0 D0		              push   psw
 1174: 1  031C	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1175: 1  031E	12 03 29	delay2ms1:    lcall  delay60us
 1176: 1  0321	D5 E0 FA	              djnz   acc,delay2ms1
 1177: 1  0324	D0 D0		              pop    psw           ;registers herstellen
 1178: 1  0326	D0 E0		              pop    acc
 1179: 1  0328	22		              ret
 1180: 1
 1181: 1			;******************************************************************************
 1182: 1			;
 1183: 1			; delay60us.
 1184: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1185: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1186: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1187: 1			;
 1188: 1			; de routine vernietigt geen registers.
 1189: 1			;
 1190: 1			;******************************************************************************
 1191: 1
 1192: 1  0329	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1193: 1  032B	C0 D0		              push   psw
 1194: 1  032D	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1195: 1  032F	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1196: 1
 1197: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1198: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1199: 1
 1200: 1  0331	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1201: 1  0334	D0 E0		              pop    acc           ;registers herstellen
 1202: 1  0336	D0 D0		              pop    psw
 1203: 1  0338	22		              ret
 1204: 1
 1205: 1  0339	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1206: 1  033B	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1207: 1  033E	D0 D0		              pop    psw
 1208: 1  0340	D0 E0		              pop    acc
 1209: 1  0342	22		              ret
 1210: 1
 1211: 1			endif        ;einde van aduc_lcd
 1212: 1
 1213: 1
 1214: 1
 1215: 1
 1216: 1			ifdef aduc_i2c
 1217: 1			;******************************************************************************
 1218: 1			;
 1219: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1220: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1221: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1222: 1			;
 1223: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1224: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1225: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1226: 1			;
 1227: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1228: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1229: 1			;
 1230: 1			; Beschikbare routines:
 1231: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1232: 1			; i2cstart     :verzenden van een start conditie
 1233: 1			; i2cstop      :verzenden van een stop conditie
 1234: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1235: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1236: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1237: 1			;               negende klokpuls
 1238: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1239: 1			;               negende klokpuls
 1240: 1			;
 1241: 1			; Toevoeging [dp]
 1242: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1243: 1			;               een slavedevice
 1244: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1245: 1			;               en plaatst deze in een geheugenbuffer
 1246: 1			;******************************************************************************
 1247: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1248: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1249: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1250: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1251: 1
 1252: 1			;******************************************************************************
 1253: 1			; i2cinit
 1254: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1255: 1			;******************************************************************************
 1256: 1  0343	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1257: 1  0345	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1258: 1  0347	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1259: 1  0349	D2 EB		                setb    i2cm            ;master mode inschakelen
 1260: 1  034B	22		                ret
 1261: 1			;******************************************************************************
 1262: 1			; i2cstart
 1263: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1264: 1			;******************************************************************************
 1265: 1  034C	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1266: 1  034E	C2 EF		                clr     mdo             ;data moet laag worden
 1267: 1  0350	D2 EE		                setb    mde             ;data pin enable
 1268: 1  0352	C2 ED		                clr     mco             ;klok laag maken
 1269: 1  0354	22		                ret
 1270: 1			;******************************************************************************
 1271: 1			; i2cstop
 1272: 1			; Dit is een subroutine die de stop conditie opwekt.
 1273: 1			;******************************************************************************
 1274: 1  0355	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1275: 1  0357	D2 EE		                setb    mde             ;data mag naar buiten
 1276: 1  0359	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1277: 1  035B	D2 EF		                setb    mdo             ;nu data pin hoog maken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1278: 1  035D	22		                ret
 1279: 1
 1280: 1			;******************************************************************************
 1281: 1			; i2coutbyte
 1282: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1283: 1			; De routine vernietigt geen registers.
 1284: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1285: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1286: 1			;         uitvoeren van de routine.
 1287: 1			;******************************************************************************
 1288: 1  035E	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1289: 1  0360	C0 F0		                push    b
 1290: 1  0362	75 F0 08	                mov     b,#008h         ;loopcounter
 1291: 1  0365	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1292: 1  0366	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1293: 1  0368	D2 EE		                setb    mde             ;pin als output activeren
 1294: 1  036A	D2 ED		                setb    mco             ;klokpukls hoog
 1295: 1  036C	C2 ED		                clr     mco             ;klokpuls laag
 1296: 1  036E	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1297: 1  0371	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1298: 1  0373	D2 ED		                setb    mco             ;klokpuls hoog
 1299: 1  0375	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1300: 1  0377	C2 ED		                clr     mco             ;klokpuls terug laag
 1301: 1  0379	D0 F0		                pop     b
 1302: 1  037B	D0 E0		                pop     acc             ;registers herstellen
 1303: 1  037D	22		                ret
 1304: 1
 1305: 1			;******************************************************************************
 1306: 1			; i2cinbyteack
 1307: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1308: 1			; De routine vernietigt geen registers. De routine zal als
 1309: 1			; negende bit een ack verzenden.
 1310: 1			;******************************************************************************
 1311: 1  037E	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1312: 1  0380	C0 D0		                push    psw
 1313: 1  0382	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1314: 1  0385	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1315: 1  0387	D2 ED		                setb    mco             ;klokpuls hoog
 1316: 1  0389	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1317: 1  038B	C2 ED		                clr     mco             ;klokpuls terug laag
 1318: 1  038D	33		                rlc     a               ;in accu shiften
 1319: 1  038E	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1320: 1  0391	C3		                clr     c               ;ack verzenden
 1321: 1  0392	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1322: 1  0394	D2 EE		                setb    mde             ;pin als output activeren
 1323: 1  0396	D2 ED		                setb    mco             ;klokpukls hoog
 1324: 1  0398	C2 ED		                clr     mco             ;klokpuls laag
 1325: 1  039A	D0 D0		                pop     psw             ;registers herstellen
 1326: 1  039C	D0 F0		                pop     b
 1327: 1  039E	22		                ret
 1328: 1
 1329: 1			;******************************************************************************
 1330: 1			; i2cinbytenack
 1331: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1332: 1			; De routine vernietigt geen registers. De routine zal als
 1333: 1			; negende bit een nack verzenden.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1334: 1			;******************************************************************************
 1335: 1  039F	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1336: 1  03A1	C0 D0		                push    psw
 1337: 1  03A3	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1338: 1  03A6	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1339: 1  03A8	D2 ED		                setb    mco             ;klokpuls hoog
 1340: 1  03AA	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1341: 1  03AC	C2 ED		                clr     mco             ;klokpuls terug laag
 1342: 1  03AE	33		                rlc     a               ;in accu shiften
 1343: 1  03AF	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1344: 1  03B2	D3		                setb    c               ;nack verzenden
 1345: 1  03B3	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1346: 1  03B5	D2 EE		                setb    mde             ;pin als output activeren
 1347: 1  03B7	D2 ED		                setb    mco             ;klokpukls hoog
 1348: 1  03B9	C2 ED		                clr     mco             ;klokpuls laag
 1349: 1  03BB	D0 D0		                pop     psw             ;registers herstellen
 1350: 1  03BD	D0 F0		                pop     b
 1351: 1  03BF	22		                ret
 1352: 1
 1353: 1			;******************************************************************************
 1354: 1			; i2csenddata
 1355: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1356: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1357: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1358: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1359: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1360: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1361: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1362: 1			;
 1363: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1364: 1			; pointer naar deze data.  .
 1365: 1
 1366: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1367: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1368: 1			;         B       = aantal te versturen bytes (minimum 1)
 1369: 1			;         R0      = startadres van te versturen datablok
 1370: 1			;
 1371: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1372: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1373: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1374: 1			;               verzonden byte waarvoor er geen ack kwam.
 1375: 1			;
 1376: 1			; Deze routine vernietigt niets...
 1377: 1			;******************************************************************************
 1378: 1  03C0	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1379: 1  03C2	C0 D0		                    push   psw
 1380: 1  03C4	E8		                    mov    a,r0
 1381: 1  03C5	C0 E0		                    push   acc           ;r0 op stack
 1382: 1
 1383: 1  03C7	12 03 4C	                    lcall  i2cstart      ;genereer startconditie
 1384: 1  03CA	E5 83		                    mov    a,dph         ;neem adresbyte
 1385: 1  03CC	12 03 5E	                    lcall  i2coutbyte    ;en verstuur naar slave
 1386: 1  03CF	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1387: 1  03D1	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1388: 1  03D3	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1389: 1  03D5	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1390: 1			;10 bit adressering!
 1391: 1  03D8	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1392: 1  03DA	12 03 5E	                    lcall  i2coutbyte    ;en verstuur naar slave
 1393: 1  03DD	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1394: 1			;7 bit adressering!
 1395: 1  03DF	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1396: 1  03E0	12 03 5E	                    lcall  i2coutbyte    ;en verstuur naar slave
 1397: 1  03E3	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1398: 1  03E5	08		                    inc    r0            ;volgende byte
 1399: 1  03E6	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1400: 1  03E9	12 03 55	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1401: 1  03EC	D0 E0		                    pop    acc
 1402: 1  03EE	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1403: 1  03EF	D0 D0		                    pop    psw
 1404: 1  03F1	C3		                    clr    c             ;alles is ok!
 1405: 1  03F2	D0 E0		                    pop    acc
 1406: 1  03F4	22		                    ret
 1407: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1408: 1  03F5	12 03 55	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1409: 1  03F8	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1410: 1  03FA	D0 D0		                    pop    psw
 1411: 1  03FC	D3		                    setb   c            ;terug met foutmelding
 1412: 1  03FD	D0 E0		                    pop    acc
 1413: 1  03FF	22		                    ret
 1414: 1
 1415: 1			;******************************************************************************
 1416: 1			; i2crcvdata
 1417: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1418: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1419: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1420: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1421: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1422: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1423: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1424: 1			;
 1425: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1426: 1			; is een pointer naar de start van dit ontvangen datablok.
 1427: 1			;
 1428: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1429: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1430: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1431: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1432: 1			;
 1433: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1434: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1435: 1			;               het adres, wordt de CY bit geset bij return.
 1436: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1437: 1			;
 1438: 1			; Deze routine vernietigt verder niets...
 1439: 1			;******************************************************************************
 1440: 1  0400	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1441: 1  0402	C0 D0		                    push    psw
 1442: 1  0404	E8		                    mov     a,r0            ;r0 op stack
 1443: 1  0405	C0 E0		                    push    acc
 1444: 1
 1445: 1  0407	12 03 4C	                    lcall   i2cstart        ;genereer startconditie

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1446: 1  040A	E5 83		                    mov     a,dph           ;neem adresbyte
 1447: 1  040C	12 03 5E	                    lcall   i2coutbyte      ;en verstuur naar slave
 1448: 1  040F	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1449: 1  0411	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1450: 1  0413	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1451: 1  0415	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1452: 1			;10 bit adressering!
 1453: 1  0418	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1454: 1  041A	12 03 5E	                    lcall   i2coutbyte      ;en verstuur naar slave
 1455: 1  041D	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1456: 1			;7 bit adressering!
 1457: 1
 1458: 1  041F	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1459: 1  0422	12 03 9F	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1460: 1  0425	F6		                    mov     @r0,a           ;en deze ook bewaren
 1461: 1  0426	80 07		                    sjmp    i2crcvdata3
 1462: 1  0428	12 03 7E	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1463: 1  042B	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1464: 1  042C	08		                    inc     r0              ;pointer verhogen
 1465: 1  042D	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1466: 1
 1467: 1  042F	12 03 55	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1468: 1  0432	D0 E0		                    pop     acc
 1469: 1  0434	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1470: 1  0435	D0 D0		                    pop     psw
 1471: 1  0437	C3		                    clr     c               ;alles is ok!
 1472: 1  0438	D0 E0		                    pop     acc
 1473: 1  043A	22		                    ret
 1474: 1			;fout: geen ack gekregen bij het versturen van het adres
 1475: 1  043B	12 03 55	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1476: 1  043E	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1477: 1  0440	D0 D0		                    pop        psw
 1478: 1  0442	D3		                    setb    c               ;terug met foutmelding
 1479: 1  0443	D0 E0		                    pop        acc
 1480: 1  0445	22		                    ret
 1481: 1
 1482: 1
 1483: 1			;******************************************************************************
 1484: 1			;
 1485: 1			; porttolcd
 1486: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1487: 1			; scherm stuurt via de port expander.
 1488: 1			;
 1489: 1			; Gebruikt geen registers
 1490: 1			;
 1491: 1			;******************************************************************************
 1492: 1
 1493: 1  0446	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1494: 1  0448	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1495: 1  044A	12 03 4C	              lcall  i2cstart      ;vertrokken
 1496: 1			ifdef    pcf8574
 1497: 1			              mov    a,#01000000b  ;schrijven naar expander
 1498: 1			endif
 1499: 1			ifdef    pcf8574A
 1500: 1  044D	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1501: 1			endif

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1502: 1  044F	12 03 5E	              lcall  i2coutbyte    ;weg er mee
 1503: 1  0452	E5 F0		              mov    a,b           ;data verzenden
 1504: 1  0454	12 03 5E	              lcall  i2coutbyte
 1505: 1  0457	12 03 55	              lcall  i2cstop       ;transactie sluiten
 1506: 1  045A	D0 D0		              pop    psw
 1507: 1  045C	D0 E0		              pop    acc
 1508: 1  045E	22		              ret
 1509: 1
 1510: 1			;******************************************************************************
 1511: 1			;
 1512: 1			; lcdtoport
 1513: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1514: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1515: 1			; aansturen van de buzzer en backlight.
 1516: 1			;
 1517: 1			; output: b register
 1518: 1			;
 1519: 1			;******************************************************************************
 1520: 1
 1521: 1  045F	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1522: 1  0461	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1523: 1  0463	12 03 4C	              lcall  i2cstart      ;vertrokken
 1524: 1			ifdef    pcf8574
 1525: 1			              mov    a,#01000000b  ;schrijven naar expander
 1526: 1			endif
 1527: 1			ifdef    pcf8574A
 1528: 1  0466	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1529: 1			endif
 1530: 1  0468	12 03 5E	              lcall  i2coutbyte    ;weg er mee
 1531: 1  046B	12 03 9F	              lcall  i2cinbytenack ;data inlezen
 1532: 1  046E	12 03 55	              lcall  i2cstop
 1533: 1  0471	F5 F0		              mov    b,a
 1534: 1  0473	D0 D0		              pop    psw
 1535: 1  0475	D0 E0		              pop    acc
 1536: 1  0477	22		              ret
 1537: 1
 1538: 1			;******************************************************************************
 1539: 1			;
 1540: 1			; lcdlighton
 1541: 1			; Dit is een subroutine die de backlight inschakeld
 1542: 1			;
 1543: 1			; Gebruikt geen registers
 1544: 1			;
 1545: 1			;******************************************************************************
 1546: 1
 1547: 1  0478	C0 F0		lcdlighton:   push   b
 1548: 1  047A	12 04 5F	              lcall  lcdtoport     ;expander lezen
 1549: 1  047D	C2 F6		              clr    b.6           ;licht aan doen
 1550: 1  047F	12 04 46	              lcall  porttolcd     ;expander schrijven
 1551: 1  0482	D0 F0		              pop    b
 1552: 1  0484	22		              ret
 1553: 1
 1554: 1
 1555: 1			;******************************************************************************
 1556: 1			;
 1557: 1			; lcdlightoff

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1558: 1			; Dit is een subroutine die de backlight uitschakeld
 1559: 1			;
 1560: 1			; Gebruikt geen registers
 1561: 1			;
 1562: 1			;******************************************************************************
 1563: 1
 1564: 1  0485	C0 F0		lcdlightoff:  push   b
 1565: 1  0487	12 04 5F	              lcall  lcdtoport     ;expander lezen
 1566: 1  048A	D2 F6		              setb   b.6           ;licht uit doen
 1567: 1  048C	12 04 46	              lcall  porttolcd     ;expander schrijven
 1568: 1  048F	D0 F0		              pop    b
 1569: 1  0491	22		              ret
 1570: 1
 1571: 1			;******************************************************************************
 1572: 1			;
 1573: 1			; lcdbuzon
 1574: 1			; Dit is een subroutine die de buzzer inschakeld
 1575: 1			;
 1576: 1			; Gebruikt geen registers
 1577: 1			;
 1578: 1			;******************************************************************************
 1579: 1
 1580: 1  0492	C0 F0		lcdbuzon:     push   b
 1581: 1  0494	12 04 5F	              lcall  lcdtoport     ;expander lezen
 1582: 1  0497	C2 F7		              clr    b.7           ;buzzer aan doen
 1583: 1  0499	12 04 46	              lcall  porttolcd     ;expander schrijven
 1584: 1  049C	D0 F0		              pop    b
 1585: 1  049E	22		              ret
 1586: 1
 1587: 1			;******************************************************************************
 1588: 1			;
 1589: 1			; lcdbuzoff
 1590: 1			; Dit is een subroutine die de buzzer uitschakeld
 1591: 1			;
 1592: 1			; Gebruikt geen registers
 1593: 1			;
 1594: 1			;******************************************************************************
 1595: 1
 1596: 1  049F	C0 F0		lcdbuzoff:    push   b
 1597: 1  04A1	12 04 5F	              lcall  lcdtoport     ;expander lezen
 1598: 1  04A4	D2 F7		              setb   b.7           ;buzzer aan doen
 1599: 1  04A6	12 04 46	              lcall  porttolcd     ;expander schrijven
 1600: 1  04A9	D0 F0		              pop    b
 1601: 1  04AB	22		              ret
 1602: 1
 1603: 1			endif    ;einde aduc_i2c
 1604: 1			;******************************************************************************
 1605: 1
 1606: 1
 1607: 1
 1608: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1609: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1610: 1			;
 1611: 1			; ADuCsio.inc
 1612: 1			; Is een include file voor de ADuC832 microcontroller.
 1613: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1614: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1615: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1616: 1			; afwijking van de standaard routines is de initsio subroutine.
 1617: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1618: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1619: 1			; zijn.
 1620: 1			;
 1621: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1622: 1			;
 1623: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1624: 1
 1625: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1626: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1627: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1628: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1629: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1630: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1631: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1632: 1
 1633: 1  04AC	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1634: 1			                                                        ;van het scherm
 1635: 1
 1636: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1637: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1638: 1
 1639: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1640: 1			;
 1641: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1642: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1643: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1644: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1645: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1646: 1			;
 1647: 1			; de routine gebruikt de psw
 1648: 1			;
 1649: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1650: 1
 1651: 1  04B0	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1652: 1  04B2	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1653: 1  04B4	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1654: 1  04B6	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1655: 1  04B9	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1656: 1
 1657: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1658: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1659: 1
 1660: 1  04BB	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1661: 1  04BE	F4		              cpl    a             ;bitbangen om laten uit te komen
 1662: 1  04BF	C3		              clr    c             ;verder doen
 1663: 1  04C0	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1664: 1  04C2	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1665: 1  04C4	24 80		              add    a,#080h       ;nu alles in orde
 1666: 1  04C6	F5 9E		              mov    t3con,a       ;baud rate klaar
 1667: 1  04C8	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1668: 1  04CB	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1669: 1  04CC	D0 E0		              pop    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1670: 1  04CE	22		              ret
 1671: 1
 1672: 1  04CF	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1673: 1  04D0	D0 E0		              pop    acc
 1674: 1  04D2	22		              ret
 1675: 1
 1676: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1677: 1			;
 1678: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1679: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1680: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1681: 1			;
 1682: 1			; de routine gebruikt geen registers.
 1683: 1			;
 1684: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1685: 1
 1686: 1  04D3	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1687: 1  04D5	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1688: 1  04D8	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1689: 1  04DA	22		              RET
 1690: 1
 1691: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1692: 1			;
 1693: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1694: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1695: 1			;
 1696: 1			; de routine gebruikt geen registers.
 1697: 1			;
 1698: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1699: 1
 1700: 1  04DB	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1701: 1  04DD	C0 D0		              push   psw
 1702: 1  04DF	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1703: 1  04E1	12 05 ED	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1704: 1  04E4	12 04 D3	              LCALL  OUTCHAR       ;VERSTUREN
 1705: 1  04E7	12 05 34	              LCALL  XONXOFF       ;FLOW CONTROL
 1706: 1  04EA	D0 D0		              pop    psw           ;registers herstellen
 1707: 1  04EC	D0 E0		              pop    acc
 1708: 1  04EE	22		              RET
 1709: 1
 1710: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1711: 1			;
 1712: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1713: 1			; WORDT XONXOFF GEBRUIKT.
 1714: 1			;
 1715: 1			; de routine gebruikt geen registers.
 1716: 1			;
 1717: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1718: 1
 1719: 1  04EF	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1720: 1  04F1	C0 D0		              push   psw
 1721: 1  04F3	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1722: 1  04F5	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1723: 1  04F6	12 04 DB	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1724: 1  04F9	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1725: 1  04FB	12 04 DB	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1726: 1  04FE	D0 D0		              pop    psw           ;registers herstellen
 1727: 1  0500	D0 E0		              pop    acc
 1728: 1  0502	22		              RET
 1729: 1
 1730: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1731: 1			;
 1732: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1733: 1			; VAN DE CURSOR.
 1734: 1			;
 1735: 1			; de routine gebruikt geen registers.
 1736: 1			;
 1737: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1738: 1
 1739: 1  0503	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1740: 1  0505	C0 D0		              push   psw
 1741: 1  0507	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1742: 1  0509	12 04 EF	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1743: 1  050C	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1744: 1  050E	12 04 EF	              LCALL  OUTBYTE       ;WEG ER MEE
 1745: 1  0511	D0 D0		              pop    psw           ;registers herstellen
 1746: 1  0513	D0 E0		              pop    acc
 1747: 1  0515	22		              RET                  ;EINDE
 1748: 1
 1749: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1750: 1			;
 1751: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1752: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1753: 1			;
 1754: 1			; de routine gebruikt geen registers.
 1755: 1			;
 1756: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1757: 1
 1758: 1  0516	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1759: 1  0518	C0 D0		              push   psw
 1760: 1  051A	C0 82		              push   dpl
 1761: 1  051C	C0 83		              push   dph
 1762: 1  051E	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1763: 1  051F	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1764: 1  0520	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1765: 1  0522	12 04 D3	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1766: 1  0525	12 05 34	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1767: 1  0528	A3		              INC    DPTR          ;DPTR AANPASSEN
 1768: 1  0529	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1769: 1  052B	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1770: 1  052D	D0 82		              pop    dpl
 1771: 1  052F	D0 D0		              pop    psw
 1772: 1  0531	D0 E0		              pop    acc
 1773: 1  0533	22		              RET                  ;EINDE ROUTINE
 1774: 1
 1775: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1776: 1			;
 1777: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1778: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1779: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1780: 1			; VERDER DOORGEGEVEN.
 1781: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1782: 1			; de routine gebruikt geen registers.
 1783: 1			;
 1784: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1785: 1
 1786: 1  0534	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1787: 1  0536	C0 D0		              push   psw
 1788: 1  0538	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1789: 1  053B	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 1790: 1  053D	D0 E0		              pop    acc
 1791: 1  053F	22		              RET                  ;ANDERS EINDE
 1792: 1  0540	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1793: 1  0542	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1794: 1  0545	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1795: 1  0548	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1796: 1
 1797: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1798: 1			;
 1799: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1800: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1801: 1			;
 1802: 1			; de routine gebruikt de accu.
 1803: 1			;
 1804: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1805: 1
 1806: 1  054A	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 1807: 1  054D	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 1808: 1  054F	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1809: 1  0551	22		              RET
 1810: 1
 1811: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1812: 1			;
 1813: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1814: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1815: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 1816: 1			; DE CARRY OP 1 GEZET WORDEN.
 1817: 1			;
 1818: 1			; De routine gebruikt de accu EN PSW.
 1819: 1			;
 1820: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1821: 1
 1822: 1  0552	C0 F0		INBYTE:       PUSH     B
 1823: 1  0554	12 05 4A	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1824: 1  0557	12 05 E0	              LCALL  LOWUPTR
 1825: 1  055A	12 05 FB	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1826: 1  055D	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1827: 1  055F	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1828: 1  0560	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1829: 1  0562	12 05 4A	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1830: 1  0565	12 05 E0	              LCALL  LOWUPTR
 1831: 1  0568	12 05 FB	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1832: 1  056B	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1833: 1  056D	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1834: 1  056F	D0 F0		INBYTE1:      POP     B
 1835: 1  0571	22		              RET
 1836: 1
 1837: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1838: 1			;
 1839: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1840: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1841: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1842: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1843: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1844: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1845: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 1846: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1847: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1848: 1			; bepalen.
 1849: 1			;
 1850: 1			; De routine gebruikt  r0 .
 1851: 1			;
 1852: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1853: 1
 1854: 1  0572	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1855: 1  0574	C0 D0		              push   psw
 1856: 1  0576	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1857: 1  0578	12 05 4A	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 1858: 1  057B	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1859: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 1860: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1861: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1862: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 1863: 1			; GEVOERD.
 1864: 1  057D	12 05 E0	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1865: 1  0580	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1866: 1  0583	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1867: 1  0584	D0 D0		              pop    psw                  ;registers herstellen
 1868: 1  0586	D0 E0		              pop    acc
 1869: 1  0588	22		              RET                         ;EINDE VAN DE ROUTINE
 1870: 1
 1871: 1  0589	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 1872: 1  058C	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1873: 1  058F	74 07		INBUFA4:      MOV    A,#BEEP
 1874: 1  0591	12 04 D3	INBUFA7:      LCALL  OUTCHAR
 1875: 1  0594	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1876: 1
 1877: 1  0596	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1878: 1  0597	90 04 AC	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1879: 1  059A	12 05 16	              LCALL  OUTMSGA
 1880: 1  059D	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 1881: 1  059F	12 05 D2	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1882: 1  05A2	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1883: 1  05A4	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1884: 1  05A7	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1885: 1  05A9	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1886: 1  05AA	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1887: 1  05AB	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1888: 1
 1889: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1890: 1			;
 1891: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1892: 1			;
 1893: 1			; De routine gebruikt niets.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1894: 1			;
 1895: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1896: 1
 1897: 1  05AD	C0 E0		BDELETE:      PUSH     ACC
 1898: 1  05AF	C0 D0		              PUSH     PSW
 1899: 1  05B1	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1900: 1  05B2	C0 E0		              PUSH     ACC
 1901: 1  05B4	E9		              MOV     A,R1
 1902: 1  05B5	C0 E0		              PUSH     ACC
 1903: 1  05B7	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1904: 1  05B9	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1905: 1  05BB	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1906: 1  05BC	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1907: 1  05BF	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1908: 1  05C0	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1909: 1  05C3	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1910: 1  05C5	F9		              MOV     R1,A
 1911: 1  05C6	D0 E0		              POP     ACC
 1912: 1  05C8	F8		              MOV     R0,A
 1913: 1  05C9	D0 D0		              POP     PSW
 1914: 1  05CB	D0 E0		              POP     ACC
 1915: 1  05CD	22		              RET                         ;EINDE VAN DE ROUTINE
 1916: 1  05CE	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1917: 1  05CF	09		              INC    R1
 1918: 1  05D0	80 ED		              SJMP   BDELETE3
 1919: 1
 1920: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1921: 1			;
 1922: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1923: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1924: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1925: 1			; AANZIEN.
 1926: 1			;
 1927: 1			; De routine gebruikt de accu en de psw.
 1928: 1			;
 1929: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1930: 1
 1931: 1  05D2	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 1932: 1  05D5	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 1933: 1  05D7	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 1934: 1  05DA	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 1935: 1  05DC	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 1936: 1  05DD	22		              RET
 1937: 1  05DE	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 1938: 1  05DF	22		              RET
 1939: 1
 1940: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1941: 1			;
 1942: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 1943: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 1944: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 1945: 1			; AANGEPAST WORDEN.
 1946: 1			;
 1947: 1			; De routine gebruikt de accu en psw .
 1948: 1			;
 1949: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1950: 1
 1951: 1  05E0	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 1952: 1  05E3	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 1953: 1  05E5	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 1954: 1  05E8	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 1955: 1  05EA	94 20		              SUBB   A,#020H              ;OMZETTING
 1956: 1  05EC	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 1957: 1
 1958: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1959: 1			;
 1960: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 1961: 1			; ASCII CODE.
 1962: 1			;
 1963: 1			; De routine gebruikt de accu .
 1964: 1			;
 1965: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1966: 1
 1967: 1  05ED	C0 D0		BATRANS:      PUSH   PSW
 1968: 1  05EF	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 1969: 1  05F2	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 1970: 1  05F4	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 1971: 1  05F6	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 1972: 1  05F8	D0 D0		              POP     PSW
 1973: 1  05FA	22		              RET
 1974: 1
 1975: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1976: 1			;
 1977: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 1978: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 1979: 1			; GEVAL WORDT DE CARRY GEZET.
 1980: 1			;
 1981: 1			; De routine gebruikt de accu en de psw.
 1982: 1			;
 1983: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1984: 1
 1985: 1  05FB	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 1986: 1  05FC	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 1987: 1  05FE	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 1988: 1  0600	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 1989: 1  0603	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 1990: 1  0605	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 1991: 1  0607	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 1992: 1  0609	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 1993: 1  060C	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 1994: 1  060D	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 1995: 1  060F	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 1996: 1  0610	22		ASCBINTRANS1: RET
 1997: 1
 1998: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1999: 1			;
 2000: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 2001: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 2002: 1			;
 2003: 1			; De routine gebruikt de accu en de psw.
 2004: 1			;
 2005: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2006: 1
 2007: 1  0611	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 2008: 1  0612	12 05 FB	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 2009: 1  0615	22		              RET                         ;EINDE OMZETTING
 2010: 1
 2011: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2012: 1			;
 2013: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 2014: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 2015: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 2016: 1			;
 2017: 1			; De routine gebruikt de accu, r0.
 2018: 1			;
 2019: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2020: 1
 2021: 1  0616	C0 F0		ASCII2:       PUSH   B
 2022: 1  0618	12 06 11	              LCALL  ASCII1               ;OMZETTEN
 2023: 1  061B	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 2024: 1  061D	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 2025: 1  061E	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 2026: 1  0620	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 2027: 1  0621	12 06 11	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 2028: 1  0624	40 02		              JC     ASCII21               ;WEG ALS C=1
 2029: 1  0626	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 2030: 1  0628	D0 F0		ASCII21:      POP     B
 2031: 1  062A	22		              RET
 2032: 1
 2033: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2034: 1			;
 2035: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2036: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2037: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2038: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2039: 1			;
 2040: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2041: 1			;
 2042: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2043: 1
 2044: 1  062B	12 06 16	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2045: 1  062E	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2046: 1  0630	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2047: 1  0632	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2048: 1  0633	12 06 16	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2049: 1  0636	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2050: 1  0638	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2051: 1  063A	22		ASCII41:      RET
 2052: 1
 2053: 1			endif        ;einde van aduc_sio
 2054: 1			;*******************************************************************************
 2055: 1
 2056: 1
 2057: 1			ifdef        aduc_math    ;rekenkundige routines
 2058: 1			;*******************************************************************************
 2059: 1			; aduc_math
 2060: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2061: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2062: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2063: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2064: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2065: 1			; zoals aangegeven:
 2066: 1			;
 2067: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2068: 1			;        ---------------------------
 2069: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2070: 1			;        ---------------------------                             statusbit = f0
 2071: 1			;        ---------------------------
 2072: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2073: 1			;        ---------------------------
 2074: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2075: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2076: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2077: 1			; return en moeten hiervoor worden gereserveerd.
 2078: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2079: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2080: 1			; en unsigned getallen.
 2081: 1			;
 2082: 1			; Beschikbare routines:
 2083: 1			;
 2084: 1			; Conversie routines:
 2085: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2086: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2087: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2088: 1			;
 2089: 1			; Som:
 2090: 1			; s_add16, add16, s_add32, add32
 2091: 1			;
 2092: 1			; Verschil:
 2093: 1			; s_sub16, sub16, s_sub32, sub32
 2094: 1			;
 2095: 1			; Vermenigvuldigen:
 2096: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2097: 1			;
 2098: 1			; Delen:
 2099: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2100: 1			;
 2101: 1			; Vemenigvuldig met factor:
 2102: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2103: 1			;
 2104: 1			; Vierkantswortel:
 2105: 1			; sqrt32, s_sqrt32
 2106: 1			;
 2107: 1			; Schuiven:
 2108: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2109: 1			;
 2110: 1			; Vergelijken:
 2111: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2112: 1			;
 2113: 1			; Tabel lookup:
 2114: 1			; table_lu
 2115: 1			;
 2116: 1			; Gonemetrische functies:
 2117: 1			; Cordic = sinus,cosinus

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2118: 1			;
 2119: 1			;*******************************************************************************
 2120: 1
 2121: 1			;*******************************************************************************
 2122: 1			;
 2123: 1			; bcdhex8     (45,77us @16.777216MHz)
 2124: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2125: 1			; naar een 2's complement hex getal.
 2126: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2127: 1			; een waarde 00h tot 63h.
 2128: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2129: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2130: 1			; input:      R0 = waarde tussen 00h en 99h.
 2131: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2132: 1			; output:     R0 = 2's complement waarde
 2133: 1			;             cy=1 bij out of range van r0
 2134: 1			;             cy=0 bij conversie ok
 2135: 1			; vernietigt: niets
 2136: 1			;*******************************************************************************
 2137: 1  063B	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2138: 1  063D	C0 D0		              push   psw
 2139: 1  063F	C0 F0		              push   b
 2140: 1
 2141: 1  0641	E8		              mov    a,r0                 ;neem te converteren waarde
 2142: 1  0642	F5 F0		              mov    b,a
 2143: 1  0644	54 0F		              anl    a,#0fh
 2144: 1  0646	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2145: 1  0649	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2146: 1  064B	E5 F0		              mov    a,b
 2147: 1  064D	54 F0		              anl    a,#0f0h
 2148: 1  064F	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2149: 1  0652	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2150: 1
 2151: 1  0654	E8		              mov    a,r0
 2152: 1  0655	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2153: 1  0657	C4		              swap   a
 2154: 1  0658	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2155: 1  065B	A4		              mul    ab
 2156: 1  065C	F5 F0		              mov    b,a                  ;bewaar dit product even
 2157: 1  065E	E8		              mov    a,r0
 2158: 1  065F	54 0F		              anl    a,#00fh
 2159: 1  0661	F8		              mov    r0,a
 2160: 1  0662	E5 F0		              mov    a,b
 2161: 1  0664	28		              add    a,r0                 ;eenheden er bijtellen
 2162: 1  0665	F8		              mov    r0,a
 2163: 1
 2164: 1  0666	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2165: 1  0668	12 07 69	              lcall  magsig8              ;omzetten naar 2's complement
 2166: 1
 2167: 1  066B	D0 F0		              pop    b
 2168: 1  066D	D0 D0		              pop    psw
 2169: 1  066F	C2 D7		              clr    cy                   ;geen fout
 2170: 1  0671	D0 E0		              pop    acc
 2171: 1  0673	22		              ret
 2172: 1
 2173: 1  0674	D0 F0		bcdhex82:     pop    b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2174: 1  0676	D0 D0		              pop    psw
 2175: 1  0678	D2 D7		              setb   cy                   ;fout! r0 out of range
 2176: 1  067A	D0 E0		              pop    acc
 2177: 1  067C	22		              ret
 2178: 1
 2179: 1			;*******************************************************************************
 2180: 1			;
 2181: 1			; hexbcd8     (38,4us @16.777216MHz)
 2182: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2183: 1			; naar een 8bit bcd getal.
 2184: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2185: 1			; bcdgetal van 00h tot +99h.
 2186: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2187: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2188: 1			; bcdgetal 00h tot -99h
 2189: 1			;
 2190: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2191: 1			;
 2192: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2193: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2194: 1			;             cy=1 bij out of range van r0
 2195: 1			;             cy=0 bij conversie ok
 2196: 1			; vernietigt: niets
 2197: 1			;*******************************************************************************
 2198: 1  067D	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2199: 1  067F	C0 D0		                push    psw
 2200: 1  0681	C0 F0		                push    b
 2201: 1  0683	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2202: 1  0684	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2203: 1  0687	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2204: 1  0689	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2205: 1  068C	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2206: 1  068E	D0 F0		                pop     b
 2207: 1  0690	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2208: 1  0692	D3		                setb    c
 2209: 1  0693	D0 E0		                pop     acc
 2210: 1  0695	22		                ret
 2211: 1  0696	12 08 31	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2212: 1  0699	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2213: 1  069A	75 F0 0A	                mov     b,#10
 2214: 1  069D	84		                div     ab
 2215: 1  069E	C4		                swap    a
 2216: 1  069F	25 F0		                add     a,b
 2217: 1  06A1	F8		                mov     r0,a
 2218: 1  06A2	D0 F0		                pop     b               ;registers herstellen
 2219: 1  06A4	D0 E0		                pop     acc             ;psw van stack halen
 2220: 1  06A6	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2221: 1  06A8	92 E5		                mov     acc.5,c
 2222: 1  06AA	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2223: 1  06AC	C3		                clr     c               ;status: conversie ok
 2224: 1  06AD	D0 E0		                pop     acc
 2225: 1  06AF	22		                ret
 2226: 1
 2227: 1
 2228: 1
 2229: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2230: 1			;
 2231: 1			; bcdhex16    (86,6us @16.777216MHz)
 2232: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2233: 1			; omzetten naar een 2's complement hex getal.
 2234: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2235: 1			; naareen waarde 0000h tot 270fh.
 2236: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2237: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2238: 1			; van -270fh).
 2239: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2240: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2241: 1			; output:     R1,R0 = 2's complement waarde
 2242: 1			;             cy=1 bij out of range van r1,r0
 2243: 1			;             cy=0 bij conversie ok
 2244: 1			; vernietigt: niets
 2245: 1			;*******************************************************************************
 2246: 1  06B0	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2247: 1  06B2	C0 D0		              push   psw
 2248: 1  06B4	C0 F0		              push   b
 2249: 1
 2250: 1  06B6	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2251: 1  06B7	F5 F0		              mov    b,a
 2252: 1  06B9	54 0F		              anl    a,#0fh
 2253: 1  06BB	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2254: 1  06BE	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2255: 1  06C0	E5 F0		              mov    a,b
 2256: 1  06C2	54 F0		              anl    a,#0f0h
 2257: 1  06C4	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2258: 1  06C7	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2259: 1  06C9	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2260: 1  06CA	F5 F0		              mov    b,a
 2261: 1  06CC	54 0F		              anl    a,#0fh
 2262: 1  06CE	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2263: 1  06D1	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2264: 1  06D3	E5 F0		              mov    a,b
 2265: 1  06D5	54 F0		              anl    a,#0f0h
 2266: 1  06D7	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2267: 1  06DA	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2268: 1
 2269: 1  06DC	E8		              mov    a,r0                  ;neem low byte voor conversie
 2270: 1  06DD	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2271: 1  06DF	C0 E0		              push   acc                   ;en even bewaren
 2272: 1
 2273: 1  06E1	E8		              mov    a,r0
 2274: 1  06E2	C4		              swap   a
 2275: 1  06E3	54 0F		              anl    a,#00fh              ;tientallen
 2276: 1  06E5	75 F0 0A	              mov    b,#00ah              ;maal tien
 2277: 1  06E8	A4		              mul    ab                   ;
 2278: 1  06E9	D0 F0		              pop    b                    ;neem eenheden
 2279: 1  06EB	25 F0		              add    a,b                  ;tel bij tientallen
 2280: 1  06ED	C0 E0		              push   acc                  ;weer bewaren
 2281: 1
 2282: 1  06EF	E9		              mov    a,r1                 ;neem high byte voor conversie
 2283: 1  06F0	54 F0		              anl    a,#0f0h
 2284: 1  06F2	C4		              swap   a
 2285: 1  06F3	C0 E0		              push   acc                  ;bewaar de duizendtallen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2286: 1
 2287: 1  06F5	E9		              mov    a,r1                  ;neem high byte voor conversie
 2288: 1  06F6	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2289: 1  06F8	75 F0 64	              mov    b,#100d              ;en maal honderd
 2290: 1  06FB	A4		              mul    ab
 2291: 1  06FC	A9 F0		              mov    r1,b
 2292: 1  06FE	F8		              mov    r0,a
 2293: 1
 2294: 1  06FF	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2295: 1  0701	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2296: 1  0704	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2297: 1  0705	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2298: 1  0708	A4		              mul    ab
 2299: 1  0709	28		              add    a,r0                 ;tel honderdtallen bij de
 2300: 1  070A	F8		              mov    r0,a                 ;duizendtallen
 2301: 1  070B	E9		              mov    a,r1
 2302: 1  070C	35 F0		              addc   a,b
 2303: 1  070E	F9		              mov    r1,a
 2304: 1
 2305: 1  070F	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2306: 1  0711	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2307: 1  0712	F8		              mov    r0,a                 ;duizendtallen
 2308: 1  0713	74 00		              mov    a,#000h
 2309: 1  0715	39		              addc   a,r1
 2310: 1  0716	F9		              mov    r1,a                 ;omzetting klaar
 2311: 1
 2312: 1  0717	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2313: 1  0719	12 07 9D	              lcall  magsig16             ;omzetten naar 2's complement
 2314: 1
 2315: 1  071C	D0 F0		              pop    b
 2316: 1  071E	D0 D0		              pop    psw
 2317: 1  0720	C2 D7		              clr    cy                   ;geen fout
 2318: 1  0722	D0 E0		              pop    acc
 2319: 1  0724	22		              ret
 2320: 1
 2321: 1  0725	D0 F0		bcdhex162:    pop    b
 2322: 1  0727	D0 D0		              pop    psw
 2323: 1  0729	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2324: 1  072B	D0 E0		              pop    acc
 2325: 1  072D	22		              ret
 2326: 1
 2327: 1			;*******************************************************************************
 2328: 1			;
 2329: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2330: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2331: 1			; naar een 24bit bcd getal.
 2332: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2333: 1			; bcdgetal van 000000h tot +032767h.
 2334: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2335: 1			; naar een bcdgetal 000000h tot -032768h
 2336: 1			;
 2337: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2338: 1			;
 2339: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2340: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2341: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2342: 1			; vernietigt: niets
 2343: 1			;*******************************************************************************
 2344: 1			;
 2345: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2346: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2347: 1			; naar een 24bit bcd getal.
 2348: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2349: 1			; bcdgetal van 000000h tot 065535h.
 2350: 1			;
 2351: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2352: 1			;
 2353: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2354: 1			;
 2355: 1			; vernietigt: niets
 2356: 1			;*******************************************************************************
 2357: 1  072E	12 08 63	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2358: 1  0731	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2359: 1  0733	C0 D0		                push   psw
 2360: 1  0735	C0 F0		                push   b
 2361: 1  0737	C0 82		                push   dpl
 2362: 1
 2363: 1  0739	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2364: 1  073C	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2365: 1  073E	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2366: 1  0740	12 0C 12	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2367: 1  0743	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2368: 1  0744	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2369: 1			                                        ;dus eerst eenheden, dan tientallen
 2370: 1			                                        ;honderdtallen, duizendtallen en
 2371: 1			                                        ;tienduizendtallen
 2372: 1  0746	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2373: 1
 2374: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2375: 1
 2376: 1  0749	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2377: 1  074B	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2378: 1  074C	D0 E0		                pop    acc              ;duizendtallen ophalen
 2379: 1  074E	C4		                swap   a                ;en combineren met de
 2380: 1  074F	F5 82		                mov    dpl,a
 2381: 1  0751	D0 E0		                pop    acc              ;honderdtallen van de stack
 2382: 1  0753	25 82		                add    a,dpl
 2383: 1  0755	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2384: 1  0756	D0 E0		                pop    acc              ;tientallen van de stack halen
 2385: 1  0758	C4		                swap   a
 2386: 1  0759	F5 82		                mov    dpl,a
 2387: 1  075B	D0 E0		                pop    acc              ;en combineren met de eenheden
 2388: 1  075D	25 82		                add    a,dpl
 2389: 1  075F	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2390: 1
 2391: 1  0760	D0 82		                pop    dpl              ;registers herstellen
 2392: 1  0762	D0 F0		                pop    b
 2393: 1  0764	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2394: 1  0766	D0 E0		                pop    acc
 2395: 1  0768	22		                ret
 2396: 1
 2397: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2398: 1			; magsig8        (13,6us @16.777216MHz)
 2399: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2400: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2401: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2402: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2403: 1			;           (f0 en f1 zijn 1 als negatief)
 2404: 1			;
 2405: 1			; output:   r0 = 2's complement
 2406: 1			;
 2407: 1			; vernietigt: niets
 2408: 1			;*******************************************************************************
 2409: 1
 2410: 1  0769	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2411: 1  076B	C0 D0		               push   psw
 2412: 1  076D	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2413: 1  0770	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2414: 1  0773	80 09		               sjmp   magsig8c
 2415: 1
 2416: 1  0775	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2417: 1  0778	80 04		               sjmp   magsig8c
 2418: 1
 2419: 1  077A	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2420: 1  077B	F4		               cpl    a                  ;complementeer abs waarde
 2421: 1  077C	04		               inc    a                  ;r0 = complement(r0)+1
 2422: 1  077D	F8		               mov    r0,a               ;bewaar in 2's complement
 2423: 1  077E	D0 D0		magsig8c:      pop    psw
 2424: 1  0780	D0 E0		               pop    acc
 2425: 1  0782	22		               ret                        ;klaar
 2426: 1
 2427: 1			;*******************************************************************************
 2428: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2429: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2430: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2431: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2432: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2433: 1			;           (f0 en f1 zijn 1 als negatief)
 2434: 1			;
 2435: 1			; output:   r4 = 2's complement
 2436: 1			;
 2437: 1			; vernietigt: niets
 2438: 1			;*******************************************************************************
 2439: 1
 2440: 1  0783	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2441: 1  0785	C0 D0		               push    psw
 2442: 1  0787	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2443: 1  078A	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2444: 1  078D	80 EF		               sjmp    magsig8c
 2445: 1
 2446: 1  078F	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2447: 1  0792	80 04		               sjmp    magsig8acc1c
 2448: 1
 2449: 1  0794	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2450: 1  0795	F4		               cpl     a                 ;complementeer abs waarde
 2451: 1  0796	04		               inc     a                 ;r4 = complement(r0)+1
 2452: 1  0797	FC		               mov     r4,a              ;bewaar in 2's complement
 2453: 1  0798	D0 D0		magsig8acc1c:  pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2454: 1  079A	D0 E0		               pop     acc
 2455: 1  079C	22		               ret                       ;klaar
 2456: 1
 2457: 1			;*******************************************************************************
 2458: 1			; magsig16        (16,6us @16.777216MHz)
 2459: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2460: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2461: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2462: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2463: 1			;           (f0 en f1 zijn 1 als negatief)
 2464: 1			;
 2465: 1			; output:   r1,r0 = 2's complement
 2466: 1			;
 2467: 1			; vernietigt: niets
 2468: 1			;*******************************************************************************
 2469: 1  079D	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2470: 1  079F	C0 D0		               push    psw
 2471: 1  07A1	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2472: 1  07A4	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2473: 1  07A7	80 0F		               sjmp    magsig16c
 2474: 1
 2475: 1  07A9	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2476: 1  07AC	80 0A		               sjmp    magsig16c
 2477: 1
 2478: 1  07AE	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2479: 1  07AF	F4		               cpl     a                ;complementeer het dan
 2480: 1  07B0	24 01		               add     a, #1            ;en tel er 1 bij
 2481: 1  07B2	F8		               mov     r0,a
 2482: 1  07B3	E9		               mov     a,r1             ;neem volgende byte
 2483: 1  07B4	F4		               cpl     a                ;complementeer en tel carry erbij
 2484: 1  07B5	34 00		               addc    a,#0
 2485: 1  07B7	F9		               mov     r1,a
 2486: 1  07B8	D0 D0		magsig16c:     pop     psw
 2487: 1  07BA	D0 E0		               pop     acc
 2488: 1  07BC	22		               ret
 2489: 1
 2490: 1			;*******************************************************************************
 2491: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2492: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2493: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2494: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2495: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2496: 1			;           (f0 en f1 zijn 1 als negatief)
 2497: 1			;
 2498: 1			; output:   r5,r4 = 2's complement
 2499: 1			;
 2500: 1			; vernietigt: niets
 2501: 1			;*******************************************************************************
 2502: 1  07BD	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2503: 1  07BF	C0 D0		                push    psw
 2504: 1  07C1	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2505: 1  07C4	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2506: 1  07C7	80 0F		                sjmp    magsig16acc1c
 2507: 1
 2508: 1  07C9	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2509: 1  07CC	80 0A		                sjmp    magsig16acc1c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2510: 1
 2511: 1  07CE	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2512: 1  07CF	F4		                cpl     a                   ;complementeer het dan
 2513: 1  07D0	24 01		                add     a,#1                ;en tel er 1 bij
 2514: 1  07D2	FC		                mov     r4,a
 2515: 1  07D3	ED		                mov     a,r5                ;neem volgende byte
 2516: 1  07D4	F4		                cpl     a                   ;complementeer en tel carry erbij
 2517: 1  07D5	34 00		                addc    a,#0
 2518: 1  07D7	FD		                mov     r5,a
 2519: 1  07D8	D0 D0		magsig16acc1c:  pop     psw
 2520: 1  07DA	D0 E0		                pop     acc
 2521: 1  07DC	22		                ret
 2522: 1
 2523: 1			;*******************************************************************************
 2524: 1			; magsig32        (22,2us @16.777216MHz)
 2525: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2526: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2527: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2528: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2529: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2530: 1			;           (f0 en f1 zijn 1 als negatief)
 2531: 1			;
 2532: 1			; output:   r3,r2,r1,r0 = 2's complement
 2533: 1			;
 2534: 1			; vernietigt: niets
 2535: 1			;*******************************************************************************
 2536: 1  07DD	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2537: 1  07DF	C0 D0		               push    psw
 2538: 1  07E1	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2539: 1  07E4	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2540: 1  07E7	80 19		               sjmp    magsig32c
 2541: 1
 2542: 1  07E9	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2543: 1  07EC	80 14		               sjmp    magsig32c
 2544: 1
 2545: 1  07EE	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2546: 1  07EF	F4		               cpl     a                 ;complementeer het dan
 2547: 1  07F0	24 01		               add     a,#1             ;en tel er 1 bij
 2548: 1  07F2	F8		               mov     r0,a
 2549: 1  07F3	E9		               mov     a,r1             ;neem volgende byte
 2550: 1  07F4	F4		               cpl     a                 ;complementeer en tel carry erbij
 2551: 1  07F5	34 00		               addc    a,#0
 2552: 1  07F7	F9		               mov     r1,a
 2553: 1  07F8	EA		               mov     a,r2            ;neem volgende byte
 2554: 1  07F9	F4		               cpl     a                ;complementeer en tel carry erbij
 2555: 1  07FA	34 00		               addc    a,#0
 2556: 1  07FC	FA		               mov     r2,a
 2557: 1  07FD	EB		               mov     a,r3            ;neem volgende byte
 2558: 1  07FE	F4		               cpl     a                ;complementeer en tel carry erbij
 2559: 1  07FF	34 00		               addc    a,#0
 2560: 1  0801	FB		               mov     r3,a
 2561: 1
 2562: 1  0802	D0 D0		magsig32c:     pop     psw
 2563: 1  0804	D0 E0		               pop     acc
 2564: 1  0806	22		               ret
 2565: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2566: 1
 2567: 1
 2568: 1			;*******************************************************************************
 2569: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2570: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2571: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2572: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2573: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2574: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2575: 1			;           (f0 en f1 zijn 1 als negatief)
 2576: 1			;
 2577: 1			; output:   r7,r6,r5,r4 = 2's complement
 2578: 1			;
 2579: 1			; vernietigt: niets
 2580: 1			;*******************************************************************************
 2581: 1  0807	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2582: 1  0809	C0 D0		               push    psw
 2583: 1  080B	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2584: 1  080E	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2585: 1  0811	80 19		               sjmp    magsig32acc1c
 2586: 1
 2587: 1  0813	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2588: 1  0816	80 14		               sjmp    magsig32acc1c
 2589: 1
 2590: 1  0818	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2591: 1  0819	F4		               cpl     a                 ;complementeer het dan
 2592: 1  081A	24 01		               add     a,#1             ;en tel er 1 bij
 2593: 1  081C	FC		               mov     r4,a
 2594: 1  081D	ED		               mov     a,r5             ;neem volgende byte
 2595: 1  081E	F4		               cpl     a                 ;complementeer en tel carry erbij
 2596: 1  081F	34 00		               addc    a,#0
 2597: 1  0821	FD		               mov     r5,a
 2598: 1  0822	EE		               mov     a,r6             ;neem volgende byte
 2599: 1  0823	F4		               cpl     a                 ;complementeer en tel carry erbij
 2600: 1  0824	34 00		               addc    a,#0
 2601: 1  0826	FE		               mov     r6,a
 2602: 1  0827	EF		               mov     a,r7             ;neem volgende byte
 2603: 1  0828	F4		               cpl     a                ;complementeer en tel carry erbij
 2604: 1  0829	34 00		               addc    a,#0
 2605: 1  082B	FF		               mov     r7,a
 2606: 1
 2607: 1  082C	D0 D0		magsig32acc1c: pop     psw
 2608: 1  082E	D0 E0		               pop     acc
 2609: 1  0830	22		               ret
 2610: 1
 2611: 1
 2612: 1			;*******************************************************************************
 2613: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2614: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2615: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2616: 1			; input:     r0 = 2's complement byte in acc0
 2617: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2618: 1			; output:    r0 = absolute waarde
 2619: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2620: 1			;
 2621: 1			; vernietigt: niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2622: 1			;*******************************************************************************
 2623: 1
 2624: 1  0831	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2625: 1  0833	C0 D0		                push    psw
 2626: 1  0835	E8		                mov     a,r0               ;neem lsb van acc0
 2627: 1  0836	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2628: 1  0839	D0 D0		                pop     psw
 2629: 1  083B	C2 D5		                clr     f0                 ;nee, positief...klaar
 2630: 1  083D	D0 E0		                pop     acc
 2631: 1  083F	22		                ret
 2632: 1  0840	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2633: 1  0841	04		                inc     a                   ;een erbij
 2634: 1  0842	F8		                mov     r0,a               ;bewaar
 2635: 1  0843	D0 D0		                pop     psw
 2636: 1  0845	D2 D5		                setb    f0                 ;f0=1 als negatief
 2637: 1  0847	D0 E0		                pop     acc
 2638: 1  0849	22		                ret
 2639: 1
 2640: 1			;*******************************************************************************
 2641: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2642: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2643: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2644: 1			; input:     r4 = 2's complement byte in acc1
 2645: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2646: 1			; output:    r4 = absolute waarde
 2647: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2648: 1			;
 2649: 1			; vernietigt: niets
 2650: 1			;*******************************************************************************
 2651: 1
 2652: 1  084A	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2653: 1  084C	C0 D0		                push    psw
 2654: 1  084E	EC		                mov     a,r4               ;neem lsb van acc0
 2655: 1  084F	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2656: 1  0852	D0 D0		                pop     psw
 2657: 1  0854	C2 D1		                clr     f1                 ;nee, positief...klaar
 2658: 1  0856	D0 E0		                pop     acc
 2659: 1  0858	22		                ret
 2660: 1  0859	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2661: 1  085A	04		                inc     a                   ;een erbij
 2662: 1  085B	FC		                mov     r4,a               ;bewaar
 2663: 1  085C	D0 D0		                pop     psw
 2664: 1  085E	D2 D1		                setb    f1                 ;f0=1 als negatief
 2665: 1  0860	D0 E0		                pop     acc
 2666: 1  0862	22		                ret
 2667: 1
 2668: 1			;*******************************************************************************
 2669: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2670: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2671: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2672: 1			; input:     r1,r0 = 2's complement word in acc0
 2673: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2674: 1			; output:    r1,r0 = absolute waarde
 2675: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2676: 1			;
 2677: 1			; vernietigt: niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2678: 1			;*******************************************************************************
 2679: 1
 2680: 1  0863	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2681: 1  0865	C0 D0		                push    psw
 2682: 1  0867	E9		                mov     a,r1               ; neem msb van acc0
 2683: 1  0868	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2684: 1  086B	D0 D0		                pop     psw
 2685: 1  086D	C2 D5		                clr     f0                 ;f0=0 als positief
 2686: 1  086F	D0 E0		                pop     acc
 2687: 1  0871	22		                ret                        ;klaar
 2688: 1
 2689: 1  0872	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2690: 1  0873	F4		                cpl     a                  ;complementeren
 2691: 1  0874	24 01		                add     a,#1               ;en een bijtellen
 2692: 1  0876	F8		                mov     r0,a
 2693: 1  0877	E9		                mov     a,r1
 2694: 1  0878	F4		                cpl     a                  ;complement eer volgende byte
 2695: 1  0879	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2696: 1  087B	F9		                mov     r1,a
 2697: 1  087C	D0 D0		                pop     psw
 2698: 1  087E	D2 D5		                setb    f0                 ;f0=1 als negatief
 2699: 1  0880	D0 E0		                pop     acc
 2700: 1  0882	22		                ret
 2701: 1
 2702: 1
 2703: 1			;*******************************************************************************
 2704: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2705: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2706: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2707: 1			; input:     r5,r4 = 2's complement word in acc1
 2708: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2709: 1			; output:    r5,r4 = absolute waarde
 2710: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2711: 1			;
 2712: 1			; vernietigt: niets
 2713: 1			;*******************************************************************************
 2714: 1
 2715: 1  0883	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2716: 1  0885	C0 D0		                push    psw
 2717: 1  0887	ED		                mov     a,r5               ;neem msb van acc1
 2718: 1  0888	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2719: 1  088B	D0 D0		                pop     psw
 2720: 1  088D	C2 D1		                clr     f1                 ;f1=0 als positief
 2721: 1  088F	D0 E0		                pop    acc
 2722: 1  0891	22		                ret                        ;klaar
 2723: 1
 2724: 1  0892	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2725: 1  0893	F4		                cpl     a                   ;complementeren
 2726: 1  0894	24 01		                add     a,#1               ;en een bijtellen
 2727: 1  0896	FC		                mov     r4,a
 2728: 1  0897	ED		                mov     a,r5
 2729: 1  0898	F4		                cpl     a                  ;complementeer volgende byte
 2730: 1  0899	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2731: 1  089B	FD		                mov     r5,a
 2732: 1  089C	D0 D0		                pop     psw
 2733: 1  089E	D2 D1		                setb    f1                ;f1=1 als negatief

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2734: 1  08A0	D0 E0		                pop     acc
 2735: 1  08A2	22		                ret
 2736: 1
 2737: 1
 2738: 1			;*******************************************************************************
 2739: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2740: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2741: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2742: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2743: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2744: 1			; output:    r7,r6 = absolute waarde
 2745: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2746: 1			;
 2747: 1			; vernietigt: niets
 2748: 1			;*******************************************************************************
 2749: 1
 2750: 1  08A3	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2751: 1  08A5	C0 D0		                push    psw
 2752: 1  08A7	EF		                mov     a,r7                ; neem msb van acc1 high
 2753: 1  08A8	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2754: 1  08AB	D0 D0		                pop     psw
 2755: 1  08AD	C2 D5		                clr     f0                  ;f0=0 als positief
 2756: 1  08AF	D0 E0		                pop     acc
 2757: 1  08B1	22		                ret                         ;klaar
 2758: 1
 2759: 1  08B2	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2760: 1  08B3	F4		                cpl     a                   ;complementeren
 2761: 1  08B4	24 01		                add     a,#1               ;en een bijtellen
 2762: 1  08B6	FE		                mov     r6,a
 2763: 1  08B7	EF		                mov     a,r7
 2764: 1  08B8	F4		                cpl     a                  ;complementeer volgende byte
 2765: 1  08B9	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2766: 1  08BB	FF		                mov     r7,a
 2767: 1  08BC	D0 D0		                pop     psw
 2768: 1  08BE	D2 D5		                setb    f0                ;f0=1 als negatief
 2769: 1  08C0	D0 E0		                pop     acc
 2770: 1  08C2	22		                ret
 2771: 1
 2772: 1
 2773: 1			;*******************************************************************************
 2774: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2775: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2776: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 2777: 1			;
 2778: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2779: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2780: 1			;            (-2147483648 tot +2147483647)
 2781: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2782: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2783: 1			;
 2784: 1			; vernietigt: niets
 2785: 1			;*******************************************************************************
 2786: 1
 2787: 1  08C3	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2788: 1  08C5	C0 D0		                push    psw
 2789: 1  08C7	EB		                mov     a,r3               ;neem msb van acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2790: 1  08C8	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2791: 1  08CB	D0 D0		                pop     psw                ;nee, positief
 2792: 1  08CD	C2 D5		                clr     f0
 2793: 1  08CF	D0 E0		                pop     acc
 2794: 1  08D1	22		                ret                        ;klaar
 2795: 1
 2796: 1  08D2	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2797: 1  08D3	F4		                cpl     a                  ;complementeren
 2798: 1  08D4	24 01		                add     a,#1               ;en een bijtellen
 2799: 1  08D6	F8		                mov     r0,a
 2800: 1  08D7	E9		                mov     a,r1               ;neem volgende byte
 2801: 1  08D8	F4		                cpl     a                  ;complementeer volgende byte
 2802: 1  08D9	34 00		                addc    a,#0
 2803: 1  08DB	F9		                mov     r1,a
 2804: 1  08DC	EA		                mov     a,r2               ;neem volgende byte
 2805: 1  08DD	F4		                cpl     a                  ;complementeer volgende byte
 2806: 1  08DE	34 00		                addc    a,#0
 2807: 1  08E0	FA		                mov     r2,a
 2808: 1  08E1	EB		                mov     a,r3               ;neem volgende byte
 2809: 1  08E2	F4		                cpl     a                  ;complementeer volgende byte
 2810: 1  08E3	34 00		                addc    a,#0
 2811: 1  08E5	FB		                mov     r3,a
 2812: 1  08E6	D0 D0		                pop     psw
 2813: 1  08E8	D2 D5		                setb    f0                 ;negatief: f0=1
 2814: 1  08EA	D0 E0		                pop     acc
 2815: 1  08EC	22		                ret                        ;klaar
 2816: 1
 2817: 1			;*******************************************************************************
 2818: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2819: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2820: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2821: 1			;
 2822: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2823: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2824: 1			;            (-2147483648 tot +2147483647)
 2825: 1			; output:    r7,r6,r5,r4 = absolute waarde
 2826: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2827: 1			;
 2828: 1			; vernietigt: niets
 2829: 1			;*******************************************************************************
 2830: 1
 2831: 1  08ED	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2832: 1  08EF	C0 D0		                push    psw
 2833: 1  08F1	EF		                mov     a,r7               ;neem msb van acc0
 2834: 1  08F2	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2835: 1  08F5	D0 D0		                pop     psw                ;nee, positief
 2836: 1  08F7	C2 D1		                clr     f1
 2837: 1  08F9	D0 E0		                pop     acc
 2838: 1  08FB	22		                ret                        ;klaar
 2839: 1
 2840: 1  08FC	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2841: 1  08FD	F4		                cpl     a                   ;complementeren
 2842: 1  08FE	24 01		                add     a,#1               ;en een bijtellen
 2843: 1  0900	FC		                mov     r4,a
 2844: 1  0901	ED		                mov     a,r5               ;neem volgende byte
 2845: 1  0902	F4		                cpl     a                  ;complementeer volgende byte

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2846: 1  0903	34 00		                addc    a,#0
 2847: 1  0905	FD		                mov     r5,a
 2848: 1  0906	EE		                mov     a,r6               ;neem volgende byte
 2849: 1  0907	F4		                cpl     a                  ;complementeer volgende byte
 2850: 1  0908	34 00		                addc    a,#0
 2851: 1  090A	FE		                mov     r6,a
 2852: 1  090B	EF		                mov     a,r7               ;neem volgende byte
 2853: 1  090C	F4		                cpl     a                  ;complementeer volgende byte
 2854: 1  090D	34 00		                addc    a,#0
 2855: 1  090F	FF		                mov     r7,a
 2856: 1  0910	D0 D0		                pop     psw
 2857: 1  0912	D2 D1		                setb    f1                 ;negatief: f0=1
 2858: 1  0914	D0 E0		                pop     acc
 2859: 1  0916	22		                ret                        ;klaar
 2860: 1
 2861: 1
 2862: 1			;*******************************************************************************
 2863: 1			; s_add16        (19,35us @16.777216MHz)
 2864: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2865: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2866: 1			; input:     r1,r0 = acc0
 2867: 1			;            r5,r4 = acc1
 2868: 1			;
 2869: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2870: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2871: 1			;                  gebruik van r3,r2 is niet nodig
 2872: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2873: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2874: 1			;
 2875: 1			; vernietigt:  niets
 2876: 1			;*******************************************************************************
 2877: 1  0917	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2878: 1  0919	C0 D0		               push    psw
 2879: 1
 2880: 1  091B	E8		               mov     a,r0           ;tel de soft accumulators op
 2881: 1  091C	2C		               add     a,r4           ;low byte eerst
 2882: 1  091D	F8		               mov     r0,a           ;resultaat bewaren
 2883: 1  091E	E9		               mov     a,r1           ;nu de high bytes
 2884: 1  091F	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2885: 1  0920	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2886: 1
 2887: 1  0921	92 D5		               mov     f0,c
 2888: 1  0923	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 2889: 1  0925	92 D1		               mov     f1,c
 2890: 1  0927	A2 D5		               mov     c,f0           ;herstel carrybit
 2891: 1
 2892: 1  0929	74 00		               mov     a,#00h
 2893: 1  092B	34 00		               addc    a,#00h
 2894: 1  092D	FA		               mov     r2,a            ;24bit resultaat klaar
 2895: 1
 2896: 1  092E	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2897: 1
 2898: 1  0931	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2899: 1  0932	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2900: 1  0935	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 2901: 1  0937	7B FF		               mov     r3,#0ffh

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2902: 1  0939	80 04		               sjmp    s_add162
 2903: 1  093B	7A 00		s_add161:      mov     r2,#00h
 2904: 1  093D	7B 00		               mov     r3,#00h
 2905: 1  093F	D0 D0		s_add162:      pop     psw
 2906: 1  0941	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2907: 1  0942	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2908: 1  0944	22		               ret
 2909: 1
 2910: 1  0945	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2911: 1  0947	C3		               clr     c
 2912: 1  0948	D0 E0		               pop     acc
 2913: 1  094A	22		               ret
 2914: 1
 2915: 1			;*******************************************************************************
 2916: 1			; add16        (13,6us @16.777216MHz)
 2917: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2918: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2919: 1			; input:     r1,r0 = acc0
 2920: 1			;            r5,r4 = acc1
 2921: 1			;
 2922: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2923: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 2924: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2925: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 2926: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 2927: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 2928: 1			;
 2929: 1			; vernietigt:  niets
 2930: 1			;*******************************************************************************
 2931: 1
 2932: 1  094B	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 2933: 1  094D	C0 D0		               push    psw
 2934: 1  094F	E8		               mov     a,r0           ;tel de soft accumulators op
 2935: 1  0950	2C		               add     a,r4           ;low byte eerst
 2936: 1  0951	F8		               mov     r0,a           ;resultaat bewaren
 2937: 1  0952	E9		               mov     a,r1           ;nu de high bytes
 2938: 1  0953	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2939: 1  0954	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2940: 1  0955	50 08		               jnc     add161          ;geen 24 bit resultaat
 2941: 1
 2942: 1  0957	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 2943: 1  0959	D0 D0		               pop     psw
 2944: 1  095B	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2945: 1  095C	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 2946: 1  095E	22		               ret
 2947: 1
 2948: 1  095F	7A 00		add161:        mov     r2,#00h
 2949: 1  0961	D0 D0		               pop     psw
 2950: 1  0963	C3		               clr     c               ;aangeven aan de gebruiker dat het
 2951: 1  0964	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 2952: 1  0966	22		               ret
 2953: 1
 2954: 1			;*******************************************************************************
 2955: 1			; s_add32        (28,0us @16.777216MHz)
 2956: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2957: 1			; Inputbereik getallen: -2147483648 tot +2147483647

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2958: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2959: 1			; input:     r3,r2,r1,r0 = acc0
 2960: 1			;            r7,r6,r5,r4 = acc1
 2961: 1			;
 2962: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2963: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2964: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 2965: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 2966: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 2967: 1			;
 2968: 1			; vernietigt:  niets
 2969: 1			;*******************************************************************************
 2970: 1  0967	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 2971: 1  0969	C0 D0		               push    psw
 2972: 1
 2973: 1  096B	E8		               mov     a,r0           ;tel de soft accumulators op
 2974: 1  096C	2C		               add     a,r4           ;low byte eerst
 2975: 1  096D	F8		               mov     r0,a           ;resultaat bewaren
 2976: 1  096E	E9		               mov     a,r1           ;nu de hogere bytes
 2977: 1  096F	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2978: 1  0970	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2979: 1
 2980: 1  0971	EA		               mov     a,r2           ;derde bytes optellen
 2981: 1  0972	3E		               addc    a,r6           ;optellen met eventuele overdracht
 2982: 1  0973	FA		               mov     r2,a           ;24bit resultaat is klaar
 2983: 1  0974	EB		               mov     a,r3           ;nu de ms bytes
 2984: 1  0975	3F		               addc    a,r7           ;optellen met eventuele overdracht
 2985: 1  0976	FB		               mov     r3,a           ;32 bit resultaat is klaar
 2986: 1
 2987: 1  0977	92 D5		               mov     f0,c
 2988: 1  0979	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 2989: 1  097B	92 D1		               mov     f1,c
 2990: 1  097D	A2 D5		               mov     c,f0           ;herstel carrybit
 2991: 1
 2992: 1  097F	74 00		               mov     a,#00h
 2993: 1  0981	34 00		               addc    a,#00h
 2994: 1  0983	FC		               mov     r4,a            ;40bit resultaat klaar
 2995: 1
 2996: 1  0984	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 2997: 1  0987	EC		               mov     a,r4            ;ja, sign extention toepassen!
 2998: 1  0988	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 2999: 1  098B	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3000: 1  098D	80 02		               sjmp    s_add322
 3001: 1  098F	7C 00		s_add321:      mov     r4,#00h
 3002: 1  0991	D0 D0		s_add322:      pop     psw
 3003: 1  0993	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3004: 1  0994	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 3005: 1  0996	22		               ret
 3006: 1
 3007: 1  0997	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 3008: 1  0999	C3		               clr     c
 3009: 1  099A	D0 E0		               pop     acc
 3010: 1  099C	22		               ret
 3011: 1
 3012: 1
 3013: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3014: 1			; add32        (18,0us @16.777216MHz)
 3015: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 3016: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3017: 1			; input:     r3,r2,r1,r0 = acc0
 3018: 1			;            r7,r6,r5,r4 = acc1
 3019: 1			;
 3020: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 3021: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3022: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3023: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 3024: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3025: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3026: 1			;
 3027: 1			; vernietigt:  niets
 3028: 1			;*******************************************************************************
 3029: 1  099D	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 3030: 1  099F	C0 D0		               push    psw
 3031: 1  09A1	E8		               mov     a,r0           ;tel de soft accumulators op
 3032: 1  09A2	2C		               add     a,r4           ;low byte eerst
 3033: 1  09A3	F8		               mov     r0,a           ;resultaat bewaren
 3034: 1  09A4	E9		               mov     a,r1           ;nu de hogere bytes
 3035: 1  09A5	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3036: 1  09A6	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3037: 1
 3038: 1  09A7	EA		               mov     a,r2           ;derde bytes optellen
 3039: 1  09A8	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3040: 1  09A9	FA		               mov     r2,a           ;24bit resultaat is klaar
 3041: 1  09AA	EB		               mov     a,r3           ;nu de ms bytes
 3042: 1  09AB	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3043: 1  09AC	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3044: 1
 3045: 1  09AD	50 08		               jnc     add321          ;geen 40 bit resultaat
 3046: 1
 3047: 1  09AF	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3048: 1  09B1	D0 D0		               pop     psw
 3049: 1  09B3	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3050: 1  09B4	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3051: 1  09B6	22		               ret
 3052: 1
 3053: 1  09B7	7C 00		add321:        mov     r4,#00h
 3054: 1  09B9	D0 D0		               pop     psw
 3055: 1  09BB	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3056: 1  09BC	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3057: 1  09BE	22		               ret
 3058: 1
 3059: 1
 3060: 1			;*******************************************************************************
 3061: 1			; s_sub16        (24,4us @16.777216MHz)
 3062: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3063: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3064: 1			; input:     r1,r0 = acc0
 3065: 1			;            r5,r4 = acc1
 3066: 1			;
 3067: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3068: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3069: 1			;                  gebruik van r3,r2 is niet nodig

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3070: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3071: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3072: 1			;
 3073: 1			; vernietigt:  niets
 3074: 1			;*******************************************************************************
 3075: 1  09BF	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3076: 1  09C1	C0 D0		                push    psw
 3077: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3078: 1
 3079: 1  09C3	EC		                mov   	a,r4            ;verander het teken van acc1
 3080: 1  09C4	F4		                cpl    	a               ;door het 2's complement te nemen
 3081: 1  09C5	24 01		                add   	a,#1
 3082: 1  09C7	FC		                mov    	r4,a
 3083: 1  09C8	ED		                mov    	a,r5
 3084: 1  09C9	F4		                cpl    	a
 3085: 1  09CA	34 00		                addc	a,#0
 3086: 1  09CC	FD		                mov    	r5,a
 3087: 1			;acc0+acc1
 3088: 1  09CD	E8						mov		a,r0
 3089: 1  09CE	2C						add		a,r4
 3090: 1  09CF	F8						mov		r0,a
 3091: 1  09D0	E9						mov		a,r1
 3092: 1  09D1	3D						addc	a,r5
 3093: 1  09D2	F9						mov		r1,a
 3094: 1
 3095: 1  09D3	92 D5		                mov    f0,c
 3096: 1  09D5	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3097: 1  09D7	92 D1		                mov    f1,c
 3098: 1  09D9	A2 D5		                mov    c,f0            ;herstel carrybit
 3099: 1
 3100: 1  09DB	74 00		                mov    a,#00h
 3101: 1  09DD	34 00		                addc   a,#00h
 3102: 1  09DF	FA		                mov    r2,a            ;24bit resultaat klaar
 3103: 1
 3104: 1  09E0	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3105: 1  09E3	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3106: 1  09E4	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3107: 1  09E7	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3108: 1  09E9	7B FF		                mov    r3,#0ffh
 3109: 1  09EB	80 04		                sjmp   s_sub162
 3110: 1  09ED	7A 00		s_sub161:       mov    r2,#00h
 3111: 1  09EF	7B 00		                mov    r3,#00h
 3112: 1  09F1	D0 D0		s_sub162:       pop    psw
 3113: 1  09F3	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3114: 1  09F4	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3115: 1  09F6	22		                ret
 3116: 1
 3117: 1  09F7	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3118: 1  09F9	C3		                clr    c
 3119: 1  09FA	D0 E0		                pop    acc
 3120: 1  09FC	22		                ret
 3121: 1
 3122: 1			;*******************************************************************************
 3123: 1			; sub16            (14,4us @16.777216MHz)
 3124: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3125: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3126: 1			; input:     r1,r0 = acc0
 3127: 1			;            r5,r4 = acc1
 3128: 1			;
 3129: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3130: 1			;            bij een underflow r2 op ffh zetten
 3131: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3132: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3133: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3134: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3135: 1			;
 3136: 1			; vernietigt:  niets
 3137: 1			;*******************************************************************************
 3138: 1
 3139: 1  09FD	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3140: 1  09FF	C0 D0		                push    psw
 3141: 1  0A01	C3		                clr     c
 3142: 1  0A02	E8		                mov     a,r0            ;tel de soft accumulators op
 3143: 1  0A03	9C		                subb    a,r4            ;low byte eerst
 3144: 1  0A04	F8		                mov     r0,a            ;resultaat bewaren
 3145: 1  0A05	E9		                mov     a,r1            ;nu de high bytes
 3146: 1  0A06	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3147: 1  0A07	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3148: 1  0A08	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3149: 1
 3150: 1  0A0A	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3151: 1  0A0C	D0 D0		                pop     psw
 3152: 1  0A0E	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3153: 1  0A0F	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3154: 1  0A11	22		                ret
 3155: 1
 3156: 1  0A12	7A 00		sub161:         mov     r2,#00h
 3157: 1  0A14	D0 D0		                pop     psw
 3158: 1  0A16	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3159: 1  0A17	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3160: 1  0A19	22		                ret
 3161: 1
 3162: 1			;*******************************************************************************
 3163: 1			; s_sub32        (27,2us @16.777216MHz)
 3164: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3165: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3166: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3167: 1			; input:     r3,r2,r1,r0 = acc0
 3168: 1			;            r7,r6,r5,r4 = acc1
 3169: 1			;
 3170: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3171: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3172: 1			;                  gebruik van r4 is niet nodig
 3173: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3174: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3175: 1			;
 3176: 1			; vernietigt:  niets
 3177: 1			;*******************************************************************************
 3178: 1  0A1A	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3179: 1  0A1C	C0 D0		                push   psw
 3180: 1
 3181: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3182: 1
 3183: 1  0A1E	EC		                mov    	a,r4            ;verander het teken van acc1
 3184: 1  0A1F	F4		                cpl    	a               ;door het 2's complement te nemen
 3185: 1  0A20	24 01		                add    	a,#1
 3186: 1  0A22	FC		                mov    	r4,a
 3187: 1  0A23	ED		                mov    	a,r5
 3188: 1  0A24	F4		                cpl    	a
 3189: 1  0A25	34 00		                addc	a,#0
 3190: 1  0A27	FD		                mov    	r5,a
 3191: 1  0A28	EE		                mov    	a,r6
 3192: 1  0A29	F4		                cpl    	a
 3193: 1  0A2A	34 00		                addc   	a,#0
 3194: 1  0A2C	FE		                mov    	r6,a
 3195: 1  0A2D	EF		                mov    	a,r7
 3196: 1  0A2E	F4		                cpl    	a
 3197: 1  0A2F	34 00		                addc   	a,#0
 3198: 1  0A31	FF		                mov    	r7,a
 3199: 1			;acc0+acc1
 3200: 1  0A32	E8						mov		a,r0
 3201: 1  0A33	2C						add		a,r4
 3202: 1  0A34	F8						mov		r0,a
 3203: 1  0A35	E9						mov		a,r1
 3204: 1  0A36	3D						addc	a,r5
 3205: 1  0A37	F9						mov		r1,a
 3206: 1  0A38	EA						mov		a,r2
 3207: 1  0A39	3E						addc	a,r6
 3208: 1  0A3A	FA						mov		r2,a
 3209: 1  0A3B	EB						mov		a,r3
 3210: 1  0A3C	3F						addc	a,r7
 3211: 1  0A3D	FB						mov		r3,a
 3212: 1
 3213: 1  0A3E	92 D5		                mov   f0,c
 3214: 1  0A40	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3215: 1  0A42	92 D1		                mov   f1,c
 3216: 1  0A44	A2 D5		                mov   c,f0            ;herstel carrybit
 3217: 1
 3218: 1  0A46	74 00		                mov   a,#00h
 3219: 1  0A48	34 00		                addc  a,#00h
 3220: 1  0A4A	FC		                mov   r4,a            ;40bit resultaat klaar
 3221: 1
 3222: 1  0A4B	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3223: 1
 3224: 1  0A4E	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3225: 1  0A4F	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3226: 1  0A52	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3227: 1  0A54	80 02		                sjmp   s_sub322
 3228: 1  0A56	7C 00		s_sub321:       mov   r4,#00h
 3229: 1  0A58	D0 D0		s_sub322:       pop   psw
 3230: 1  0A5A	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3231: 1  0A5B	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3232: 1  0A5D	22		                ret
 3233: 1
 3234: 1  0A5E	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3235: 1  0A60	C3		                clr   c
 3236: 1  0A61	D0 E0		                pop   acc
 3237: 1  0A63	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3238: 1
 3239: 1
 3240: 1			;*******************************************************************************
 3241: 1			; sub32        (18,7us @16.777216MHz)
 3242: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3243: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3244: 1			; input:     r3,r2,r1,r0 = acc0
 3245: 1			;            r7,r6,r5,r4 = acc1
 3246: 1			;
 3247: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3248: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3249: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3250: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3251: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3252: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3253: 1			;
 3254: 1			; vernietigt:  niets
 3255: 1			;*******************************************************************************
 3256: 1  0A64	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3257: 1  0A66	C0 D0		               push    psw
 3258: 1  0A68	C3		               clr       c
 3259: 1  0A69	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3260: 1  0A6A	9C		               subb    a,r4           ;low byte eerst
 3261: 1  0A6B	F8		               mov     r0,a           ;resultaat bewaren
 3262: 1  0A6C	E9		               mov     a,r1           ;nu de hogere bytes
 3263: 1  0A6D	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3264: 1  0A6E	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3265: 1
 3266: 1  0A6F	EA		               mov     a,r2           ;derde bytes optellen
 3267: 1  0A70	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3268: 1  0A71	FA		               mov     r2,a           ;24bit resultaat is klaar
 3269: 1  0A72	EB		               mov     a,r3           ;nu de ms bytes
 3270: 1  0A73	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3271: 1  0A74	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3272: 1
 3273: 1  0A75	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3274: 1
 3275: 1  0A77	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3276: 1  0A79	D0 D0		               pop     psw
 3277: 1  0A7B	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3278: 1  0A7C	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3279: 1  0A7E	22		               ret
 3280: 1
 3281: 1  0A7F	7C 00		sub321:        mov     r4,#00h
 3282: 1  0A81	D0 D0		               pop     psw
 3283: 1  0A83	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3284: 1  0A84	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3285: 1  0A86	22		               ret
 3286: 1
 3287: 1
 3288: 1
 3289: 1			;*******************************************************************************
 3290: 1			; mul16        (71,2us @16.777216MHz)
 3291: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3292: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3293: 1			; input:     r1,r0 = acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3294: 1			;            r5,r4 = acc1
 3295: 1			;
 3296: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3297: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3298: 1			;
 3299: 1			; vernietigt:  niets
 3300: 1			;*******************************************************************************
 3301: 1  0A87	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3302: 1  0A89	C0 D0		                push    psw
 3303: 1  0A8B	C0 F0		                push    b
 3304: 1  0A8D	C0 82		                push    dpl
 3305: 1  0A8F	C0 83		                push    dph
 3306: 1
 3307: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3308: 1
 3309: 1  0A91	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3310: 1  0A93	89 83		                mov     dph,r1
 3311: 1  0A95	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3312: 1  0A97	08		                inc     r0              ;pointer naar eerste vrije plaats
 3313: 1  0A98	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3314: 1  0A9A	E5 81		                mov     a,sp            ;plaats alloceren
 3315: 1  0A9C	24 03		                add     a,#3            ;3 bytes nodig
 3316: 1  0A9E	F5 81		                mov     sp,a            ;stackpointer verzetten
 3317: 1
 3318: 1  0AA0	E5 82		                mov     a,dpl            ;acc0 lsb
 3319: 1  0AA2	8C F0		                mov     b,r4            ;acc1 lsb
 3320: 1  0AA4	A4		                mul     ab
 3321: 1  0AA5	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3322: 1  0AA6	08		                inc     r0
 3323: 1  0AA7	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3324: 1
 3325: 1  0AA9	E5 83		                mov     a,dph            ;acc0 msb
 3326: 1  0AAB	8C F0		                mov     b,r4            ;acc1 lsb
 3327: 1  0AAD	A4		                mul     ab
 3328: 1
 3329: 1  0AAE	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3330: 1  0AAF	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3331: 1  0AB0	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3332: 1  0AB2	34 00		                addc    a,#0
 3333: 1  0AB4	08		                inc     r0               ;bewaar als tussenresultaat
 3334: 1  0AB5	F6		                mov     @r0,a
 3335: 1
 3336: 1  0AB6	E5 82		                mov     a,dpl            ;acc0 lsb
 3337: 1  0AB8	8D F0		                mov     b,r5             ;acc1 msb
 3338: 1  0ABA	A4		                mul     ab
 3339: 1  0ABB	18		                dec     r0
 3340: 1  0ABC	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3341: 1  0ABD	F6		                mov     @r0,a            ;en bewaar weer
 3342: 1  0ABE	08		                inc     r0
 3343: 1  0ABF	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3344: 1  0AC1	36		                addc    a,@r0
 3345: 1  0AC2	F6		                mov     @r0,a            ;en bewaar weer
 3346: 1  0AC3	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3347: 1
 3348: 1  0AC5	E5 83		                mov     a,dph            ;acc0 msb
 3349: 1  0AC7	8D F0		                mov     b,r5             ;acc1 msb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3350: 1  0AC9	A4		                mul     AB
 3351: 1  0ACA	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3352: 1  0ACB	FA		                mov     r2,a
 3353: 1  0ACC	E5 F0		                mov     a,b
 3354: 1  0ACE	34 00		                addc    a,#0
 3355: 1
 3356: 1  0AD0	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3357: 1  0AD2	34 00		                addc    a,#0
 3358: 1
 3359: 1  0AD4	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3360: 1  0AD5	18		                dec     r0
 3361: 1  0AD6	86 83		                mov     dph,@r0
 3362: 1  0AD8	18		                dec     r0
 3363: 1  0AD9	86 82		                mov     dpl,@r0
 3364: 1
 3365: 1  0ADB	89 81		                mov     sp,r1            ;zet stackpointer terug
 3366: 1  0ADD	A9 83		                mov     r1,dph
 3367: 1  0ADF	A8 82		                mov     r0,dpl
 3368: 1
 3369: 1  0AE1	D0 83		                pop     dph              ;herstel de bewaarde registers
 3370: 1  0AE3	D0 82		                pop     dpl
 3371: 1  0AE5	D0 F0		                pop     b
 3372: 1  0AE7	D0 D0		                pop     psw
 3373: 1  0AE9	D0 E0		                pop     acc
 3374: 1  0AEB	22		                ret
 3375: 1
 3376: 1
 3377: 1
 3378: 1			;*******************************************************************************
 3379: 1			; mul16acc1        (71,2us @16.777216MHz)
 3380: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3381: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3382: 1			; input:     r5,r4 = acc1 low
 3383: 1			;            r7,r6 = acc1 high
 3384: 1			;
 3385: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3386: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3387: 1			;
 3388: 1			; vernietigt:  niets
 3389: 1			;*******************************************************************************
 3390: 1  0AEC	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3391: 1  0AEE	C0 D0		                push    psw
 3392: 1  0AF0	C0 F0		                push    b
 3393: 1  0AF2	C0 82		                push    dpl
 3394: 1  0AF4	C0 83		                push    dph
 3395: 1
 3396: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3397: 1
 3398: 1  0AF6	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3399: 1  0AF8	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3400: 1
 3401: 1  0AFA	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3402: 1  0AFC	08		                inc     r0               ;pointer naar eerste vrije plaats
 3403: 1  0AFD	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3404: 1  0AFF	E5 81		                mov     a,sp             ;plaats alloceren
 3405: 1  0B01	24 03		                add     a,#3             ;3 bytes nodig

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3406: 1  0B03	F5 81		                mov     sp,a             ;stackpointer verzetten
 3407: 1
 3408: 1  0B05	EC		                mov     a,r4             ;acc1 low lsb
 3409: 1  0B06	8E F0		                mov     b,r6             ;acc1 high lsb
 3410: 1  0B08	A4		                mul     ab
 3411: 1  0B09	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3412: 1  0B0A	08		                inc     r0
 3413: 1  0B0B	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3414: 1
 3415: 1  0B0D	ED		                mov     a,r5             ;acc1 low msb
 3416: 1  0B0E	8E F0		                mov     b,r6             ;acc1 high lsb
 3417: 1  0B10	A4		                mul     ab
 3418: 1
 3419: 1  0B11	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3420: 1  0B12	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3421: 1  0B13	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3422: 1  0B15	34 00		                addc    a,#0
 3423: 1  0B17	08		                inc     r0               ;bewaar als tussenresultaat
 3424: 1  0B18	F6		                mov     @r0,a
 3425: 1
 3426: 1  0B19	EC		                mov     a,r4             ;acc1 low lsb
 3427: 1  0B1A	8F F0		                mov     b,r7             ;acc1 high msb
 3428: 1  0B1C	A4		                mul     ab
 3429: 1  0B1D	18		                dec     r0
 3430: 1  0B1E	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3431: 1  0B1F	F6		                mov     @r0,a            ;en bewaar weer
 3432: 1  0B20	08		                inc     r0
 3433: 1  0B21	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3434: 1  0B23	36		                addc    a,@r0
 3435: 1  0B24	F6		                mov     @r0,a            ;en bewaar weer
 3436: 1  0B25	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3437: 1
 3438: 1  0B27	ED		                mov     a,r5             ;acc1 low msb
 3439: 1  0B28	8F F0		                mov     b,r7             ;acc1 high msb
 3440: 1  0B2A	A4		                mul     AB
 3441: 1
 3442: 1  0B2B	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3443: 1  0B2C	FE		                mov     r6,a             ;deze byte van product is al klaar
 3444: 1  0B2D	E5 F0		                mov     a,b
 3445: 1  0B2F	34 00		                addc    a,#0
 3446: 1  0B31	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3447: 1  0B33	34 00		                addc    a,#0
 3448: 1
 3449: 1  0B35	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3450: 1  0B36	18		                dec     r0
 3451: 1  0B37	E6		                mov     a,@r0
 3452: 1  0B38	FD		                mov     r5,a
 3453: 1  0B39	18		                dec     r0
 3454: 1  0B3A	E6		                mov     a,@r0
 3455: 1  0B3B	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3456: 1
 3457: 1  0B3C	89 81		                mov     sp,r1            ;zet stackpointer terug
 3458: 1  0B3E	A9 83		                mov     r1,dph
 3459: 1  0B40	A8 82		                mov     r0,dpl
 3460: 1
 3461: 1  0B42	D0 83		                pop     dph              ;herstel de bewaarde registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3462: 1  0B44	D0 82		                pop     dpl
 3463: 1  0B46	D0 F0		                pop     b
 3464: 1  0B48	D0 D0		                pop     psw
 3465: 1  0B4A	D0 E0		                pop     acc
 3466: 1  0B4C	22		                ret
 3467: 1
 3468: 1			;*******************************************************************************
 3469: 1			; s_mul16        (121,1us @16.777216MHz)
 3470: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3471: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3472: 1			; input:     r1,r0 = acc0
 3473: 1			;            r5,r4 = acc1
 3474: 1			;
 3475: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3476: 1			;                                  -1073709056 tot +1073741824
 3477: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3478: 1			;
 3479: 1			; vernietigt:  niets
 3480: 1			;*******************************************************************************
 3481: 1  0B4D	12 08 63	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3482: 1  0B50	12 08 83	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3483: 1  0B53	12 0A 87	                lcall    mul16           ;maak product
 3484: 1  0B56	12 07 DD	                lcall    magsig32        ;maak 2's complement formaat
 3485: 1  0B59	22		                ret                      ;klaar
 3486: 1
 3487: 1			;*******************************************************************************
 3488: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3489: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3490: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3491: 1			; input:     r5,r4 = acc1 low
 3492: 1			;            r7,r6 = acc1 high
 3493: 1			;
 3494: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3495: 1			;                                  -1073709056 tot +1073741824
 3496: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3497: 1			; vernietigt:  niets
 3498: 1			;*******************************************************************************
 3499: 1  0B5A	12 08 83	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3500: 1  0B5D	12 08 A3	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3501: 1  0B60	12 0A EC	                lcall    mul16acc1       ;maak product
 3502: 1  0B63	12 08 07	                lcall    magsig32acc1    ;maak 2's complement formaat
 3503: 1  0B66	22		                ret                      ;klaar
 3504: 1
 3505: 1			;*******************************************************************************
 3506: 1			; s_mul816        (83,5us @16.777216MHz)
 3507: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3508: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3509: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3510: 1			; input:     r1,r0 = acc0
 3511: 1			;               r4 = acc1
 3512: 1			;
 3513: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3514: 1			;                                  -4194176 tot +4194304
 3515: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3516: 1			; vernietigt:  niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3517: 1			;*******************************************************************************
 3518: 1  0B67	12 08 63	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3519: 1  0B6A	12 08 4A	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3520: 1  0B6D	12 0B 74	                lcall    mul816          ;8bit x 16 bit product
 3521: 1  0B70	12 07 DD	                lcall    magsig32        ;abs. waarde naar 2's complement
 3522: 1  0B73	22		                ret
 3523: 1
 3524: 1			;*******************************************************************************
 3525: 1			; mul816        (29,4us @16.777216MHz)
 3526: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3527: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3528: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3529: 1			; input:     r1,r0 = acc0
 3530: 1			;               r4 = acc1
 3531: 1			;
 3532: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3533: 1			;                           0..16711425 (000000h..feff01h)
 3534: 1			;
 3535: 1			; vernietigt:  niets
 3536: 1			;*******************************************************************************
 3537: 1  0B74	C0 E0		mul816:         push    acc             ;bewaar registers
 3538: 1  0B76	C0 F0		                push    b
 3539: 1  0B78	C0 D0		                push    psw
 3540: 1  0B7A	EC		                mov     a,r4            ;neem acc1
 3541: 1  0B7B	88 F0		                mov     b,r0            ;neem lsb van acc0
 3542: 1  0B7D	A4		                mul     ab              ;maak product
 3543: 1  0B7E	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3544: 1  0B7F	C0 F0		                push    b               ;bewaar lsb van het product
 3545: 1  0B81	EC		                mov     a,r4            ;neem acc1
 3546: 1  0B82	89 F0		                mov     b,r1            ;neem msb can acc0
 3547: 1  0B84	A4		                mul     ab              ;maak product
 3548: 1  0B85	AA F0		                mov     r2,b            ;bewaar msb van product even
 3549: 1  0B87	F5 F0		                mov     b,a             ;verplaats lsb van product
 3550: 1  0B89	D0 E0		                pop     acc             ;neem msb van vorig product
 3551: 1  0B8B	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3552: 1  0B8D	F9		                mov     r1,a            ;de middenste byte is klaar
 3553: 1  0B8E	EA		                mov     a,r2            ;tel nu de eventuele
 3554: 1  0B8F	34 00		                addc    a,#0            ;carry bij de msb
 3555: 1  0B91	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3556: 1  0B92	7B 00		                mov     r3,#0
 3557: 1  0B94	D0 D0		                pop     psw
 3558: 1  0B96	D0 F0		                pop     b
 3559: 1  0B98	D0 E0		                pop     acc
 3560: 1  0B9A	22		                ret
 3561: 1
 3562: 1			;*******************************************************************************
 3563: 1			; s_mac16        (145,1us @16.777216MHz)
 3564: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3565: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3566: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3567: 1			; input:     r7,r6 = acc1 (high word)
 3568: 1			;            r5,r4 = acc1 (low  word)
 3569: 1			;
 3570: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3571: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3572: 1			;                          -2147483648 tot +2147483647

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3573: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3574: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3575: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3576: 1			;
 3577: 1			; vernietigt:  niets
 3578: 1			;*******************************************************************************
 3579: 1  0B9B	12 0B 5A	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3580: 1  0B9E	C0 E0		                push    acc
 3581: 1  0BA0	C0 D0		                push    psw
 3582: 1  0BA2	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3583: 1  0BA3	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3584: 1  0BA4	F8		                mov     r0,a
 3585: 1  0BA5	ED		                mov     a,r5
 3586: 1  0BA6	39		                addc    a,r1
 3587: 1  0BA7	F9		                mov     r1,a
 3588: 1  0BA8	EE		                mov     a,r6
 3589: 1  0BA9	3A		                addc    a,r2
 3590: 1  0BAA	FA		                mov     r2,a
 3591: 1  0BAB	EF		                mov     a,r7
 3592: 1  0BAC	3B		                addc    a,r3
 3593: 1  0BAD	FB		                mov     r3,a
 3594: 1  0BAE	20 D2 06	                jb      ov,s_mac161
 3595: 1  0BB1	D0 D0		                pop     psw
 3596: 1  0BB3	C3		                clr     c                ;ok, 32bit som binnen bereik
 3597: 1  0BB4	D0 E0		                pop     acc
 3598: 1  0BB6	22		                ret
 3599: 1  0BB7	D0 D0		s_mac161:       pop     psw
 3600: 1  0BB9	D3		                setb    c                ;fout! 32bit som buiten bereik
 3601: 1  0BBA	D0 E0		                pop     acc
 3602: 1  0BBC	22		                ret
 3603: 1
 3604: 1
 3605: 1			;*******************************************************************************
 3606: 1			; s_div8        (78us @16.777216MHz)
 3607: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3608: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3609: 1			; input:    r0 = acc0 deeltal (2's compl)
 3610: 1			;           r4 = acc1 deler   (2's compl)
 3611: 1			;
 3612: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3613: 1			;           r4 = rest (2's compl)
 3614: 1			;           cy=1 bij acc1=0 (deling door nul)
 3615: 1			;            cy=0 in andere gevallen
 3616: 1			;
 3617: 1			; vernietigt: niets
 3618: 1			;*******************************************************************************
 3619: 1  0BBD	12 08 31	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3620: 1  0BC0	12 08 4A	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3621: 1  0BC3	12 0B CF	                lcall   div8
 3622: 1  0BC6	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3623: 1  0BC8	12 07 69	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3624: 1  0BCB	12 07 83	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3625: 1  0BCE	22		s_div81:        ret
 3626: 1
 3627: 1			;*******************************************************************************
 3628: 1			; div8        (19,4us @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3629: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3630: 1			; absolute waarde
 3631: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3632: 1			; input:    r0 = acc0 deeltal
 3633: 1			;           r4 = acc1 deler
 3634: 1			;
 3635: 1			; output:   r0 = quotient van deling acc0/acc1
 3636: 1			;           r4 = rest
 3637: 1			;           cy=1 bij acc1=0 (deling door nul)
 3638: 1			;            cy=0 in andere gevallen
 3639: 1			;
 3640: 1			; vernietigt: niets
 3641: 1			;*******************************************************************************
 3642: 1  0BCF	C0 E0		div8:           push    acc             ;bewaar registers
 3643: 1  0BD1	C0 F0		                push    b
 3644: 1  0BD3	C0 D0		                push    psw
 3645: 1  0BD5	EC		                mov     a,r4            ;neem deler
 3646: 1  0BD6	60 0F		                jz      div81           ;deling door nul?
 3647: 1  0BD8	E8		                mov     a,r0            ;nee, neem deeltal
 3648: 1  0BD9	8C F0		                mov     b,r4            ;en deler
 3649: 1  0BDB	84		                div     ab              ;en maak deling
 3650: 1  0BDC	F8		                mov     r0,a            ;bewaar quotient in acc0
 3651: 1  0BDD	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3652: 1  0BDF	D0 D0		                pop     psw             ;herstel registers
 3653: 1  0BE1	D0 F0		                pop     b
 3654: 1  0BE3	D0 E0		                pop     acc
 3655: 1  0BE5	C3		                clr     c                ;geen deling door nul
 3656: 1  0BE6	22		                ret
 3657: 1
 3658: 1  0BE7	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3659: 1  0BE9	D0 F0		                pop     b
 3660: 1  0BEB	D0 E0		                pop     acc
 3661: 1  0BED	D3		                setb    c
 3662: 1  0BEE	22		                ret
 3663: 1
 3664: 1
 3665: 1			;*******************************************************************************
 3666: 1			; s_div16        (469,1us @16.777216MHz)
 3667: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3668: 1			; 2's Complement Format
 3669: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3670: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3671: 1			;           r5, r4 = acc1 deler   (2's compl)
 3672: 1			;
 3673: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3674: 1			;           r5, r4 = rest
 3675: 1			;           cy=1 bij acc1=0 (deling door nul)
 3676: 1			;            cy=0 in andere gevallen
 3677: 1			;
 3678: 1			; vernietigt: niets
 3679: 1			;*******************************************************************************
 3680: 1  0BEF	C0 E0		s_div16:        push    acc
 3681: 1  0BF1	C0 D0		                push    psw
 3682: 1  0BF3	ED		                mov     a,r5            ;neem msb van deler
 3683: 1  0BF4	4C		                orl     a,r4            ;combineer met lsb van deler
 3684: 1  0BF5	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3685: 1  0BF7	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3686: 1  0BF9	D0 E0		                pop     acc
 3687: 1  0BFB	D3		                setb    C               ;fout, deling door nul!
 3688: 1  0BFC	22		                ret
 3689: 1
 3690: 1  0BFD	12 08 63	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3691: 1  0C00	12 08 83	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3692: 1  0C03	12 0C 12	                lcall   div16
 3693: 1  0C06	12 07 9D	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3694: 1  0C09	12 07 BD	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3695: 1  0C0C	D0 D0		                pop     psw
 3696: 1  0C0E	C3		                clr     C               ;delig ok
 3697: 1  0C0F	D0 E0		                pop     acc
 3698: 1  0C11	22		                ret                     ;klaar
 3699: 1
 3700: 1			;*******************************************************************************
 3701: 1			; div16            (405,1us @16.777216MHz)
 3702: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3703: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3704: 1			; input:    r1, r0 = Deeltal (acc0)
 3705: 1			;           r5, r4 = Deler   (acc1)
 3706: 1			;
 3707: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3708: 1			;           r5, r4 = rest van de deling acc0/acc1
 3709: 1			;            cy=1 bij deling door nul (acc1=0)
 3710: 1			;            cy=0 bij normale deling
 3711: 1			;
 3712: 1			; vernietigt: niets
 3713: 1			;*******************************************************************************
 3714: 1
 3715: 1  0C12	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3716: 1  0C14	C0 D0		                push    psw
 3717: 1			;check voor deling door nul
 3718: 1  0C16	EC		                mov     a,r4           ;neem lsb deler
 3719: 1  0C17	4D		                orl     a,r5           ;combineer met msb van deler
 3720: 1  0C18	70 06		                jnz     div160         ;niet nul, dan verder werken
 3721: 1  0C1A	D0 D0		                pop     psw            ;als nul, dikke snul
 3722: 1  0C1C	D3		                setb    c              ;terug met errorstatus
 3723: 1  0C1D	D0 E0		                pop     acc
 3724: 1  0C1F	22		                ret
 3725: 1
 3726: 1  0C20	C0 F0		div160:         push    b              ;registers verder bewaren
 3727: 1  0C22	EF		                mov     a,r7
 3728: 1  0C23	C0 E0		                push    acc            ;push r7 op stack
 3729: 1  0C25	EE		                mov     a,r6
 3730: 1  0C26	C0 E0		                push    acc            ;push r6 op stack
 3731: 1  0C28	EB		                mov     a,r3
 3732: 1  0C29	C0 E0		                push    acc            ;push r3 op stack
 3733: 1  0C2B	EA		                mov     a,r2
 3734: 1  0C2C	C0 E0		                push    acc            ;push r2 op stack
 3735: 1  0C2E	C0 83		                push    dph
 3736: 1  0C30	C0 82		                push    dpl
 3737: 1
 3738: 1  0C32	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3739: 1  0C34	7B 00		                mov     r3,#0
 3740: 1  0C36	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3741: 1  0C38	7E 00		                mov     r6,#0
 3742: 1  0C3A	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3743: 1
 3744: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3745: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3746: 1			;het aantal significante bits af in de lusteller b
 3747: 1
 3748: 1  0C3D	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3749: 1  0C3E	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3750: 1  0C41	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3751: 1  0C42	E8		                mov     a,r0            ;lsb van deeltal nemen
 3752: 1  0C43	33		                rlc     a                ;en opschuiven
 3753: 1  0C44	F8		                mov     r0,a
 3754: 1  0C45	E9		                mov     a,r1            ;msb van deeltal nemen
 3755: 1  0C46	33		                rlc     a
 3756: 1  0C47	F9		                mov     r1,a
 3757: 1  0C48	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3758: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3759: 1  0C4B	7C 00		                mov     r4,#0
 3760: 1  0C4D	7D 00		                mov     r5,#0
 3761: 1  0C4F	80 2E		                sjmp    div164          ;klaar!
 3762: 1
 3763: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3764: 1
 3765: 1  0C51	C3		div162:            clr     C            ;start met carry op nul
 3766: 1  0C52	E8		                mov     a,r0            ;schuif deeltal naar links
 3767: 1  0C53	33		                rlc     a
 3768: 1  0C54	F8		                mov     r0,a
 3769: 1  0C55	E9		                mov     a,r1
 3770: 1  0C56	33		                rlc     a
 3771: 1  0C57	F9		                mov     r1,a
 3772: 1  0C58	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3773: 1  0C59	33		                rlc     a               ;gedeeltelijke rest
 3774: 1  0C5A	FE		                mov     r6,a
 3775: 1  0C5B	EF		                mov     a,r7
 3776: 1  0C5C	33		                rlc     a
 3777: 1  0C5D	FF		                mov     r7,a
 3778: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3779: 1  0C5E	EE		                mov     a,r6
 3780: 1  0C5F	C3		                clr     C
 3781: 1  0C60	9C		                subb    a,r4
 3782: 1  0C61	F5 82		                mov     dpl,a
 3783: 1  0C63	EF		                mov     a,r7
 3784: 1  0C64	9D		                subb    a,r5
 3785: 1  0C65	F5 83		                mov     dph,a
 3786: 1  0C67	40 04		                jc      div163
 3787: 1  0C69	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3788: 1  0C6B	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3789: 1
 3790: 1  0C6D	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3791: 1  0C6E	EA		                mov     a,r2            ;binnenschuiven
 3792: 1  0C6F	33		                rlc     a
 3793: 1  0C70	FA		                mov     r2,a
 3794: 1  0C71	EB		                mov     a,r3
 3795: 1  0C72	33		                rlc     a
 3796: 1  0C73	FB		                mov     r3,a            ;tijdelijk quotient is aangepast

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3797: 1  0C74	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3798: 1
 3799: 1  0C77	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3800: 1  0C78	F9		                mov     r1,a
 3801: 1  0C79	EA		                mov     a,r2
 3802: 1  0C7A	F8		                mov     r0,a
 3803: 1  0C7B	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3804: 1  0C7C	FD		                mov     r5,a
 3805: 1  0C7D	EE		                mov     a,r6
 3806: 1  0C7E	FC		                mov     r4,a
 3807: 1
 3808: 1  0C7F	D0 82		div164:         pop     dpl             ;registers herstellen
 3809: 1  0C81	D0 83		                pop     dph
 3810: 1  0C83	D0 E0		                pop     acc
 3811: 1  0C85	FA		                mov     r2,a            ;r2 van stack halen
 3812: 1  0C86	D0 E0		                pop     acc
 3813: 1  0C88	FB		                mov     r3,a            ;r3 van stack halen
 3814: 1  0C89	D0 E0		                pop     acc
 3815: 1  0C8B	FE		                mov     r6,a            ;r6 van stack halen
 3816: 1  0C8C	D0 E0		                pop     acc
 3817: 1  0C8E	FF		                mov     r7,a            ;r7 van stack halen
 3818: 1  0C8F	D0 F0		                pop     b
 3819: 1  0C91	D0 D0		                pop     psw
 3820: 1  0C93	C3		                clr     c               ;deling ok
 3821: 1  0C94	D0 E0		                pop     acc
 3822: 1  0C96	22		                ret
 3823: 1
 3824: 1
 3825: 1			;*******************************************************************************
 3826: 1			; s_div32        (2,15ms @16.777216MHz)
 3827: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3828: 1			; 2's Complement Format
 3829: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3830: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3831: 1			;
 3832: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 3833: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3834: 1			;
 3835: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3836: 1			;           r7,r6,r5, r4 = rest
 3837: 1			;           cy=1 bij acc1=0 (deling door nul)
 3838: 1			;            cy=0 in andere gevallen
 3839: 1			;
 3840: 1			; vernietigt: niets
 3841: 1			;*******************************************************************************
 3842: 1  0C97	C0 E0		s_div32:        push    acc
 3843: 1  0C99	C0 D0		                push    psw
 3844: 1  0C9B	EF		                mov     a,r7            ;neem msb van deler
 3845: 1  0C9C	4E		                orl     a,r6            ;combineer met lsb's van deler
 3846: 1  0C9D	4D		                orl     a,r5
 3847: 1  0C9E	4C		                orl     a,r4
 3848: 1  0C9F	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3849: 1  0CA1	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3850: 1  0CA3	D0 E0		                pop     acc
 3851: 1  0CA5	D3		                setb    C                ;fout, deling door nul!
 3852: 1  0CA6	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3853: 1
 3854: 1  0CA7	12 08 C3	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3855: 1  0CAA	12 08 ED	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3856: 1  0CAD	12 0C BC	                lcall   div32            ;deel 32bit/32bit
 3857: 1  0CB0	12 07 DD	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3858: 1  0CB3	12 08 07	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3859: 1  0CB6	D0 D0		                pop     psw
 3860: 1  0CB8	C3		                clr     C                ;delig ok
 3861: 1  0CB9	D0 E0		                pop     acc
 3862: 1  0CBB	22		                ret                        ;klaar
 3863: 1
 3864: 1
 3865: 1			;*******************************************************************************
 3866: 1			; div32        (2,09ms @16.777216MHz)
 3867: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3868: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3869: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3870: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3871: 1			;
 3872: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 3873: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3874: 1			;            cy=1 bij deling door nul (acc1=0)
 3875: 1			;            cy=0 bij normale deling
 3876: 1			;
 3877: 1			; vernietigt: niets
 3878: 1			;*******************************************************************************
 3879: 1  0CBC	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3880: 1  0CBE	C0 D0		                push    psw
 3881: 1			;check voor deling door nul
 3882: 1  0CC0	EF		                mov     a,r7            ;neem msb van deler
 3883: 1  0CC1	4E		                orl     a,r6            ;combineer met lsb's van deler
 3884: 1  0CC2	4D		                orl     a,r5
 3885: 1  0CC3	4C		                orl     a,r4
 3886: 1  0CC4	70 06		                jnz     div320          ;niet nul, dan verder werken
 3887: 1  0CC6	D0 D0		                pop     psw             ;als nul, dikke snul
 3888: 1  0CC8	D3		                setb    c               ;terug met errorstatus
 3889: 1  0CC9	D0 E0		                pop     acc
 3890: 1  0CCB	22		                ret
 3891: 1
 3892: 1  0CCC	C0 F0		div320:         push    b                ;registers verder bewaren
 3893: 1  0CCE	C0 83		                push    dph
 3894: 1  0CD0	C0 82		                push    dpl
 3895: 1
 3896: 1  0CD2	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3897: 1
 3898: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3899: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3900: 1			;het aantal significante bits af in de lusteller b
 3901: 1
 3902: 1  0CD5	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3903: 1  0CD6	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3904: 1  0CD9	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3905: 1  0CDA	E8		                mov     a,r0            ;lsb van deeltal nemen
 3906: 1  0CDB	33		                rlc     a               ;en opschuiven
 3907: 1  0CDC	F8		                mov     r0,a
 3908: 1  0CDD	E9		                mov     a,r1           ;volgende byte van deeltal nemen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3909: 1  0CDE	33		                rlc     a
 3910: 1  0CDF	F9		                mov     r1,a
 3911: 1  0CE0	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3912: 1  0CE1	33		                rlc     a
 3913: 1  0CE2	FA		                mov     r2,a
 3914: 1  0CE3	EB		                mov     a,r3           ;lsb van deeltal nemen
 3915: 1  0CE4	33		                rlc     a
 3916: 1  0CE5	FB		                mov     r3,a
 3917: 1  0CE6	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3918: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3919: 1  0CE9	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3920: 1  0CEB	7E 00		                mov     r6,#0
 3921: 1  0CED	7D 00		                mov     r5,#0
 3922: 1  0CEF	7C 00		                mov     r4,#0
 3923: 1  0CF1	02 0D BA	                ljmp    div324           ;klaar!
 3924: 1
 3925: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 3926: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 3927: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 3928: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 3929: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 3930: 1
 3931: 1  0CF4			div320b:
 3932: 1  0CF4	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 3933: 1
 3934: 1  0CF7	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 3935: 1  0CF9	24 0C		                add     a,#12           ;met 12 plaatsen
 3936: 1  0CFB	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 3937: 1
 3938: 1  0CFD	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 3939: 1  0CFE	C0 E0		                push    acc
 3940: 1  0D00	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 3941: 1  0D01	C0 E0		                push    acc
 3942: 1
 3943: 1  0D03	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 3944: 1  0D05	08		                inc     r0              ;de deler
 3945: 1  0D06	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 3946: 1  0D08	24 05		                add     a,#5            ;het tijdelijk verschil X
 3947: 1  0D0A	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 3948: 1  0D0B	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 3949: 1  0D0D	24 09		                add     a,#9            ;quotient
 3950: 1  0D0F	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 3951: 1
 3952: 1			;Eenmalig de variabelen op stack initaliseren
 3953: 1			;Tijdelijk quotient op nul zetten
 3954: 1
 3955: 1  0D11	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 3956: 1  0D13	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 3957: 1  0D14	C0 F0		                push    b                ;loopteller deling bewaren
 3958: 1  0D16	75 F0 04	                mov     b,#4
 3959: 1  0D19	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 3960: 1  0D1B	09		                inc     r1
 3961: 1  0D1C	D5 F0 FA	                djnz    b,div320c
 3962: 1  0D1F	D0 F0		                pop     b                ;loopteller deling ophalen
 3963: 1  0D21	19		                dec     r1
 3964: 1  0D22	19		                dec     r1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3965: 1  0D23	19		                dec     r1
 3966: 1  0D24	19		                dec     r1               ;pointer weer op startadres quotient
 3967: 1  0D25	C9		                xch     a,r1             ;weer omwisselen
 3968: 1  0D26	C5 82		                xch     a,dpl
 3969: 1
 3970: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 3971: 1  0D28	EC		                mov     a,r4
 3972: 1  0D29	F6		                mov     @r0,a
 3973: 1  0D2A	08		                inc     r0
 3974: 1  0D2B	ED		                mov     a,r5
 3975: 1  0D2C	F6		                mov     @r0,a
 3976: 1  0D2D	08		                inc     r0
 3977: 1  0D2E	EE		                mov     a,r6
 3978: 1  0D2F	F6		                mov     @r0,a
 3979: 1  0D30	08		                inc     r0
 3980: 1  0D31	EF		                mov     a,r7
 3981: 1  0D32	F6		                mov     @r0,a
 3982: 1  0D33	18		                dec     r0             ;pointer herstellen naar lsb van deler
 3983: 1  0D34	18		                dec     r0
 3984: 1  0D35	18		                dec     r0
 3985: 1
 3986: 1  0D36	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 3987: 1  0D38	7E 00		                mov     r6,#0
 3988: 1  0D3A	7D 00		                mov     r5,#0
 3989: 1  0D3C	7C 00		                mov     r4,#0
 3990: 1
 3991: 1
 3992: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 3993: 1  0D3E	C3		div322:         clr     C               ;start met carry op nul
 3994: 1
 3995: 1  0D3F	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 3996: 1  0D41	33		                rlc     a
 3997: 1  0D42	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 3998: 1  0D44	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 3999: 1  0D46	D0 E0		                pop     acc             ;r1 van deeltal van stack
 4000: 1  0D48	33		                rlc     a
 4001: 1  0D49	C0 E0		                push    acc             ;en weer bewaren
 4002: 1  0D4B	05 81		                inc     sp              ;stackpointer weer corrigeren
 4003: 1
 4004: 1  0D4D	EA		                mov     a,r2
 4005: 1  0D4E	33		                rlc     a
 4006: 1  0D4F	FA		                mov     r2,a
 4007: 1  0D50	EB		                mov     a,r3
 4008: 1  0D51	33		                rlc     a
 4009: 1  0D52	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 4010: 1
 4011: 1  0D53	EC		                mov     a,r4            ;schuif carry van deeltal in de
 4012: 1  0D54	33		                rlc     a               ;gedeeltelijke rest r7..r4
 4013: 1  0D55	FC		                mov     r4,a
 4014: 1  0D56	ED		                mov     a,r5
 4015: 1  0D57	33		                rlc     a
 4016: 1  0D58	FD		                mov     r5,a
 4017: 1  0D59	EE		                mov     a,r6
 4018: 1  0D5A	33		                rlc     a
 4019: 1  0D5B	FE		                mov     r6,a
 4020: 1  0D5C	EF		                mov     a,r7

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4021: 1  0D5D	33		                rlc     a
 4022: 1  0D5E	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 4023: 1
 4024: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 4025: 1
 4026: 1  0D5F	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 4027: 1  0D60	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 4028: 1  0D61	96		                subb    a,@r0           ;trek er de lsb deler af
 4029: 1  0D62	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4030: 1  0D63	08		                inc     r0              ;pointers aanpassen
 4031: 1  0D64	09		                inc     r1
 4032: 1  0D65	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4033: 1  0D66	96		                subb    a,@r0           ;trek er volgende byte deler af
 4034: 1  0D67	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4035: 1  0D68	08		                inc     r0              ;pointers aanpassen
 4036: 1  0D69	09		                inc     r1
 4037: 1  0D6A	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4038: 1  0D6B	96		                subb    a,@r0           ;trek er volgende byte deler af
 4039: 1  0D6C	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4040: 1  0D6D	08		                inc     r0              ;pointers aanpassen
 4041: 1  0D6E	09		                inc     r1
 4042: 1  0D6F	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4043: 1  0D70	96		                subb    a,@r0           ;trek er msb deler af
 4044: 1  0D71	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4045: 1  0D72	18		                dec     r0              ;pointers herstellen naar lsb's
 4046: 1  0D73	18		                dec     r0
 4047: 1  0D74	18		                dec     r0
 4048: 1  0D75	19		                dec     r1
 4049: 1  0D76	19		                dec     r1
 4050: 1  0D77	19		                dec     r1
 4051: 1
 4052: 1  0D78	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4053: 1  0D7A	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4054: 1  0D7B	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4055: 1  0D7C	09		                inc     r1
 4056: 1  0D7D	E7		                mov     a,@r1
 4057: 1  0D7E	FD		                mov     r5,a
 4058: 1  0D7F	09		                inc     r1
 4059: 1  0D80	E7		                mov     a,@r1
 4060: 1  0D81	FE		                mov     r6,a
 4061: 1  0D82	09		                inc     r1
 4062: 1  0D83	E7		                mov     a,@r1
 4063: 1  0D84	FF		                mov     r7,a
 4064: 1  0D85	19		                dec     r1              ;met pointer weer naar lsb van
 4065: 1  0D86	19		                dec     r1              ;het tijdelijk verschil wijzen
 4066: 1  0D87	19		                dec     r1
 4067: 1
 4068: 1
 4069: 1  0D88	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4070: 1  0D89	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4071: 1  0D8B	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4072: 1  0D8C	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4073: 1  0D8E	E7		                mov     a,@r1           ;neem lsb van qoutient
 4074: 1  0D8F	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4075: 1  0D90	F7		                mov     @r1,a
 4076: 1  0D91	09		                inc     r1              ;volgende byte

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4077: 1  0D92	E7		                mov     a,@r1
 4078: 1  0D93	33		                rlc     a
 4079: 1  0D94	F7		                mov     @r1,a
 4080: 1  0D95	09		                inc     r1              ;volgende byte
 4081: 1  0D96	E7		                mov     a,@r1
 4082: 1  0D97	33		                rlc     a
 4083: 1  0D98	F7		                mov     @r1,a
 4084: 1  0D99	09		                inc     r1              ;volgende byte
 4085: 1  0D9A	E7		                mov     a,@r1
 4086: 1  0D9B	33		                rlc     a
 4087: 1  0D9C	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4088: 1  0D9D	19		                dec     r1
 4089: 1  0D9E	19		                dec     r1
 4090: 1  0D9F	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4091: 1  0DA0	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4092: 1  0DA2	C9		                xch     a,r1            ;r1=pointer naar verschil
 4093: 1  0DA3	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4094: 1
 4095: 1  0DA5	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4096: 1
 4097: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4098: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4099: 1
 4100: 1  0DA8	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4101: 1  0DAA	18		                dec     r0
 4102: 1  0DAB	18		                dec     r0
 4103: 1  0DAC	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4104: 1  0DAD	FB		                mov     r3,a            ;en verplaatsen
 4105: 1  0DAE	18		                dec     r0              ;volgende byte
 4106: 1  0DAF	E6		                mov     a,@r0
 4107: 1  0DB0	FA		                mov     r2,a
 4108: 1  0DB1	18		                dec     r0              ;volgende byte
 4109: 1  0DB2	E6		                mov     a,@r0
 4110: 1  0DB3	F9		                mov     r1,a
 4111: 1  0DB4	18		                dec     r0              ;volgende byte
 4112: 1  0DB5	E6		                mov     a,@r0
 4113: 1  0DB6	F8		                mov     r0,a            ;laatste byte verplaatst!
 4114: 1
 4115: 1  0DB7	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4116: 1			                                         ;weer vrijgeven
 4117: 1
 4118: 1
 4119: 1  0DBA	D0 82		div324:         pop     dpl             ;registers herstellen
 4120: 1  0DBC	D0 83		                pop     dph
 4121: 1  0DBE	D0 F0		                pop     b
 4122: 1  0DC0	D0 D0		                pop     psw
 4123: 1  0DC2	C3		                clr     c               ;normale deling
 4124: 1  0DC3	D0 E0		                pop     acc
 4125: 1  0DC5	22		                ret
 4126: 1
 4127: 1			;*******************************************************************************
 4128: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4129: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4130: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4131: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4132: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4133: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4134: 1			;
 4135: 1			; input:     r5,r4 = acc1 (low word product)
 4136: 1			;            r7,r6 = acc1 (high word product)
 4137: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4138: 1			;
 4139: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4140: 1			;            r7,r6,r5,r4 = acc1 = rest
 4141: 1			;                          -2147483648 tot +2147483647
 4142: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4143: 1			;             cy=1 bij deling door nul (acc0=0)
 4144: 1			;             cy=0 bij normale deling
 4145: 1			;
 4146: 1			; vernietigt:  niets
 4147: 1			;*******************************************************************************
 4148: 1  0DC6	C0 E0		s_muldiv:       push    acc
 4149: 1  0DC8	C0 D0		                push    psw
 4150: 1  0DCA	E8		                mov     a,r0            ;neem msb van deler
 4151: 1  0DCB	49		                orl     a,r1            ;combineer met lsb's van deler
 4152: 1  0DCC	4A		                orl     a,r2
 4153: 1  0DCD	4B		                orl     a,r3
 4154: 1  0DCE	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4155: 1  0DD0	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4156: 1  0DD2	D0 E0		                pop     acc
 4157: 1  0DD4	D3		                setb    C               ;fout, deling door nul!
 4158: 1  0DD5	22		                ret
 4159: 1
 4160: 1  0DD6	12 08 83	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4161: 1  0DD9	12 08 A3	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4162: 1  0DDC	12 0D EB	                lcall    muldiv          ;maak product en daarna de deling
 4163: 1  0DDF	12 07 DD	                lcall    magsig32        ;quotient naar 2's complement
 4164: 1  0DE2	12 08 07	                lcall    magsig32acc1    ;rest naar 2's complement
 4165: 1  0DE5	D0 D0		                pop     psw
 4166: 1  0DE7	C3		                clr     c                ;deling is ok
 4167: 1  0DE8	D0 E0		                pop    acc
 4168: 1  0DEA	22		                ret
 4169: 1
 4170: 1			;*******************************************************************************
 4171: 1			; muldiv        (2,0ms @16.777216MHz)
 4172: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4173: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4174: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4175: 1			; 32bit rest in acc1.
 4176: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4177: 1			;
 4178: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4179: 1			;
 4180: 1			; input:     r5,r4 = acc1 (low word product)
 4181: 1			;            r7,r6 = acc1 (high word product)
 4182: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4183: 1			;
 4184: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4185: 1			;            r7,r6,r5,r4 = acc1 = rest
 4186: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4187: 1			;             cy=1 bij deling door nul (acc0=0)
 4188: 1			;             cy=0 bij normale deling

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4189: 1			;
 4190: 1			; vernietigt:  niets
 4191: 1			;*******************************************************************************
 4192: 1  0DEB	C0 E0		muldiv:         push    acc
 4193: 1  0DED	C0 D0		                push    psw
 4194: 1  0DEF	E8		                mov     a,r0            ;neem msb van deler
 4195: 1  0DF0	49		                orl     a,r1            ;combineer met lsb's van deler
 4196: 1  0DF1	4A		                orl     a,r2
 4197: 1  0DF2	4B		                orl     a,r3
 4198: 1  0DF3	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4199: 1  0DF5	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4200: 1  0DF7	D0 E0		                pop     acc
 4201: 1  0DF9	D3		                setb    C               ;fout, deling door nul!
 4202: 1  0DFA	22		                ret
 4203: 1
 4204: 1  0DFB	12 0A EC	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4205: 1  0DFE	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4206: 1  0DFF	C0 E0		                push    acc
 4207: 1  0E01	ED		                mov     a,r5
 4208: 1  0E02	C0 E0		                push    acc
 4209: 1  0E04	EE		                mov     a,r6
 4210: 1  0E05	C0 E0		                push    acc
 4211: 1  0E07	EF		                mov     a,r7
 4212: 1  0E08	C0 E0		                push    acc             ;product staat nu op stack
 4213: 1
 4214: 1  0E0A	E8		                mov     a,r0            ;deler in acc1 stoppen
 4215: 1  0E0B	FC		                mov     r4,a
 4216: 1  0E0C	E9		                mov     a,r1
 4217: 1  0E0D	FD		                mov     r5,a
 4218: 1  0E0E	EA		                mov     a,r2
 4219: 1  0E0F	FE		                mov     r6,a
 4220: 1  0E10	EB		                mov     a,r3
 4221: 1  0E11	FF		                mov     r7,a            ;deler zit volledig in acc1
 4222: 1
 4223: 1  0E12	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4224: 1  0E14	FB		                mov     r3,a
 4225: 1  0E15	D0 E0		                pop     acc
 4226: 1  0E17	FA		                mov     r2,a
 4227: 1  0E18	D0 E0		                pop     acc
 4228: 1  0E1A	F9		                mov     r1,a
 4229: 1  0E1B	D0 E0		                pop     acc
 4230: 1  0E1D	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4231: 1  0E1E	12 0C BC	                lcall   div32           ;maak deling
 4232: 1
 4233: 1  0E21	D0 D0		                pop     psw            ;herstel registers
 4234: 1  0E23	D0 E0		                pop     acc
 4235: 1  0E25	C3		                clr     C              ;resultaat ok!
 4236: 1  0E26	22		                ret
 4237: 1
 4238: 1			;*******************************************************************************
 4239: 1			; mul16_pi        (257,1us @16.777216MHz)
 4240: 1			; acc0 = acc0 x pi
 4241: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4242: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4243: 1			;
 4244: 1			; input:     r1,r0 = acc0 (low word)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4245: 1			;
 4246: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4247: 1			;
 4248: 1			; vernietigt:  niets
 4249: 1			;*******************************************************************************
 4250: 1  0E27	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4251: 1  0E29	C0 D0		                push    psw
 4252: 1  0E2B	EC		                mov     a,r4
 4253: 1  0E2C	C0 E0		                push    acc
 4254: 1  0E2E	ED		                mov     a,r5
 4255: 1  0E2F	C0 E0		                push    acc
 4256: 1  0E31	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4257: 1  0E33	7C 0F		                mov     r4,#0fH
 4258: 1  0E35	12 0A 87	                lcall   mul16           ;acc0 = acc0 x acc1
 4259: 1  0E38	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4260: 1  0E3A	12 10 23	                lcall   shiftright32    ;om te delen door 2^14
 4261: 1  0E3D	D0 E0		                pop     acc
 4262: 1  0E3F	FD		                mov     r5,a
 4263: 1  0E40	D0 E0		                pop     acc
 4264: 1  0E42	FC		                mov     r4,a
 4265: 1  0E43	D0 D0		                pop     psw
 4266: 1  0E45	D0 E0		                pop     acc
 4267: 1  0E47	22		                ret
 4268: 1
 4269: 1			;*******************************************************************************
 4270: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4271: 1			; acc0 = acc0 x 1/pi
 4272: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4273: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4274: 1			;
 4275: 1			; input:     r1,r0 = acc0 (low word)
 4276: 1			;
 4277: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4278: 1			;
 4279: 1			; vernietigt:  niets
 4280: 1			;*******************************************************************************
 4281: 1  0E48	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4282: 1  0E4A	C0 D0		                push    psw
 4283: 1  0E4C	EC		                mov     a,r4
 4284: 1  0E4D	C0 E0		                push    acc
 4285: 1  0E4F	ED		                mov     a,r5
 4286: 1  0E50	C0 E0		                push    acc
 4287: 1  0E52	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4288: 1  0E54	7C 7D		                mov     r4,#07dH
 4289: 1  0E56	12 0A 87	                lcall    mul16          ;acc0 = acc0 x acc1
 4290: 1  0E59	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4291: 1  0E5B	12 10 23	                lcall   shiftright32    ;om te delen door 2^16
 4292: 1  0E5E	D0 E0		                pop     acc
 4293: 1  0E60	FD		                mov     r5,a
 4294: 1  0E61	D0 E0		                pop     acc
 4295: 1  0E63	FC		                mov     r4,a
 4296: 1  0E64	D0 D0		                pop     psw
 4297: 1  0E66	D0 E0		                pop     acc
 4298: 1  0E68	22		                ret
 4299: 1
 4300: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4301: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4302: 1			; acc0 = acc0 x sqrt2
 4303: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4304: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4305: 1			;
 4306: 1			; input:     r1,r0 = acc0 (low word)
 4307: 1			;
 4308: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4309: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4310: 1			;
 4311: 1			; vernietigt:  niets
 4312: 1			;*******************************************************************************
 4313: 1  0E69	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4314: 1  0E6B	C0 D0		                push    psw
 4315: 1  0E6D	EC		                mov     a,r4
 4316: 1  0E6E	C0 E0		                push    acc
 4317: 1  0E70	ED		                mov     a,r5
 4318: 1  0E71	C0 E0		                push    acc
 4319: 1  0E73	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4320: 1  0E75	7C 05		                mov     r4,#005H
 4321: 1  0E77	12 0A 87	                lcall   mul16           ;acc0 = acc0 x acc1
 4322: 1  0E7A	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4323: 1  0E7C	12 10 23	                lcall   shiftright32    ;om te delen door 2^15
 4324: 1  0E7F	D0 E0		                pop     acc
 4325: 1  0E81	FD		                mov     r5,a
 4326: 1  0E82	D0 E0		                pop     acc
 4327: 1  0E84	FC		                mov     r4,a
 4328: 1  0E85	D0 D0		                pop     psw
 4329: 1  0E87	D0 E0		                pop     acc
 4330: 1  0E89	22		                ret
 4331: 1
 4332: 1
 4333: 1
 4334: 1			;*******************************************************************************
 4335: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4336: 1			; acc0 = acc0 x 1/sqrt2
 4337: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4338: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4339: 1			;
 4340: 1			; input:     r1,r0 = acc0 (low word)
 4341: 1			;
 4342: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4343: 1			;
 4344: 1			; vernietigt:  niets
 4345: 1			;*******************************************************************************
 4346: 1  0E8A	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4347: 1  0E8C	C0 D0		                push    psw
 4348: 1  0E8E	EC		                mov     a,r4
 4349: 1  0E8F	C0 E0		                push    acc
 4350: 1  0E91	ED		                mov     a,r5
 4351: 1  0E92	C0 E0		                push    acc
 4352: 1  0E94	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4353: 1  0E96	7C 05		                mov     r4,#005H
 4354: 1  0E98	12 0A 87	                lcall   mul16           ;acc0 = acc0 x acc1
 4355: 1  0E9B	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4356: 1  0E9D	12 10 23	                lcall   shiftright32    ;om te delen door 2^16

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4357: 1  0EA0	D0 E0		                pop     acc
 4358: 1  0EA2	FD		                mov     r5,a
 4359: 1  0EA3	D0 E0		                pop     acc
 4360: 1  0EA5	FC		                mov     r4,a
 4361: 1  0EA6	D0 D0		                pop     psw
 4362: 1  0EA8	D0 E0		                pop     acc
 4363: 1  0EAA	22		                ret
 4364: 1
 4365: 1			;*******************************************************************************
 4366: 1			; mul16_10        (98,7us @16.777216MHz)
 4367: 1			; acc0 = acc0 x 10
 4368: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4369: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4370: 1			;
 4371: 1			; input:     r1,r0 = acc0 (low word)
 4372: 1			;
 4373: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4374: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4375: 1			; vernietigt:  niets
 4376: 1			;*******************************************************************************
 4377: 1  0EAB	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4378: 1  0EAD	C0 D0		                push    psw
 4379: 1  0EAF	EC		                mov     a,r4
 4380: 1  0EB0	C0 E0		                push    acc
 4381: 1  0EB2	7C 01		                mov     r4,#1           ;acc0 x2
 4382: 1  0EB4	12 10 4F	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4383: 1  0EB7	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4384: 1  0EB8	C0 E0		                push    acc
 4385: 1  0EBA	EA		                mov     a,r2
 4386: 1  0EBB	C0 E0		                push    acc
 4387: 1  0EBD	E9		                mov     a,r1
 4388: 1  0EBE	C0 E0		                push    acc
 4389: 1  0EC0	E8		                mov     a,r0
 4390: 1  0EC1	C0 E0		                push    acc             ;acc0 op stack
 4391: 1  0EC3	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4392: 1  0EC5	12 10 4F	                lcall   shiftleft32     ;acc0 =acc0 x4
 4393: 1  0EC8	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4394: 1  0ECA	28		                add     a,r0            ;tel bij huidige acc0
 4395: 1  0ECB	F8		                mov     r0,a
 4396: 1  0ECC	D0 E0		                pop     acc
 4397: 1  0ECE	39		                addc    a,r1
 4398: 1  0ECF	F9		                mov     r1,a
 4399: 1  0ED0	D0 E0		                pop     acc
 4400: 1  0ED2	3A		                addc    a,r2
 4401: 1  0ED3	FA		                mov     r2,a
 4402: 1  0ED4	D0 E0		                pop     acc
 4403: 1  0ED6	3B		                addc    a,r3
 4404: 1  0ED7	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4405: 1
 4406: 1
 4407: 1  0ED8	D0 E0		                pop     acc
 4408: 1  0EDA	FC		                mov     r4,a
 4409: 1  0EDB	D0 D0		                pop     psw
 4410: 1  0EDD	D0 E0		                pop     acc
 4411: 1  0EDF	22		                ret
 4412: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4413: 1			;*******************************************************************************
 4414: 1			; mul16_100        (169,1us @16.777216MHz)
 4415: 1			; acc0 = acc0 x 100
 4416: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4417: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4418: 1			;
 4419: 1			; input:     r1,r0 = acc0 (low word)
 4420: 1			;
 4421: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4422: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4423: 1			; vernietigt:  niets
 4424: 1			;*******************************************************************************
 4425: 1  0EE0	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4426: 1  0EE2	C0 D0		                push    psw
 4427: 1  0EE4	EC		                mov     a,r4
 4428: 1  0EE5	C0 E0		                push    acc
 4429: 1  0EE7	7C 02		                mov     r4,#2           ;acc0 x4
 4430: 1  0EE9	12 10 4F	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4431: 1  0EEC	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4432: 1  0EED	C0 E0		                push    acc
 4433: 1  0EEF	EA		                mov     a,r2
 4434: 1  0EF0	C0 E0		                push    acc
 4435: 1  0EF2	E9		                mov     a,r1
 4436: 1  0EF3	C0 E0		                push    acc
 4437: 1  0EF5	E8		                mov     a,r0
 4438: 1  0EF6	C0 E0		                push    acc             ;acc0 op stack
 4439: 1
 4440: 1  0EF8	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4441: 1  0EFA	12 10 4F	                lcall   shiftleft32     ;acc0 =acc0 x8
 4442: 1  0EFD	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4443: 1  0EFE	C0 E0		                push    acc
 4444: 1  0F00	EA		                mov     a,r2
 4445: 1  0F01	C0 E0		                push    acc
 4446: 1  0F03	E9		                mov     a,r1
 4447: 1  0F04	C0 E0		                push    acc
 4448: 1  0F06	E8		                mov     a,r0
 4449: 1  0F07	C0 E0		                push    acc             ;acc0 op stack
 4450: 1
 4451: 1  0F09	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4452: 1  0F0B	12 10 4F	                lcall   shiftleft32     ;acc0 =acc0 x2
 4453: 1  0F0E	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4454: 1  0F10	28		                add     a,r0            ;tel bij huidige acc0
 4455: 1  0F11	F8		                mov     r0,a
 4456: 1  0F12	D0 E0		                pop     acc
 4457: 1  0F14	39		                addc    a,r1
 4458: 1  0F15	F9		                mov     r1,a
 4459: 1  0F16	D0 E0		                pop     acc
 4460: 1  0F18	3A		                addc    a,r2
 4461: 1  0F19	FA		                mov     r2,a
 4462: 1  0F1A	D0 E0		                pop     acc
 4463: 1  0F1C	3B		                addc    a,r3
 4464: 1  0F1D	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4465: 1
 4466: 1  0F1E	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4467: 1  0F20	28		                add     a,r0            ;tel bij huidige acc0
 4468: 1  0F21	F8		                mov     r0,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4469: 1  0F22	D0 E0		                pop     acc
 4470: 1  0F24	39		                addc    a,r1
 4471: 1  0F25	F9		                mov     r1,a
 4472: 1  0F26	D0 E0		                pop     acc
 4473: 1  0F28	3A		                addc    a,r2
 4474: 1  0F29	FA		                mov     r2,a
 4475: 1  0F2A	D0 E0		                pop     acc
 4476: 1  0F2C	3B		                addc    a,r3
 4477: 1  0F2D	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4478: 1
 4479: 1  0F2E	D0 E0		                pop     acc
 4480: 1  0F30	FC		                mov     r4,a
 4481: 1  0F31	D0 D0		                pop     psw
 4482: 1  0F33	D0 E0		                pop     acc
 4483: 1  0F35	22		                ret
 4484: 1
 4485: 1			;*******************************************************************************
 4486: 1			; sqrt32        (2,99ms @16.777216MHz)
 4487: 1			; acc0 = acc0 ^(1/2)
 4488: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4489: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4490: 1			;
 4491: 1			; input:     r3,r2,r1,r0 = acc0
 4492: 1			;
 4493: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4494: 1			;
 4495: 1			; vernietigt:  niets
 4496: 1			;*******************************************************************************
 4497: 1  0F36	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4498: 1  0F38	C0 F0		                push    b
 4499: 1  0F3A	C0 D0		                push    psw
 4500: 1  0F3C	C0 82		                push    dpl
 4501: 1  0F3E	C0 83		                push    dph
 4502: 1  0F40	EC		                mov     a,r4
 4503: 1  0F41	C0 E0		                push    acc
 4504: 1  0F43	ED		                mov     a,r5
 4505: 1  0F44	C0 E0		                push    acc
 4506: 1  0F46	EE		                mov     a,r6
 4507: 1  0F47	C0 E0		                push    acc
 4508: 1  0F49	EF		                mov     a,r7
 4509: 1  0F4A	C0 E0		                push    acc
 4510: 1
 4511: 1  0F4C	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4512: 1  0F4E	7D 00		                mov     r5,#0
 4513: 1  0F50	7E 00		                mov     r6,#0
 4514: 1  0F52	7F 00		                mov     r7,#0
 4515: 1  0F54	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4516: 1  0F57	75 83 00	                mov     dph,#0
 4517: 1  0F5A	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4518: 1			;hier start het algorithme voor het berekenen van de wortel
 4519: 1  0F5D	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4520: 1  0F5F	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4521: 1  0F62	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4522: 1  0F63	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4523: 1  0F64	33		                rlc     a                ;getest worden om een wortelbit te
 4524: 1  0F65	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4525: 1  0F66	E9		                mov     a,r1            ;met nullen!
 4526: 1  0F67	33		                rlc     a
 4527: 1  0F68	F9		                mov     r1,a
 4528: 1  0F69	EA		                mov     a,r2
 4529: 1  0F6A	33		                rlc     a
 4530: 1  0F6B	FA		                mov     r2,a
 4531: 1  0F6C	EB		                mov     a,r3
 4532: 1  0F6D	33		                rlc     a
 4533: 1  0F6E	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4534: 1
 4535: 1  0F6F	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4536: 1  0F70	33		                rlc     a
 4537: 1  0F71	FC		                mov     r4,a
 4538: 1  0F72	ED		                mov     a,r5
 4539: 1  0F73	33		                rlc     a
 4540: 1  0F74	FD		                mov     r5,a
 4541: 1  0F75	EE		                mov     a,r6
 4542: 1  0F76	33		                rlc     a
 4543: 1  0F77	FE		                mov     r6,a
 4544: 1  0F78	EF		                mov     a,r7
 4545: 1  0F79	33		                rlc     a
 4546: 1  0F7A	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4547: 1  0F7B	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4548: 1
 4549: 1  0F7E	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4550: 1
 4551: 1  0F80	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4552: 1  0F81	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4553: 1  0F83	33		                rlc     a
 4554: 1  0F84	F5 82		                mov     dpl,a
 4555: 1  0F86	E5 83		                mov     a,dph
 4556: 1  0F88	33		                rlc     a
 4557: 1  0F89	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4558: 1
 4559: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4560: 1  0F8B	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4561: 1  0F8C	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4562: 1  0F8E	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4563: 1  0F8F	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4564: 1  0F91	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4565: 1  0F92	C0 E0		                push    acc             ;van acc1
 4566: 1  0F94	EB		                mov     a,r3
 4567: 1  0F95	C0 E0		                push    acc
 4568: 1  0F97	EC		                mov     a,r4
 4569: 1  0F98	C0 E0		                push    acc
 4570: 1  0F9A	ED		                mov     a,r5
 4571: 1  0F9B	C0 E0		                push    acc
 4572: 1  0F9D	EE		                mov     a,r6
 4573: 1  0F9E	C0 E0		                push    acc
 4574: 1  0FA0	EF		                mov     a,r7
 4575: 1  0FA1	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4576: 1
 4577: 1  0FA3	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4578: 1  0FA5	AD 83		                mov     r5,dph
 4579: 1  0FA7	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4580: 1  0FA9	AF 83		                mov     r7,dph

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4581: 1  0FAB	12 0A EC	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4582: 1
 4583: 1  0FAE	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4584: 1  0FB0	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4585: 1  0FB1	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4586: 1  0FB3	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4587: 1  0FB4	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4588: 1  0FB6	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4589: 1  0FB7	D0 E0		                pop     acc             ;de stack...
 4590: 1  0FB9	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4591: 1
 4592: 1  0FBA	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4593: 1  0FBB	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4594: 1  0FBC	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4595: 1  0FBD	E9		                mov     a,r1            ;in acc1.
 4596: 1  0FBE	9D		                subb    a,r5            ;We doen dit door de carry van het
 4597: 1  0FBF	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4598: 1  0FC0	9E		                subb    a,r6
 4599: 1  0FC1	EB		                mov     a,r3
 4600: 1  0FC2	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4601: 1  0FC3	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4602: 1			                                        ;wortel behouden
 4603: 1  0FC5	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4604: 1  0FC7	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4605: 1  0FC9	F5 82		                mov     dpl,a          ;wortel aanpassen
 4606: 1
 4607: 1  0FCB	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4608: 1  0FCD	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4609: 1  0FCF	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4610: 1
 4611: 1  0FD1	D0 E0		                pop     acc            ;haal acc1 weer op
 4612: 1  0FD3	FF		                mov     r7,a
 4613: 1  0FD4	D0 E0		                pop     acc
 4614: 1  0FD6	FE		                mov     r6,a
 4615: 1  0FD7	D0 E0		                pop     acc
 4616: 1  0FD9	FD		                mov     r5,a
 4617: 1  0FDA	D0 E0		                pop     acc
 4618: 1  0FDC	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4619: 1
 4620: 1  0FDD	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4621: 1  0FDF	FB		                mov     r3,a
 4622: 1  0FE0	D0 E0		                pop     acc
 4623: 1  0FE2	FA		                mov     r2,a
 4624: 1  0FE3	D0 E0		                pop     acc
 4625: 1  0FE5	F9		                mov     r1,a
 4626: 1  0FE6	D0 E0		                pop     acc
 4627: 1  0FE8	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4628: 1
 4629: 1  0FE9	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4630: 1  0FEC	80 03		                sjmp    sqrt325
 4631: 1  0FEE	02 0F 5D	sqrt324:        ljmp    sqrt320        ;uit acc0
 4632: 1
 4633: 1  0FF1	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4634: 1  0FF3	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4635: 1
 4636: 1  0FF5	D0 E0		                pop     acc            ;herstel de gebruikte registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4637: 1  0FF7	FF		                mov     r7,a
 4638: 1  0FF8	D0 E0		                pop     acc
 4639: 1  0FFA	FE		                mov     r6,a
 4640: 1  0FFB	D0 E0		                pop     acc
 4641: 1  0FFD	FD		                mov     r5,a
 4642: 1  0FFE	D0 E0		                pop     acc
 4643: 1  1000	FC		                mov     r4,a           ;acc1 is hersteld
 4644: 1  1001	D0 83		                pop     dph
 4645: 1  1003	D0 82		                pop     dpl
 4646: 1  1005	D0 D0		                pop     psw
 4647: 1  1007	D0 F0		                pop     b
 4648: 1  1009	D0 E0		                pop     acc
 4649: 1
 4650: 1  100B	22		                ret                    ;eindelijk klaar...
 4651: 1
 4652: 1			;*******************************************************************************
 4653: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4654: 1			; acc0 = acc0 ^(1/2)
 4655: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4656: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4657: 1			;                           (-2147483648 tot +2147483647)
 4658: 1			; input:     r3,r2,r1,r0 = acc0
 4659: 1			;
 4660: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4661: 1			;            CY = 1 als acc0 negatief is
 4662: 1			; vernietigt:  niets
 4663: 1			;*******************************************************************************
 4664: 1  100C	C0 E0		s_sqrt32:       push    acc
 4665: 1  100E	C0 D0		                push    psw
 4666: 1  1010	EB		                mov     a,r3
 4667: 1  1011	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4668: 1  1014	D0 D0		                pop     psw
 4669: 1  1016	D3		                setb    c                ;als negatief dan error
 4670: 1  1017	D0 E0		                pop     acc
 4671: 1  1019	22		                ret
 4672: 1  101A	D0 D0		s_sqrt321:      pop     psw
 4673: 1  101C	D0 E0		                pop     acc
 4674: 1  101E	12 0F 36	                lcall   sqrt32            ;wortel trekken
 4675: 1  1021	C3		                clr     c                 ;wortel ok
 4676: 1  1022	22		                ret                       ;klaar
 4677: 1
 4678: 1			;*******************************************************************************
 4679: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4680: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4681: 1			; (logical shift)
 4682: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4683: 1			;
 4684: 1			; input:     r3,r2,r1,r0 = acc0
 4685: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4686: 1			;
 4687: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4688: 1			;            CY=1 als N>=32
 4689: 1			; vernietigt:  niets
 4690: 1			;*******************************************************************************
 4691: 1  1023	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4692: 1  1025	C0 D0		                push    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4693: 1  1027	EC		                mov     a,r4            ;neem aantal shifts
 4694: 1  1028	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4695: 1  102B	40 06		shiftright1:    jc      shiftright2
 4696: 1  102D	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4697: 1  102F	D3		                setb    c               ;N buiten bereik
 4698: 1  1030	D0 E0		                pop     acc
 4699: 1  1032	22		                ret
 4700: 1
 4701: 1  1033	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4702: 1  1035	8C F0		                mov     b,r4            ;lusteller initialiseren
 4703: 1  1037	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4704: 1  1038	EB		                mov     a,r3            ;start bij msb
 4705: 1  1039	13		                rrc     a
 4706: 1  103A	FB		                mov     r3,a
 4707: 1  103B	EA		                mov     a,r2
 4708: 1  103C	13		                rrc     a
 4709: 1  103D	FA		                mov     r2,a
 4710: 1  103E	E9		                mov     a,r1
 4711: 1  103F	13		                rrc     a
 4712: 1  1040	F9		                mov     r1,a
 4713: 1  1041	E8		                mov     a,r0
 4714: 1  1042	13		                rrc     a
 4715: 1  1043	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4716: 1  1044	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4717: 1  1047	D0 F0		                pop     b               ;registers herstellen
 4718: 1  1049	D0 D0		                pop     psw
 4719: 1  104B	C3		                clr     c               ;N is binnen bereik
 4720: 1  104C	D0 E0		                pop     acc
 4721: 1  104E	22		                ret
 4722: 1
 4723: 1			;*******************************************************************************
 4724: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4725: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4726: 1			; (logical shift)
 4727: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4728: 1			;
 4729: 1			; input:     r3,r2,r1,r0 = acc0
 4730: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4731: 1			;
 4732: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4733: 1			;
 4734: 1			; vernietigt:  niets
 4735: 1			;*******************************************************************************
 4736: 1  104F	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4737: 1  1051	C0 D0		                push    psw
 4738: 1  1053	EC		                mov     a,r4            ;neem aantal shifts
 4739: 1  1054	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4740: 1  1057	40 06		shiftleft1:     jc      shiftleft2
 4741: 1  1059	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4742: 1  105B	D3		                setb    c               ;N buiten bereik
 4743: 1  105C	D0 E0		                pop     acc
 4744: 1  105E	22		                ret
 4745: 1
 4746: 1  105F	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4747: 1  1061	8C F0		                mov     b,r4            ;lusteller initialiseren
 4748: 1  1063	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4749: 1  1064	E8		                mov     a,r0            ;start bij lsb
 4750: 1  1065	33		                rlc     a
 4751: 1  1066	F8		                mov     r0,a
 4752: 1  1067	E9		                mov     a,r1
 4753: 1  1068	33		                rlc     a
 4754: 1  1069	F9		                mov     r1,a
 4755: 1  106A	EA		                mov     a,r2
 4756: 1  106B	33		                rlc     a
 4757: 1  106C	FA		                mov     r2,a
 4758: 1  106D	EB		                mov     a,r3
 4759: 1  106E	33		                rlc     a
 4760: 1  106F	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4761: 1  1070	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4762: 1  1073	D0 F0		                pop     b               ;registers herstellen
 4763: 1  1075	D0 D0		                pop     psw
 4764: 1  1077	C3		                clr     c               ;N is binnen bereik
 4765: 1  1078	D0 E0		                pop     acc
 4766: 1  107A	22		                ret
 4767: 1
 4768: 1			;*******************************************************************************
 4769: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4770: 1			; (arithmetic shift)
 4771: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4772: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4773: 1			; niet van teken!
 4774: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4775: 1			;                       (-2147483648 tot +2147483647)
 4776: 1			;
 4777: 1			; input:     r3,r2,r1,r0 = acc0
 4778: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4779: 1			;
 4780: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4781: 1			;            CY=1 als N>=31
 4782: 1			; vernietigt:  niets
 4783: 1			;*******************************************************************************
 4784: 1  107B	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 4785: 1  107D	C0 D0		                push    psw
 4786: 1  107F	EC		                mov     a,r4            ;neem aantal shifts
 4787: 1  1080	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4788: 1  1083	40 06		s_shiftright1:  jc      s_shiftright2
 4789: 1  1085	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4790: 1  1087	D3		                setb    c               ;N buiten bereik
 4791: 1  1088	D0 E0		                pop     acc
 4792: 1  108A	22		                ret
 4793: 1
 4794: 1  108B	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4795: 1  108D	8C F0		                mov     b,r4            ;lusteller initialiseren
 4796: 1  108F	EB		                mov     a,r3
 4797: 1  1090	20 E7 04	                jb      acc.7,s_shiftright20
 4798: 1  1093	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4799: 1  1095	80 02		                sjmp    s_shiftright3
 4800: 1  1097	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4801: 1
 4802: 1  1099	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4803: 1  109B	EB		                mov     a,r3            ;start bij msb
 4804: 1  109C	13		                rrc     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4805: 1  109D	FB		                mov     r3,a
 4806: 1  109E	EA		                mov     a,r2
 4807: 1  109F	13		                rrc     a
 4808: 1  10A0	FA		                mov     r2,a
 4809: 1  10A1	E9		                mov     a,r1
 4810: 1  10A2	13		                rrc     a
 4811: 1  10A3	F9		                mov     r1,a
 4812: 1  10A4	E8		                mov     a,r0
 4813: 1  10A5	13		                rrc     a
 4814: 1  10A6	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4815: 1  10A7	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4816: 1  10AA	D0 F0		                pop     b               ;registers herstellen
 4817: 1  10AC	D0 D0		                pop     psw
 4818: 1  10AE	C3		                clr     c               ;N is binnen bereik
 4819: 1  10AF	D0 E0		                pop     acc
 4820: 1  10B1	22		                ret
 4821: 1
 4822: 1			;*******************************************************************************
 4823: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4824: 1			; (arithmetic shift)
 4825: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4826: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 4827: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4828: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4829: 1			;                       (-2147483648 tot +2147483647)
 4830: 1			;
 4831: 1			; input:     r3,r2,r1,r0 = acc0
 4832: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4833: 1			;
 4834: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4835: 1			;            CY=1 als N>=31
 4836: 1			; vernietigt:  niets
 4837: 1			;*******************************************************************************
 4838: 1  10B2	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 4839: 1  10B4	C0 D0		                push    psw
 4840: 1  10B6	EC		                mov     a,r4            ;neem aantal shifts
 4841: 1  10B7	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4842: 1  10BA	40 06		s_shiftleft1:   jc      s_shiftleft2
 4843: 1  10BC	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4844: 1  10BE	D3		                setb    c               ;N buiten bereik
 4845: 1  10BF	D0 E0		                pop     acc
 4846: 1  10C1	22		                ret
 4847: 1
 4848: 1  10C2	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4849: 1  10C4	8C F0		                mov     b,r4            ;lusteller initialiseren
 4850: 1
 4851: 1
 4852: 1
 4853: 1  10C6	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4854: 1  10C7	E8		                mov     a,r0             ;start bij lsb
 4855: 1  10C8	33		                rlc     a
 4856: 1  10C9	F8		                mov     r0,a
 4857: 1  10CA	E9		                mov     a,r1
 4858: 1  10CB	33		                rlc     a
 4859: 1  10CC	F9		                mov     r1,a
 4860: 1  10CD	EA		                mov     a,r2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4861: 1  10CE	33		                rlc     a
 4862: 1  10CF	FA		                mov     r2,a
 4863: 1  10D0	EB		                mov     a,r3
 4864: 1  10D1	33		                rlc     a
 4865: 1  10D2	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4866: 1  10D4	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4867: 1  10D5	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4868: 1  10D8	D0 F0		                pop     b                ;registers herstellen
 4869: 1  10DA	D0 D0		                pop     psw
 4870: 1  10DC	C3		                clr     c                ;N is binnen bereik
 4871: 1  10DD	D0 E0		                pop     acc
 4872: 1  10DF	22		                ret
 4873: 1
 4874: 1			;*******************************************************************************
 4875: 1			; s_cmp16    (29,5us @16.777216MHz)
 4876: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4877: 1			;
 4878: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4879: 1			;
 4880: 1			; input:     r1,r0 = acc0
 4881: 1			;            r5,r4 = acc1
 4882: 1			;
 4883: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4884: 1			;             f0=0,cy=0  als acc0 > acc1
 4885: 1			;             f0=1 cy=0    als acc1 = acc0
 4886: 1			;
 4887: 1			; vernietigt:  niets
 4888: 1			;*******************************************************************************
 4889: 1  10E0	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4890: 1  10E2	C0 D0		                push    psw
 4891: 1  10E4	E8		                mov     a,r0
 4892: 1  10E5	C0 E0		                push    acc
 4893: 1  10E7	E9		                mov     a,r1
 4894: 1  10E8	C0 E0		                push    acc
 4895: 1
 4896: 1  10EA	E9		                mov     a,r1            ;neem msb van acc0
 4897: 1  10EB	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4898: 1  10EC	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4899: 1  10EF	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4900: 1			                                        ;negatief is
 4901: 1  10F0	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4902: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4903: 1
 4904: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4905: 1			;acc0>acc1
 4906: 1  10F3	D0 E0		s_cmp160:       pop     acc
 4907: 1  10F5	F9		                mov     r1,a
 4908: 1  10F6	D0 E0		                pop     acc
 4909: 1  10F8	F8		                mov     r0,a
 4910: 1  10F9	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4911: 1  10FB	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4912: 1  10FD	C3		                clr     c               ;geef dit aan in de outputstatus
 4913: 1  10FE	D0 E0		                pop     acc
 4914: 1  1100	22		                ret
 4915: 1			;acc0<acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4916: 1  1101	D0 E0		s_cmp161:       pop     acc
 4917: 1  1103	F9		                mov     r1,a
 4918: 1  1104	D0 E0		                pop     acc
 4919: 1  1106	F8		                mov     r0,a
 4920: 1  1107	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4921: 1  1109	D3		                setb    c               ;groter dan acc0
 4922: 1  110A	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4923: 1  110C	D0 E0		                pop     acc
 4924: 1  110E	22		                ret
 4925: 1			;gelijk teken, maak verschil
 4926: 1  110F	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 4927: 1  1110	E8		                mov     a,r0            ;acc0-acc1
 4928: 1  1111	9C		                subb    a,r4
 4929: 1  1112	F8		                mov     r0,a
 4930: 1  1113	E9		                mov     a,r1
 4931: 1  1114	9D		                subb    a,r5
 4932: 1  1115	F9		                mov     r1,a
 4933: 1  1116	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 4934: 1  1119	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 4935: 1  111A	60 02		                jz      s_cmp163        ;acc0=acc1
 4936: 1  111C	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 4937: 1			;acc0=acc1
 4938: 1  111E	D0 E0		s_cmp163:       pop     acc
 4939: 1  1120	F9		                mov     r1,a
 4940: 1  1121	D0 E0		                pop     acc
 4941: 1  1123	F8		                mov     r0,a
 4942: 1  1124	D0 D0		                pop     psw             ;acc0=acc1
 4943: 1  1126	C3		                clr     c               ;geef dit aan in de outputstatus
 4944: 1  1127	D2 D5		                setb    f0
 4945: 1  1129	D0 E0		                pop     acc
 4946: 1  112B	22		                ret
 4947: 1
 4948: 1			;*******************************************************************************
 4949: 1			; cmp16            (19,9us @16.777216MHz)
 4950: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 4951: 1			;
 4952: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 4953: 1			;
 4954: 1			; input:     r1,r0 = acc0
 4955: 1			;            r5,r4 = acc1
 4956: 1			;
 4957: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4958: 1			;             f0=0,cy=0  als acc0 > acc1
 4959: 1			;             f0=1 cy=0    als acc1 = acc0
 4960: 1			;
 4961: 1			; vernietigt:  niets
 4962: 1			;*******************************************************************************
 4963: 1  112C	C0 E0		cmp16:          push    acc             ;bewaar registers
 4964: 1  112E	C0 F0		                push    b
 4965: 1  1130	C0 D0		                push    psw
 4966: 1
 4967: 1  1132	C3		                clr     c               ;vergelijk acc0 met acc1
 4968: 1  1133	E9		                mov     a,r1            ;eerst de msb's
 4969: 1  1134	8D F0		                mov     b,r5            ;test r1-r5
 4970: 1  1136	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4971: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4972: 1  1139	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 4973: 1  113A	8C F0		                mov     b,r4            ;test r0-r4
 4974: 1  113C	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4975: 1			;acc0=acc1
 4976: 1  113F	D0 D0		                pop     psw
 4977: 1  1141	D2 D5		                setb    f0
 4978: 1  1143	C3		                clr     c
 4979: 1  1144	D0 F0		                pop     b
 4980: 1  1146	D0 E0		                pop     acc
 4981: 1  1148	22		                ret
 4982: 1  1149	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 4983: 1			;acc0>acc1
 4984: 1  114B	D0 D0		                pop     psw
 4985: 1  114D	C2 D5		                clr     f0
 4986: 1  114F	C3		                clr     c
 4987: 1  1150	D0 F0		                pop     b
 4988: 1  1152	D0 E0		                pop     acc
 4989: 1  1154	22		                ret
 4990: 1			;acc0<acc1
 4991: 1  1155	D0 D0		cmp162:         pop     psw
 4992: 1  1157	D3		                setb    c
 4993: 1  1158	C2 D5		                clr     f0
 4994: 1  115A	D0 F0		                pop     b
 4995: 1  115C	D0 E0		                pop     acc
 4996: 1  115E	22		                ret
 4997: 1
 4998: 1			;*******************************************************************************
 4999: 1			; s_cmp32        (44,3us @16.777216MHz)
 5000: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 5001: 1			;
 5002: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 5003: 1			;                         -2147483648 tot +2147483647
 5004: 1			; input:     r1,r0 = acc0
 5005: 1			;            r5,r4 = acc1
 5006: 1			;
 5007: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5008: 1			;             f0=0,cy=0  als acc0 > acc1
 5009: 1			;             f0=1 cy=0    als acc1 = acc0
 5010: 1			;
 5011: 1			; vernietigt:  niets
 5012: 1			;*******************************************************************************
 5013: 1  115F	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 5014: 1  1161	C0 D0		                push    psw
 5015: 1  1163	E8		                mov     a,r0
 5016: 1  1164	C0 E0		                push    acc
 5017: 1  1166	E9		                mov     a,r1
 5018: 1  1167	C0 E0		                push    acc
 5019: 1  1169	EA		                mov     a,r2
 5020: 1  116A	C0 E0		                push    acc
 5021: 1  116C	EB		                mov     a,r3
 5022: 1  116D	C0 E0		                push    acc
 5023: 1
 5024: 1  116F	EB		                mov     a,r3            ;neem msb van acc0
 5025: 1  1170	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 5026: 1  1171	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 5027: 1  1173	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5028: 1  1175	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 5029: 1  1176	A2 E7		                mov     c,acc.7         ;negatief is
 5030: 1  1178	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 5031: 1			                                        ;acc1 positief. Dus acc1>acc0
 5032: 1			;acc0>acc1
 5033: 1  117A	D0 E0		s_cmp320:       pop     acc
 5034: 1  117C	FB		                mov     r3,a
 5035: 1  117D	D0 E0		                pop     acc
 5036: 1  117F	FA		                mov     r2,a
 5037: 1  1180	D0 E0		                pop     acc
 5038: 1  1182	F9		                mov     r1,a
 5039: 1  1183	D0 E0		                pop     acc
 5040: 1  1185	F8		                mov     r0,a
 5041: 1  1186	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5042: 1  1188	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5043: 1  118A	C3		                clr     c               ;geef dit aan in de outputstatus
 5044: 1  118B	D0 E0		                pop     acc
 5045: 1  118D	22		                ret
 5046: 1			;acc0<acc1
 5047: 1  118E	D0 E0		s_cmp321:       pop     acc
 5048: 1  1190	FB		                mov     r3,a
 5049: 1  1191	D0 E0		                pop     acc
 5050: 1  1193	FA		                mov     r2,a
 5051: 1  1194	D0 E0		                pop     acc
 5052: 1  1196	F9		                mov     r1,a
 5053: 1  1197	D0 E0		                pop     acc
 5054: 1  1199	F8		                mov     r0,a
 5055: 1  119A	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5056: 1  119C	D3		                setb    c               ;groter dan acc0
 5057: 1  119D	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5058: 1  119F	D0 E0		                pop     acc
 5059: 1  11A1	22		                ret
 5060: 1			;gelijk teken, maak verschil
 5061: 1  11A2	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5062: 1  11A3	E8		                mov     a,r0            ;acc0-acc1
 5063: 1  11A4	9C		                subb    a,r4
 5064: 1  11A5	F8		                mov     r0,a
 5065: 1  11A6	E9		                mov     a,r1
 5066: 1  11A7	9D		                subb    a,r5
 5067: 1  11A8	F9		                mov     r1,a
 5068: 1  11A9	EA		                mov     a,r2
 5069: 1  11AA	9E		                subb    a,r6
 5070: 1  11AB	FA		                mov     r2,a
 5071: 1  11AC	EB		                mov     a,r3
 5072: 1  11AD	9F		                subb    a,r7
 5073: 1  11AE	FB		                mov     r3,a
 5074: 1  11AF	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5075: 1  11B2	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5076: 1  11B3	49		                orl     a,r1
 5077: 1  11B4	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5078: 1  11B5	60 02		                jz      s_cmp323        ;acc0=acc1
 5079: 1  11B7	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5080: 1			;acc0=acc1
 5081: 1  11B9	D0 E0		s_cmp323:       pop     acc
 5082: 1  11BB	FB		                mov     r3,a
 5083: 1  11BC	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5084: 1  11BE	FA		                mov     r2,a
 5085: 1  11BF	D0 E0		                pop     acc
 5086: 1  11C1	F9		                mov     r1,a
 5087: 1  11C2	D0 E0		                pop     acc
 5088: 1  11C4	F8		                mov     r0,a
 5089: 1  11C5	D0 D0		                pop     psw             ;acc0=acc1
 5090: 1  11C7	C3		                clr     c               ;geef dit aan in de outputstatus
 5091: 1  11C8	D2 D5		                setb    f0
 5092: 1  11CA	D0 E0		                pop     acc
 5093: 1  11CC	22		                ret
 5094: 1
 5095: 1			;*******************************************************************************
 5096: 1			; cmp32        (27,14us @16.777216MHz)
 5097: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5098: 1			;
 5099: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5100: 1			;
 5101: 1			; input:     r3,r2,r1,r0 = acc0
 5102: 1			;            r7,r6,r5,r4 = acc1
 5103: 1			;
 5104: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5105: 1			;            f0=0,cy=0  als acc0 > acc1
 5106: 1			;            f0=1 cy=0    als acc1 = acc0
 5107: 1			;
 5108: 1			; vernietigt:  niets
 5109: 1			;*******************************************************************************
 5110: 1  11CD	C0 E0		cmp32:          push    acc             ;bewaar registers
 5111: 1  11CF	C0 F0		                push    b
 5112: 1  11D1	C0 D0		                push    psw
 5113: 1
 5114: 1  11D3	C3		                clr     c               ;vergelijk acc0 met acc1
 5115: 1  11D4	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5116: 1  11D5	8F F0		                mov     b,r7            ;test r3-r7
 5117: 1  11D7	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5118: 1
 5119: 1  11DA	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5120: 1  11DB	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5121: 1  11DD	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5122: 1
 5123: 1  11E0	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5124: 1  11E1	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5125: 1  11E3	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5126: 1
 5127: 1  11E6	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5128: 1  11E7	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5129: 1  11E9	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5130: 1			;acc0=acc1
 5131: 1  11EC	D0 D0		                pop     psw
 5132: 1  11EE	D2 D5		                setb    f0
 5133: 1  11F0	C3		                clr     c
 5134: 1  11F1	D0 F0		                pop     b
 5135: 1  11F3	D0 E0		                pop     acc
 5136: 1  11F5	22		                ret
 5137: 1  11F6	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5138: 1			;acc0>acc1, indien cy=0
 5139: 1  11F8	D0 D0		                pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5140: 1  11FA	C2 D5		                clr     f0
 5141: 1  11FC	C3		                clr     c
 5142: 1  11FD	D0 F0		                pop     b
 5143: 1  11FF	D0 E0		                pop     acc
 5144: 1  1201	22		                ret
 5145: 1			;acc0<acc1
 5146: 1  1202	D0 D0		cmp322:         pop     psw
 5147: 1  1204	D3		                setb    c
 5148: 1  1205	C2 D5		                clr     f0
 5149: 1  1207	D0 F0		                pop     b
 5150: 1  1209	D0 E0		                pop     acc
 5151: 1  120B	22		                ret
 5152: 1
 5153: 1
 5154: 1			;*******************************************************************************
 5155: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5156: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5157: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5158: 1			; adres zitten.
 5159: 1			;
 5160: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5161: 1			;
 5162: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5163: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5164: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5165: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5166: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5167: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5168: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5169: 1			;                cy = 0  lookup is ok
 5170: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5171: 1			; vernietigt:  niets
 5172: 1			;*******************************************************************************
 5173: 1  120C	C0 E0		table_lu:       push    acc             ;bewaren registers
 5174: 1  120E	C0 D0		                push    psw
 5175: 1  1210	C0 82		                push    dpl
 5176: 1  1212	C0 83		                push    dph
 5177: 1
 5178: 1  1214	A2 D5		                mov     c,f0            ;byte of word items?
 5179: 1  1216	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5180: 1			;tabel met byte items
 5181: 1  1218	E5 82		                mov     a,dpl           ;datapointer plus index
 5182: 1  121A	28		                add     a,r0
 5183: 1  121B	F5 82		                mov     dpl,a
 5184: 1  121D	E5 83		                mov     a,dph
 5185: 1  121F	39		                addc    a,r1
 5186: 1  1220	F5 83		                mov     dph,a
 5187: 1  1222	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5188: 1  1224	A2 D1		                mov     c,f1            ;code of datageheugen?
 5189: 1  1226	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5190: 1
 5191: 1			;bytetabel in codegeheugen
 5192: 1  1228	74 00		                mov     a,#0
 5193: 1  122A	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5194: 1  122B	F8		                mov     r0,a            ;en stop in acc0
 5195: 1  122C	79 00		                mov     r1,#0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5196: 1  122E	02 12 8D	                ljmp    table_lu4       ;en klaar
 5197: 1
 5198: 1			;bytetabel in datageheugen
 5199: 1  1231	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5200: 1  1232	F8		                mov     r0,a            ;en stop in acc0
 5201: 1  1233	79 00		                mov     r1,#0
 5202: 1  1235	02 12 8D	                ljmp    table_lu4       ;en klaar
 5203: 1
 5204: 1  1238	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5205: 1  123A	D0 82		                pop     dpl
 5206: 1  123C	D0 D0		                pop     psw
 5207: 1  123E	D3		                setb    c              ;foutstatus teruggeven!
 5208: 1  123F	D0 E0		                pop     acc
 5209: 1  1241	22		                ret
 5210: 1
 5211: 1			;tabel met word items
 5212: 1  1242	E8		table_lu2:      mov     a,r0            ;index op stack
 5213: 1  1243	C0 E0		                push    acc
 5214: 1  1245	E9		                mov     a,r1
 5215: 1  1246	C0 E0		                push    acc
 5216: 1
 5217: 1  1248	C3		                clr      c              ;index maal 2 (word items)
 5218: 1  1249	E8		                mov     a,r0
 5219: 1  124A	33		                rlc     a
 5220: 1  124B	F8		                mov     r0,a
 5221: 1  124C	E9		                mov     a,r1
 5222: 1  124D	33		                rlc     a
 5223: 1  124E	F9		                mov     r1,a
 5224: 1
 5225: 1  124F	E5 82		                mov     a,dpl           ;datapointer plus index
 5226: 1  1251	28		                add     a,r0
 5227: 1  1252	F5 82		                mov     dpl,a
 5228: 1  1254	E5 83		                mov     a,dph
 5229: 1  1256	39		                addc    a,r1
 5230: 1  1257	F5 83		                mov     dph,a
 5231: 1
 5232: 1  1259	D0 E0		                pop     acc             ;index weer van stack
 5233: 1  125B	F9		                mov     r1,a
 5234: 1  125C	D0 E0		                pop     acc
 5235: 1  125E	F8		                mov     r0,a
 5236: 1
 5237: 1  125F	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5238: 1  1261	A2 D1		                mov     c,f1            ;code of datageheugen?
 5239: 1  1263	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5240: 1			;wordtabel in codegeheugen
 5241: 1  1265	74 00		                mov     a,#0
 5242: 1  1267	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5243: 1  1268	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5244: 1  1269	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5245: 1  126B	24 01		                add     a,#1
 5246: 1  126D	F5 82		                mov     dpl,a
 5247: 1  126F	E5 83		                mov     a,dph
 5248: 1  1271	34 00		                addc    a,#0
 5249: 1  1273	F5 83		                mov     dph,a
 5250: 1  1275	74 00		                mov     a,#0
 5251: 1  1277	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5252: 1  1278	F9		                mov     r1,a            ;msb in acc0 stoppen
 5253: 1  1279	80 12		                sjmp    table_lu4        ;en klaar
 5254: 1			;wordtabel    in datageheugen
 5255: 1  127B	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5256: 1  127C	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5257: 1  127D	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5258: 1  127F	24 01		                add     a,#1
 5259: 1  1281	F5 82		                mov     dpl,a
 5260: 1  1283	E5 83		                mov     a,dph
 5261: 1  1285	34 00		                addc    a,#0
 5262: 1  1287	F5 83		                mov     dph,a
 5263: 1  1289	74 00		                mov     a,#0
 5264: 1  128B	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5265: 1  128C	F9		                mov     r1,a            ;msb in acc0 stoppen
 5266: 1			                                        ;en klaar
 5267: 1
 5268: 1  128D	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5269: 1  128F	D0 82		                pop     dpl
 5270: 1  1291	D0 D0		                pop     psw
 5271: 1  1293	D0 E0		                pop     acc
 5272: 1  1295	22		                ret
 5273: 1
 5274: 1
 5275: 1
 5276: 1			;*******************************************************************************
 5277: 1			; Cordic        (2,11ms @16.777216MHz)
 5278: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5279: 1			; waarde (2's complement) opgegeven hoek.
 5280: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5281: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5282: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5283: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5284: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5285: 1			; als geschaalde getallen ter beschikking komen.
 5286: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5287: 1			;
 5288: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5289: 1			;
 5290: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5291: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5292: 1			;            cy = 0 : hoek binnen bereik
 5293: 1			;            cy = 1 : error, hoek buiten bereik
 5294: 1			;            nauwkeurigheid: 12 msbits
 5295: 1			; vernietigt:  niets
 5296: 1			;*******************************************************************************
 5297: 1  1296	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5298: 1  1298	C0 D0		                push    psw
 5299: 1  129A	C0 83		                push    dph
 5300: 1  129C	C0 82		                push    dpl
 5301: 1  129E	C0 F0		                push    b
 5302: 1
 5303: 1  12A0	EF		                mov     a,r7
 5304: 1  12A1	C0 E0		                push    acc
 5305: 1  12A3	EE		                mov     a,r6
 5306: 1  12A4	C0 E0		                push    acc
 5307: 1  12A6	ED		                mov     a,r5

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5308: 1  12A7	C0 E0		                push    acc
 5309: 1  12A9	EC		                mov     a,r4
 5310: 1  12AA	C0 E0		                push    acc
 5311: 1
 5312: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5313: 1			;en niet groter dan pi/2 radialen (6478h)
 5314: 1  12AC	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5315: 1  12AE	7D 64		                mov     r5,#64h
 5316: 1  12B0	12 11 2C	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5317: 1  12B3	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5318: 1  12B6	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5319: 1  12B8	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5320: 1
 5321: 1  12BA	C2 A0		cordic000:      clr     p2.0
 5322: 1  12BC	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5323: 1  12BE	7D 9B		                mov     r5,#9bh
 5324: 1  12C0	12 11 2C	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5325: 1  12C3	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5326: 1  12C6	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5327: 1  12C8	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5328: 1
 5329: 1  12CA	C2 A1		cordic_error:   clr     p2.1
 5330: 1  12CC	02 13 7E	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5331: 1
 5332: 1			;Hoek is -pi/2 resultaat gekend
 5333: 1  12CF	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5334: 1  12D1	7A 00		                mov     r2,#000h
 5335: 1  12D3	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5336: 1  12D5	78 00		                mov     r0,#000h
 5337: 1  12D7	C3		                clr     c
 5338: 1  12D8	02 13 7E	                ljmp    cordic40        ;en klaar
 5339: 1			;hoek is +pi/2 resultaat gekend
 5340: 1  12DB	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5341: 1  12DD	7A FF		                mov     r2,#0ffh
 5342: 1  12DF	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5343: 1  12E1	78 00		                mov     r0,#000h
 5344: 1  12E3	C3		                clr     c
 5345: 1  12E4	02 13 7E	                ljmp    cordic40        ;en klaar
 5346: 1
 5347: 1  12E7	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5348: 1  12E9	7D 00		                mov     r5,#00h
 5349: 1  12EB	12 11 2C	                lcall   cmp16            ;vergelijk de hoeken
 5350: 1  12EE	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5351: 1  12F1	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5352: 1			;hoek is 0, resultaat gekend
 5353: 1  12F3	C2 A7		cordic_nul:     clr     p2.7
 5354: 1  12F5	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5355: 1  12F7	7A 00		                mov     r2,#000h
 5356: 1  12F9	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5357: 1  12FB	78 FF		                mov     r0,#0ffh
 5358: 1  12FD	C3		                clr     c
 5359: 1  12FE	02 13 7E	                ljmp    cordic40        ;en klaar
 5360: 1
 5361: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5362: 1  1301	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5363: 1  1302	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5364: 1  1304	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5365: 1  1305	C0 E0		                push    acc
 5366: 1
 5367: 1  1307	7B 00		                mov     r3,#00h         ;y=0
 5368: 1  1309	7A 00		                mov     r2,#00h
 5369: 1  130B	79 26		                mov     r1,#026h        ;x = K * 2^14
 5370: 1  130D	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5371: 1
 5372: 1  130F	75 F0 00	                mov     b,#00h          ;loopteller=0
 5373: 1
 5374: 1  1312	90 13 D6	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5375: 1
 5376: 1  1315	EB		cordic1:        mov     a,r3            ;sry=y
 5377: 1  1316	FF		                mov     r7,a
 5378: 1  1317	EA		                mov     a,r2
 5379: 1  1318	FE		                mov     r6,a
 5380: 1  1319	E9		                mov     a,r1            ;srx=x
 5381: 1  131A	FD		                mov     r5,a
 5382: 1  131B	E8		                mov     a,r0
 5383: 1  131C	FC		                mov     r4,a
 5384: 1
 5385: 1  131D	12 13 9D	                lcall   cordic5          ;srx en sry >> loopteller
 5386: 1
 5387: 1  1320	D0 E0		                pop     acc
 5388: 1  1322	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5389: 1
 5390: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5391: 1  1325	C3		                clr     c
 5392: 1  1326	E8		                mov     a,r0            ;bereken x=x-sry
 5393: 1  1327	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5394: 1  1328	F8		                mov     r0,a
 5395: 1  1329	E9		                mov     a,r1
 5396: 1  132A	9F		                subb    a,r7
 5397: 1  132B	F9		                mov     r1,a
 5398: 1
 5399: 1  132C	EA		                mov     a,r2            ;bereken y=y+srx
 5400: 1  132D	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5401: 1  132E	FA		                mov     r2,a
 5402: 1  132F	EB		                mov     a,r3
 5403: 1  1330	3D		                addc    a,r5
 5404: 1  1331	FB		                mov     r3,a
 5405: 1
 5406: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5407: 1  1332	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5408: 1  1334	93		                movc    a,@a+dptr
 5409: 1  1335	A3		                inc     dptr
 5410: 1  1336	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5411: 1  1337	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5412: 1  1339	C3		                clr     c               ;verklein de hoek
 5413: 1  133A	9C		                subb    a,r4
 5414: 1  133B	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5415: 1  133D	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5416: 1
 5417: 1  133F	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5418: 1  1341	93		                movc    a,@a+dptr
 5419: 1  1342	A3		                inc     dptr            ;wijs naar volgende tabelwaarde

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5420: 1  1343	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5421: 1  1344	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5422: 1  1346	9D		                subb    a,r5            ;verklein de hoek
 5423: 1  1347	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5424: 1
 5425: 1			;loopteller incrementeren en testen op einde van de iteratie
 5426: 1  1349	05 F0		cordic2:        inc     b               ;loopteller++
 5427: 1  134B	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5428: 1  134D	65 F0		                xrl     a,b             ;test op gelijkheid
 5429: 1  134F	60 28		                jz      cordic4         ;ja klaar!
 5430: 1  1351	02 13 15	                ljmp    cordic1         ;nee, nog even verder...
 5431: 1
 5432: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5433: 1  1354	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5434: 1  1355	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5435: 1  1356	F8		                mov     r0,a
 5436: 1  1357	E9		                mov     a,r1
 5437: 1  1358	3F		                addc    a,r7
 5438: 1  1359	F9		                mov     r1,a
 5439: 1
 5440: 1  135A	C3		                clr     c
 5441: 1  135B	EA		                mov     a,r2            ;bereken y=y-srx
 5442: 1  135C	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5443: 1  135D	FA		                mov     r2,a
 5444: 1  135E	EB		                mov     a,r3
 5445: 1  135F	9D		                subb    a,r5
 5446: 1  1360	FB		                mov     r3,a
 5447: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5448: 1  1361	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5449: 1  1363	93		                movc    a,@a+dptr
 5450: 1  1364	A3		                inc     dptr
 5451: 1  1365	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5452: 1  1366	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5453: 1  1368	2C		                add     a,r4            ;vergroot de hoek
 5454: 1  1369	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5455: 1  136B	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5456: 1
 5457: 1  136D	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5458: 1  136F	93		                movc    a,@a+dptr
 5459: 1  1370	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5460: 1  1371	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5461: 1  1372	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5462: 1  1374	3D		                addc    a,r5            ;vergroot de hoek
 5463: 1  1375	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5464: 1
 5465: 1  1377	80 D0		                sjmp    cordic2
 5466: 1
 5467: 1  1379	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5468: 1  137B	D0 E0		                pop     acc             ;dummy hoek van stack
 5469: 1  137D	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5470: 1
 5471: 1  137E	D0 E0		cordic40:       pop     acc
 5472: 1  1380	FC		                mov     r4,a
 5473: 1  1381	D0 E0		                pop     acc
 5474: 1  1383	FD		                mov     r5,a
 5475: 1  1384	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5476: 1  1386	FE		                mov     r6,a
 5477: 1  1387	D0 E0		                pop     acc
 5478: 1  1389	FF		                mov     r7,a
 5479: 1  138A	D0 F0		                pop     b
 5480: 1  138C	D0 82		                pop     dpl
 5481: 1  138E	D0 83		                pop     dph
 5482: 1  1390	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5483: 1  1392	D0 D0		                pop     psw
 5484: 1  1394	D0 E0		                pop     acc
 5485: 1  1396	22		                ret
 5486: 1
 5487: 1  1397	D0 D0		cordic41:       pop     psw
 5488: 1  1399	D3		                setb    c
 5489: 1  139A	D0 E0		                pop     acc
 5490: 1  139C	22		                ret
 5491: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5492: 1			;over het aantal posities aangegeven in het B register.
 5493: 1  139D	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5494: 1  139F	74 00		                mov     a,#0            ;test of loopteller=0
 5495: 1  13A1	65 F0		                xrl     a,b
 5496: 1  13A3	60 2E		                jz      cordic52        ;klaar
 5497: 1
 5498: 1  13A5	ED		                mov     a,r5            ;test teken van srx
 5499: 1  13A6	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5500: 1  13A9	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5501: 1  13AB	80 02		                sjmp    cordic50
 5502: 1  13AD	D2 D5		cordic5a:       setb    f0
 5503: 1  13AF	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5504: 1  13B1	ED		                mov     a,r5            ;eerst de msb
 5505: 1  13B2	13		                rrc     a
 5506: 1  13B3	FD		                mov     r5,a
 5507: 1  13B4	EC		                mov     a,r4            ;dan de lsb
 5508: 1  13B5	13		                rrc     a
 5509: 1  13B6	FC		                mov     r4,a
 5510: 1  13B7	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5511: 1  13BA	D0 F0		                pop     b               ;haal de loopteller van stack
 5512: 1  13BC	C0 F0		                push    b               ;en bewaar hem weer
 5513: 1  13BE	EF		                mov     a,r7            ;test teken van sry
 5514: 1  13BF	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5515: 1  13C2	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5516: 1  13C4	80 02		                sjmp    cordic51
 5517: 1  13C6	D2 D5		cordic5b:       setb    f0
 5518: 1  13C8	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5519: 1  13CA	EF		                mov     a,r7            ;eerst de msb
 5520: 1  13CB	13		                rrc     a
 5521: 1  13CC	FF		                mov     r7,a
 5522: 1  13CD	EE		                mov     a,r6            ;dan de lsb
 5523: 1  13CE	13		                rrc     a
 5524: 1  13CF	FE		                mov     r6,a
 5525: 1  13D0	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5526: 1
 5527: 1  13D3	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5528: 1  13D5	22		                ret
 5529: 1
 5530: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5531: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5532: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5533: 1  13D6	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5534: 1  13D8	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5535: 1  13DA	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5536: 1  13DC	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5537: 1  13DE	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5538: 1  13E0	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5539: 1  13E2	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5540: 1  13E4	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5541: 1  13E6	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5542: 1  13E8	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5543: 1  13EA	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5544: 1  13EC	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5545: 1  13EE	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5546: 1  13F0	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5547: 1  13F2	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5548: 1
 5549: 1			endif        ;einde van aduc_math
 5550: 1			;******************************************************************************
 5551: 1
 5552: 1			ifdef        aduc_adc    ;A/D conversie routines
 5553: 1			;*******************************************************************************
 5554: 1			; ADuCADC_mide
 5555: 1			; Geschreven door [dp] op 5/1/2014
 5556: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5557: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5558: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5559: 1			; bron instellen.
 5560: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5561: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5562: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5563: 1			;
 5564: 1			;*******************************************************************************
 5565: 1
 5566: 1			;*******************************************************************************
 5567: 1			; adc_init
 5568: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5569: 1			; -  4 track&hold clockperiodes
 5570: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5571: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5572: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5573: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5574: 1			;
 5575: 1			; input: R0 =  0  : Interne referentiebron
 5576: 1			;        R0 <> 0  : Externe referentiebron
 5577: 1			;
 5578: 1			; Deze routine vernietigt niets
 5579: 1			;*******************************************************************************
 5580: 1  13F4	C0 E0		adc_init:       push    acc                 ;registers op stack
 5581: 1  13F6	C0 D0		                push    psw
 5582: 1  13F8	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5583: 1  13FB	E8		                mov     a,r0                ;welke referentiebron?
 5584: 1  13FC	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5585: 1  13FE	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5586: 1  1401	D0 D0		adc_init1:      pop     psw
 5587: 1  1403	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5588: 1  1405	22		                ret
 5589: 1
 5590: 1			;*******************************************************************************
 5591: 1			; adc_single
 5592: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5593: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5594: 1			; (2's complement) formaat van de meetwaarde.
 5595: 1			; _____________________________________________________________
 5596: 1			; resolutie  |     unsigned      |           signed            |
 5597: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5598: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5599: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5600: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5601: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5602: 1			; _____________________________________________________________
 5603: 1			;
 5604: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5605: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5606: 1			; De ingangsparameter wordt doorgegeven via R0.
 5607: 1			;
 5608: 1			; input:
 5609: 1			;             7    6    5    4    3    2    1    0
 5610: 1			;           _______________________________________
 5611: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5612: 1			;           ---------------------------------------
 5613: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5614: 1			;                                         1000b = temp.sensor
 5615: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5616: 1			;                                   10b = 12 bits, 11b = 12 bits
 5617: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5618: 1			;
 5619: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5620: 1			;         cy=0  bij conversie ok
 5621: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5622: 1			;
 5623: 1			; Deze routine vernietigt niets
 5624: 1			;*******************************************************************************
 5625: 1  1406	C0 E0		adc_single:     push    acc                 ;registers op stack
 5626: 1  1408	C0 D0		                push    psw
 5627: 1  140A	C0 F0		                push    b
 5628: 1  140C	E8		                mov     a,r0                ;neem inputparameter
 5629: 1  140D	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5630: 1  140F	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5631: 1  1412	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5632: 1  1414	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5633: 1  1416	D2 DC		                setb    sconv               ;start een meting
 5634: 1  1418	E8		                mov     a,r0                ;neem parameter terug
 5635: 1  1419	A2 E6		                mov     c,acc.6
 5636: 1  141B	92 D5		                mov     f0,c                ;bewaar format bit
 5637: 1  141D	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5638: 1  1420	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5639: 1  1423	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5640: 1  1426	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5641: 1			;*******************************************************************************
 5642: 1			;8 bit resultaat gevraagd
 5643: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5644: 1  1429	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5645: 1  142B	C4		                swap    a                    ;swap nibbles
 5646: 1  142C	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5647: 1  142E	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5648: 1  1430	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5649: 1  1432	C4		                swap    a
 5650: 1  1433	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5651: 1  1435	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5652: 1			;8 bit unsigned formaat
 5653: 1  1438	79 00		                mov     r1,#00h              ;unsigned
 5654: 1  143A	F8		                mov     r0,a
 5655: 1  143B	80 63		                sjmp    adc_single42
 5656: 1			;8 bit signed formaat
 5657: 1  143D	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5658: 1  1440	24 80		                add     a,#80h                ;negatief getal van maken
 5659: 1  1442	F8		                mov     r0,a
 5660: 1  1443	79 FF		                mov     r1,#0ffh
 5661: 1  1445	80 59		                sjmp    adc_single42
 5662: 1  1447	C3		adc_single20:   clr     c
 5663: 1  1448	94 80		                subb    a,#80h                ;positief deel verkleinen
 5664: 1  144A	F8		                mov     r0,a
 5665: 1  144B	79 00		                mov     r1,#00h
 5666: 1  144D	80 51		                sjmp    adc_single42
 5667: 1
 5668: 1  144F	02 14 A8	adc_single21:   ljmp    adc_single43
 5669: 1			;*******************************************************************************
 5670: 1			;10 bit resultaat gevraagd
 5671: 1			;*******************************************************************************
 5672: 1  1452	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5673: 1  1454	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5674: 1  1456	03		                rr     a              ;naar msbits roteren
 5675: 1  1457	03		                rr     a
 5676: 1  1458	F5 F0		                mov    b,a            ;even bewaren
 5677: 1  145A	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5678: 1  145C	03		                rr     a              ;twee plaatsen opschuiven
 5679: 1  145D	03		                rr     a
 5680: 1  145E	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5681: 1  1460	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5682: 1  1462	F5 F0		                mov    b,a            ;low byte even bewaren
 5683: 1  1464	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5684: 1  1466	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5685: 1  1468	03		                rr     a               ;en op hun plaats schuiven
 5686: 1  1469	03		                rr     a
 5687: 1  146A	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5688: 1			;10 bit unsigned formaat
 5689: 1  146D	F9		                mov    r1,a            ;unsigned
 5690: 1  146E	A8 F0		                mov    r0,b
 5691: 1  1470	80 2E		                sjmp   adc_single42
 5692: 1			;10 bit signed formaat
 5693: 1  1472	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5694: 1  1475	24 FE		                add    a,#0feh             ;negatief getal van maken
 5695: 1  1477	F9		                mov    r1,a
 5696: 1  1478	A8 F0		                mov    r0,b
 5697: 1  147A	80 24		                sjmp   adc_single42
 5698: 1  147C	C3		adc_single31:   clr    c
 5699: 1  147D	94 02		                subb   a,#02h              ;positief deel verkleinen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5700: 1  147F	F9		                mov    r1,a
 5701: 1  1480	A8 F0		                mov    r0,b
 5702: 1  1482	80 1C		                sjmp   adc_single42
 5703: 1
 5704: 1			;*******************************************************************************
 5705: 1			;12 bit resultaat gevraagd
 5706: 1			;*******************************************************************************
 5707: 1  1484	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5708: 1  1486	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5709: 1  1488	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5710: 1			;12 bit unsigned formaat
 5711: 1  148B	A8 D9		                mov    r0,adcdatal           ;unsigned
 5712: 1  148D	F9		                mov    r1,a
 5713: 1  148E	80 10		                sjmp   adc_single42
 5714: 1			;12 bit signed formaat
 5715: 1  1490	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5716: 1  1493	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5717: 1  1495	F9		                mov    r1,a
 5718: 1  1496	A8 D9		                mov    r0,adcdatal
 5719: 1  1498	80 06		                sjmp   adc_single42
 5720: 1  149A	C3		adc_single41:   clr    c
 5721: 1  149B	94 08		                subb   a,#08h                ;positief deel verkleinen
 5722: 1  149D	F9		                mov    r1,a
 5723: 1  149E	A8 D9		                mov    r0,adcdatal
 5724: 1  14A0	D0 F0		adc_single42:   pop    b
 5725: 1  14A2	D0 D0		                pop    psw
 5726: 1  14A4	C3		                clr    c
 5727: 1  14A5	D0 E0		                pop    acc
 5728: 1  14A7	22		                ret
 5729: 1
 5730: 1  14A8	D0 F0		adc_single43:   pop    b
 5731: 1  14AA	D0 D0		                pop    psw
 5732: 1  14AC	D3		                setb   c
 5733: 1  14AD	D0 E0		                pop    acc
 5734: 1  14AF	22		                ret
 5735: 1
 5736: 1			endif        ;einde van aduc_adc
 5737: 1			;*******************************************************************************
 5738: 1
 5739: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5740: 1			;******************************************************************************
 5741: 1			; ADuCKEY_mide.inc
 5742: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5743: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5744: 1			;
 5745: 1			;     V2.0      V1.1
 5746: 1			;                           |   |   |   |
 5747: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5748: 1			;                   |       |   |   |   |
 5749: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5750: 1			;                   |       |   |   |   |
 5751: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5752: 1			;                   |       |   |   |   |
 5753: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5754: 1			;                   |       |   |   |   |
 5755: 1			;     P0.4      P3.4|-K1----|   |   |   |

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5756: 1			;                   |           |   |   |
 5757: 1			;     P0.5      P3.5|-K2--------|   |   |
 5758: 1			;                   |               |   |
 5759: 1			;     P0.6      P3.6|-K3------------|   |
 5760: 1			;                   |                   |
 5761: 1			;     P0.7      P3.7|-K4----------------|
 5762: 1			;
 5763: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5764: 1			; gebruikt.
 5765: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5766: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5767: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5768: 1			; en als ingang wordt aangeboden.
 5769: 1			;
 5770: 1			;                                  ___                 ___
 5771: 1			;                     ____________|   |  |------------|   |
 5772: 1			;              ____  |   ____     |   |  |   ____     |   |
 5773: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5774: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5775: 1			; '1'= toets  | cl |    | cl |              | cl |
 5776: 1			;  ingedrukt  |____|    |____|              |____|
 5777: 1			;                |         |                   |
 5778: 1			;      CLOCK     |         |                   |
 5779: 1			;         _______|_________|___________________|
 5780: 1			;
 5781: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 5782: 1			;
 5783: 1			;              MAP0      MAP1                 MAP2         MAP3
 5784: 1			;
 5785: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5786: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5787: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5788: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5789: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 5790: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5791: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 5792: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5793: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5794: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5795: 1			;
 5796: 1			;          MAP0    MAP1          MAP2    MAP3
 5797: 1			;         _______________       _______________
 5798: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 5799: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5800: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5801: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5802: 1			;
 5803: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5804: 1			;         | | | | | | | |       | | | | | | | |
 5805: 1			;        K K K K K K K K       K K K K K K K K
 5806: 1			;         O O O O O O O O       O O O O O O O O
 5807: 1			;         L L L L L L L L       L L L L L L L L
 5808: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5809: 1			;
 5810: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 5811: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5812: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5813: 1			; van bitmaps van voor naar achter.
 5814: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5815: 1			;
 5816: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5817: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5818: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5819: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 5820: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5821: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5822: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5823: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5824: 1			; deze toetswaarde weer.
 5825: 1			;
 5826: 1			;
 5827: 1			;
 5828: 1			;******************************************************************************
 5829: 1
 5830: 1
 5831: 1			;******************************************************************************
 5832: 1			; key_init
 5833: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 5834: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5835: 1			; input: niets
 5836: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 5837: 1			;         (map0,map1,map2,map3 =0)
 5838: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5839: 1			; Deze routine vernietigt niets
 5840: 1			;******************************************************************************
 5841: 1
 5842: 1  14B0	C0 E0		Key_init:       push    acc          ;bewaar registers
 5843: 1  14B2	C0 D0		                push    psw
 5844: 1  14B4	E8		                mov     a,r0
 5845: 1  14B5	C0 E0		                push    acc
 5846: 1  14B7	E9		                mov     a,r1
 5847: 1  14B8	C0 E0		                push    acc
 5848: 1  14BA	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5849: 1  14BC	79 09		                mov     r1,#9        ;9 bytes in de maps
 5850: 1  14BE	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5851: 1  14C0	08		                inc     r0           ;volgende byte nemen
 5852: 1  14C1	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5853: 1  14C3	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5854: 1  14C5	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 5855: 1  14C7	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5856: 1  14CA	D0 E0		                pop     acc          ;herstel registers
 5857: 1  14CC	F9		                mov     r1,a
 5858: 1  14CD	D0 E0		                pop     acc
 5859: 1  14CF	F8		                mov     r0,a
 5860: 1  14D0	D0 D0		                pop     psw
 5861: 1  14D2	D0 E0		                pop     acc
 5862: 1  14D4	22		                ret                    ;terug naar caller
 5863: 1			;******************************************************************************
 5864: 1
 5865: 1
 5866: 1			;******************************************************************************
 5867: 1			; toets_flank

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5868: 1			; Deze routine detecteert de indrukflank van een toets.
 5869: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5870: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5871: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5872: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5873: 1			; minder dan 20ms duurt.
 5874: 1			; input : niets
 5875: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5876: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5877: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5878: 1			;
 5879: 1			; Deze routine vernietigt geen registers.
 5880: 1			;******************************************************************************
 5881: 1  14D5	C0 E0		Toets_flank:    push    acc
 5882: 1  14D7	C0 D0		                push    psw
 5883: 1  14D9	12 14 F3	                lcall   Keyscan
 5884: 1  14DC	12 15 6F	                lcall   Keyedge
 5885: 1  14DF	D0 D0		                pop     psw
 5886: 1  14E1	D0 E0		                pop     acc
 5887: 1  14E3	22		                ret
 5888: 1
 5889: 1			;******************************************************************************
 5890: 1			; toets_ingedrukt
 5891: 1			; Deze routine detecteert een ingedrukte toets.
 5892: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5893: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5894: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5895: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5896: 1			; minder dan 20ms duurt.
 5897: 1			; input : niets
 5898: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5899: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5900: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5901: 1			;
 5902: 1			; Deze routine vernietigt geen registers.
 5903: 1			;******************************************************************************
 5904: 1  14E4	C0 E0		Toets_ingedrukt:push    acc
 5905: 1  14E6	C0 D0		                push    psw
 5906: 1  14E8	12 14 F3	                lcall   Keyscan
 5907: 1  14EB	12 15 56	                lcall   Keydown
 5908: 1  14EE	D0 D0		                pop     psw
 5909: 1  14F0	D0 E0		                pop     acc
 5910: 1  14F2	22		                ret
 5911: 1
 5912: 1
 5913: 1			;******************************************************************************
 5914: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5915: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5916: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5917: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5918: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5919: 1			; zoals aangegeven in het blokschema van het algorithme.
 5920: 1			; input : niets
 5921: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5922: 1			;         ervan weergeven
 5923: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5924: 1			; Deze routine vernietigt geen registers
 5925: 1			;******************************************************************************
 5926: 1
 5927: 1  14F3	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 5928: 1  14F5	C0 D0		                push    psw
 5929: 1  14F7	C0 F0		                push    b
 5930: 1  14F9	E8		                mov     a,r0
 5931: 1  14FA	C0 E0		                push    acc
 5932: 1  14FC	E9		                mov     a,r1
 5933: 1  14FD	C0 E0		                push    acc
 5934: 1  14FF	EA		                mov     a,r2
 5935: 1  1500	C0 E0		                push    acc
 5936: 1  1502	EE		                mov     a,r6
 5937: 1  1503	C0 E0		                push    acc
 5938: 1
 5939: 1  1505	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 5940: 1  1507	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 5941: 1  150A	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 5942: 1  150C	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 5943: 1
 5944: 1  150E			Scanloop:
 5945: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 5946: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 5947: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 5948: 1			                mov     p0.0,c
 5949: 1			                mov     c,acc.1
 5950: 1			                mov     p0.1,c
 5951: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 5952: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 5953: 1			endif
 5954: 1
 5955: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 5956: 1  150E	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 5957: 1			                                      ;een rij-lijn
 5958: 1			endif
 5959: 1
 5960: 1			; Eerst de flipflops implementeren.
 5961: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 5962: 1			; te lezen van de kolomlijnen
 5963: 1  1510	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 5964: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5965: 1  1511	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 5966: 1  1512	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 5967: 1  1513	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 5968: 1  1514	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 5969: 1  1516	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 5970: 1  1517	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 5971: 1  1518	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 5972: 1  151A	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 5973: 1  151B	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 5974: 1  151C	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 5975: 1  151D	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 5976: 1  151E	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 5977: 1  1520	FA		                mov     r2,a          ;even bewaren in register
 5978: 1
 5979: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5980: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 5981: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 5982: 1			                                      ;poort3 kolomlijnen
 5983: 1			endif
 5984: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 5985: 1  1521	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 5986: 1			                                     ;poort0 kolomlijnen
 5987: 1			endif
 5988: 1  1523	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 5989: 1  1524	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 5990: 1  1526	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 5991: 1  1527	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 5992: 1
 5993: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 5994: 1			; Nu volgen de logische functies uit het blokschema
 5995: 1
 5996: 1  1528	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 5997: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5998: 1  1529	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 5999: 1  152A	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 6000: 1  152B	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 6001: 1  152C	54 0F		                anl     a,#00001111b ;low nibble houden
 6002: 1  152E	FA		                mov     r2,a         ;resultaat bewaren
 6003: 1  152F	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 6004: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 6005: 1  1530	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 6006: 1  1531	C4		                swap    a            ;map2 naar low nibble schuiven
 6007: 1  1532	5A		                anl     a,r2         ;combineren met output vorige and poort
 6008: 1  1533	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 6009: 1  1535	FA		                mov     r2,a         ;even bewaren
 6010: 1  1536	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 6011: 1  1537	54 F0		                anl     a,#11110000b ;map2 overhouden
 6012: 1  1539	4A		                orl     a,r2         ;en combineren met nieuwe map3
 6013: 1  153A	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 6014: 1
 6015: 1			; We gaan nu de volgende lijn scannen
 6016: 1
 6017: 1  153B	EE		                mov     a,r6         ;scanpatroon nemen
 6018: 1  153C	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 6019: 1  153D	FE		                mov     r6,a         ;scanpatroon bewaren
 6020: 1
 6021: 1  153E	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 6022: 1  153F	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 6023: 1  1540	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 6024: 1  1543	D0 E0		                pop     acc          ;herstel registers
 6025: 1  1545	FE		                mov     r6,a
 6026: 1  1546	D0 E0		                pop     acc
 6027: 1  1548	FA		                mov     r2,a
 6028: 1  1549	D0 E0		                pop     acc
 6029: 1  154B	F9		                mov     r1,a
 6030: 1  154C	D0 E0		                pop     acc
 6031: 1  154E	F8		                mov     r0,a
 6032: 1  154F	D0 F0		                pop     b
 6033: 1  1551	D0 D0		                pop     psw
 6034: 1  1553	D0 E0		                pop     acc
 6035: 1  1555	22		                ret                    ;terug naar caller

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6036: 1			;******************************************************************************
 6037: 1
 6038: 1
 6039: 1			;******************************************************************************
 6040: 1			; Keydown, Keyedge (twee entry's)
 6041: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6042: 1			;
 6043: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6044: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6045: 1			; Er zijn twee detectie-modes:
 6046: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6047: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6048: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6049: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6050: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6051: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6052: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6053: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6054: 1			;
 6055: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6056: 1			; (flankdetectie mode).
 6057: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6058: 1			; (toets ingedrukt mode).
 6059: 1			;
 6060: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6061: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6062: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6063: 1			; geldt voor een standaard 4x4 keypad.
 6064: 1			;
 6065: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6066: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6067: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6068: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6069: 1			;
 6070: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6071: 1			; output: key = gedetecteerde toets
 6072: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6073: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6074: 1			;
 6075: 1			; Deze routine vernietigt geen registers
 6076: 1			;******************************************************************************
 6077: 1
 6078: 1			;'Toets ingedrukt mode' enty van de routine
 6079: 1  1556	C0 E0		Keydown:        push    acc            ;registers bewaren
 6080: 1  1558	C0 D0		                push    psw
 6081: 1  155A	C0 F0		                push    b
 6082: 1  155C	C0 82		                push    dpl
 6083: 1  155E	C0 83		                push    dph
 6084: 1  1560	E8		                mov     a,r0
 6085: 1  1561	C0 E0		                push    acc
 6086: 1  1563	E9		                mov     a,r1
 6087: 1  1564	C0 E0		                push    acc
 6088: 1  1566	EA		                mov     a,r2
 6089: 1  1567	C0 E0		                push    acc
 6090: 1  1569	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6091: 1  156B	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6092: 1  156D	80 15		                sjmp    Key1           ;continue
 6093: 1
 6094: 1			;'Flankdetectiemode' entry van de routine
 6095: 1  156F	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6096: 1  1571	C0 D0		                push    psw
 6097: 1  1573	C0 F0		                push    b
 6098: 1  1575	C0 82		                push    dpl
 6099: 1  1577	C0 83		                push    dph
 6100: 1  1579	E8		                mov     a,r0
 6101: 1  157A	C0 E0		                push    acc
 6102: 1  157C	E9		                mov     a,r1
 6103: 1  157D	C0 E0		                push    acc
 6104: 1  157F	EA		                mov     a,r2
 6105: 1  1580	C0 E0		                push    acc
 6106: 1  1582	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6107: 1  1584	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6108: 1  1586	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6109: 1  1588	E6		                mov     a,@r0         ;map entry ophalen
 6110: 1  1589	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6111: 1  158C	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6112: 1  158E	C4		                swap    a             ;map1 en map0 omwisselen
 6113: 1  158F	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6114: 1  1591	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6115: 1  1592	33		                rlc     a             ;kolombit testen
 6116: 1  1593	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6117: 1  1595	33		                rlc    a              ;nee, dan verder roteren
 6118: 1  1596	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6119: 1  1598	08		                inc     r0            ;rijpointer in maps verder zetten
 6120: 1  1599	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6121: 1  159B	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6122: 1
 6123: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6124: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6125: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6126: 1
 6127: 1  159D	1A		toetsin:        dec     r2            ;rij-1
 6128: 1  159E	19		                dec     r1            ;kolom-1
 6129: 1  159F	EA		                mov     a,r2          ;neem rij-1
 6130: 1  15A0	23		                rl      a             ;(rij-1)x2
 6131: 1  15A1	23		                rl      a              ;(rij-1)x4
 6132: 1  15A2	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6133: 1  15A3	90 15 C1	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6134: 1  15A6	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6135: 1  15A7	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6136: 1  15A9	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6137: 1  15AB	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6138: 1  15AD	D0 E0		                pop     acc            ;herstellen registers
 6139: 1  15AF	FA		                mov     r2,a
 6140: 1  15B0	D0 E0		                pop     acc
 6141: 1  15B2	F9		                mov     r1,a
 6142: 1  15B3	D0 E0		                pop     acc
 6143: 1  15B5	F8		                mov     r0,a
 6144: 1  15B6	D0 83		                pop     dph
 6145: 1  15B8	D0 82		                pop     dpl
 6146: 1  15BA	D0 F0		                pop     b
 6147: 1  15BC	D0 D0		                pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6148: 1  15BE	D0 E0		                pop     acc
 6149: 1  15C0	22		                ret                    ;terug naar caller
 6150: 1			;******************************************************************************
 6151: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6152: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6153: 1
 6154: 1  15C1	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6155: 1  15C2	30		                db    '0'    ;kolom2@rij4 toets
 6156: 1  15C3	23		                db    '#'    ;kolom3@rij4 toets
 6157: 1  15C4	44		                db    'D'    ;kolom4@rij4 toets
 6158: 1
 6159: 1  15C5	37		                db    '7'    ;kolom1@rij3 toets
 6160: 1  15C6	38		                db    '8'    ;kolom2@rij3 toets
 6161: 1  15C7	39		                db    '9'    ;kolom3@rij3 toets
 6162: 1  15C8	43		                db    'C'    ;kolom4@rij3 toets
 6163: 1
 6164: 1  15C9	34		                db    '4'    ;kolom1@rij2 toets
 6165: 1  15CA	35		                db    '5'    ;kolom2@rij2 toets
 6166: 1  15CB	36		                db    '6'    ;kolom3@rij2 toets
 6167: 1  15CC	42		                db    'B'    ;kolom4@rij2 toets
 6168: 1
 6169: 1  15CD	31		                db    '1'    ;kolom1@rij1 toets
 6170: 1  15CE	32		                db    '2'    ;kolom2@rij1 toets
 6171: 1  15CF	33		                db    '3'    ;kolom3@rij1 toets
 6172: 1  15D0	41		                db    'A'    ;kolom4@rij1 toets
 6173: 1
 6174: 1			;******************************************************************************
 6175: 1			; switch_init
 6176: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6177: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6178: 1			; input : niets
 6179: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6180: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6181: 1			;
 6182: 1			; Deze routine vernietigt niets
 6183: 1			;******************************************************************************
 6184: 1
 6185: 1  15D1	C0 E0		switch_init:    push    acc
 6186: 1  15D3	C0 D0		                push    psw
 6187: 1  15D5	C0 F0		                push    b
 6188: 1  15D7	E8		                mov     a,r0         ;bewaar registers
 6189: 1  15D8	C0 E0		                push    acc
 6190: 1
 6191: 1  15DA	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6192: 1  15DC	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6193: 1  15DF	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6194: 1  15E1	08		                inc     r0           ;volgende byte nemen
 6195: 1  15E2	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6196: 1  15E5	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6197: 1  15E7	C2 03		                clr     negvalid
 6198: 1  15E9	C2 04		                clr     posvalid
 6199: 1
 6200: 1  15EB	D0 E0		                pop     acc
 6201: 1  15ED	F8		                mov     r0,a
 6202: 1  15EE	D0 F0		                pop     b
 6203: 1  15F0	D0 D0		                pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6204: 1  15F2	D0 E0		                pop     acc
 6205: 1  15F4	22		                ret                   ;terug naar caller
 6206: 1
 6207: 1			;******************************************************************************
 6208: 1			; read_switch
 6209: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6210: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6211: 1			; Deze routine werkt volgens onderstaand blokschema.
 6212: 1			;
 6213: 1			;                                  ___                    ___
 6214: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6215: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6216: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6217: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6218: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6219: 1			;             |____|    |____|              |____|  ----o| 3 |
 6220: 1			;                |         |                   |      |  |   |
 6221: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6222: 1			;         _______*_________*___________________|       --|___|---- posedge
 6223: 1			;
 6224: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6225: 1			;                              (swvalid-flag)
 6226: 1			;            switch1   switch2    debounce      closed
 6227: 1			;
 6228: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6229: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6230: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6231: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6232: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6233: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6234: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6235: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6236: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6237: 1			; een detector voor positieve flanken (posedge).
 6238: 1			;
 6239: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6240: 1			;         bij aduc832v1.1 :
 6241: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6242: 1			;         bij aduc832v2.0 :
 6243: 1			;         als f0=0 dan: schakelaars op p0
 6244: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6245: 1			;
 6246: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6247: 1			;         geactualiseerd.
 6248: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6249: 1			;                  schakelaars weergeeft
 6250: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6251: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6252: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6253: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6254: 1			;                  werd gedetecteerd op een schakelaar.
 6255: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6256: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6257: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6258: 1			;                  werd gedetecteerd op een schakelaar.
 6259: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6260: 1			;
 6261: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6262: 1			; en flags te initialiseren.
 6263: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6264: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6265: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6266: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6267: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6268: 1			; bijhorende flag resetten.
 6269: 1			;
 6270: 1			; Deze routine vernietigt niets
 6271: 1			;******************************************************************************
 6272: 1  15F5	C0 E0		read_switch:    push    acc            ;registers bewaren
 6273: 1  15F7	C0 D0		                push    psw
 6274: 1  15F9	C0 F0		                push    b
 6275: 1			;Flipflops uitvoeren is bytes doorschuiven
 6276: 1  15FB	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6277: 1  15FE	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6278: 1
 6279: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6280: 1			                clr      a
 6281: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6282: 1			                mov     acc.0,c
 6283: 1			                mov     c,p0.1
 6284: 1			                mov     acc.1,c
 6285: 1			                mov     b,a            ;even bewaren
 6286: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6287: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6288: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6289: 1			endif        ;einde aduc832_v1_1
 6290: 1
 6291: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6292: 1  1601	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6293: 1  1604	E5 80		                mov     a,p0           ;lees de schakelaars
 6294: 1  1606	80 04		                sjmp    lowlogic
 6295: 1  1608	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6296: 1  160A	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6297: 1			endif        ;einde aduc832_2_0
 6298: 1
 6299: 1  160C	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6300: 1  160D	F5 40		                mov     switch1,a      ;en sample opslaan
 6301: 1
 6302: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6303: 1
 6304: 1  160F	E5 40		                mov     a,switch1      ;neem laatste sample
 6305: 1  1611	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6306: 1  1613	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6307: 1  1615	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6308: 1			;negatieve flankdetectie
 6309: 1  1617	E5 43		                mov     a,closed      ;neem 3de FF
 6310: 1  1619	F4		                cpl     a             ;complementeer
 6311: 1  161A	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6312: 1  161C	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6313: 1  161E	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6314: 1  1620	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6315: 1  1622	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111



 Line  I  Addr  Code            Source

 6316: 1			;positieve flankdetectie
 6317: 1  1624	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6318: 1  1626	F4		                cpl     a             ;complementeer
 6319: 1  1627	55 43		                anl     a,closed      ;combineer met 3de FF
 6320: 1  1629	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6321: 1  162B	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6322: 1  162D	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6323: 1  162F	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6324: 1  1631	D0 D0		                pop     psw
 6325: 1  1633	D0 E0		                pop     acc
 6326: 1  1635	22		                ret
 6327: 1
 6328: 1			endif    ;einde van aduc_key
 6329: 1
 6330: 1
 6331:				end





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 150
ACC				  DATA	      E0	  69
ADCCON1				  DATA	      EF	  72
ADCCON2				  DATA	      D8	  65
ADCCON3				  DATA	      F5	  78
ADCDATAH			  DATA	      DA	  67
ADCDATAL			  DATA	      D9	  66
ADCGAINH			  DATA	      F4	  77
ADCGAINL			  DATA	      F3	  76
ADCI				  BIT	      DF	 159
ADCOFSH				  DATA	      F2	  75
ADCOFSL				  DATA	      F1	  74
ADC_INIT			  CODE	    13F4	5580
ADC_INIT1			  CODE	    1401	5586
ADC_SINGLE			  CODE	    1406	5625
ADC_SINGLE1			  CODE	    1412	5631
ADC_SINGLE2			  CODE	    143D	5657
ADC_SINGLE20			  CODE	    1447	5662
ADC_SINGLE21			  CODE	    144F	5668
ADC_SINGLE3			  CODE	    1452	5672
ADC_SINGLE30			  CODE	    1472	5693
ADC_SINGLE31			  CODE	    147C	5698
ADC_SINGLE4			  CODE	    1484	5707
ADC_SINGLE40			  CODE	    1490	5715
ADC_SINGLE41			  CODE	    149A	5720
ADC_SINGLE42			  CODE	    14A0	5724
ADC_SINGLE43			  CODE	    14A8	5730
ADD16				  CODE	    094B	2932
ADD161				  CODE	    095F	2948
ADD32				  CODE	    099D	3029
ADD321				  CODE	    09B7	3053
ADUC832_V2_0			  NUMBER    0001	 238
ADUC_ADC			  NUMBER    0001	 259
ADUC_I2C			  NUMBER    0001	 256
ADUC_KEY			  NUMBER    0001	 260
ADUC_LCD			  NUMBER    0001	 253
ADUC_MATH			  NUMBER    0001	 258
ADUC_SIO			  NUMBER    0001	 257
ASCBINTRANS			  CODE	    05FB	1985
ASCBINTRANS1			  CODE	    0610	1996
ASCBINTRANS2			  CODE	    060F	1995
ASCBINTRANS3			  CODE	    0603	1989
ASCBINTRANS4			  CODE	    060C	1993
ASCCTR				  CODE	    05D2	1931
ASCCTR1				  CODE	    05D5	1932
ASCCTR2				  CODE	    05DA	1934
ASCCTR3				  CODE	    05DE	1937
ASCII1				  CODE	    0611	2007

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII2				  CODE	    0616	2021
ASCII21				  CODE	    0628	2030
ASCII4				  CODE	    062B	2044
ASCII41				  CODE	    063A	2051
B				  DATA	      F0	  73
BACKLIGHT			  BIT	      F6	 405
BACKSP				  NUMBER    0008	1630
BARCHARS			  CODE	    02BB	1031
BAREINDE			  CODE	    02E2	1074
BARLCD				  CODE	    0256	 952
BARLCD1				  CODE	    0291	 986
BARLCD2				  CODE	    0298	 991
BARLCD3				  CODE	    02A1	 999
BARLCD4				  CODE	    02A6	1003
BARLCDE				  CODE	    02AE	1008
BARLCD_1			  CODE	    0271	 968
BATRANS				  CODE	    05ED	1967
BATRANS1			  CODE	    05F2	1969
BATRANS2			  CODE	    05F6	1971
BCDHEX16			  CODE	    06B0	2246
BCDHEX161			  CODE	    06BE	2254
BCDHEX1611			  CODE	    06C7	2258
BCDHEX1612			  CODE	    06D1	2263
BCDHEX1613			  CODE	    06DA	2267
BCDHEX162			  CODE	    0725	2321
BCDHEX8				  CODE	    063B	2137
BCDHEX81			  CODE	    0649	2145
BCDHEX811			  CODE	    0652	2149
BCDHEX82			  CODE	    0674	2173
BDELETE				  CODE	    05AD	1897
BDELETE1			  CODE	    05BB	1905
BDELETE2			  CODE	    05CE	1916
BDELETE3			  CODE	    05BF	1907
BEEP				  NUMBER    0007	1631
BLANK				  NUMBER    0020	1625
BUILD				  CODE	    02E3	1106
BUILD1				  CODE	    02FB	1148
BUILD2				  CODE	    030A	1155
BUILD3				  CODE	    02FE	1149
BUILD_ADR			  CODE	    02F1	1143
BUZZER				  BIT	      F7	 406
CAP2				  BIT	      C8	 136
CCONV				  BIT	      DD	 157
CFG832				  DATA	      AF	  38
CGRAM				  NUMBER    0040	 421
CHIPID				  DATA	      C2	  52
CLEARDISP			  NUMBER    0001	 411
CLOSED				  NUMBER    0043	 325
CMP16				  CODE	    112C	4963
CMP161				  CODE	    1149	4982
CMP162				  CODE	    1155	4991
CMP32				  CODE	    11CD	5110
CMP321				  CODE	    11F6	5137
CMP322				  CODE	    1202	5146
CNT2				  BIT	      C9	 137
CORDIC				  CODE	    1296	5297

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CORDIC0				  CODE	    1301	5362
CORDIC00			  CODE	    12E7	5347
CORDIC000			  CODE	    12BA	5321
CORDIC1				  CODE	    1315	5376
CORDIC2				  CODE	    1349	5426
CORDIC3				  CODE	    1354	5433
CORDIC4				  CODE	    1379	5467
CORDIC40			  CODE	    137E	5471
CORDIC41			  CODE	    1397	5487
CORDIC5				  CODE	    139D	5493
CORDIC50			  CODE	    13AF	5503
CORDIC51			  CODE	    13C8	5518
CORDIC52			  CODE	    13D3	5527
CORDIC5A			  CODE	    13AD	5502
CORDIC5B			  CODE	    13C6	5517
CORDIC_ATAN			  CODE	    13D6	5533
CORDIC_ERROR			  CODE	    12CA	5329
CORDIC_MIN90			  CODE	    12CF	5333
CORDIC_NUL			  CODE	    12F3	5353
CORDIC_PLUS90			  CODE	    12DB	5340
CPHA				  BIT	      FA	 174
CPOL				  BIT	      FB	 175
CR				  NUMBER    000D	1628
CS0				  BIT	      D8	 152
CS1				  BIT	      D9	 153
CS2				  BIT	      DA	 154
CS3				  BIT	      DB	 155
CURSATHOM			  NUMBER    0002	 412
CURSOROFF			  NUMBER    000C	 417
CURSORONB			  NUMBER    000F	 418
CURSORONN			  NUMBER    000E	 419
CY				  BIT	      D7	 151
D0				  BIT	      ED	 161
D0EN				  BIT	      EB	 160
D1				  BIT	      EF	 163
D1EN				  BIT	      EE	 162
DAC0H				  DATA	      FA	  82
DAC0L				  DATA	      F9	  81
DAC1H				  DATA	      FC	  84
DAC1L				  DATA	      FB	  83
DACCON				  DATA	      FD	  85
DCON				  DATA	      E8	  70
DDRAM				  NUMBER    0080	 422
DEBOUNCE			  NUMBER    0042	 324
DELAY2MS			  CODE	    0318	1172
DELAY2MS1			  CODE	    031E	1175
DELAY60US			  CODE	    0329	1192
DELAY60US1			  CODE	    033B	1206
DELAY60US2			  CODE	    0339	1205
DIPSWITCH			  NUMBER    0001	 278
DISPDPTR			  CODE	    0503	1739
DISPDPTRLCD			  CODE	    011D	 627
DISPLAYOF			  NUMBER    0008	 416
DISPLAYON			  NUMBER    0001	 415
DIV16				  CODE	    0C12	3715
DIV160				  CODE	    0C20	3726

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DIV161				  CODE	    0C3E	3749
DIV162				  CODE	    0C51	3765
DIV163				  CODE	    0C6D	3790
DIV164				  CODE	    0C7F	3808
DIV32				  CODE	    0CBC	3879
DIV320				  CODE	    0CCC	3892
DIV320A				  CODE	    0CD6	3903
DIV320B				  CODE	    0CF4	3931
DIV320C				  CODE	    0D19	3959
DIV322				  CODE	    0D3E	3993
DIV323				  CODE	    0D88	4069
DIV324				  CODE	    0DBA	4119
DIV8				  CODE	    0BCF	3642
DIV81				  CODE	    0BE7	3658
DMA				  BIT	      DE	 158
DMAH				  DATA	      D3	  62
DMAL				  DATA	      D2	  61
DMAP				  DATA	      D4	  63
DPCON				  DATA	      A7	  34
DPH				  DATA	      83	  11
DPL				  DATA	      82	  10
DPP				  DATA	      84	  12
E				  BIT	      F1	 403
EA				  BIT	      AF	 111
EADC				  BIT	      AE	 110
EADRH				  DATA	      C7	  54
EADRL				  DATA	      C6	  53
ECON				  DATA	      B9	  46
EDATA1				  DATA	      BC	  47
EDATA2				  DATA	      BD	  48
EDATA3				  DATA	      BE	  49
EDATA4				  DATA	      BF	  50
ENDBUF				  NUMBER    007F	1637
ENTRYMODE			  NUMBER    0006	 414
ES				  BIT	      AC	 108
ET0				  BIT	      A9	 105
ET1				  BIT	      AB	 107
ET2				  BIT	      AD	 109
EX0				  BIT	      A8	 104
EX1				  BIT	      AA	 106
EXEN2				  BIT	      CB	 139
EXF2				  BIT	      CE	 142
F0				  BIT	      D5	 149
F1				  BIT	      D1	 145
FF				  NUMBER    000C	1627
FUNCTIONS			  NUMBER    0028	 420
HEXBCD16			  CODE	    072E	2357
HEXBCD161			  CODE	    073C	2364
HEXBCD16_U			  CODE	    0731	2358
HEXBCD8				  CODE	    067D	2198
HEXBCD81			  CODE	    0687	2203
HEXBCD82			  CODE	    068C	2205
HEXBCD83			  CODE	    0696	2211
HEXBUF2LCD			  CODE	    01F9	 893
HEXBUF2LCD1			  CODE	    021D	 909
HEXBUF2LCDE			  CODE	    0234	 920

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBUFTXT			  CODE	    0242	 929
HOUR				  DATA	      A5	  32
HTHSEC				  DATA	      A2	  29
I2CADD				  DATA	      9B	  24
I2CCON				  DATA	      E8	  71
I2CDAT				  DATA	      9A	  23
I2CI				  BIT	      E8	 164
I2CINBYTEA1			  CODE	    0385	1314
I2CINBYTEACK			  CODE	    037E	1311
I2CINBYTEN1			  CODE	    03A6	1338
I2CINBYTENACK			  CODE	    039F	1335
I2CINIT				  CODE	    0343	1256
I2CM				  BIT	      EB	 167
I2COUTBYTE			  CODE	    035E	1288
I2COUTBYTE1			  CODE	    0365	1291
I2CPCF8574			  NUMBER    0040	1247
I2CPCF8574A			  NUMBER    0070	1248
I2CRCVDATA			  CODE	    0400	1440
I2CRCVDATA1			  CODE	    041F	1458
I2CRCVDATA2			  CODE	    0428	1462
I2CRCVDATA3			  CODE	    042F	1467
I2CRCVERROR			  CODE	    043B	1475
I2CRS				  BIT	      EA	 166
I2CSENDDATA			  CODE	    03C0	1378
I2CSENDDATA1			  CODE	    03DF	1395
I2CSENDERROR			  CODE	    03F5	1408
I2CSTART			  CODE	    034C	1265
I2CSTOP				  CODE	    0355	1274
I2CTX				  BIT	      E9	 165
IE				  DATA	      A8	  35
IE0				  BIT	      89	  87
IE1				  BIT	      8B	  89
IEIP2				  DATA	      A9	  36
INBUFA				  CODE	    0572	1854
INBUFA1				  CODE	    0589	1871
INBUFA2				  CODE	    0578	1857
INBUFA3				  CODE	    0596	1877
INBUFA4				  CODE	    058F	1873
INBUFA5				  CODE	    05A9	1885
INBUFA6				  CODE	    059F	1881
INBUFA7				  CODE	    0591	1874
INBYTE				  CODE	    0552	1822
INBYTE1				  CODE	    056F	1834
INCHAR				  CODE	    054A	1806
INITLCD				  CODE	    004D	 437
INITLCD1			  CODE	    005E	 454
INITSIO				  CODE	    04B0	1651
INITSIO1			  CODE	    04B9	1655
INITSIOE			  CODE	    04CF	1672
INT0				  BIT	      B2	 114
INT0_ROUT			  CODE	    0029	 201
INT1				  BIT	      B3	 115
INTVAL				  DATA	      A6	  33
IP				  DATA	      B8	  45
ISPI				  BIT	      FF	 179
IT0				  BIT	      88	  86

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
IT1				  BIT	      8A	  88
KEY				  NUMBER    0038	 311
KEY1				  CODE	    1584	6107
KEY2				  CODE	    1591	6114
KEYDOWN				  CODE	    1556	6079
KEYEDGE				  CODE	    156F	6095
KEYFLAGS			  NUMBER    0020	 286
KEYINIT1			  CODE	    14BE	5850
KEYMAP				  NUMBER    0030	 305
KEYMODE				  BIT	      01	 290
KEYSCAN				  CODE	    14F3	5927
KEYVALID			  BIT	      00	 288
KEY_INIT			  CODE	    14B0	5842
KOLOMLOOP			  CODE	    1593	6116
LCDBUZOFF			  CODE	    049F	1596
LCDBUZON			  CODE	    0492	1580
LCDLIGHTOFF			  CODE	    0485	1564
LCDLIGHTON			  CODE	    0478	1547
LCDPORT				  NUMBER    00F0	 402
LCDTOPORT			  CODE	    045F	1521
LF				  NUMBER    000A	1629
LOOP				  CODE	    0027	 199
LOWLOGIC			  CODE	    160C	6299
LOWUPTR				  CODE	    05E0	1951
LOWUPTR1			  CODE	    05E3	1952
LOWUPTR2			  CODE	    05EC	1956
LOWUPTR3			  CODE	    05E8	1954
MAGSIG16			  CODE	    079D	2469
MAGSIG16A			  CODE	    07AE	2478
MAGSIG16ACC1			  CODE	    07BD	2502
MAGSIG16ACC1A			  CODE	    07CE	2511
MAGSIG16ACC1B			  CODE	    07C9	2508
MAGSIG16ACC1C			  CODE	    07D8	2519
MAGSIG16B			  CODE	    07A9	2475
MAGSIG16C			  CODE	    07B8	2486
MAGSIG32			  CODE	    07DD	2536
MAGSIG32A			  CODE	    07EE	2545
MAGSIG32ACC1			  CODE	    0807	2581
MAGSIG32ACC1A			  CODE	    0818	2590
MAGSIG32ACC1B			  CODE	    0813	2587
MAGSIG32ACC1C			  CODE	    082C	2607
MAGSIG32B			  CODE	    07E9	2542
MAGSIG32C			  CODE	    0802	2562
MAGSIG8				  CODE	    0769	2410
MAGSIG8A			  CODE	    077A	2419
MAGSIG8ACC1			  CODE	    0783	2440
MAGSIG8ACC1A			  CODE	    0794	2449
MAGSIG8ACC1B			  CODE	    078F	2446
MAGSIG8ACC1C			  CODE	    0798	2453
MAGSIG8B			  CODE	    0775	2416
MAGSIG8C			  CODE	    077E	2423
MAP01PTR			  NUMBER    0030	 307
MAP23PTR			  NUMBER    0034	 310
MATRIX				  NUMBER    0001	 276
MCO				  BIT	      ED	 169
MDE				  BIT	      EE	 170

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MDI				  BIT	      EC	 168
MDO				  BIT	      EF	 171
MIN				  DATA	      A4	  31
MUL16				  CODE	    0A87	3301
MUL16ACC1			  CODE	    0AEC	3390
MUL16_10			  CODE	    0EAB	4377
MUL16_100			  CODE	    0EE0	4425
MUL16_I_PI			  CODE	    0E48	4281
MUL16_I_SQRT2			  CODE	    0E8A	4346
MUL16_PI			  CODE	    0E27	4250
MUL16_SQRT2			  CODE	    0E69	4313
MUL816				  CODE	    0B74	3537
MULDIV				  CODE	    0DEB	4192
MULDIV1				  CODE	    0DFB	4204
NEGEDGE				  NUMBER    0044	 326
NEGVALID			  BIT	      03	 295
NOKEY				  CODE	    15AB	6137
OUTBYTE				  CODE	    04EF	1719
OUTBYTELCD			  CODE	    010C	 608
OUTC				  CODE	    01B9	 814
OUTCHAR				  CODE	    04D3	1686
OUTCHAR1			  CODE	    04D5	1687
OUTCHARLCD			  CODE	    00AB	 523
OUTCHARLCD1			  CODE	    00B2	 526
OUTCHARLCD2			  CODE	    00BC	 530
OUTCHARLCD2_0			  CODE	    00B7	 528
OUTCHARLCD3			  CODE	    00C5	 540
OUTCHARLCD4			  CODE	    00CC	 544
OUTCHARLCD5			  CODE	    00D3	 548
OUTCHARLCD6			  CODE	    00DA	 552
OUTCHARLCD7			  CODE	    00E1	 556
OUTCHARLCD8			  CODE	    00E8	 564
OUTCHARLCD9			  CODE	    00ED	 572
OUTCHARLCDE			  CODE	    00F0	 573
OUTD				  CODE	    017F	 736
OUTHNIBC			  CODE	    01CF	 856
OUTHNIBD			  CODE	    018F	 784
OUTMSGA				  CODE	    0516	1758
OUTMSGA1			  CODE	    052B	1769
OUTMSGA2			  CODE	    051E	1762
OUTMSGALCD			  CODE	    0130	 651
OUTMSGALCD1			  CODE	    0138	 658
OUTMSGALCDE			  CODE	    0143	 668
OUTNIB				  CODE	    04DB	1700
OUTNIBLCD			  CODE	    00F5	 587
OUTNIBLCD1			  CODE	    0100	 592
OUTNIBLCDE			  CODE	    0104	 594
OV				  BIT	      D2	 146
P				  BIT	      D0	 144
P0				  DATA	      80	   8
P1				  DATA	      90	  20
P2				  DATA	      A0	  27
P3				  DATA	      B0	  39
PADC				  BIT	      BE	 126
PCF8574A			  NUMBER    0001	1250
PCON				  DATA	      87	  13

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
PJENIS				  CODE	    0040	 215
PLLCON				  DATA	      D7	  64
PORTTOLCD			  CODE	    0446	1493
POSEDGE				  NUMBER    0045	 327
POSVALID			  BIT	      04	 297
PRE0				  BIT	      C4	 132
PRE1				  BIT	      C5	 133
PRE2				  BIT	      C6	 134
PRE3				  BIT	      C7	 135
PS				  BIT	      BC	 124
PSI				  BIT	      BF	 127
PSMCON				  DATA	      DF	  68
PSW				  DATA	      D0	  60
PT0				  BIT	      B9	 121
PT1				  BIT	      BB	 123
PT2				  BIT	      BD	 125
PWM0H				  DATA	      B2	  41
PWM0L				  DATA	      B1	  40
PWM1H				  DATA	      B4	  43
PWM1L				  DATA	      B3	  42
PWMCON				  DATA	      AE	  37
PX0				  BIT	      B8	 120
PX1				  BIT	      BA	 122
RB8				  BIT	      9A	  98
RCAP2H				  DATA	      CB	  57
RCAP2L				  DATA	      CA	  56
RCLK				  BIT	      CD	 141
RD				  BIT	      B7	 119
READ_PORT3			  CODE	    1608	6295
READ_SWITCH			  CODE	    15F5	6272
READ_SWITCH1			  CODE	    1624	6317
READ_SWITCH2			  CODE	    162F	6323
REGTOLCD			  CODE	    014C	 688
REGTOLCD1			  CODE	    015D	 698
REGTOLCD2			  CODE	    016B	 708
REN				  BIT	      9C	 100
RI				  BIT	      98	  96
RIJLOOP				  CODE	    1586	6108
RS				  BIT	      F0	 404
RS0				  BIT	      D3	 147
RS1				  BIT	      D4	 148
RXD				  BIT	      B0	 112
SBUF				  DATA	      99	  22
SCANLOOP			  CODE	    150E	5944
SCON				  DATA	      98	  21
SCONV				  BIT	      DC	 156
SEC				  DATA	      A3	  30
SEQ1				  CODE	    0045	 219
SHIFTLEFT1			  CODE	    1057	4740
SHIFTLEFT2			  CODE	    105F	4746
SHIFTLEFT3			  CODE	    1063	4748
SHIFTLEFT32			  CODE	    104F	4736
SHIFTRIGHT1			  CODE	    102B	4695
SHIFTRIGHT2			  CODE	    1033	4701
SHIFTRIGHT3			  CODE	    1037	4703
SHIFTRIGHT32			  CODE	    1023	4691

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SIGMAG16ACC0			  CODE	    0863	2680
SIGMAG16ACC0A			  CODE	    0872	2689
SIGMAG16ACC1			  CODE	    0883	2715
SIGMAG16ACC1A			  CODE	    0892	2724
SIGMAG16ACC1H			  CODE	    08A3	2750
SIGMAG16ACC1HA			  CODE	    08B2	2759
SIGMAG32ACC0			  CODE	    08C3	2787
SIGMAG32ACC0A			  CODE	    08D2	2796
SIGMAG32ACC1			  CODE	    08ED	2831
SIGMAG32ACC1A			  CODE	    08FC	2840
SIGMAG8ACC0			  CODE	    0831	2624
SIGMAG8ACC0A			  CODE	    0840	2632
SIGMAG8ACC1			  CODE	    084A	2652
SIGMAG8ACC1A			  CODE	    0859	2660
SM0				  BIT	      9F	 103
SM1				  BIT	      9E	 102
SM2				  BIT	      9D	 101
SP				  DATA	      81	   9
SPE				  BIT	      FD	 177
SPH				  DATA	      B7	  44
SPICON				  DATA	      F8	  80
SPIDAT				  DATA	      F7	  79
SPIM				  BIT	      FC	 176
SPR0				  BIT	      F8	 172
SPR1				  BIT	      F9	 173
SQRT32				  CODE	    0F36	4497
SQRT320				  CODE	    0F5D	4519
SQRT321				  CODE	    0F62	4521
SQRT322				  CODE	    0FC5	4603
SQRT323				  CODE	    0FCB	4607
SQRT324				  CODE	    0FEE	4631
SQRT3240			  CODE	    0FE9	4629
SQRT325				  CODE	    0FF1	4633
STACK_INIT			  NUMBER    007F	 182
START				  CODE	    000E	 189
STRTBUF				  NUMBER    0054	1636
SUB16				  CODE	    09FD	3139
SUB161				  CODE	    0A12	3156
SUB32				  CODE	    0A64	3256
SUB321				  CODE	    0A7F	3281
SWINIT				  CODE	    15DF	6193
SWITCH1				  NUMBER    0040	 322
SWITCH2				  NUMBER    0041	 323
SWITCHMAP			  NUMBER    0040	 321
SWITCH_INIT			  CODE	    15D1	6185
SWVALID				  BIT	      02	 293
S_ADD16				  CODE	    0917	2877
S_ADD161			  CODE	    093B	2903
S_ADD162			  CODE	    093F	2905
S_ADD163			  CODE	    0945	2910
S_ADD32				  CODE	    0967	2970
S_ADD321			  CODE	    098F	3001
S_ADD322			  CODE	    0991	3002
S_ADD323			  CODE	    0997	3007
S_CMP16				  CODE	    10E0	4889
S_CMP160			  CODE	    10F3	4906

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_CMP161			  CODE	    1101	4916
S_CMP162			  CODE	    110F	4926
S_CMP163			  CODE	    111E	4938
S_CMP32				  CODE	    115F	5013
S_CMP320			  CODE	    117A	5033
S_CMP321			  CODE	    118E	5047
S_CMP322			  CODE	    11A2	5061
S_CMP323			  CODE	    11B9	5081
S_DIV16				  CODE	    0BEF	3680
S_DIV161			  CODE	    0BFD	3690
S_DIV32				  CODE	    0C97	3842
S_DIV321			  CODE	    0CA7	3854
S_DIV8				  CODE	    0BBD	3619
S_DIV81				  CODE	    0BCE	3625
S_MAC16				  CODE	    0B9B	3579
S_MAC161			  CODE	    0BB7	3599
S_MUL16				  CODE	    0B4D	3481
S_MUL16ACC1			  CODE	    0B5A	3499
S_MUL816			  CODE	    0B67	3518
S_MULDIV			  CODE	    0DC6	4148
S_MULDIV1			  CODE	    0DD6	4160
S_SHIFTLEFT1			  CODE	    10BA	4842
S_SHIFTLEFT2			  CODE	    10C2	4848
S_SHIFTLEFT3			  CODE	    10C6	4853
S_SHIFTLEFT32			  CODE	    10B2	4838
S_SHIFTRIGHT1			  CODE	    1083	4788
S_SHIFTRIGHT2			  CODE	    108B	4794
S_SHIFTRIGHT20			  CODE	    1097	4800
S_SHIFTRIGHT3			  CODE	    1099	4802
S_SHIFTRIGHT32			  CODE	    107B	4784
S_SQRT32			  CODE	    100C	4664
S_SQRT321			  CODE	    101A	4672
S_SUB16				  CODE	    09BF	3075
S_SUB161			  CODE	    09ED	3110
S_SUB162			  CODE	    09F1	3112
S_SUB163			  CODE	    09F7	3117
S_SUB32				  CODE	    0A1A	3178
S_SUB321			  CODE	    0A56	3228
S_SUB322			  CODE	    0A58	3229
S_SUB323			  CODE	    0A5E	3234
T0				  BIT	      B4	 116
T1				  BIT	      B5	 117
T2				  BIT	      90	  94
T2CON				  DATA	      C8	  55
T2EX				  BIT	      91	  95
T3CON				  DATA	      9E	  25
T3FD				  DATA	      9D	  26
TABLE_LU			  CODE	    120C	5173
TABLE_LU1			  CODE	    1231	5199
TABLE_LU2			  CODE	    1242	5212
TABLE_LU3			  CODE	    127B	5255
TABLE_LU4			  CODE	    128D	5268
TABLE_LU_10			  CODE	    1238	5204
TB8				  BIT	      9B	  99
TCLK				  BIT	      CC	 140
TCON				  DATA	      88	  14

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TF0				  BIT	      8D	  91
TF1				  BIT	      8F	  93
TF2				  BIT	      CF	 143
TH0				  DATA	      8C	  18
TH1				  DATA	      8D	  19
TH2				  DATA	      CD	  59
TI				  BIT	      99	  97
TIMECON				  DATA	      A1	  28
TL0				  DATA	      8A	  16
TL1				  DATA	      8B	  17
TL2				  DATA	      CC	  58
TMOD				  DATA	      89	  15
TOETSIN				  CODE	    159D	6127
TOETSTABEL			  CODE	    15C1	6154
TOETS_FLANK			  CODE	    14D5	5881
TOETS_INGEDRUKT			  CODE	    14E4	5904
TR0				  BIT	      8C	  90
TR1				  BIT	      8E	  92
TR2				  BIT	      CA	 138
TXD				  BIT	      B1	 113
WCOL				  BIT	      FE	 178
WDCON				  DATA	      C0	  51
WDE				  BIT	      C1	 129
WDIR				  BIT	      C3	 131
WDS				  BIT	      C2	 130
WDWR				  BIT	      C0	 128
WISSEN				  CODE	    04AC	1633
WR				  BIT	      B6	 118
XOFF				  NUMBER    0013	1626
XONXOFF				  CODE	    0534	1786
XONXOFF1			  CODE	    0540	1792
XONXOFF2			  CODE	    053B	1789
XONXOFF3			  CODE	    0545	1794
