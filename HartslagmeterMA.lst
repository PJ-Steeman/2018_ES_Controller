
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\HartslagmeterMA.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\HartslagmeterMA.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\HartslagmeterMA.lst



 Line  I  Addr  Code            Source

    1:				;Anton Peeters & Pieter-Jan Steeman
    2:
    3:				$nolist
  181:
  182:		N      0090	stack_init	equ	090h
  183:		N      0080	startbuffer	equ	080h
  184:		N      0071	rammsb		equ	071h
  185:		N      0070	ramlsb		equ	070h
  186:		N      0072	teller		equ	072h
  187:		N      0000			org	0000h
  188:
  189:	  0000	02 00 2E			ljmp	start
  190:		N      002B			org	002bh
  191:	  002B	02 00 64			ljmp	int_rout
  192:
  193:	  002E	75 81 90	start:		mov	sp,#stack_init		;init van de stack
  194:	  0031	75 D7 00			mov	pllcon,#0
  195:	  0034	7E 80				mov	r6,#startbuffer		;locatie van de start van de barrel
  196:	  0036	78 01				mov	r0,#1			;voor lcd init
  197:	  0038	12 00 DF			lcall	initlcd
  198:	  003B	12 05 0A			lcall	lcdlighton
  199:
  200:	  003E	12 14 86			lcall 	adc_init
  201:	  0041	75 FD 1D			mov	daccon,#00011101b
  202:
  203:	  0044	D2 D4				setb	rs1
  204:
  205:	  0046	90 03 4D			mov	dptr,#barchars
  206:	  0049	12 03 75			lcall	build
  207:
  208:	  004C	D2 AF				setb	ea
  209:	  004E	D2 AD				setb	et2
  210:
  211:	  0050	75 CC B1			mov	tl2,#0b1h
  212:	  0053	75 CD E4			mov	th2,#0e4h
  213:	  0056	75 CA B1			mov	rcap2l,#0b1h		;wacht 5ms
  214:	  0059	75 CB E4			mov	rcap2h,#0e4h		;wacht 5ms
  215:	  005C	75 C8 04			mov	t2con,#00000100b
  216:
  217:	  005F			loop:		;doe een context switch naar een andere registerbank, zodat het scherm niet flipt.
  218:	  005F	12 00 9B			lcall	bar			;zet de waardes om naar een barchart
  219:	  0062	80 FB				sjmp	loop
  220:

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  221:	  0064	C0 E0		int_rout:	push	acc
  222:	  0066	C0 D0				push	psw
  223:	  0068	C2 D4				clr	rs1
  224:	  006A	C2 CF				clr	tf2
  225:	  006C	12 00 7C			lcall	adcbuffer		;adc en buffer toewijzing
  226:	  006F	12 00 B2			lcall	gemiddelde
  227:	  0072	12 00 92			lcall	todac
  228:	  0075	B2 A0				cpl	p2.0
  229:	  0077	D0 D0				pop	psw
  230:	  0079	D0 E0				pop	acc
  231:	  007B	32				reti
  232:
  233:	  007C	78 27		adcbuffer:	mov	r0,#00100111b		;initialiseer de nodige waardes voor een 12bit signa
				al
  234:	  007E	12 14 98			lcall	adc_single
  235:	  0081	E8				mov	a,r0			;zet ingelezen waardes in r2 en r3(lsb en msb)
  236:	  0082	FA				mov	r2,a
  237:	  0083	E9				mov	a,r1
  238:	  0084	FB				mov	r3,a
  239:	  0085	EE				mov	a,r6
  240:	  0086	F8				mov	r0,a
  241:	  0087	EA				mov	a,r2
  242:	  0088	F6				mov	@r0,a			;zet lsb in barrel
  243:	  0089	08				inc	r0
  244:	  008A	EB				mov	a,r3
  245:	  008B	F6				mov	@r0,a			;zet msb in barrel
  246:	  008C	08				inc	r0
  247:	  008D	E8				mov	a,r0
  248:	  008E	54 8F				anl	a,#08fh			;indien buiten barrelregister zou gaan -> terug naar
				 onder
  249:	  0090	FE				mov	r6,a
  250:	  0091	22				ret
  251:
  252:	  0092	A9 71		todac:		mov	r1,rammsb			;gemiddelde msb in r1
  253:	  0094	89 FA				mov	dac0h,r1		;gemiddelde msb naar DAC
  254:	  0096	A8 70				mov	r0,ramlsb			;gemiddelde lsb in r0
  255:	  0098	88 F9				mov	dac0l,r0		;gemiddelde lsb naar DAC
  256:	  009A	22				ret
  257:
  258:	  009B	A9 71		bar:		mov	r1,rammsb			;gemiddelde msb in r1
  259:	  009D	A8 70				mov	r0,ramlsb			;gemiddelde lsb in r0
  260:	  009F	7D 00				mov	r5,#0
  261:	  00A1	7C 69				mov	r4,#105			;nodig voor div16 (4096/40)
  262:	  00A3	12 0C A4			lcall	div16			;quotient terug in r0
  263:	  00A6	E8				mov	a,r0
  264:						;lcall	outbytelcd
  265:	  00A7	FA				mov	r2,a			;zet de waarde om in bars
  266:	  00A8	78 28				mov	r0,#40
  267:	  00AA	74 40				mov	a,#40h
  268:	  00AC	8A F0				mov	b,r2
  269:	  00AE	12 02 E8			lcall	barlcd
  270:	  00B1	22				ret
  271:
  272:	  00B2	7F 80		gemiddelde:	mov	r7,#startbuffer		;start van de barrel in r7
  273:	  00B4	75 72 08			mov	teller,#8			;looptiloop init
  274:	  00B7	79 00				mov	r1,#0

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  275:	  00B9	78 00				mov	r0,#0
  276:	  00BB	E9		looptiloop:	mov	a,r1
  277:	  00BC	FB				mov	r3,a
  278:	  00BD	EF				mov	a,r7
  279:	  00BE	F9				mov	r1,a
  280:	  00BF	E7				mov	a,@r1
  281:	  00C0	FC				mov	r4,a			;lsb in r4
  282:	  00C1	09				inc	r1
  283:	  00C2	E7				mov	a,@r1			;msb in r5
  284:	  00C3	FD				mov	r5,a
  285:	  00C4	09				inc	r1
  286:	  00C5	E9				mov	a,r1
  287:	  00C6	FF				mov	r7,a
  288:	  00C7	EB				mov	a,r3
  289:	  00C8	F9				mov	r1,a
  290:	  00C9	12 09 DD			lcall	add16			;16 bit opteller
  291:	  00CC	E5 72				mov	a,teller
  292:	  00CE	14				dec	a
  293:	  00CF	F5 72				mov	teller,a
  294:	  00D1	70 E8				jnz	looptiloop
  295:	  00D3	7D 00				mov	r5,#0
  296:	  00D5	7C 08				mov	r4,#8
  297:	  00D7	12 0C A4			lcall	div16
  298:	  00DA	88 70				mov	ramlsb,r0			;lsb in RAM
  299:	  00DC	89 71				mov	rammsb,r1			;msb in RAM
  300:	  00DE	22				ret
  301:
  302:				$include (c:/aduc800_mideA.inc)
  303: 1			;******************************************************************************
  304: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  305: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  306: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  307: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  308: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  309: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  310: 1			;******************************************************************************
  311: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  312: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  313: 1			;******************************************************************************
  314: 1
  315: 1
  316: 1			;******************************************************************************
  317: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  318: 1			; hebben voor onze toepassing. Door een module te definieren via het
  319: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  320: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  321: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  322: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  323: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  324: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  325: 1			; definities.
  326: 1			;******************************************************************************
  327: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  328: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  329: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  330: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  331: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  332: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  333: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  334: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  335: 1
  336: 1			ifdef    aduc_key
  337: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  338: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  339: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  340: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  341: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  342: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  343: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  344: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  345: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  346: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  347: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  348: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  349: 1			;definities wel gemaakt worden.
  350: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  351: 1			                            ;anders commentaar van maken!
  352: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  353: 1			                            ;gelezen, anders commentaar van maken!
  354: 1			;******************************************************************************
  355: 1			;Declaraties van de flags voor de aduc_key driver.
  356: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  357: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  358: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  359: 1			;switch_init en read_switch.
  360: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  361: 1			                                ;bereik = 20h-2fh!
  362: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  363: 1			                                   ;een geldige waarde bevat
  364: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  365: 1			                                   ;die de detectie mode aangeeft
  366: 1			;declaratie van de read_switch flags
  367: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  368: 1			                                   ;ontdenderde schakelaars zijn
  369: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  370: 1			                                   ;flanken zijn
  371: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  372: 1			                                   ;flanken zijn
  373: 1			ifdef    matrix        ;matrix keyboard
  374: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  375: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  376: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  377: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  378: 1			;toepassing.
  379: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  380: 1			                                ;geheugenbuffer
  381: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  382: 1			                                ;debounce en de flankdetectie samples stockeren
  383: 1			                                ;de eerste 4 bytes dienen voor debouncing
  384: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  385: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  386: 1			                                ;toetswaarde aangeeft

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  387: 1			                                ;bij een geldige keyvalid flag ('1')
  388: 1			endif    ;einde matrix keyboard
  389: 1
  390: 1			ifdef    dipswitch
  391: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  392: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  393: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  394: 1			;toepassing
  395: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  396: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  397: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  398: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  399: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  400: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  401: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  402: 1			endif    ;einde dipswitch
  403: 1			;******************************************************************************
  404: 1			endif    ;einde aduc_key
  405: 1
  406: 1
  407: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  408: 1
  409: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  410: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  411: 1			endif                               ;dus doen we dit hier nog eens!
  412: 1			;******************************************************************************
  413: 1
  414: 1			;******************************************************************************
  415: 1			;
  416: 1			; ADuc_lcd.inc
  417: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  418: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  419: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  420: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  421: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  422: 1			; het plaatsen van de cursor op een correcte plaats).
  423: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  424: 1			; display gebruiken.
  425: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  426: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  427: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  428: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  429: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  430: 1			;
  431: 1			; Versie ADuC832v1.1:
  432: 1			; Hier is het LCD verbonden met pinnen van poort0
  433: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  434: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  435: 1			;
  436: 1			; Versie ADuC832v2.2:
  437: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  438: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  439: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  440: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  441: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  442: 1			;

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  443: 1			;
  444: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  445: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  446: 1			;  aduclcd0.inc
  447: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  448: 1			;  aduclcd1.inc
  449: 1			;    -00dh en 00ah worden door outchar verwerkt
  450: 1			;    -bij de init wordt het display anders opgestart
  451: 1			;
  452: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  453: 1			;  van gebruik en uitgebreid  met :
  454: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  455: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  456: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  457: 1			;    debug doeleinden
  458: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  459: 1			;    user codes aan te maken
  460: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  461: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  462: 1			;
  463: 1			; Beschikbare routines:
  464: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  465: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  466: 1			; build_adr, delay2ms, delay60us
  467: 1			;******************************************************************************
  468: 1
  469: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  470: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  471: 1			e             bit    lcdport.2            ;enable
  472: 1			rs            bit    lcdport.3            ;register select
  473: 1			endif    ;einde aduc832_v1_1
  474: 1
  475: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  476: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  477: 1	B	 F1	e             bit    lcdport.1            ;enable
  478: 1	B	 F0	rs            bit    lcdport.0            ;register select
  479: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  480: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  481: 1			endif    ;einde aduc832_v2_0
  482: 1
  483: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  484: 1			;het uitvoeren van de overeenkomstige commando's.
  485: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  486: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  487: 1
  488: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  489: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  490: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  491: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  492: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  493: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  494: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  495: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  496: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  497: 1
  498: 1			;******************************************************************************

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  499: 1			;
  500: 1			; initlcd
  501: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  502: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  503: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  504: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  505: 1			; Na initialisering wordt het scherm leeg gemaakt.
  506: 1			;
  507: 1			; registergebruik: geen
  508: 1			;
  509: 1			;******************************************************************************
  510: 1
  511: 1  00DF	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  512: 1  00E1	C0 D0		              push   psw
  513: 1  00E3	C0 F0		              push   b
  514: 1			ifdef  aduc832_v1_1
  515: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  516: 1			                                   ;let op:twee laagste bits worden
  517: 1			                                   ;niet gebruikt
  518: 1			endif
  519: 1
  520: 1			ifdef    aduc832_v2_0
  521: 1  00E5	12 03 D5	              lcall  i2cinit              ;LCD via een I2C bus
  522: 1  00E8	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  523: 1			                                          ;buzzer en backlight  op 1 gezet
  524: 1  00EB	12 04 D8	              lcall  porttolcd            ;data uit b naar het scherm
  525: 1			endif
  526: 1
  527: 1  00EE	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  528: 1  00F0	12 03 AA	initlcd1:     lcall  delay2ms
  529: 1  00F3	D5 E0 FA	              djnz   acc,initlcd1
  530: 1  00F6	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  531: 1  00F8	12 02 61	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  532: 1  00FB	12 03 AA	              lcall  delay2ms      ;om het display altijd opgestart
  533: 1  00FE	74 30		              mov    a,#00110000b  ;te krijgen.
  534: 1  0100	12 02 61	              lcall  outhnibc
  535: 1  0103	12 03 AA	              lcall  delay2ms
  536: 1  0106	74 30		              mov    a,#00110000b
  537: 1  0108	12 02 61	              lcall  outhnibc
  538: 1  010B	12 03 AA	              lcall  delay2ms
  539: 1  010E	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  540: 1  0110	12 02 61	              lcall  outhnibc      ;hoge nibble naar het controleregister
  541: 1  0113	12 03 AA	              lcall  delay2ms      ;niet nodig volgens datasheet
  542: 1  0116	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  543: 1  0118	12 02 4B	              lcall  outc          ;naar display
  544: 1  011B	12 03 AA	              lcall  delay2ms      ;is iets te lang volgens datasheet
  545: 1  011E	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  546: 1  0120	12 02 4B	              lcall  outc
  547: 1  0123	12 03 AA	              lcall  delay2ms      ;ook deze delay is iets te lang
  548: 1  0126	74 01		              mov    a,#displayon  ;clear display and home cursor
  549: 1  0128	12 02 4B	              lcall  outc
  550: 1  012B	12 03 AA	              lcall  delay2ms      ;deze wachttijd is bijna juist
  551: 1  012E	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  552: 1  0130	12 02 4B	              lcall  outc
  553: 1  0133	12 03 AA	              lcall  delay2ms      ;wachten weer veel te lang
  554: 1  0136	D0 F0		              pop    b

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  555: 1  0138	D0 D0		              pop    psw           ;registers terug in orde zetten
  556: 1  013A	D0 E0		              pop    acc
  557: 1  013C	22		              ret                  ;einde van de initialisatie
  558: 1
  559: 1			;******************************************************************************
  560: 1			;
  561: 1			; outcharlcd
  562: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  563: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  564: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  565: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  566: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  567: 1			; De controlekarakters komen overeen met volgende acties:
  568: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  569: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  570: 1			;              (line feed+ carriage return!)
  571: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  572: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  573: 1			;      011h   =cursor on, blink mode
  574: 1			;      012h   =cursor on, no blink mode
  575: 1			;      013h   =cursor off
  576: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  577: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  578: 1			;              van het LCD
  579: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  580: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  581: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  582: 1			; positie 6 (C5H-80H=45H)
  583: 1			;
  584: 1			; Deze routine vernietigt geen registers
  585: 1			;
  586: 1			;******************************************************************************
  587: 1
  588: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  589: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  590: 1			; dataregister van het scherm.
  591: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  592: 1			; controlebyte doorsturen naar het LCD.
  593: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  594: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  595: 1			; naar de LCD sturen.
  596: 1
  597: 1  013D	C0 E0		outcharlcd:   push   acc           ;registers op stack
  598: 1  013F	C0 D0		              push   psw
  599: 1  0141	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  600: 1  0144	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  601: 1  0146	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  602: 1  0149	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  603: 1  014B	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  604: 1  014E	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  605: 1
  606: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  607: 1			; Als het een commando is, moeten we het uitvoeren.
  608: 1			; Indien niet, gewoon terug zonder actie!
  609: 1
  610: 1  0150	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  611: 1  0153	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  612: 1  0155	80 28		              sjmp   outcharlcd9          ;afsluiten
  613: 1
  614: 1  0157	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  615: 1  015A	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  616: 1  015C	80 21		              sjmp   outcharlcd9
  617: 1
  618: 1  015E	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  619: 1  0161	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  620: 1  0163	80 1A		              sjmp   outcharlcd9
  621: 1
  622: 1  0165	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  623: 1  0168	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  624: 1  016A	80 13		              sjmp   outcharlcd9
  625: 1
  626: 1  016C	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  627: 1  016F	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  628: 1  0171	80 0C		              sjmp   outcharlcd9
  629: 1
  630: 1  0173	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  631: 1  0176	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  632: 1  0178	80 05		              sjmp   outcharlcd9
  633: 1
  634: 1
  635: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  636: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  637: 1
  638: 1  017A	12 02 11	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  639: 1  017D	80 03		              sjmp   outcharlcde   ;einde routine
  640: 1
  641: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  642: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  643: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  644: 1			; op dat adres te zetten.
  645: 1
  646: 1  017F	12 02 4B	outcharlcd9:  lcall  outc          ;klaar
  647: 1  0182	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  648: 1  0184	D0 E0		              pop    acc
  649: 1  0186	22		              ret
  650: 1
  651: 1			;******************************************************************************
  652: 1			;
  653: 1			; outniblcd
  654: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  655: 1			; op het lcd scherm.
  656: 1			;
  657: 1			; de routine vernietigt geen registers
  658: 1			;
  659: 1			;******************************************************************************
  660: 1
  661: 1  0187	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  662: 1  0189	C0 D0		              push   psw
  663: 1  018B	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  664: 1  018D	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  665: 1  018F	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  666: 1  0192	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  667: 1  0194	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  668: 1  0196	12 02 11	outniblcde:   lcall  outd          ;naar het scherm
  669: 1  0199	D0 D0		              pop    psw
  670: 1  019B	D0 E0		              pop    acc
  671: 1  019D	22		              ret
  672: 1
  673: 1			;******************************************************************************
  674: 1			;
  675: 1			; outbytelcd
  676: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  677: 1			;
  678: 1			; de routine vernietigt geen registers
  679: 1			;
  680: 1			;******************************************************************************
  681: 1
  682: 1  019E	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  683: 1  01A0	C0 D0		              push   psw
  684: 1  01A2	C4		              swap   a             ;bitjes omruilen
  685: 1  01A3	12 01 87	              lcall  outniblcd
  686: 1  01A6	C4		              swap   a             ;nog eens
  687: 1  01A7	12 01 87	              lcall  outniblcd
  688: 1  01AA	D0 D0		              pop    psw
  689: 1  01AC	D0 E0		              pop    acc
  690: 1  01AE	22		              ret
  691: 1
  692: 1			;******************************************************************************
  693: 1			;
  694: 1			; dispdptrlcd
  695: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  696: 1			;
  697: 1			; de routine vernietigt geen registers
  698: 1			;
  699: 1			;******************************************************************************
  700: 1
  701: 1  01AF	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  702: 1  01B1	C0 D0		              push   psw
  703: 1  01B3	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  704: 1  01B5	12 01 9E	              lcall  outbytelcd
  705: 1  01B8	E5 82		              mov    a,dpl         ;dan het lage deel
  706: 1  01BA	12 01 9E	              lcall  outbytelcd
  707: 1  01BD	D0 D0		              pop    psw
  708: 1  01BF	D0 E0		              pop    acc
  709: 1  01C1	22		              ret
  710: 1
  711: 1			;******************************************************************************
  712: 1			;
  713: 1			; outmsgalcd
  714: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  715: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  716: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  717: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  718: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  719: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  720: 1			;
  721: 1			; de routine vernietigt geen registers
  722: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  723: 1			;******************************************************************************
  724: 1
  725: 1  01C2	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  726: 1  01C4	C0 D0		              push   psw
  727: 1  01C6	C0 83		              push   dph           ;ook de data pointer
  728: 1  01C8	C0 82		              push   dpl
  729: 1
  730: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  731: 1
  732: 1  01CA	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  733: 1  01CB	93		              movc   a,@a+dptr     ;waarde lezen
  734: 1  01CC	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  735: 1
  736: 1			; de code is niet 0 dus versturen met outchar
  737: 1
  738: 1  01CE	12 01 3D	              lcall  outcharlcd    ;weg er mee
  739: 1  01D1	A3		              inc    dptr          ;naar volgende ascii code wijzen
  740: 1  01D2	02 01 CA	              ljmp   outmsgalcd1   ;lus sluiten
  741: 1
  742: 1  01D5	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  743: 1  01D7	D0 83		              pop    dph
  744: 1  01D9	D0 D0		              pop    psw
  745: 1  01DB	D0 E0		              pop    acc
  746: 1  01DD	22		              ret
  747: 1
  748: 1			;******************************************************************************
  749: 1			;
  750: 1			; regtolcd
  751: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  752: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  753: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  754: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  755: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  756: 1			;
  757: 1			; de routine vernietigt geen registers
  758: 1			;
  759: 1			;******************************************************************************
  760: 1
  761: 1
  762: 1  01DE	C0 E0		regtolcd:     push   acc           ;registers op de stack
  763: 1  01E0	C0 D0		              push   psw
  764: 1  01E2	E8		              mov    a,r0
  765: 1  01E3	C0 E0		              push   acc
  766: 1  01E5	E9		              mov    a,r1
  767: 1  01E6	C0 E0		              push   acc
  768: 1  01E8	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  769: 1  01EA	12 01 3D	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  770: 1			                                   ;plaats
  771: 1  01ED	79 00		              mov    r1,#000h      ;werkt als loopcounter
  772: 1  01EF	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  773: 1  01F0	12 01 3D	              lcall  outcharlcd    ;weg er mee
  774: 1  01F3	08		              inc    r0
  775: 1  01F4	09		              inc    r1
  776: 1  01F5	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  777: 1			                                          ;nieuwe lijn genomen worden
  778: 1  01F8	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  779: 1  01FA	12 01 3D	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  780: 1			                                   ;plaats
  781: 1
  782: 1  01FD	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  783: 1  01FE	12 01 3D	              lcall  outcharlcd    ;weg er mee
  784: 1  0201	08		              inc    r0
  785: 1  0202	09		              inc    r1
  786: 1  0203	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  787: 1  0206	D0 E0		              pop    acc
  788: 1  0208	F9		              mov    r1,a
  789: 1  0209	D0 E0		              pop    acc
  790: 1  020B	F8		              mov    r0,a
  791: 1  020C	D0 D0		              pop    psw           ;registers herstellen
  792: 1  020E	D0 E0		              pop    acc
  793: 1  0210	22		              ret
  794: 1
  795: 1			;******************************************************************************
  796: 1			;
  797: 1			; outd
  798: 1			; Is een routine die naar het data register van het display een
  799: 1			; volledige byte stuurt.
  800: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  801: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  802: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  803: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  804: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  805: 1			;
  806: 1			; De routine vernietigt geen registers.
  807: 1			;
  808: 1			;******************************************************************************
  809: 1
  810: 1  0211	C0 E0		outd:         push   acc           ;registers op stack zetten
  811: 1  0213	C0 D0		              push   psw
  812: 1  0215	12 02 21	              lcall  outhnibd      ;hoogste vier bits verzenden
  813: 1			ifdef     aduc832_v1_1
  814: 1			              lcall  delay60us     ;niet echt nodig
  815: 1			endif
  816: 1  0218	C4		              swap   a             ;bitjes omruilen
  817: 1  0219	12 02 21	              lcall  outhnibd      ;naar het scherm sturen
  818: 1
  819: 1			ifdef    aduc832_v1_1
  820: 1			              lcall  delay60us     ;altijd goed
  821: 1			endif
  822: 1
  823: 1  021C	D0 D0		              pop    psw           ;registers terug herstellen
  824: 1  021E	D0 E0		              pop    acc
  825: 1  0220	22		              ret
  826: 1
  827: 1			;******************************************************************************
  828: 1			;
  829: 1			; outhnibd
  830: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  831: 1			; lcd scherm.
  832: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  833: 1			; de routine vernietigt geen registers.
  834: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  835: 1			;******************************************************************************
  836: 1			ifdef     aduc832_v1_1
  837: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  838: 1			              push   psw
  839: 1			              setb   rs            ;controle lijn in orde
  840: 1			              clr    e             ;deselectie display
  841: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  842: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  843: 1			              mov     c,acc.6      ;afblijven!
  844: 1			              mov     lcdport.6,c
  845: 1			              mov     c,acc.5
  846: 1			              mov     lcdport.5,c
  847: 1			              mov     c,acc.4
  848: 1			              mov     lcdport.4,c
  849: 1			              setb   e             ;display enabelen
  850: 1			              nop                  ;450ns is normaal gezien voldoende
  851: 1			              clr    e             ;display deselecteren
  852: 1			              pop    psw           ;registers herstellen
  853: 1			              pop    acc
  854: 1			              ret
  855: 1			endif
  856: 1
  857: 1			ifdef    aduc832_v2_0
  858: 1  0221	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  859: 1  0223	C0 D0		              push   psw
  860: 1  0225	C0 F0		              push   b             ;werkregister
  861: 1  0227	12 04 F1	              lcall  lcdtoport     ;lees de expander naar b register
  862: 1  022A	D2 F0		              setb   rs            ;controle lijn in orde
  863: 1  022C	C2 F1		              clr    e             ;deselectie display
  864: 1  022E	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  865: 1  0230	03		              rr     a             ;bits op juiste plaats zetten
  866: 1  0231	03		              rr     a             ;voor b reg
  867: 1  0232	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  868: 1  0235	42 F0		              orl    b,a           ;bij elkaar voegen
  869: 1  0237	12 04 D8	              lcall  porttolcd     ;naar expander
  870: 1  023A	D2 F1		              setb   e             ;display enabelen
  871: 1  023C	12 04 D8	              lcall  porttolcd
  872: 1  023F	C2 F1		              clr    e             ;display deselecteren
  873: 1  0241	12 04 D8	              lcall  porttolcd
  874: 1  0244	D0 F0		              pop    b
  875: 1  0246	D0 D0		              pop    psw           ;registers herstellen
  876: 1  0248	D0 E0		              pop    acc
  877: 1  024A	22		              ret
  878: 1			endif
  879: 1			;******************************************************************************
  880: 1			;
  881: 1			; outc
  882: 1			; Is een routine die naar het controleregister van het display een
  883: 1			; volledige byte (commando) stuurt.
  884: 1			; De routine vernietigt geen registers.
  885: 1			;
  886: 1			;******************************************************************************
  887: 1
  888: 1  024B	C0 E0		outc:         push   acc           ;registers op stack zetten
  889: 1  024D	C0 D0		              push   psw
  890: 1  024F	12 02 61	              lcall  outhnibc      ;hoogste vier bits verzenden

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  891: 1  0252	12 03 AA	              lcall  delay2ms      ;niet echt nodig
  892: 1  0255	C4		              swap   a             ;bitjes omruilen
  893: 1  0256	12 02 61	              lcall  outhnibc      ;naar het scherm sturen
  894: 1  0259	12 03 AA	              lcall  delay2ms      ;altijd goed voor traagste commando
  895: 1  025C	D0 D0		              pop    psw           ;registers terug herstellen
  896: 1  025E	D0 E0		              pop    acc
  897: 1  0260	22		              ret
  898: 1
  899: 1			;******************************************************************************
  900: 1			;
  901: 1			; outhnibc
  902: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  903: 1			; het lcd scherm.
  904: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  905: 1			; de routine vernietigt geen registers.
  906: 1			;
  907: 1			;******************************************************************************
  908: 1			ifdef     aduc832_v1_1
  909: 1			outhnibc:     push   acc           ;registers op stack plaatsen
  910: 1			              push   psw
  911: 1			              clr    rs            ;controle lijn in orde
  912: 1			              clr    e             ;deselectie display
  913: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  914: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  915: 1			              mov     c,acc.6      ;afblijven!
  916: 1			              mov     lcdport.6,c
  917: 1			              mov     c,acc.5
  918: 1			              mov     lcdport.5,c
  919: 1			              mov     c,acc.4
  920: 1			              mov     lcdport.4,c
  921: 1			              setb   e             ;display enabelen
  922: 1			              nop                  ;450ns is normaal gezien voldoende
  923: 1			              clr    e             ;display deselecteren
  924: 1			              pop    psw           ;registers herstellen
  925: 1			              pop    acc
  926: 1			              ret
  927: 1			endif
  928: 1
  929: 1			ifdef    aduc832_v2_0
  930: 1  0261	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
  931: 1  0263	C0 D0		              push   psw
  932: 1  0265	C0 F0		              push   b             ;werkregister
  933: 1  0267	12 04 F1	              lcall  lcdtoport     ;lees de expander naar b register
  934: 1  026A	C2 F0		              clr    rs            ;controle lijn in orde
  935: 1  026C	C2 F1		              clr    e             ;deselectie display
  936: 1  026E	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  937: 1  0270	03		              rr     a             ;bits op juiste plaats zetten
  938: 1  0271	03		              rr     a             ;voor b reg
  939: 1  0272	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  940: 1  0275	42 F0		              orl    b,a           ;bij elkaar voegen
  941: 1  0277	12 04 D8	              lcall  porttolcd     ;naar expnder
  942: 1  027A	D2 F1		              setb   e             ;display enabelen
  943: 1  027C	12 04 D8	              lcall  porttolcd
  944: 1  027F	C2 F1		              clr    e             ;display deselecteren
  945: 1  0281	12 04 D8	              lcall  porttolcd
  946: 1  0284	D0 F0		              pop    b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  947: 1  0286	D0 D0		              pop    psw           ;registers herstellen
  948: 1  0288	D0 E0		              pop    acc
  949: 1  028A	22		              ret
  950: 1			endif
  951: 1
  952: 1			;******************************************************************************
  953: 1			; hexbuf2lcd
  954: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  955: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  956: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  957: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  958: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  959: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  960: 1			;
  961: 1			; ADR| HEX DATA  |
  962: 1			; 42 |AF 2D 23 5A|
  963: 1			;
  964: 1			; Deze routine vernietigt geen registers
  965: 1			;******************************************************************************
  966: 1
  967: 1  028B	C0 E0		hexbuf2lcd:   push   acc
  968: 1  028D	C0 F0		              push   b
  969: 1  028F	C0 D0		              push   psw
  970: 1  0291	C0 82		              push   dpl
  971: 1  0293	C0 83		              push   dph
  972: 1  0295	E8		              mov     a,r0
  973: 1  0296	C0 E0		              push   acc
  974: 1  0298	90 02 D4	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
  975: 1  029B	12 01 C2	              lcall   outmsgalcd
  976: 1  029E	E8		              mov    a,r0            ;neem pointerwaarde
  977: 1  029F	12 01 9E	              lcall  outbytelcd      ;byte afdrukken als startadres
  978: 1  02A2	74 20		              mov    a,#' '          ;spatie afdrukken
  979: 1  02A4	12 01 3D	              lcall  outcharlcd
  980: 1  02A7	74 7C		              mov    a,#'|'          ;pipe afdrukken
  981: 1  02A9	12 01 3D	              lcall  outcharlcd
  982: 1  02AC	75 F0 04	              mov    b,#4            ;bytecounter=4
  983: 1  02AF	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  984: 1  02B0	12 01 9E	              lcall  outbytelcd      ;byte naar buiten
  985: 1  02B3	74 20		              mov    a,#' '          ;neem whitespace char
  986: 1  02B5	12 01 3D	              lcall  outcharlcd       ;druk af
  987: 1  02B8	08		              inc    r0              ;volgende byte
  988: 1  02B9	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
  989: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  990: 1  02BC	74 CF		              mov    a,#0cfh         ;adres laatste char
  991: 1  02BE	12 01 3D	              lcall   outcharlcd
  992: 1  02C1	74 7C		              mov    a,#'|'          ;neem pipe
  993: 1  02C3	12 01 3D	              lcall  outcharlcd      ;ascii code afdrukken
  994: 1  02C6	D0 E0		hexbuf2lcde:  pop    acc
  995: 1  02C8	F8		              mov   r0,a
  996: 1  02C9	D0 83		              pop   dph
  997: 1  02CB	D0 82		              pop   dpl
  998: 1  02CD	D0 D0		              pop   psw
  999: 1  02CF	D0 F0		              pop   b
 1000: 1  02D1	D0 E0		              pop   acc
 1001: 1  02D3	22		              ret
 1002: 1			                        ;'0123456789abcdef'

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

 1003: 1  02D4	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  02D8	52 7C 20 48
       1  02DC	45 58 20 44
       1  02E0	41 54 41 20
       1  02E4	20 7C C0 00
 1004: 1
 1005: 1
 1006: 1			;******************************************************************************
 1007: 1			; barlcd
 1008: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
 1009: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
 1010: 1			; de inhoud van A
 1011: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
 1012: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
 1013: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
 1014: 1			; aangemaakt in de LCD CGRAM.
 1015: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
 1016: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
 1017: 1			;       lcall build
 1018: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
 1019: 1			;       mov     a, #42h     ;de startlocatie is 42h
 1020: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
 1021: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
 1022: 1			;
 1023: 1			; Deze routine vernietigt geen registers.
 1024: 1			;******************************************************************************
 1025: 1
 1026: 1  02E8	C0 82		barlcd:       push   dpl
 1027: 1  02EA	88 82		              mov     dpl,r0
 1028: 1  02EC	C0 82		              push   dpl
 1029: 1  02EE	C0 E0		              push   acc            ;bewaar startlocatie
 1030: 1  02F0	C0 D0		              push   psw            ;bewaar status
 1031: 1  02F2	C0 F0		              push   b              ;bewaar aantal bar's
 1032: 1  02F4	F5 F0		              mov    b,a            ;bewaar startlocatie
 1033: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
 1034: 1  02F6	E8		              mov    a,r0           ;neem maximum aantal bar's
 1035: 1  02F7	C0 F0		              push   b              ;bewaar startadres
 1036: 1  02F9	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
 1037: 1  02FC	84		              div    ab             ;bereken dus het aantal nodige blokjes
 1038: 1  02FD	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
 1039: 1  02FE	E5 F0		              mov    a,b            ;neem restbars
 1040: 1  0300	60 01		              jz     barlcd_1       ;als nul dan verder
 1041: 1  0302	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
 1042: 1  0303	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
 1043: 1  0305	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
 1044: 1  0307	12 01 3D	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
 1045: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
 1046: 1  030A	74 13		              mov    a,#13h         ;cursor off
 1047: 1  030C	12 01 3D	              lcall  outcharlcd     ;stuur naar LCD
 1048: 1  030F	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
 1049: 1  0311	C0 F0		              push   b              ;en weer bewaren
 1050: 1  0313	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
 1051: 1  0315	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
 1052: 1  0317	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
 1053: 1  031A	84		              div    ab             ;A=aantal volle blokjes, B=rest
 1054: 1  031B	C0 F0		              push   b              ;bewaar rest

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1055: 1  031D	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
 1056: 1  031F	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
 1057: 1
 1058: 1			;Druk de volle 5x8 blokjes af van de bargraph
 1059: 1  0321	74 04		              mov    a,#4           ;neem code voor vol blokje
 1060: 1  0323	12 02 11	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
 1061: 1  0326	18		              dec    r0             ;verminder karaktersteller
 1062: 1  0327	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
 1063: 1
 1064: 1			;Druk het onvolledige blokje (rest) af
 1065: 1  032A	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
 1066: 1  032C	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
 1067: 1  032E	14		              dec    a              ;converteer rest naar code voor de
 1068: 1			                                    ;overeenkomende bar's
 1069: 1  032F	12 02 11	              lcall  outd           ;druk resterende bar's af
 1070: 1  0332	18		              dec    r0             ;verminder karakterteller
 1071: 1
 1072: 1			;Test of we aan het einde van de bargraph zitten..
 1073: 1  0333	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
 1074: 1  0336	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
 1075: 1
 1076: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
 1077: 1  0338	74 20		barlcd4:      mov    a,#' '         ;neem spatie
 1078: 1  033A	12 02 11	              lcall  outd           ;en druk af
 1079: 1  033D	18		              dec    r0             ;karakterteller verminderen
 1080: 1  033E	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
 1081: 1
 1082: 1  0340	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
 1083: 1  0342	D0 D0		              pop    psw            ;haal status weer
 1084: 1  0344	D0 E0		              pop    acc            ;haal startlocatie weer
 1085: 1  0346	D0 82		              pop    dpl
 1086: 1  0348	A8 82		              mov    r0,dpl
 1087: 1  034A	D0 82		              pop    dpl
 1088: 1  034C	22		              ret
 1089: 1
 1090: 1
 1091: 1
 1092: 1			;******************************************************************************
 1093: 1			; barchars
 1094: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
 1095: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
 1096: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
 1097: 1			; kunnen pas daarna worden gebruikt.
 1098: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
 1099: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
 1100: 1			; (max. 3 extra char's).
 1101: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
 1102: 1			; opgeslagen met MSB=1.
 1103: 1			;******************************************************************************
 1104: 1
 1105: 1  034D	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1106: 1  034E	10		              db 00010000b
 1107: 1  034F	10		              db 00010000b
 1108: 1  0350	10		              db 00010000b
 1109: 1  0351	10		              db 00010000b
 1110: 1  0352	10		              db 00010000b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1111: 1  0353	10		              db 00010000b
 1112: 1  0354	10		              db 00010000b
 1113: 1
 1114: 1  0355	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1115: 1  0356	18		              db 00011000b
 1116: 1  0357	18		              db 00011000b
 1117: 1  0358	18		              db 00011000b
 1118: 1  0359	18		              db 00011000b
 1119: 1  035A	18		              db 00011000b
 1120: 1  035B	18		              db 00011000b
 1121: 1  035C	18		              db 00011000b
 1122: 1
 1123: 1  035D	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1124: 1  035E	1C		              db 00011100b
 1125: 1  035F	1C		              db 00011100b
 1126: 1  0360	1C		              db 00011100b
 1127: 1  0361	1C		              db 00011100b
 1128: 1  0362	1C		              db 00011100b
 1129: 1  0363	1C		              db 00011100b
 1130: 1  0364	1C		              db 00011100b
 1131: 1
 1132: 1  0365	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1133: 1  0366	1E		              db 00011110b
 1134: 1  0367	1E		              db 00011110b
 1135: 1  0368	1E		              db 00011110b
 1136: 1  0369	1E		              db 00011110b
 1137: 1  036A	1E		              db 00011110b
 1138: 1  036B	1E		              db 00011110b
 1139: 1  036C	1E		              db 00011110b
 1140: 1
 1141: 1  036D	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1142: 1  036E	1F		              db 00011111b
 1143: 1  036F	1F		              db 00011111b
 1144: 1  0370	1F		              db 00011111b
 1145: 1  0371	1F		              db 00011111b
 1146: 1  0372	1F		              db 00011111b
 1147: 1  0373	1F		              db 00011111b
 1148: 1  0374	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1149: 1
 1150: 1			;******************************************************************************
 1151: 1			;
 1152: 1			; build
 1153: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1154: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1155: 1			; overeen komen met de ASCII codes 00h-07h.
 1156: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1157: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1158: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1159: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1160: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1161: 1			;
 1162: 1			; De routine vernietigt geen registers.
 1163: 1			;
 1164: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1165: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1166: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1167: 1			;      lcall  outcharlcd         ; druk de karakter af
 1168: 1			;
 1169: 1			;eigenkarakter:
 1170: 1			;      db 00001110b
 1171: 1			;      db 00001010b
 1172: 1			;      db 00001110b
 1173: 1			;      db 00000100b
 1174: 1			;      db 00011111b
 1175: 1			;      db 00000100b
 1176: 1			;      db 00001010b
 1177: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1178: 1			;******************************************************************************
 1179: 1
 1180: 1  0375	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1181: 1  0377	C0 D0		              push   psw
 1182: 1  0379	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1183: 1  037B	12 03 83	              lcall  build_adr
 1184: 1  037E	D0 D0		              pop    psw
 1185: 1  0380	D0 E0		              pop    acc
 1186: 1  0382	22		              ret                  ;terug
 1187: 1
 1188: 1			;******************************************************************************
 1189: 1			; build_adr
 1190: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1191: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1192: 1			; die overeen komen met de ASCII codes 00h-07h.
 1193: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1194: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1195: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1196: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1197: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1198: 1			;
 1199: 1			; De routine vernietigt geen registers.
 1200: 1			;
 1201: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1202: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1203: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1204: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1205: 1			;      lcall  outcharlcd        ; druk de karakter af
 1206: 1			;
 1207: 1			;eigenkarakters:
 1208: 1			;      db 00001110b
 1209: 1			;      db 00001010b
 1210: 1			;      db 00001110b
 1211: 1			;       db 00000100b
 1212: 1			;      db 00011111b
 1213: 1			;      db 00000100b
 1214: 1			;      db 00001010b
 1215: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1216: 1			;******************************************************************************
 1217: 1  0383	C0 E0		build_adr:      push   acc
 1218: 1  0385	C0 D0		              push   psw
 1219: 1  0387	C0 83		              push   dph
 1220: 1  0389	C0 82		              push   dpl
 1221: 1  038B	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1222: 1  038D	12 02 4B	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1223: 1  0390	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1224: 1  0392	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1225: 1  0393	12 02 11	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1226: 1  0396	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1227: 1  0399	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1228: 1  039A	80 F4		              sjmp   build3
 1229: 1  039C	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1230: 1  039E	12 02 4B	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1231: 1  03A1	D0 82		              pop    dpl
 1232: 1  03A3	D0 83		              pop    dph
 1233: 1  03A5	D0 D0		              pop    psw
 1234: 1  03A7	D0 E0		              pop    acc
 1235: 1  03A9	22		              ret
 1236: 1
 1237: 1			;******************************************************************************
 1238: 1			;
 1239: 1			; delay2ms
 1240: 1			; Is een vertragingsroutine van 2ms.
 1241: 1			;
 1242: 1			; De routine vernietigt geen registers.
 1243: 1			;
 1244: 1			;******************************************************************************
 1245: 1
 1246: 1  03AA	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1247: 1  03AC	C0 D0		              push   psw
 1248: 1  03AE	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1249: 1  03B0	12 03 BB	delay2ms1:    lcall  delay60us
 1250: 1  03B3	D5 E0 FA	              djnz   acc,delay2ms1
 1251: 1  03B6	D0 D0		              pop    psw           ;registers herstellen
 1252: 1  03B8	D0 E0		              pop    acc
 1253: 1  03BA	22		              ret
 1254: 1
 1255: 1			;******************************************************************************
 1256: 1			;
 1257: 1			; delay60us.
 1258: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1259: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1260: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1261: 1			;
 1262: 1			; de routine vernietigt geen registers.
 1263: 1			;
 1264: 1			;******************************************************************************
 1265: 1
 1266: 1  03BB	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1267: 1  03BD	C0 D0		              push   psw
 1268: 1  03BF	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1269: 1  03C1	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1270: 1
 1271: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1272: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1273: 1
 1274: 1  03C3	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1275: 1  03C6	D0 E0		              pop    acc           ;registers herstellen
 1276: 1  03C8	D0 D0		              pop    psw
 1277: 1  03CA	22		              ret
 1278: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1279: 1  03CB	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1280: 1  03CD	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1281: 1  03D0	D0 D0		              pop    psw
 1282: 1  03D2	D0 E0		              pop    acc
 1283: 1  03D4	22		              ret
 1284: 1
 1285: 1			endif        ;einde van aduc_lcd
 1286: 1
 1287: 1
 1288: 1
 1289: 1
 1290: 1			ifdef aduc_i2c
 1291: 1			;******************************************************************************
 1292: 1			;
 1293: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1294: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1295: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1296: 1			;
 1297: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1298: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1299: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1300: 1			;
 1301: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1302: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1303: 1			;
 1304: 1			; Beschikbare routines:
 1305: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1306: 1			; i2cstart     :verzenden van een start conditie
 1307: 1			; i2cstop      :verzenden van een stop conditie
 1308: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1309: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1310: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1311: 1			;               negende klokpuls
 1312: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1313: 1			;               negende klokpuls
 1314: 1			;
 1315: 1			; Toevoeging [dp]
 1316: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1317: 1			;               een slavedevice
 1318: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1319: 1			;               en plaatst deze in een geheugenbuffer
 1320: 1			;******************************************************************************
 1321: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1322: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1323: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1324: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1325: 1
 1326: 1			;******************************************************************************
 1327: 1			; i2cinit
 1328: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1329: 1			;******************************************************************************
 1330: 1  03D5	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1331: 1  03D7	D2 ED		                setb    mco             ;klok moet hoog wakker worden

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1332: 1  03D9	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1333: 1  03DB	D2 EB		                setb    i2cm            ;master mode inschakelen
 1334: 1  03DD	22		                ret
 1335: 1			;******************************************************************************
 1336: 1			; i2cstart
 1337: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1338: 1			;******************************************************************************
 1339: 1  03DE	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1340: 1  03E0	C2 EF		                clr     mdo             ;data moet laag worden
 1341: 1  03E2	D2 EE		                setb    mde             ;data pin enable
 1342: 1  03E4	C2 ED		                clr     mco             ;klok laag maken
 1343: 1  03E6	22		                ret
 1344: 1			;******************************************************************************
 1345: 1			; i2cstop
 1346: 1			; Dit is een subroutine die de stop conditie opwekt.
 1347: 1			;******************************************************************************
 1348: 1  03E7	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1349: 1  03E9	D2 EE		                setb    mde             ;data mag naar buiten
 1350: 1  03EB	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1351: 1  03ED	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1352: 1  03EF	22		                ret
 1353: 1
 1354: 1			;******************************************************************************
 1355: 1			; i2coutbyte
 1356: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1357: 1			; De routine vernietigt geen registers.
 1358: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1359: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1360: 1			;         uitvoeren van de routine.
 1361: 1			;******************************************************************************
 1362: 1  03F0	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1363: 1  03F2	C0 F0		                push    b
 1364: 1  03F4	75 F0 08	                mov     b,#008h         ;loopcounter
 1365: 1  03F7	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1366: 1  03F8	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1367: 1  03FA	D2 EE		                setb    mde             ;pin als output activeren
 1368: 1  03FC	D2 ED		                setb    mco             ;klokpukls hoog
 1369: 1  03FE	C2 ED		                clr     mco             ;klokpuls laag
 1370: 1  0400	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1371: 1  0403	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1372: 1  0405	D2 ED		                setb    mco             ;klokpuls hoog
 1373: 1  0407	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1374: 1  0409	C2 ED		                clr     mco             ;klokpuls terug laag
 1375: 1  040B	D0 F0		                pop     b
 1376: 1  040D	D0 E0		                pop     acc             ;registers herstellen
 1377: 1  040F	22		                ret
 1378: 1
 1379: 1			;******************************************************************************
 1380: 1			; i2cinbyteack
 1381: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1382: 1			; De routine vernietigt geen registers. De routine zal als
 1383: 1			; negende bit een ack verzenden.
 1384: 1			;******************************************************************************
 1385: 1  0410	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1386: 1  0412	C0 D0		                push    psw
 1387: 1  0414	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1388: 1  0417	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1389: 1  0419	D2 ED		                setb    mco             ;klokpuls hoog
 1390: 1  041B	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1391: 1  041D	C2 ED		                clr     mco             ;klokpuls terug laag
 1392: 1  041F	33		                rlc     a               ;in accu shiften
 1393: 1  0420	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1394: 1  0423	C3		                clr     c               ;ack verzenden
 1395: 1  0424	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1396: 1  0426	D2 EE		                setb    mde             ;pin als output activeren
 1397: 1  0428	D2 ED		                setb    mco             ;klokpukls hoog
 1398: 1  042A	C2 ED		                clr     mco             ;klokpuls laag
 1399: 1  042C	D0 D0		                pop     psw             ;registers herstellen
 1400: 1  042E	D0 F0		                pop     b
 1401: 1  0430	22		                ret
 1402: 1
 1403: 1			;******************************************************************************
 1404: 1			; i2cinbytenack
 1405: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1406: 1			; De routine vernietigt geen registers. De routine zal als
 1407: 1			; negende bit een nack verzenden.
 1408: 1			;******************************************************************************
 1409: 1  0431	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1410: 1  0433	C0 D0		                push    psw
 1411: 1  0435	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1412: 1  0438	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1413: 1  043A	D2 ED		                setb    mco             ;klokpuls hoog
 1414: 1  043C	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1415: 1  043E	C2 ED		                clr     mco             ;klokpuls terug laag
 1416: 1  0440	33		                rlc     a               ;in accu shiften
 1417: 1  0441	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1418: 1  0444	D3		                setb    c               ;nack verzenden
 1419: 1  0445	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1420: 1  0447	D2 EE		                setb    mde             ;pin als output activeren
 1421: 1  0449	D2 ED		                setb    mco             ;klokpukls hoog
 1422: 1  044B	C2 ED		                clr     mco             ;klokpuls laag
 1423: 1  044D	D0 D0		                pop     psw             ;registers herstellen
 1424: 1  044F	D0 F0		                pop     b
 1425: 1  0451	22		                ret
 1426: 1
 1427: 1			;******************************************************************************
 1428: 1			; i2csenddata
 1429: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1430: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1431: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1432: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1433: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1434: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1435: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1436: 1			;
 1437: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1438: 1			; pointer naar deze data.  .
 1439: 1
 1440: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1441: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1442: 1			;         B       = aantal te versturen bytes (minimum 1)
 1443: 1			;         R0      = startadres van te versturen datablok

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1444: 1			;
 1445: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1446: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1447: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1448: 1			;               verzonden byte waarvoor er geen ack kwam.
 1449: 1			;
 1450: 1			; Deze routine vernietigt niets...
 1451: 1			;******************************************************************************
 1452: 1  0452	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1453: 1  0454	C0 D0		                    push   psw
 1454: 1  0456	E8		                    mov    a,r0
 1455: 1  0457	C0 E0		                    push   acc           ;r0 op stack
 1456: 1
 1457: 1  0459	12 03 DE	                    lcall  i2cstart      ;genereer startconditie
 1458: 1  045C	E5 83		                    mov    a,dph         ;neem adresbyte
 1459: 1  045E	12 03 F0	                    lcall  i2coutbyte    ;en verstuur naar slave
 1460: 1  0461	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1461: 1  0463	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1462: 1  0465	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1463: 1  0467	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1464: 1			;10 bit adressering!
 1465: 1  046A	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1466: 1  046C	12 03 F0	                    lcall  i2coutbyte    ;en verstuur naar slave
 1467: 1  046F	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1468: 1			;7 bit adressering!
 1469: 1  0471	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1470: 1  0472	12 03 F0	                    lcall  i2coutbyte    ;en verstuur naar slave
 1471: 1  0475	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1472: 1  0477	08		                    inc    r0            ;volgende byte
 1473: 1  0478	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1474: 1  047B	12 03 E7	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1475: 1  047E	D0 E0		                    pop    acc
 1476: 1  0480	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1477: 1  0481	D0 D0		                    pop    psw
 1478: 1  0483	C3		                    clr    c             ;alles is ok!
 1479: 1  0484	D0 E0		                    pop    acc
 1480: 1  0486	22		                    ret
 1481: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1482: 1  0487	12 03 E7	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1483: 1  048A	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1484: 1  048C	D0 D0		                    pop    psw
 1485: 1  048E	D3		                    setb   c            ;terug met foutmelding
 1486: 1  048F	D0 E0		                    pop    acc
 1487: 1  0491	22		                    ret
 1488: 1
 1489: 1			;******************************************************************************
 1490: 1			; i2crcvdata
 1491: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1492: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1493: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1494: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1495: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1496: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1497: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1498: 1			;
 1499: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1500: 1			; is een pointer naar de start van dit ontvangen datablok.
 1501: 1			;
 1502: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1503: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1504: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1505: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1506: 1			;
 1507: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1508: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1509: 1			;               het adres, wordt de CY bit geset bij return.
 1510: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1511: 1			;
 1512: 1			; Deze routine vernietigt verder niets...
 1513: 1			;******************************************************************************
 1514: 1  0492	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1515: 1  0494	C0 D0		                    push    psw
 1516: 1  0496	E8		                    mov     a,r0            ;r0 op stack
 1517: 1  0497	C0 E0		                    push    acc
 1518: 1
 1519: 1  0499	12 03 DE	                    lcall   i2cstart        ;genereer startconditie
 1520: 1  049C	E5 83		                    mov     a,dph           ;neem adresbyte
 1521: 1  049E	12 03 F0	                    lcall   i2coutbyte      ;en verstuur naar slave
 1522: 1  04A1	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1523: 1  04A3	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1524: 1  04A5	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1525: 1  04A7	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1526: 1			;10 bit adressering!
 1527: 1  04AA	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1528: 1  04AC	12 03 F0	                    lcall   i2coutbyte      ;en verstuur naar slave
 1529: 1  04AF	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1530: 1			;7 bit adressering!
 1531: 1
 1532: 1  04B1	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1533: 1  04B4	12 04 31	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1534: 1  04B7	F6		                    mov     @r0,a           ;en deze ook bewaren
 1535: 1  04B8	80 07		                    sjmp    i2crcvdata3
 1536: 1  04BA	12 04 10	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1537: 1  04BD	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1538: 1  04BE	08		                    inc     r0              ;pointer verhogen
 1539: 1  04BF	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1540: 1
 1541: 1  04C1	12 03 E7	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1542: 1  04C4	D0 E0		                    pop     acc
 1543: 1  04C6	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1544: 1  04C7	D0 D0		                    pop     psw
 1545: 1  04C9	C3		                    clr     c               ;alles is ok!
 1546: 1  04CA	D0 E0		                    pop     acc
 1547: 1  04CC	22		                    ret
 1548: 1			;fout: geen ack gekregen bij het versturen van het adres
 1549: 1  04CD	12 03 E7	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1550: 1  04D0	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1551: 1  04D2	D0 D0		                    pop        psw
 1552: 1  04D4	D3		                    setb    c               ;terug met foutmelding
 1553: 1  04D5	D0 E0		                    pop        acc
 1554: 1  04D7	22		                    ret
 1555: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1556: 1
 1557: 1			;******************************************************************************
 1558: 1			;
 1559: 1			; porttolcd
 1560: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1561: 1			; scherm stuurt via de port expander.
 1562: 1			;
 1563: 1			; Gebruikt geen registers
 1564: 1			;
 1565: 1			;******************************************************************************
 1566: 1
 1567: 1  04D8	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1568: 1  04DA	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1569: 1  04DC	12 03 DE	              lcall  i2cstart      ;vertrokken
 1570: 1			ifdef    pcf8574
 1571: 1			              mov    a,#01000000b  ;schrijven naar expander
 1572: 1			endif
 1573: 1			ifdef    pcf8574A
 1574: 1  04DF	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1575: 1			endif
 1576: 1  04E1	12 03 F0	              lcall  i2coutbyte    ;weg er mee
 1577: 1  04E4	E5 F0		              mov    a,b           ;data verzenden
 1578: 1  04E6	12 03 F0	              lcall  i2coutbyte
 1579: 1  04E9	12 03 E7	              lcall  i2cstop       ;transactie sluiten
 1580: 1  04EC	D0 D0		              pop    psw
 1581: 1  04EE	D0 E0		              pop    acc
 1582: 1  04F0	22		              ret
 1583: 1
 1584: 1			;******************************************************************************
 1585: 1			;
 1586: 1			; lcdtoport
 1587: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1588: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1589: 1			; aansturen van de buzzer en backlight.
 1590: 1			;
 1591: 1			; output: b register
 1592: 1			;
 1593: 1			;******************************************************************************
 1594: 1
 1595: 1  04F1	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1596: 1  04F3	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1597: 1  04F5	12 03 DE	              lcall  i2cstart      ;vertrokken
 1598: 1			ifdef    pcf8574
 1599: 1			              mov    a,#01000000b  ;schrijven naar expander
 1600: 1			endif
 1601: 1			ifdef    pcf8574A
 1602: 1  04F8	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1603: 1			endif
 1604: 1  04FA	12 03 F0	              lcall  i2coutbyte    ;weg er mee
 1605: 1  04FD	12 04 31	              lcall  i2cinbytenack ;data inlezen
 1606: 1  0500	12 03 E7	              lcall  i2cstop
 1607: 1  0503	F5 F0		              mov    b,a
 1608: 1  0505	D0 D0		              pop    psw
 1609: 1  0507	D0 E0		              pop    acc
 1610: 1  0509	22		              ret
 1611: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1612: 1			;******************************************************************************
 1613: 1			;
 1614: 1			; lcdlighton
 1615: 1			; Dit is een subroutine die de backlight inschakeld
 1616: 1			;
 1617: 1			; Gebruikt geen registers
 1618: 1			;
 1619: 1			;******************************************************************************
 1620: 1
 1621: 1  050A	C0 F0		lcdlighton:   push   b
 1622: 1  050C	12 04 F1	              lcall  lcdtoport     ;expander lezen
 1623: 1  050F	C2 F6		              clr    b.6           ;licht aan doen
 1624: 1  0511	12 04 D8	              lcall  porttolcd     ;expander schrijven
 1625: 1  0514	D0 F0		              pop    b
 1626: 1  0516	22		              ret
 1627: 1
 1628: 1
 1629: 1			;******************************************************************************
 1630: 1			;
 1631: 1			; lcdlightoff
 1632: 1			; Dit is een subroutine die de backlight uitschakeld
 1633: 1			;
 1634: 1			; Gebruikt geen registers
 1635: 1			;
 1636: 1			;******************************************************************************
 1637: 1
 1638: 1  0517	C0 F0		lcdlightoff:  push   b
 1639: 1  0519	12 04 F1	              lcall  lcdtoport     ;expander lezen
 1640: 1  051C	D2 F6		              setb   b.6           ;licht uit doen
 1641: 1  051E	12 04 D8	              lcall  porttolcd     ;expander schrijven
 1642: 1  0521	D0 F0		              pop    b
 1643: 1  0523	22		              ret
 1644: 1
 1645: 1			;******************************************************************************
 1646: 1			;
 1647: 1			; lcdbuzon
 1648: 1			; Dit is een subroutine die de buzzer inschakeld
 1649: 1			;
 1650: 1			; Gebruikt geen registers
 1651: 1			;
 1652: 1			;******************************************************************************
 1653: 1
 1654: 1  0524	C0 F0		lcdbuzon:     push   b
 1655: 1  0526	12 04 F1	              lcall  lcdtoport     ;expander lezen
 1656: 1  0529	C2 F7		              clr    b.7           ;buzzer aan doen
 1657: 1  052B	12 04 D8	              lcall  porttolcd     ;expander schrijven
 1658: 1  052E	D0 F0		              pop    b
 1659: 1  0530	22		              ret
 1660: 1
 1661: 1			;******************************************************************************
 1662: 1			;
 1663: 1			; lcdbuzoff
 1664: 1			; Dit is een subroutine die de buzzer uitschakeld
 1665: 1			;
 1666: 1			; Gebruikt geen registers
 1667: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1668: 1			;******************************************************************************
 1669: 1
 1670: 1  0531	C0 F0		lcdbuzoff:    push   b
 1671: 1  0533	12 04 F1	              lcall  lcdtoport     ;expander lezen
 1672: 1  0536	D2 F7		              setb   b.7           ;buzzer aan doen
 1673: 1  0538	12 04 D8	              lcall  porttolcd     ;expander schrijven
 1674: 1  053B	D0 F0		              pop    b
 1675: 1  053D	22		              ret
 1676: 1
 1677: 1			endif    ;einde aduc_i2c
 1678: 1			;******************************************************************************
 1679: 1
 1680: 1
 1681: 1
 1682: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1683: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1684: 1			;
 1685: 1			; ADuCsio.inc
 1686: 1			; Is een include file voor de ADuC832 microcontroller.
 1687: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1688: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1689: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1690: 1			; afwijking van de standaard routines is de initsio subroutine.
 1691: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1692: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1693: 1			; zijn.
 1694: 1			;
 1695: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1696: 1			;
 1697: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1698: 1
 1699: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1700: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1701: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1702: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1703: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1704: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1705: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1706: 1
 1707: 1  053E	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1708: 1			                                                        ;van het scherm
 1709: 1
 1710: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1711: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1712: 1
 1713: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1714: 1			;
 1715: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1716: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1717: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1718: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1719: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1720: 1			;
 1721: 1			; de routine gebruikt de psw
 1722: 1			;
 1723: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1724: 1
 1725: 1  0542	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1726: 1  0544	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1727: 1  0546	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1728: 1  0548	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1729: 1  054B	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1730: 1
 1731: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1732: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1733: 1
 1734: 1  054D	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1735: 1  0550	F4		              cpl    a             ;bitbangen om laten uit te komen
 1736: 1  0551	C3		              clr    c             ;verder doen
 1737: 1  0552	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1738: 1  0554	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1739: 1  0556	24 80		              add    a,#080h       ;nu alles in orde
 1740: 1  0558	F5 9E		              mov    t3con,a       ;baud rate klaar
 1741: 1  055A	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1742: 1  055D	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1743: 1  055E	D0 E0		              pop    acc
 1744: 1  0560	22		              ret
 1745: 1
 1746: 1  0561	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1747: 1  0562	D0 E0		              pop    acc
 1748: 1  0564	22		              ret
 1749: 1
 1750: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1751: 1			;
 1752: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1753: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1754: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1755: 1			;
 1756: 1			; de routine gebruikt geen registers.
 1757: 1			;
 1758: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1759: 1
 1760: 1  0565	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1761: 1  0567	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1762: 1  056A	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1763: 1  056C	22		              RET
 1764: 1
 1765: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1766: 1			;
 1767: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1768: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1769: 1			;
 1770: 1			; de routine gebruikt geen registers.
 1771: 1			;
 1772: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1773: 1
 1774: 1  056D	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1775: 1  056F	C0 D0		              push   psw
 1776: 1  0571	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1777: 1  0573	12 06 7F	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1778: 1  0576	12 05 65	              LCALL  OUTCHAR       ;VERSTUREN
 1779: 1  0579	12 05 C6	              LCALL  XONXOFF       ;FLOW CONTROL

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1780: 1  057C	D0 D0		              pop    psw           ;registers herstellen
 1781: 1  057E	D0 E0		              pop    acc
 1782: 1  0580	22		              RET
 1783: 1
 1784: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1785: 1			;
 1786: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1787: 1			; WORDT XONXOFF GEBRUIKT.
 1788: 1			;
 1789: 1			; de routine gebruikt geen registers.
 1790: 1			;
 1791: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1792: 1
 1793: 1  0581	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1794: 1  0583	C0 D0		              push   psw
 1795: 1  0585	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1796: 1  0587	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1797: 1  0588	12 05 6D	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1798: 1  058B	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1799: 1  058D	12 05 6D	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1800: 1  0590	D0 D0		              pop    psw           ;registers herstellen
 1801: 1  0592	D0 E0		              pop    acc
 1802: 1  0594	22		              RET
 1803: 1
 1804: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1805: 1			;
 1806: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1807: 1			; VAN DE CURSOR.
 1808: 1			;
 1809: 1			; de routine gebruikt geen registers.
 1810: 1			;
 1811: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1812: 1
 1813: 1  0595	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1814: 1  0597	C0 D0		              push   psw
 1815: 1  0599	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1816: 1  059B	12 05 81	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1817: 1  059E	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1818: 1  05A0	12 05 81	              LCALL  OUTBYTE       ;WEG ER MEE
 1819: 1  05A3	D0 D0		              pop    psw           ;registers herstellen
 1820: 1  05A5	D0 E0		              pop    acc
 1821: 1  05A7	22		              RET                  ;EINDE
 1822: 1
 1823: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1824: 1			;
 1825: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1826: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1827: 1			;
 1828: 1			; de routine gebruikt geen registers.
 1829: 1			;
 1830: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1831: 1
 1832: 1  05A8	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1833: 1  05AA	C0 D0		              push   psw
 1834: 1  05AC	C0 82		              push   dpl
 1835: 1  05AE	C0 83		              push   dph

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1836: 1  05B0	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1837: 1  05B1	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1838: 1  05B2	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1839: 1  05B4	12 05 65	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1840: 1  05B7	12 05 C6	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1841: 1  05BA	A3		              INC    DPTR          ;DPTR AANPASSEN
 1842: 1  05BB	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1843: 1  05BD	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1844: 1  05BF	D0 82		              pop    dpl
 1845: 1  05C1	D0 D0		              pop    psw
 1846: 1  05C3	D0 E0		              pop    acc
 1847: 1  05C5	22		              RET                  ;EINDE ROUTINE
 1848: 1
 1849: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1850: 1			;
 1851: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1852: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1853: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1854: 1			; VERDER DOORGEGEVEN.
 1855: 1			;
 1856: 1			; de routine gebruikt geen registers.
 1857: 1			;
 1858: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1859: 1
 1860: 1  05C6	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1861: 1  05C8	C0 D0		              push   psw
 1862: 1  05CA	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1863: 1  05CD	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 1864: 1  05CF	D0 E0		              pop    acc
 1865: 1  05D1	22		              RET                  ;ANDERS EINDE
 1866: 1  05D2	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1867: 1  05D4	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1868: 1  05D7	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1869: 1  05DA	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1870: 1
 1871: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1872: 1			;
 1873: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1874: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1875: 1			;
 1876: 1			; de routine gebruikt de accu.
 1877: 1			;
 1878: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1879: 1
 1880: 1  05DC	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 1881: 1  05DF	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 1882: 1  05E1	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1883: 1  05E3	22		              RET
 1884: 1
 1885: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1886: 1			;
 1887: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1888: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1889: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 1890: 1			; DE CARRY OP 1 GEZET WORDEN.
 1891: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1892: 1			; De routine gebruikt de accu EN PSW.
 1893: 1			;
 1894: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1895: 1
 1896: 1  05E4	C0 F0		INBYTE:       PUSH     B
 1897: 1  05E6	12 05 DC	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1898: 1  05E9	12 06 72	              LCALL  LOWUPTR
 1899: 1  05EC	12 06 8D	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1900: 1  05EF	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1901: 1  05F1	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1902: 1  05F2	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1903: 1  05F4	12 05 DC	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1904: 1  05F7	12 06 72	              LCALL  LOWUPTR
 1905: 1  05FA	12 06 8D	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1906: 1  05FD	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1907: 1  05FF	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1908: 1  0601	D0 F0		INBYTE1:      POP     B
 1909: 1  0603	22		              RET
 1910: 1
 1911: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1912: 1			;
 1913: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1914: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1915: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1916: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1917: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1918: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1919: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 1920: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1921: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1922: 1			; bepalen.
 1923: 1			;
 1924: 1			; De routine gebruikt  r0 .
 1925: 1			;
 1926: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1927: 1
 1928: 1  0604	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1929: 1  0606	C0 D0		              push   psw
 1930: 1  0608	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1931: 1  060A	12 05 DC	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 1932: 1  060D	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1933: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 1934: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1935: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1936: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 1937: 1			; GEVOERD.
 1938: 1  060F	12 06 72	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1939: 1  0612	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1940: 1  0615	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1941: 1  0616	D0 D0		              pop    psw                  ;registers herstellen
 1942: 1  0618	D0 E0		              pop    acc
 1943: 1  061A	22		              RET                         ;EINDE VAN DE ROUTINE
 1944: 1
 1945: 1  061B	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 1946: 1  061E	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1947: 1  0621	74 07		INBUFA4:      MOV    A,#BEEP

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1948: 1  0623	12 05 65	INBUFA7:      LCALL  OUTCHAR
 1949: 1  0626	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1950: 1
 1951: 1  0628	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1952: 1  0629	90 05 3E	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1953: 1  062C	12 05 A8	              LCALL  OUTMSGA
 1954: 1  062F	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 1955: 1  0631	12 06 64	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1956: 1  0634	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1957: 1  0636	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1958: 1  0639	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1959: 1  063B	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1960: 1  063C	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1961: 1  063D	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1962: 1
 1963: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1964: 1			;
 1965: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1966: 1			;
 1967: 1			; De routine gebruikt niets.
 1968: 1			;
 1969: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1970: 1
 1971: 1  063F	C0 E0		BDELETE:      PUSH     ACC
 1972: 1  0641	C0 D0		              PUSH     PSW
 1973: 1  0643	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1974: 1  0644	C0 E0		              PUSH     ACC
 1975: 1  0646	E9		              MOV     A,R1
 1976: 1  0647	C0 E0		              PUSH     ACC
 1977: 1  0649	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1978: 1  064B	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1979: 1  064D	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1980: 1  064E	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1981: 1  0651	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1982: 1  0652	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1983: 1  0655	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1984: 1  0657	F9		              MOV     R1,A
 1985: 1  0658	D0 E0		              POP     ACC
 1986: 1  065A	F8		              MOV     R0,A
 1987: 1  065B	D0 D0		              POP     PSW
 1988: 1  065D	D0 E0		              POP     ACC
 1989: 1  065F	22		              RET                         ;EINDE VAN DE ROUTINE
 1990: 1  0660	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1991: 1  0661	09		              INC    R1
 1992: 1  0662	80 ED		              SJMP   BDELETE3
 1993: 1
 1994: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1995: 1			;
 1996: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1997: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1998: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1999: 1			; AANZIEN.
 2000: 1			;
 2001: 1			; De routine gebruikt de accu en de psw.
 2002: 1			;
 2003: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2004: 1
 2005: 1  0664	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 2006: 1  0667	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 2007: 1  0669	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 2008: 1  066C	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 2009: 1  066E	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 2010: 1  066F	22		              RET
 2011: 1  0670	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 2012: 1  0671	22		              RET
 2013: 1
 2014: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2015: 1			;
 2016: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 2017: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 2018: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 2019: 1			; AANGEPAST WORDEN.
 2020: 1			;
 2021: 1			; De routine gebruikt de accu en psw .
 2022: 1			;
 2023: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2024: 1
 2025: 1  0672	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 2026: 1  0675	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 2027: 1  0677	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 2028: 1  067A	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 2029: 1  067C	94 20		              SUBB   A,#020H              ;OMZETTING
 2030: 1  067E	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 2031: 1
 2032: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2033: 1			;
 2034: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 2035: 1			; ASCII CODE.
 2036: 1			;
 2037: 1			; De routine gebruikt de accu .
 2038: 1			;
 2039: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2040: 1
 2041: 1  067F	C0 D0		BATRANS:      PUSH   PSW
 2042: 1  0681	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 2043: 1  0684	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 2044: 1  0686	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 2045: 1  0688	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 2046: 1  068A	D0 D0		              POP     PSW
 2047: 1  068C	22		              RET
 2048: 1
 2049: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2050: 1			;
 2051: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 2052: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 2053: 1			; GEVAL WORDT DE CARRY GEZET.
 2054: 1			;
 2055: 1			; De routine gebruikt de accu en de psw.
 2056: 1			;
 2057: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2058: 1
 2059: 1  068D	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2060: 1  068E	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 2061: 1  0690	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 2062: 1  0692	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 2063: 1  0695	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 2064: 1  0697	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 2065: 1  0699	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 2066: 1  069B	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 2067: 1  069E	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 2068: 1  069F	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 2069: 1  06A1	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 2070: 1  06A2	22		ASCBINTRANS1: RET
 2071: 1
 2072: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2073: 1			;
 2074: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 2075: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 2076: 1			;
 2077: 1			; De routine gebruikt de accu en de psw.
 2078: 1			;
 2079: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2080: 1
 2081: 1  06A3	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 2082: 1  06A4	12 06 8D	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 2083: 1  06A7	22		              RET                         ;EINDE OMZETTING
 2084: 1
 2085: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2086: 1			;
 2087: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 2088: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 2089: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 2090: 1			;
 2091: 1			; De routine gebruikt de accu, r0.
 2092: 1			;
 2093: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2094: 1
 2095: 1  06A8	C0 F0		ASCII2:       PUSH   B
 2096: 1  06AA	12 06 A3	              LCALL  ASCII1               ;OMZETTEN
 2097: 1  06AD	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 2098: 1  06AF	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 2099: 1  06B0	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 2100: 1  06B2	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 2101: 1  06B3	12 06 A3	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 2102: 1  06B6	40 02		              JC     ASCII21               ;WEG ALS C=1
 2103: 1  06B8	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 2104: 1  06BA	D0 F0		ASCII21:      POP     B
 2105: 1  06BC	22		              RET
 2106: 1
 2107: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2108: 1			;
 2109: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2110: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2111: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2112: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2113: 1			;
 2114: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2115: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2116: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2117: 1
 2118: 1  06BD	12 06 A8	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2119: 1  06C0	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2120: 1  06C2	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2121: 1  06C4	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2122: 1  06C5	12 06 A8	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2123: 1  06C8	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2124: 1  06CA	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2125: 1  06CC	22		ASCII41:      RET
 2126: 1
 2127: 1			endif        ;einde van aduc_sio
 2128: 1			;*******************************************************************************
 2129: 1
 2130: 1
 2131: 1			ifdef        aduc_math    ;rekenkundige routines
 2132: 1			;*******************************************************************************
 2133: 1			; aduc_math
 2134: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2135: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2136: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2137: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2138: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2139: 1			; zoals aangegeven:
 2140: 1			;
 2141: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2142: 1			;        ---------------------------
 2143: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2144: 1			;        ---------------------------                             statusbit = f0
 2145: 1			;        ---------------------------
 2146: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2147: 1			;        ---------------------------
 2148: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2149: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2150: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2151: 1			; return en moeten hiervoor worden gereserveerd.
 2152: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2153: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2154: 1			; en unsigned getallen.
 2155: 1			;
 2156: 1			; Beschikbare routines:
 2157: 1			;
 2158: 1			; Conversie routines:
 2159: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2160: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2161: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2162: 1			;
 2163: 1			; Som:
 2164: 1			; s_add16, add16, s_add32, add32
 2165: 1			;
 2166: 1			; Verschil:
 2167: 1			; s_sub16, sub16, s_sub32, sub32
 2168: 1			;
 2169: 1			; Vermenigvuldigen:
 2170: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2171: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2172: 1			; Delen:
 2173: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2174: 1			;
 2175: 1			; Vemenigvuldig met factor:
 2176: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2177: 1			;
 2178: 1			; Vierkantswortel:
 2179: 1			; sqrt32, s_sqrt32
 2180: 1			;
 2181: 1			; Schuiven:
 2182: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2183: 1			;
 2184: 1			; Vergelijken:
 2185: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2186: 1			;
 2187: 1			; Tabel lookup:
 2188: 1			; table_lu
 2189: 1			;
 2190: 1			; Gonemetrische functies:
 2191: 1			; Cordic = sinus,cosinus
 2192: 1			;
 2193: 1			;*******************************************************************************
 2194: 1
 2195: 1			;*******************************************************************************
 2196: 1			;
 2197: 1			; bcdhex8     (45,77us @16.777216MHz)
 2198: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2199: 1			; naar een 2's complement hex getal.
 2200: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2201: 1			; een waarde 00h tot 63h.
 2202: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2203: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2204: 1			; input:      R0 = waarde tussen 00h en 99h.
 2205: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2206: 1			; output:     R0 = 2's complement waarde
 2207: 1			;             cy=1 bij out of range van r0
 2208: 1			;             cy=0 bij conversie ok
 2209: 1			; vernietigt: niets
 2210: 1			;*******************************************************************************
 2211: 1  06CD	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2212: 1  06CF	C0 D0		              push   psw
 2213: 1  06D1	C0 F0		              push   b
 2214: 1
 2215: 1  06D3	E8		              mov    a,r0                 ;neem te converteren waarde
 2216: 1  06D4	F5 F0		              mov    b,a
 2217: 1  06D6	54 0F		              anl    a,#0fh
 2218: 1  06D8	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2219: 1  06DB	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2220: 1  06DD	E5 F0		              mov    a,b
 2221: 1  06DF	54 F0		              anl    a,#0f0h
 2222: 1  06E1	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2223: 1  06E4	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2224: 1
 2225: 1  06E6	E8		              mov    a,r0
 2226: 1  06E7	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2227: 1  06E9	C4		              swap   a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2228: 1  06EA	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2229: 1  06ED	A4		              mul    ab
 2230: 1  06EE	F5 F0		              mov    b,a                  ;bewaar dit product even
 2231: 1  06F0	E8		              mov    a,r0
 2232: 1  06F1	54 0F		              anl    a,#00fh
 2233: 1  06F3	F8		              mov    r0,a
 2234: 1  06F4	E5 F0		              mov    a,b
 2235: 1  06F6	28		              add    a,r0                 ;eenheden er bijtellen
 2236: 1  06F7	F8		              mov    r0,a
 2237: 1
 2238: 1  06F8	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2239: 1  06FA	12 07 FB	              lcall  magsig8              ;omzetten naar 2's complement
 2240: 1
 2241: 1  06FD	D0 F0		              pop    b
 2242: 1  06FF	D0 D0		              pop    psw
 2243: 1  0701	C2 D7		              clr    cy                   ;geen fout
 2244: 1  0703	D0 E0		              pop    acc
 2245: 1  0705	22		              ret
 2246: 1
 2247: 1  0706	D0 F0		bcdhex82:     pop    b
 2248: 1  0708	D0 D0		              pop    psw
 2249: 1  070A	D2 D7		              setb   cy                   ;fout! r0 out of range
 2250: 1  070C	D0 E0		              pop    acc
 2251: 1  070E	22		              ret
 2252: 1
 2253: 1			;*******************************************************************************
 2254: 1			;
 2255: 1			; hexbcd8     (38,4us @16.777216MHz)
 2256: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2257: 1			; naar een 8bit bcd getal.
 2258: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2259: 1			; bcdgetal van 00h tot +99h.
 2260: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2261: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2262: 1			; bcdgetal 00h tot -99h
 2263: 1			;
 2264: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2265: 1			;
 2266: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2267: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2268: 1			;             cy=1 bij out of range van r0
 2269: 1			;             cy=0 bij conversie ok
 2270: 1			; vernietigt: niets
 2271: 1			;*******************************************************************************
 2272: 1  070F	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2273: 1  0711	C0 D0		                push    psw
 2274: 1  0713	C0 F0		                push    b
 2275: 1  0715	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2276: 1  0716	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2277: 1  0719	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2278: 1  071B	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2279: 1  071E	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2280: 1  0720	D0 F0		                pop     b
 2281: 1  0722	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2282: 1  0724	D3		                setb    c
 2283: 1  0725	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2284: 1  0727	22		                ret
 2285: 1  0728	12 08 C3	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2286: 1  072B	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2287: 1  072C	75 F0 0A	                mov     b,#10
 2288: 1  072F	84		                div     ab
 2289: 1  0730	C4		                swap    a
 2290: 1  0731	25 F0		                add     a,b
 2291: 1  0733	F8		                mov     r0,a
 2292: 1  0734	D0 F0		                pop     b               ;registers herstellen
 2293: 1  0736	D0 E0		                pop     acc             ;psw van stack halen
 2294: 1  0738	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2295: 1  073A	92 E5		                mov     acc.5,c
 2296: 1  073C	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2297: 1  073E	C3		                clr     c               ;status: conversie ok
 2298: 1  073F	D0 E0		                pop     acc
 2299: 1  0741	22		                ret
 2300: 1
 2301: 1
 2302: 1
 2303: 1			;*******************************************************************************
 2304: 1			;
 2305: 1			; bcdhex16    (86,6us @16.777216MHz)
 2306: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2307: 1			; omzetten naar een 2's complement hex getal.
 2308: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2309: 1			; naareen waarde 0000h tot 270fh.
 2310: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2311: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2312: 1			; van -270fh).
 2313: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2314: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2315: 1			; output:     R1,R0 = 2's complement waarde
 2316: 1			;             cy=1 bij out of range van r1,r0
 2317: 1			;             cy=0 bij conversie ok
 2318: 1			; vernietigt: niets
 2319: 1			;*******************************************************************************
 2320: 1  0742	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2321: 1  0744	C0 D0		              push   psw
 2322: 1  0746	C0 F0		              push   b
 2323: 1
 2324: 1  0748	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2325: 1  0749	F5 F0		              mov    b,a
 2326: 1  074B	54 0F		              anl    a,#0fh
 2327: 1  074D	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2328: 1  0750	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2329: 1  0752	E5 F0		              mov    a,b
 2330: 1  0754	54 F0		              anl    a,#0f0h
 2331: 1  0756	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2332: 1  0759	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2333: 1  075B	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2334: 1  075C	F5 F0		              mov    b,a
 2335: 1  075E	54 0F		              anl    a,#0fh
 2336: 1  0760	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2337: 1  0763	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2338: 1  0765	E5 F0		              mov    a,b
 2339: 1  0767	54 F0		              anl    a,#0f0h

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2340: 1  0769	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2341: 1  076C	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2342: 1
 2343: 1  076E	E8		              mov    a,r0                  ;neem low byte voor conversie
 2344: 1  076F	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2345: 1  0771	C0 E0		              push   acc                   ;en even bewaren
 2346: 1
 2347: 1  0773	E8		              mov    a,r0
 2348: 1  0774	C4		              swap   a
 2349: 1  0775	54 0F		              anl    a,#00fh              ;tientallen
 2350: 1  0777	75 F0 0A	              mov    b,#00ah              ;maal tien
 2351: 1  077A	A4		              mul    ab                   ;
 2352: 1  077B	D0 F0		              pop    b                    ;neem eenheden
 2353: 1  077D	25 F0		              add    a,b                  ;tel bij tientallen
 2354: 1  077F	C0 E0		              push   acc                  ;weer bewaren
 2355: 1
 2356: 1  0781	E9		              mov    a,r1                 ;neem high byte voor conversie
 2357: 1  0782	54 F0		              anl    a,#0f0h
 2358: 1  0784	C4		              swap   a
 2359: 1  0785	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2360: 1
 2361: 1  0787	E9		              mov    a,r1                  ;neem high byte voor conversie
 2362: 1  0788	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2363: 1  078A	75 F0 64	              mov    b,#100d              ;en maal honderd
 2364: 1  078D	A4		              mul    ab
 2365: 1  078E	A9 F0		              mov    r1,b
 2366: 1  0790	F8		              mov    r0,a
 2367: 1
 2368: 1  0791	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2369: 1  0793	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2370: 1  0796	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2371: 1  0797	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2372: 1  079A	A4		              mul    ab
 2373: 1  079B	28		              add    a,r0                 ;tel honderdtallen bij de
 2374: 1  079C	F8		              mov    r0,a                 ;duizendtallen
 2375: 1  079D	E9		              mov    a,r1
 2376: 1  079E	35 F0		              addc   a,b
 2377: 1  07A0	F9		              mov    r1,a
 2378: 1
 2379: 1  07A1	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2380: 1  07A3	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2381: 1  07A4	F8		              mov    r0,a                 ;duizendtallen
 2382: 1  07A5	74 00		              mov    a,#000h
 2383: 1  07A7	39		              addc   a,r1
 2384: 1  07A8	F9		              mov    r1,a                 ;omzetting klaar
 2385: 1
 2386: 1  07A9	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2387: 1  07AB	12 08 2F	              lcall  magsig16             ;omzetten naar 2's complement
 2388: 1
 2389: 1  07AE	D0 F0		              pop    b
 2390: 1  07B0	D0 D0		              pop    psw
 2391: 1  07B2	C2 D7		              clr    cy                   ;geen fout
 2392: 1  07B4	D0 E0		              pop    acc
 2393: 1  07B6	22		              ret
 2394: 1
 2395: 1  07B7	D0 F0		bcdhex162:    pop    b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2396: 1  07B9	D0 D0		              pop    psw
 2397: 1  07BB	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2398: 1  07BD	D0 E0		              pop    acc
 2399: 1  07BF	22		              ret
 2400: 1
 2401: 1			;*******************************************************************************
 2402: 1			;
 2403: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2404: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2405: 1			; naar een 24bit bcd getal.
 2406: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2407: 1			; bcdgetal van 000000h tot +032767h.
 2408: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2409: 1			; naar een bcdgetal 000000h tot -032768h
 2410: 1			;
 2411: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2412: 1			;
 2413: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2414: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2415: 1			;
 2416: 1			; vernietigt: niets
 2417: 1			;*******************************************************************************
 2418: 1			;
 2419: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2420: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2421: 1			; naar een 24bit bcd getal.
 2422: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2423: 1			; bcdgetal van 000000h tot 065535h.
 2424: 1			;
 2425: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2426: 1			;
 2427: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2428: 1			;
 2429: 1			; vernietigt: niets
 2430: 1			;*******************************************************************************
 2431: 1  07C0	12 08 F5	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2432: 1  07C3	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2433: 1  07C5	C0 D0		                push   psw
 2434: 1  07C7	C0 F0		                push   b
 2435: 1  07C9	C0 82		                push   dpl
 2436: 1
 2437: 1  07CB	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2438: 1  07CE	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2439: 1  07D0	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2440: 1  07D2	12 0C A4	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2441: 1  07D5	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2442: 1  07D6	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2443: 1			                                        ;dus eerst eenheden, dan tientallen
 2444: 1			                                        ;honderdtallen, duizendtallen en
 2445: 1			                                        ;tienduizendtallen
 2446: 1  07D8	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2447: 1
 2448: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2449: 1
 2450: 1  07DB	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2451: 1  07DD	FA		                mov    r2,a             ;ms digit in outputregister stoppen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2452: 1  07DE	D0 E0		                pop    acc              ;duizendtallen ophalen
 2453: 1  07E0	C4		                swap   a                ;en combineren met de
 2454: 1  07E1	F5 82		                mov    dpl,a
 2455: 1  07E3	D0 E0		                pop    acc              ;honderdtallen van de stack
 2456: 1  07E5	25 82		                add    a,dpl
 2457: 1  07E7	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2458: 1  07E8	D0 E0		                pop    acc              ;tientallen van de stack halen
 2459: 1  07EA	C4		                swap   a
 2460: 1  07EB	F5 82		                mov    dpl,a
 2461: 1  07ED	D0 E0		                pop    acc              ;en combineren met de eenheden
 2462: 1  07EF	25 82		                add    a,dpl
 2463: 1  07F1	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2464: 1
 2465: 1  07F2	D0 82		                pop    dpl              ;registers herstellen
 2466: 1  07F4	D0 F0		                pop    b
 2467: 1  07F6	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2468: 1  07F8	D0 E0		                pop    acc
 2469: 1  07FA	22		                ret
 2470: 1
 2471: 1			;*******************************************************************************
 2472: 1			; magsig8        (13,6us @16.777216MHz)
 2473: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2474: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2475: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2476: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2477: 1			;           (f0 en f1 zijn 1 als negatief)
 2478: 1			;
 2479: 1			; output:   r0 = 2's complement
 2480: 1			;
 2481: 1			; vernietigt: niets
 2482: 1			;*******************************************************************************
 2483: 1
 2484: 1  07FB	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2485: 1  07FD	C0 D0		               push   psw
 2486: 1  07FF	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2487: 1  0802	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2488: 1  0805	80 09		               sjmp   magsig8c
 2489: 1
 2490: 1  0807	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2491: 1  080A	80 04		               sjmp   magsig8c
 2492: 1
 2493: 1  080C	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2494: 1  080D	F4		               cpl    a                  ;complementeer abs waarde
 2495: 1  080E	04		               inc    a                  ;r0 = complement(r0)+1
 2496: 1  080F	F8		               mov    r0,a               ;bewaar in 2's complement
 2497: 1  0810	D0 D0		magsig8c:      pop    psw
 2498: 1  0812	D0 E0		               pop    acc
 2499: 1  0814	22		               ret                        ;klaar
 2500: 1
 2501: 1			;*******************************************************************************
 2502: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2503: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2504: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2505: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2506: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2507: 1			;           (f0 en f1 zijn 1 als negatief)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2508: 1			;
 2509: 1			; output:   r4 = 2's complement
 2510: 1			;
 2511: 1			; vernietigt: niets
 2512: 1			;*******************************************************************************
 2513: 1
 2514: 1  0815	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2515: 1  0817	C0 D0		               push    psw
 2516: 1  0819	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2517: 1  081C	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2518: 1  081F	80 EF		               sjmp    magsig8c
 2519: 1
 2520: 1  0821	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2521: 1  0824	80 04		               sjmp    magsig8acc1c
 2522: 1
 2523: 1  0826	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2524: 1  0827	F4		               cpl     a                 ;complementeer abs waarde
 2525: 1  0828	04		               inc     a                 ;r4 = complement(r0)+1
 2526: 1  0829	FC		               mov     r4,a              ;bewaar in 2's complement
 2527: 1  082A	D0 D0		magsig8acc1c:  pop     psw
 2528: 1  082C	D0 E0		               pop     acc
 2529: 1  082E	22		               ret                       ;klaar
 2530: 1
 2531: 1			;*******************************************************************************
 2532: 1			; magsig16        (16,6us @16.777216MHz)
 2533: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2534: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2535: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2536: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2537: 1			;           (f0 en f1 zijn 1 als negatief)
 2538: 1			;
 2539: 1			; output:   r1,r0 = 2's complement
 2540: 1			;
 2541: 1			; vernietigt: niets
 2542: 1			;*******************************************************************************
 2543: 1  082F	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2544: 1  0831	C0 D0		               push    psw
 2545: 1  0833	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2546: 1  0836	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2547: 1  0839	80 0F		               sjmp    magsig16c
 2548: 1
 2549: 1  083B	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2550: 1  083E	80 0A		               sjmp    magsig16c
 2551: 1
 2552: 1  0840	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2553: 1  0841	F4		               cpl     a                ;complementeer het dan
 2554: 1  0842	24 01		               add     a, #1            ;en tel er 1 bij
 2555: 1  0844	F8		               mov     r0,a
 2556: 1  0845	E9		               mov     a,r1             ;neem volgende byte
 2557: 1  0846	F4		               cpl     a                ;complementeer en tel carry erbij
 2558: 1  0847	34 00		               addc    a,#0
 2559: 1  0849	F9		               mov     r1,a
 2560: 1  084A	D0 D0		magsig16c:     pop     psw
 2561: 1  084C	D0 E0		               pop     acc
 2562: 1  084E	22		               ret
 2563: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2564: 1			;*******************************************************************************
 2565: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2566: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2567: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2568: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2569: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2570: 1			;           (f0 en f1 zijn 1 als negatief)
 2571: 1			;
 2572: 1			; output:   r5,r4 = 2's complement
 2573: 1			;
 2574: 1			; vernietigt: niets
 2575: 1			;*******************************************************************************
 2576: 1  084F	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2577: 1  0851	C0 D0		                push    psw
 2578: 1  0853	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2579: 1  0856	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2580: 1  0859	80 0F		                sjmp    magsig16acc1c
 2581: 1
 2582: 1  085B	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2583: 1  085E	80 0A		                sjmp    magsig16acc1c
 2584: 1
 2585: 1  0860	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2586: 1  0861	F4		                cpl     a                   ;complementeer het dan
 2587: 1  0862	24 01		                add     a,#1                ;en tel er 1 bij
 2588: 1  0864	FC		                mov     r4,a
 2589: 1  0865	ED		                mov     a,r5                ;neem volgende byte
 2590: 1  0866	F4		                cpl     a                   ;complementeer en tel carry erbij
 2591: 1  0867	34 00		                addc    a,#0
 2592: 1  0869	FD		                mov     r5,a
 2593: 1  086A	D0 D0		magsig16acc1c:  pop     psw
 2594: 1  086C	D0 E0		                pop     acc
 2595: 1  086E	22		                ret
 2596: 1
 2597: 1			;*******************************************************************************
 2598: 1			; magsig32        (22,2us @16.777216MHz)
 2599: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2600: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2601: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2602: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2603: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2604: 1			;           (f0 en f1 zijn 1 als negatief)
 2605: 1			;
 2606: 1			; output:   r3,r2,r1,r0 = 2's complement
 2607: 1			;
 2608: 1			; vernietigt: niets
 2609: 1			;*******************************************************************************
 2610: 1  086F	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2611: 1  0871	C0 D0		               push    psw
 2612: 1  0873	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2613: 1  0876	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2614: 1  0879	80 19		               sjmp    magsig32c
 2615: 1
 2616: 1  087B	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2617: 1  087E	80 14		               sjmp    magsig32c
 2618: 1
 2619: 1  0880	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2620: 1  0881	F4		               cpl     a                 ;complementeer het dan
 2621: 1  0882	24 01		               add     a,#1             ;en tel er 1 bij
 2622: 1  0884	F8		               mov     r0,a
 2623: 1  0885	E9		               mov     a,r1             ;neem volgende byte
 2624: 1  0886	F4		               cpl     a                 ;complementeer en tel carry erbij
 2625: 1  0887	34 00		               addc    a,#0
 2626: 1  0889	F9		               mov     r1,a
 2627: 1  088A	EA		               mov     a,r2            ;neem volgende byte
 2628: 1  088B	F4		               cpl     a                ;complementeer en tel carry erbij
 2629: 1  088C	34 00		               addc    a,#0
 2630: 1  088E	FA		               mov     r2,a
 2631: 1  088F	EB		               mov     a,r3            ;neem volgende byte
 2632: 1  0890	F4		               cpl     a                ;complementeer en tel carry erbij
 2633: 1  0891	34 00		               addc    a,#0
 2634: 1  0893	FB		               mov     r3,a
 2635: 1
 2636: 1  0894	D0 D0		magsig32c:     pop     psw
 2637: 1  0896	D0 E0		               pop     acc
 2638: 1  0898	22		               ret
 2639: 1
 2640: 1
 2641: 1
 2642: 1			;*******************************************************************************
 2643: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2644: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2645: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2646: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2647: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2648: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2649: 1			;           (f0 en f1 zijn 1 als negatief)
 2650: 1			;
 2651: 1			; output:   r7,r6,r5,r4 = 2's complement
 2652: 1			;
 2653: 1			; vernietigt: niets
 2654: 1			;*******************************************************************************
 2655: 1  0899	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2656: 1  089B	C0 D0		               push    psw
 2657: 1  089D	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2658: 1  08A0	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2659: 1  08A3	80 19		               sjmp    magsig32acc1c
 2660: 1
 2661: 1  08A5	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2662: 1  08A8	80 14		               sjmp    magsig32acc1c
 2663: 1
 2664: 1  08AA	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2665: 1  08AB	F4		               cpl     a                 ;complementeer het dan
 2666: 1  08AC	24 01		               add     a,#1             ;en tel er 1 bij
 2667: 1  08AE	FC		               mov     r4,a
 2668: 1  08AF	ED		               mov     a,r5             ;neem volgende byte
 2669: 1  08B0	F4		               cpl     a                 ;complementeer en tel carry erbij
 2670: 1  08B1	34 00		               addc    a,#0
 2671: 1  08B3	FD		               mov     r5,a
 2672: 1  08B4	EE		               mov     a,r6             ;neem volgende byte
 2673: 1  08B5	F4		               cpl     a                 ;complementeer en tel carry erbij
 2674: 1  08B6	34 00		               addc    a,#0
 2675: 1  08B8	FE		               mov     r6,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2676: 1  08B9	EF		               mov     a,r7             ;neem volgende byte
 2677: 1  08BA	F4		               cpl     a                ;complementeer en tel carry erbij
 2678: 1  08BB	34 00		               addc    a,#0
 2679: 1  08BD	FF		               mov     r7,a
 2680: 1
 2681: 1  08BE	D0 D0		magsig32acc1c: pop     psw
 2682: 1  08C0	D0 E0		               pop     acc
 2683: 1  08C2	22		               ret
 2684: 1
 2685: 1
 2686: 1			;*******************************************************************************
 2687: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2688: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2689: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2690: 1			; input:     r0 = 2's complement byte in acc0
 2691: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2692: 1			; output:    r0 = absolute waarde
 2693: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2694: 1			;
 2695: 1			; vernietigt: niets
 2696: 1			;*******************************************************************************
 2697: 1
 2698: 1  08C3	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2699: 1  08C5	C0 D0		                push    psw
 2700: 1  08C7	E8		                mov     a,r0               ;neem lsb van acc0
 2701: 1  08C8	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2702: 1  08CB	D0 D0		                pop     psw
 2703: 1  08CD	C2 D5		                clr     f0                 ;nee, positief...klaar
 2704: 1  08CF	D0 E0		                pop     acc
 2705: 1  08D1	22		                ret
 2706: 1  08D2	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2707: 1  08D3	04		                inc     a                   ;een erbij
 2708: 1  08D4	F8		                mov     r0,a               ;bewaar
 2709: 1  08D5	D0 D0		                pop     psw
 2710: 1  08D7	D2 D5		                setb    f0                 ;f0=1 als negatief
 2711: 1  08D9	D0 E0		                pop     acc
 2712: 1  08DB	22		                ret
 2713: 1
 2714: 1			;*******************************************************************************
 2715: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2716: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2717: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2718: 1			; input:     r4 = 2's complement byte in acc1
 2719: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2720: 1			; output:    r4 = absolute waarde
 2721: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2722: 1			;
 2723: 1			; vernietigt: niets
 2724: 1			;*******************************************************************************
 2725: 1
 2726: 1  08DC	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2727: 1  08DE	C0 D0		                push    psw
 2728: 1  08E0	EC		                mov     a,r4               ;neem lsb van acc0
 2729: 1  08E1	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2730: 1  08E4	D0 D0		                pop     psw
 2731: 1  08E6	C2 D1		                clr     f1                 ;nee, positief...klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2732: 1  08E8	D0 E0		                pop     acc
 2733: 1  08EA	22		                ret
 2734: 1  08EB	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2735: 1  08EC	04		                inc     a                   ;een erbij
 2736: 1  08ED	FC		                mov     r4,a               ;bewaar
 2737: 1  08EE	D0 D0		                pop     psw
 2738: 1  08F0	D2 D1		                setb    f1                 ;f0=1 als negatief
 2739: 1  08F2	D0 E0		                pop     acc
 2740: 1  08F4	22		                ret
 2741: 1
 2742: 1			;*******************************************************************************
 2743: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2744: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2745: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2746: 1			; input:     r1,r0 = 2's complement word in acc0
 2747: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2748: 1			; output:    r1,r0 = absolute waarde
 2749: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2750: 1			;
 2751: 1			; vernietigt: niets
 2752: 1			;*******************************************************************************
 2753: 1
 2754: 1  08F5	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2755: 1  08F7	C0 D0		                push    psw
 2756: 1  08F9	E9		                mov     a,r1               ; neem msb van acc0
 2757: 1  08FA	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2758: 1  08FD	D0 D0		                pop     psw
 2759: 1  08FF	C2 D5		                clr     f0                 ;f0=0 als positief
 2760: 1  0901	D0 E0		                pop     acc
 2761: 1  0903	22		                ret                        ;klaar
 2762: 1
 2763: 1  0904	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2764: 1  0905	F4		                cpl     a                  ;complementeren
 2765: 1  0906	24 01		                add     a,#1               ;en een bijtellen
 2766: 1  0908	F8		                mov     r0,a
 2767: 1  0909	E9		                mov     a,r1
 2768: 1  090A	F4		                cpl     a                  ;complement eer volgende byte
 2769: 1  090B	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2770: 1  090D	F9		                mov     r1,a
 2771: 1  090E	D0 D0		                pop     psw
 2772: 1  0910	D2 D5		                setb    f0                 ;f0=1 als negatief
 2773: 1  0912	D0 E0		                pop     acc
 2774: 1  0914	22		                ret
 2775: 1
 2776: 1
 2777: 1			;*******************************************************************************
 2778: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2779: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2780: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2781: 1			; input:     r5,r4 = 2's complement word in acc1
 2782: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2783: 1			; output:    r5,r4 = absolute waarde
 2784: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2785: 1			;
 2786: 1			; vernietigt: niets
 2787: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2788: 1
 2789: 1  0915	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2790: 1  0917	C0 D0		                push    psw
 2791: 1  0919	ED		                mov     a,r5               ;neem msb van acc1
 2792: 1  091A	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2793: 1  091D	D0 D0		                pop     psw
 2794: 1  091F	C2 D1		                clr     f1                 ;f1=0 als positief
 2795: 1  0921	D0 E0		                pop    acc
 2796: 1  0923	22		                ret                        ;klaar
 2797: 1
 2798: 1  0924	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2799: 1  0925	F4		                cpl     a                   ;complementeren
 2800: 1  0926	24 01		                add     a,#1               ;en een bijtellen
 2801: 1  0928	FC		                mov     r4,a
 2802: 1  0929	ED		                mov     a,r5
 2803: 1  092A	F4		                cpl     a                  ;complementeer volgende byte
 2804: 1  092B	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2805: 1  092D	FD		                mov     r5,a
 2806: 1  092E	D0 D0		                pop     psw
 2807: 1  0930	D2 D1		                setb    f1                ;f1=1 als negatief
 2808: 1  0932	D0 E0		                pop     acc
 2809: 1  0934	22		                ret
 2810: 1
 2811: 1
 2812: 1			;*******************************************************************************
 2813: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2814: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2815: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2816: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2817: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2818: 1			; output:    r7,r6 = absolute waarde
 2819: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2820: 1			;
 2821: 1			; vernietigt: niets
 2822: 1			;*******************************************************************************
 2823: 1
 2824: 1  0935	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2825: 1  0937	C0 D0		                push    psw
 2826: 1  0939	EF		                mov     a,r7                ; neem msb van acc1 high
 2827: 1  093A	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2828: 1  093D	D0 D0		                pop     psw
 2829: 1  093F	C2 D5		                clr     f0                  ;f0=0 als positief
 2830: 1  0941	D0 E0		                pop     acc
 2831: 1  0943	22		                ret                         ;klaar
 2832: 1
 2833: 1  0944	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2834: 1  0945	F4		                cpl     a                   ;complementeren
 2835: 1  0946	24 01		                add     a,#1               ;en een bijtellen
 2836: 1  0948	FE		                mov     r6,a
 2837: 1  0949	EF		                mov     a,r7
 2838: 1  094A	F4		                cpl     a                  ;complementeer volgende byte
 2839: 1  094B	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2840: 1  094D	FF		                mov     r7,a
 2841: 1  094E	D0 D0		                pop     psw
 2842: 1  0950	D2 D5		                setb    f0                ;f0=1 als negatief
 2843: 1  0952	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2844: 1  0954	22		                ret
 2845: 1
 2846: 1
 2847: 1			;*******************************************************************************
 2848: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2849: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2850: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 2851: 1			;
 2852: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2853: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2854: 1			;            (-2147483648 tot +2147483647)
 2855: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2856: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2857: 1			;
 2858: 1			; vernietigt: niets
 2859: 1			;*******************************************************************************
 2860: 1
 2861: 1  0955	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2862: 1  0957	C0 D0		                push    psw
 2863: 1  0959	EB		                mov     a,r3               ;neem msb van acc0
 2864: 1  095A	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2865: 1  095D	D0 D0		                pop     psw                ;nee, positief
 2866: 1  095F	C2 D5		                clr     f0
 2867: 1  0961	D0 E0		                pop     acc
 2868: 1  0963	22		                ret                        ;klaar
 2869: 1
 2870: 1  0964	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2871: 1  0965	F4		                cpl     a                  ;complementeren
 2872: 1  0966	24 01		                add     a,#1               ;en een bijtellen
 2873: 1  0968	F8		                mov     r0,a
 2874: 1  0969	E9		                mov     a,r1               ;neem volgende byte
 2875: 1  096A	F4		                cpl     a                  ;complementeer volgende byte
 2876: 1  096B	34 00		                addc    a,#0
 2877: 1  096D	F9		                mov     r1,a
 2878: 1  096E	EA		                mov     a,r2               ;neem volgende byte
 2879: 1  096F	F4		                cpl     a                  ;complementeer volgende byte
 2880: 1  0970	34 00		                addc    a,#0
 2881: 1  0972	FA		                mov     r2,a
 2882: 1  0973	EB		                mov     a,r3               ;neem volgende byte
 2883: 1  0974	F4		                cpl     a                  ;complementeer volgende byte
 2884: 1  0975	34 00		                addc    a,#0
 2885: 1  0977	FB		                mov     r3,a
 2886: 1  0978	D0 D0		                pop     psw
 2887: 1  097A	D2 D5		                setb    f0                 ;negatief: f0=1
 2888: 1  097C	D0 E0		                pop     acc
 2889: 1  097E	22		                ret                        ;klaar
 2890: 1
 2891: 1			;*******************************************************************************
 2892: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2893: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2894: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2895: 1			;
 2896: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2897: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2898: 1			;            (-2147483648 tot +2147483647)
 2899: 1			; output:    r7,r6,r5,r4 = absolute waarde

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2900: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2901: 1			;
 2902: 1			; vernietigt: niets
 2903: 1			;*******************************************************************************
 2904: 1
 2905: 1  097F	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2906: 1  0981	C0 D0		                push    psw
 2907: 1  0983	EF		                mov     a,r7               ;neem msb van acc0
 2908: 1  0984	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2909: 1  0987	D0 D0		                pop     psw                ;nee, positief
 2910: 1  0989	C2 D1		                clr     f1
 2911: 1  098B	D0 E0		                pop     acc
 2912: 1  098D	22		                ret                        ;klaar
 2913: 1
 2914: 1  098E	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2915: 1  098F	F4		                cpl     a                   ;complementeren
 2916: 1  0990	24 01		                add     a,#1               ;en een bijtellen
 2917: 1  0992	FC		                mov     r4,a
 2918: 1  0993	ED		                mov     a,r5               ;neem volgende byte
 2919: 1  0994	F4		                cpl     a                  ;complementeer volgende byte
 2920: 1  0995	34 00		                addc    a,#0
 2921: 1  0997	FD		                mov     r5,a
 2922: 1  0998	EE		                mov     a,r6               ;neem volgende byte
 2923: 1  0999	F4		                cpl     a                  ;complementeer volgende byte
 2924: 1  099A	34 00		                addc    a,#0
 2925: 1  099C	FE		                mov     r6,a
 2926: 1  099D	EF		                mov     a,r7               ;neem volgende byte
 2927: 1  099E	F4		                cpl     a                  ;complementeer volgende byte
 2928: 1  099F	34 00		                addc    a,#0
 2929: 1  09A1	FF		                mov     r7,a
 2930: 1  09A2	D0 D0		                pop     psw
 2931: 1  09A4	D2 D1		                setb    f1                 ;negatief: f0=1
 2932: 1  09A6	D0 E0		                pop     acc
 2933: 1  09A8	22		                ret                        ;klaar
 2934: 1
 2935: 1
 2936: 1			;*******************************************************************************
 2937: 1			; s_add16        (19,35us @16.777216MHz)
 2938: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2939: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2940: 1			; input:     r1,r0 = acc0
 2941: 1			;            r5,r4 = acc1
 2942: 1			;
 2943: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2944: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2945: 1			;                  gebruik van r3,r2 is niet nodig
 2946: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2947: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2948: 1			;
 2949: 1			; vernietigt:  niets
 2950: 1			;*******************************************************************************
 2951: 1  09A9	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2952: 1  09AB	C0 D0		               push    psw
 2953: 1
 2954: 1  09AD	E8		               mov     a,r0           ;tel de soft accumulators op
 2955: 1  09AE	2C		               add     a,r4           ;low byte eerst

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2956: 1  09AF	F8		               mov     r0,a           ;resultaat bewaren
 2957: 1  09B0	E9		               mov     a,r1           ;nu de high bytes
 2958: 1  09B1	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2959: 1  09B2	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2960: 1
 2961: 1  09B3	92 D5		               mov     f0,c
 2962: 1  09B5	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 2963: 1  09B7	92 D1		               mov     f1,c
 2964: 1  09B9	A2 D5		               mov     c,f0           ;herstel carrybit
 2965: 1
 2966: 1  09BB	74 00		               mov     a,#00h
 2967: 1  09BD	34 00		               addc    a,#00h
 2968: 1  09BF	FA		               mov     r2,a            ;24bit resultaat klaar
 2969: 1
 2970: 1  09C0	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2971: 1
 2972: 1  09C3	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2973: 1  09C4	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2974: 1  09C7	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 2975: 1  09C9	7B FF		               mov     r3,#0ffh
 2976: 1  09CB	80 04		               sjmp    s_add162
 2977: 1  09CD	7A 00		s_add161:      mov     r2,#00h
 2978: 1  09CF	7B 00		               mov     r3,#00h
 2979: 1  09D1	D0 D0		s_add162:      pop     psw
 2980: 1  09D3	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2981: 1  09D4	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2982: 1  09D6	22		               ret
 2983: 1
 2984: 1  09D7	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2985: 1  09D9	C3		               clr     c
 2986: 1  09DA	D0 E0		               pop     acc
 2987: 1  09DC	22		               ret
 2988: 1
 2989: 1			;*******************************************************************************
 2990: 1			; add16        (13,6us @16.777216MHz)
 2991: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2992: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2993: 1			; input:     r1,r0 = acc0
 2994: 1			;            r5,r4 = acc1
 2995: 1			;
 2996: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2997: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 2998: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2999: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 3000: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 3001: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 3002: 1			;
 3003: 1			; vernietigt:  niets
 3004: 1			;*******************************************************************************
 3005: 1
 3006: 1  09DD	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 3007: 1  09DF	C0 D0		               push    psw
 3008: 1  09E1	E8		               mov     a,r0           ;tel de soft accumulators op
 3009: 1  09E2	2C		               add     a,r4           ;low byte eerst
 3010: 1  09E3	F8		               mov     r0,a           ;resultaat bewaren
 3011: 1  09E4	E9		               mov     a,r1           ;nu de high bytes

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3012: 1  09E5	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3013: 1  09E6	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3014: 1  09E7	50 08		               jnc     add161          ;geen 24 bit resultaat
 3015: 1
 3016: 1  09E9	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 3017: 1  09EB	D0 D0		               pop     psw
 3018: 1  09ED	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3019: 1  09EE	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 3020: 1  09F0	22		               ret
 3021: 1
 3022: 1  09F1	7A 00		add161:        mov     r2,#00h
 3023: 1  09F3	D0 D0		               pop     psw
 3024: 1  09F5	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3025: 1  09F6	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 3026: 1  09F8	22		               ret
 3027: 1
 3028: 1			;*******************************************************************************
 3029: 1			; s_add32        (28,0us @16.777216MHz)
 3030: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 3031: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3032: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3033: 1			; input:     r3,r2,r1,r0 = acc0
 3034: 1			;            r7,r6,r5,r4 = acc1
 3035: 1			;
 3036: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 3037: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3038: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 3039: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3040: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3041: 1			;
 3042: 1			; vernietigt:  niets
 3043: 1			;*******************************************************************************
 3044: 1  09F9	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 3045: 1  09FB	C0 D0		               push    psw
 3046: 1
 3047: 1  09FD	E8		               mov     a,r0           ;tel de soft accumulators op
 3048: 1  09FE	2C		               add     a,r4           ;low byte eerst
 3049: 1  09FF	F8		               mov     r0,a           ;resultaat bewaren
 3050: 1  0A00	E9		               mov     a,r1           ;nu de hogere bytes
 3051: 1  0A01	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3052: 1  0A02	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3053: 1
 3054: 1  0A03	EA		               mov     a,r2           ;derde bytes optellen
 3055: 1  0A04	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3056: 1  0A05	FA		               mov     r2,a           ;24bit resultaat is klaar
 3057: 1  0A06	EB		               mov     a,r3           ;nu de ms bytes
 3058: 1  0A07	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3059: 1  0A08	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3060: 1
 3061: 1  0A09	92 D5		               mov     f0,c
 3062: 1  0A0B	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 3063: 1  0A0D	92 D1		               mov     f1,c
 3064: 1  0A0F	A2 D5		               mov     c,f0           ;herstel carrybit
 3065: 1
 3066: 1  0A11	74 00		               mov     a,#00h
 3067: 1  0A13	34 00		               addc    a,#00h

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3068: 1  0A15	FC		               mov     r4,a            ;40bit resultaat klaar
 3069: 1
 3070: 1  0A16	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 3071: 1  0A19	EC		               mov     a,r4            ;ja, sign extention toepassen!
 3072: 1  0A1A	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 3073: 1  0A1D	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3074: 1  0A1F	80 02		               sjmp    s_add322
 3075: 1  0A21	7C 00		s_add321:      mov     r4,#00h
 3076: 1  0A23	D0 D0		s_add322:      pop     psw
 3077: 1  0A25	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3078: 1  0A26	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 3079: 1  0A28	22		               ret
 3080: 1
 3081: 1  0A29	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 3082: 1  0A2B	C3		               clr     c
 3083: 1  0A2C	D0 E0		               pop     acc
 3084: 1  0A2E	22		               ret
 3085: 1
 3086: 1
 3087: 1			;*******************************************************************************
 3088: 1			; add32        (18,0us @16.777216MHz)
 3089: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 3090: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3091: 1			; input:     r3,r2,r1,r0 = acc0
 3092: 1			;            r7,r6,r5,r4 = acc1
 3093: 1			;
 3094: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 3095: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3096: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3097: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 3098: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3099: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3100: 1			;
 3101: 1			; vernietigt:  niets
 3102: 1			;*******************************************************************************
 3103: 1  0A2F	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 3104: 1  0A31	C0 D0		               push    psw
 3105: 1  0A33	E8		               mov     a,r0           ;tel de soft accumulators op
 3106: 1  0A34	2C		               add     a,r4           ;low byte eerst
 3107: 1  0A35	F8		               mov     r0,a           ;resultaat bewaren
 3108: 1  0A36	E9		               mov     a,r1           ;nu de hogere bytes
 3109: 1  0A37	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3110: 1  0A38	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3111: 1
 3112: 1  0A39	EA		               mov     a,r2           ;derde bytes optellen
 3113: 1  0A3A	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3114: 1  0A3B	FA		               mov     r2,a           ;24bit resultaat is klaar
 3115: 1  0A3C	EB		               mov     a,r3           ;nu de ms bytes
 3116: 1  0A3D	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3117: 1  0A3E	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3118: 1
 3119: 1  0A3F	50 08		               jnc     add321          ;geen 40 bit resultaat
 3120: 1
 3121: 1  0A41	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3122: 1  0A43	D0 D0		               pop     psw
 3123: 1  0A45	D3		               setb    c               ;aangeven aan de gebruiker dat het

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3124: 1  0A46	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3125: 1  0A48	22		               ret
 3126: 1
 3127: 1  0A49	7C 00		add321:        mov     r4,#00h
 3128: 1  0A4B	D0 D0		               pop     psw
 3129: 1  0A4D	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3130: 1  0A4E	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3131: 1  0A50	22		               ret
 3132: 1
 3133: 1
 3134: 1			;*******************************************************************************
 3135: 1			; s_sub16        (24,4us @16.777216MHz)
 3136: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3137: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3138: 1			; input:     r1,r0 = acc0
 3139: 1			;            r5,r4 = acc1
 3140: 1			;
 3141: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3142: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3143: 1			;                  gebruik van r3,r2 is niet nodig
 3144: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3145: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3146: 1			;
 3147: 1			; vernietigt:  niets
 3148: 1			;*******************************************************************************
 3149: 1  0A51	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3150: 1  0A53	C0 D0		                push    psw
 3151: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3152: 1
 3153: 1  0A55	EC		                mov   	a,r4            ;verander het teken van acc1
 3154: 1  0A56	F4		                cpl    	a               ;door het 2's complement te nemen
 3155: 1  0A57	24 01		                add   	a,#1
 3156: 1  0A59	FC		                mov    	r4,a
 3157: 1  0A5A	ED		                mov    	a,r5
 3158: 1  0A5B	F4		                cpl    	a
 3159: 1  0A5C	34 00		                addc	a,#0
 3160: 1  0A5E	FD		                mov    	r5,a
 3161: 1			;acc0+acc1
 3162: 1  0A5F	E8						mov		a,r0
 3163: 1  0A60	2C						add		a,r4
 3164: 1  0A61	F8						mov		r0,a
 3165: 1  0A62	E9						mov		a,r1
 3166: 1  0A63	3D						addc	a,r5
 3167: 1  0A64	F9						mov		r1,a
 3168: 1
 3169: 1  0A65	92 D5		                mov    f0,c
 3170: 1  0A67	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3171: 1  0A69	92 D1		                mov    f1,c
 3172: 1  0A6B	A2 D5		                mov    c,f0            ;herstel carrybit
 3173: 1
 3174: 1  0A6D	74 00		                mov    a,#00h
 3175: 1  0A6F	34 00		                addc   a,#00h
 3176: 1  0A71	FA		                mov    r2,a            ;24bit resultaat klaar
 3177: 1
 3178: 1  0A72	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3179: 1  0A75	EA		                mov    a,r2            ;ja, sign extention toepassen!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3180: 1  0A76	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3181: 1  0A79	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3182: 1  0A7B	7B FF		                mov    r3,#0ffh
 3183: 1  0A7D	80 04		                sjmp   s_sub162
 3184: 1  0A7F	7A 00		s_sub161:       mov    r2,#00h
 3185: 1  0A81	7B 00		                mov    r3,#00h
 3186: 1  0A83	D0 D0		s_sub162:       pop    psw
 3187: 1  0A85	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3188: 1  0A86	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3189: 1  0A88	22		                ret
 3190: 1
 3191: 1  0A89	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3192: 1  0A8B	C3		                clr    c
 3193: 1  0A8C	D0 E0		                pop    acc
 3194: 1  0A8E	22		                ret
 3195: 1
 3196: 1			;*******************************************************************************
 3197: 1			; sub16            (14,4us @16.777216MHz)
 3198: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3199: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3200: 1			; input:     r1,r0 = acc0
 3201: 1			;            r5,r4 = acc1
 3202: 1			;
 3203: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3204: 1			;            bij een underflow r2 op ffh zetten
 3205: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3206: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3207: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3208: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3209: 1			;
 3210: 1			; vernietigt:  niets
 3211: 1			;*******************************************************************************
 3212: 1
 3213: 1  0A8F	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3214: 1  0A91	C0 D0		                push    psw
 3215: 1  0A93	C3		                clr     c
 3216: 1  0A94	E8		                mov     a,r0            ;tel de soft accumulators op
 3217: 1  0A95	9C		                subb    a,r4            ;low byte eerst
 3218: 1  0A96	F8		                mov     r0,a            ;resultaat bewaren
 3219: 1  0A97	E9		                mov     a,r1            ;nu de high bytes
 3220: 1  0A98	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3221: 1  0A99	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3222: 1  0A9A	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3223: 1
 3224: 1  0A9C	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3225: 1  0A9E	D0 D0		                pop     psw
 3226: 1  0AA0	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3227: 1  0AA1	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3228: 1  0AA3	22		                ret
 3229: 1
 3230: 1  0AA4	7A 00		sub161:         mov     r2,#00h
 3231: 1  0AA6	D0 D0		                pop     psw
 3232: 1  0AA8	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3233: 1  0AA9	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3234: 1  0AAB	22		                ret
 3235: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3236: 1			;*******************************************************************************
 3237: 1			; s_sub32        (27,2us @16.777216MHz)
 3238: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3239: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3240: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3241: 1			; input:     r3,r2,r1,r0 = acc0
 3242: 1			;            r7,r6,r5,r4 = acc1
 3243: 1			;
 3244: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3245: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3246: 1			;                  gebruik van r4 is niet nodig
 3247: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3248: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3249: 1			;
 3250: 1			; vernietigt:  niets
 3251: 1			;*******************************************************************************
 3252: 1  0AAC	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3253: 1  0AAE	C0 D0		                push   psw
 3254: 1
 3255: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3256: 1
 3257: 1  0AB0	EC		                mov    	a,r4            ;verander het teken van acc1
 3258: 1  0AB1	F4		                cpl    	a               ;door het 2's complement te nemen
 3259: 1  0AB2	24 01		                add    	a,#1
 3260: 1  0AB4	FC		                mov    	r4,a
 3261: 1  0AB5	ED		                mov    	a,r5
 3262: 1  0AB6	F4		                cpl    	a
 3263: 1  0AB7	34 00		                addc	a,#0
 3264: 1  0AB9	FD		                mov    	r5,a
 3265: 1  0ABA	EE		                mov    	a,r6
 3266: 1  0ABB	F4		                cpl    	a
 3267: 1  0ABC	34 00		                addc   	a,#0
 3268: 1  0ABE	FE		                mov    	r6,a
 3269: 1  0ABF	EF		                mov    	a,r7
 3270: 1  0AC0	F4		                cpl    	a
 3271: 1  0AC1	34 00		                addc   	a,#0
 3272: 1  0AC3	FF		                mov    	r7,a
 3273: 1			;acc0+acc1
 3274: 1  0AC4	E8						mov		a,r0
 3275: 1  0AC5	2C						add		a,r4
 3276: 1  0AC6	F8						mov		r0,a
 3277: 1  0AC7	E9						mov		a,r1
 3278: 1  0AC8	3D						addc	a,r5
 3279: 1  0AC9	F9						mov		r1,a
 3280: 1  0ACA	EA						mov		a,r2
 3281: 1  0ACB	3E						addc	a,r6
 3282: 1  0ACC	FA						mov		r2,a
 3283: 1  0ACD	EB						mov		a,r3
 3284: 1  0ACE	3F						addc	a,r7
 3285: 1  0ACF	FB						mov		r3,a
 3286: 1
 3287: 1  0AD0	92 D5		                mov   f0,c
 3288: 1  0AD2	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3289: 1  0AD4	92 D1		                mov   f1,c
 3290: 1  0AD6	A2 D5		                mov   c,f0            ;herstel carrybit
 3291: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3292: 1  0AD8	74 00		                mov   a,#00h
 3293: 1  0ADA	34 00		                addc  a,#00h
 3294: 1  0ADC	FC		                mov   r4,a            ;40bit resultaat klaar
 3295: 1
 3296: 1  0ADD	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3297: 1
 3298: 1  0AE0	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3299: 1  0AE1	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3300: 1  0AE4	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3301: 1  0AE6	80 02		                sjmp   s_sub322
 3302: 1  0AE8	7C 00		s_sub321:       mov   r4,#00h
 3303: 1  0AEA	D0 D0		s_sub322:       pop   psw
 3304: 1  0AEC	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3305: 1  0AED	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3306: 1  0AEF	22		                ret
 3307: 1
 3308: 1  0AF0	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3309: 1  0AF2	C3		                clr   c
 3310: 1  0AF3	D0 E0		                pop   acc
 3311: 1  0AF5	22		                ret
 3312: 1
 3313: 1
 3314: 1			;*******************************************************************************
 3315: 1			; sub32        (18,7us @16.777216MHz)
 3316: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3317: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3318: 1			; input:     r3,r2,r1,r0 = acc0
 3319: 1			;            r7,r6,r5,r4 = acc1
 3320: 1			;
 3321: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3322: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3323: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3324: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3325: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3326: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3327: 1			;
 3328: 1			; vernietigt:  niets
 3329: 1			;*******************************************************************************
 3330: 1  0AF6	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3331: 1  0AF8	C0 D0		               push    psw
 3332: 1  0AFA	C3		               clr       c
 3333: 1  0AFB	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3334: 1  0AFC	9C		               subb    a,r4           ;low byte eerst
 3335: 1  0AFD	F8		               mov     r0,a           ;resultaat bewaren
 3336: 1  0AFE	E9		               mov     a,r1           ;nu de hogere bytes
 3337: 1  0AFF	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3338: 1  0B00	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3339: 1
 3340: 1  0B01	EA		               mov     a,r2           ;derde bytes optellen
 3341: 1  0B02	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3342: 1  0B03	FA		               mov     r2,a           ;24bit resultaat is klaar
 3343: 1  0B04	EB		               mov     a,r3           ;nu de ms bytes
 3344: 1  0B05	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3345: 1  0B06	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3346: 1
 3347: 1  0B07	50 08		               jnc     sub321         ;geen 40 bit resultaat

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3348: 1
 3349: 1  0B09	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3350: 1  0B0B	D0 D0		               pop     psw
 3351: 1  0B0D	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3352: 1  0B0E	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3353: 1  0B10	22		               ret
 3354: 1
 3355: 1  0B11	7C 00		sub321:        mov     r4,#00h
 3356: 1  0B13	D0 D0		               pop     psw
 3357: 1  0B15	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3358: 1  0B16	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3359: 1  0B18	22		               ret
 3360: 1
 3361: 1
 3362: 1
 3363: 1			;*******************************************************************************
 3364: 1			; mul16        (71,2us @16.777216MHz)
 3365: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3366: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3367: 1			; input:     r1,r0 = acc0
 3368: 1			;            r5,r4 = acc1
 3369: 1			;
 3370: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3371: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3372: 1			;
 3373: 1			; vernietigt:  niets
 3374: 1			;*******************************************************************************
 3375: 1  0B19	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3376: 1  0B1B	C0 D0		                push    psw
 3377: 1  0B1D	C0 F0		                push    b
 3378: 1  0B1F	C0 82		                push    dpl
 3379: 1  0B21	C0 83		                push    dph
 3380: 1
 3381: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3382: 1
 3383: 1  0B23	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3384: 1  0B25	89 83		                mov     dph,r1
 3385: 1  0B27	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3386: 1  0B29	08		                inc     r0              ;pointer naar eerste vrije plaats
 3387: 1  0B2A	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3388: 1  0B2C	E5 81		                mov     a,sp            ;plaats alloceren
 3389: 1  0B2E	24 03		                add     a,#3            ;3 bytes nodig
 3390: 1  0B30	F5 81		                mov     sp,a            ;stackpointer verzetten
 3391: 1
 3392: 1  0B32	E5 82		                mov     a,dpl            ;acc0 lsb
 3393: 1  0B34	8C F0		                mov     b,r4            ;acc1 lsb
 3394: 1  0B36	A4		                mul     ab
 3395: 1  0B37	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3396: 1  0B38	08		                inc     r0
 3397: 1  0B39	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3398: 1
 3399: 1  0B3B	E5 83		                mov     a,dph            ;acc0 msb
 3400: 1  0B3D	8C F0		                mov     b,r4            ;acc1 lsb
 3401: 1  0B3F	A4		                mul     ab
 3402: 1
 3403: 1  0B40	26		                add     a,@r0            ;tel lsb bij tussenresultaat

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3404: 1  0B41	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3405: 1  0B42	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3406: 1  0B44	34 00		                addc    a,#0
 3407: 1  0B46	08		                inc     r0               ;bewaar als tussenresultaat
 3408: 1  0B47	F6		                mov     @r0,a
 3409: 1
 3410: 1  0B48	E5 82		                mov     a,dpl            ;acc0 lsb
 3411: 1  0B4A	8D F0		                mov     b,r5             ;acc1 msb
 3412: 1  0B4C	A4		                mul     ab
 3413: 1  0B4D	18		                dec     r0
 3414: 1  0B4E	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3415: 1  0B4F	F6		                mov     @r0,a            ;en bewaar weer
 3416: 1  0B50	08		                inc     r0
 3417: 1  0B51	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3418: 1  0B53	36		                addc    a,@r0
 3419: 1  0B54	F6		                mov     @r0,a            ;en bewaar weer
 3420: 1  0B55	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3421: 1
 3422: 1  0B57	E5 83		                mov     a,dph            ;acc0 msb
 3423: 1  0B59	8D F0		                mov     b,r5             ;acc1 msb
 3424: 1  0B5B	A4		                mul     AB
 3425: 1  0B5C	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3426: 1  0B5D	FA		                mov     r2,a
 3427: 1  0B5E	E5 F0		                mov     a,b
 3428: 1  0B60	34 00		                addc    a,#0
 3429: 1
 3430: 1  0B62	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3431: 1  0B64	34 00		                addc    a,#0
 3432: 1
 3433: 1  0B66	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3434: 1  0B67	18		                dec     r0
 3435: 1  0B68	86 83		                mov     dph,@r0
 3436: 1  0B6A	18		                dec     r0
 3437: 1  0B6B	86 82		                mov     dpl,@r0
 3438: 1
 3439: 1  0B6D	89 81		                mov     sp,r1            ;zet stackpointer terug
 3440: 1  0B6F	A9 83		                mov     r1,dph
 3441: 1  0B71	A8 82		                mov     r0,dpl
 3442: 1
 3443: 1  0B73	D0 83		                pop     dph              ;herstel de bewaarde registers
 3444: 1  0B75	D0 82		                pop     dpl
 3445: 1  0B77	D0 F0		                pop     b
 3446: 1  0B79	D0 D0		                pop     psw
 3447: 1  0B7B	D0 E0		                pop     acc
 3448: 1  0B7D	22		                ret
 3449: 1
 3450: 1
 3451: 1
 3452: 1			;*******************************************************************************
 3453: 1			; mul16acc1        (71,2us @16.777216MHz)
 3454: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3455: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3456: 1			; input:     r5,r4 = acc1 low
 3457: 1			;            r7,r6 = acc1 high
 3458: 1			;
 3459: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3460: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3461: 1			;
 3462: 1			; vernietigt:  niets
 3463: 1			;*******************************************************************************
 3464: 1  0B7E	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3465: 1  0B80	C0 D0		                push    psw
 3466: 1  0B82	C0 F0		                push    b
 3467: 1  0B84	C0 82		                push    dpl
 3468: 1  0B86	C0 83		                push    dph
 3469: 1
 3470: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3471: 1
 3472: 1  0B88	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3473: 1  0B8A	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3474: 1
 3475: 1  0B8C	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3476: 1  0B8E	08		                inc     r0               ;pointer naar eerste vrije plaats
 3477: 1  0B8F	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3478: 1  0B91	E5 81		                mov     a,sp             ;plaats alloceren
 3479: 1  0B93	24 03		                add     a,#3             ;3 bytes nodig
 3480: 1  0B95	F5 81		                mov     sp,a             ;stackpointer verzetten
 3481: 1
 3482: 1  0B97	EC		                mov     a,r4             ;acc1 low lsb
 3483: 1  0B98	8E F0		                mov     b,r6             ;acc1 high lsb
 3484: 1  0B9A	A4		                mul     ab
 3485: 1  0B9B	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3486: 1  0B9C	08		                inc     r0
 3487: 1  0B9D	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3488: 1
 3489: 1  0B9F	ED		                mov     a,r5             ;acc1 low msb
 3490: 1  0BA0	8E F0		                mov     b,r6             ;acc1 high lsb
 3491: 1  0BA2	A4		                mul     ab
 3492: 1
 3493: 1  0BA3	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3494: 1  0BA4	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3495: 1  0BA5	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3496: 1  0BA7	34 00		                addc    a,#0
 3497: 1  0BA9	08		                inc     r0               ;bewaar als tussenresultaat
 3498: 1  0BAA	F6		                mov     @r0,a
 3499: 1
 3500: 1  0BAB	EC		                mov     a,r4             ;acc1 low lsb
 3501: 1  0BAC	8F F0		                mov     b,r7             ;acc1 high msb
 3502: 1  0BAE	A4		                mul     ab
 3503: 1  0BAF	18		                dec     r0
 3504: 1  0BB0	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3505: 1  0BB1	F6		                mov     @r0,a            ;en bewaar weer
 3506: 1  0BB2	08		                inc     r0
 3507: 1  0BB3	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3508: 1  0BB5	36		                addc    a,@r0
 3509: 1  0BB6	F6		                mov     @r0,a            ;en bewaar weer
 3510: 1  0BB7	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3511: 1
 3512: 1  0BB9	ED		                mov     a,r5             ;acc1 low msb
 3513: 1  0BBA	8F F0		                mov     b,r7             ;acc1 high msb
 3514: 1  0BBC	A4		                mul     AB
 3515: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3516: 1  0BBD	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3517: 1  0BBE	FE		                mov     r6,a             ;deze byte van product is al klaar
 3518: 1  0BBF	E5 F0		                mov     a,b
 3519: 1  0BC1	34 00		                addc    a,#0
 3520: 1  0BC3	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3521: 1  0BC5	34 00		                addc    a,#0
 3522: 1
 3523: 1  0BC7	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3524: 1  0BC8	18		                dec     r0
 3525: 1  0BC9	E6		                mov     a,@r0
 3526: 1  0BCA	FD		                mov     r5,a
 3527: 1  0BCB	18		                dec     r0
 3528: 1  0BCC	E6		                mov     a,@r0
 3529: 1  0BCD	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3530: 1
 3531: 1  0BCE	89 81		                mov     sp,r1            ;zet stackpointer terug
 3532: 1  0BD0	A9 83		                mov     r1,dph
 3533: 1  0BD2	A8 82		                mov     r0,dpl
 3534: 1
 3535: 1  0BD4	D0 83		                pop     dph              ;herstel de bewaarde registers
 3536: 1  0BD6	D0 82		                pop     dpl
 3537: 1  0BD8	D0 F0		                pop     b
 3538: 1  0BDA	D0 D0		                pop     psw
 3539: 1  0BDC	D0 E0		                pop     acc
 3540: 1  0BDE	22		                ret
 3541: 1
 3542: 1			;*******************************************************************************
 3543: 1			; s_mul16        (121,1us @16.777216MHz)
 3544: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3545: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3546: 1			; input:     r1,r0 = acc0
 3547: 1			;            r5,r4 = acc1
 3548: 1			;
 3549: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3550: 1			;                                  -1073709056 tot +1073741824
 3551: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3552: 1			;
 3553: 1			; vernietigt:  niets
 3554: 1			;*******************************************************************************
 3555: 1  0BDF	12 08 F5	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3556: 1  0BE2	12 09 15	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3557: 1  0BE5	12 0B 19	                lcall    mul16           ;maak product
 3558: 1  0BE8	12 08 6F	                lcall    magsig32        ;maak 2's complement formaat
 3559: 1  0BEB	22		                ret                      ;klaar
 3560: 1
 3561: 1			;*******************************************************************************
 3562: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3563: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3564: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3565: 1			; input:     r5,r4 = acc1 low
 3566: 1			;            r7,r6 = acc1 high
 3567: 1			;
 3568: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3569: 1			;                                  -1073709056 tot +1073741824
 3570: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3571: 1			; vernietigt:  niets
 3572: 1			;*******************************************************************************
 3573: 1  0BEC	12 09 15	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3574: 1  0BEF	12 09 35	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3575: 1  0BF2	12 0B 7E	                lcall    mul16acc1       ;maak product
 3576: 1  0BF5	12 08 99	                lcall    magsig32acc1    ;maak 2's complement formaat
 3577: 1  0BF8	22		                ret                      ;klaar
 3578: 1
 3579: 1			;*******************************************************************************
 3580: 1			; s_mul816        (83,5us @16.777216MHz)
 3581: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3582: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3583: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3584: 1			; input:     r1,r0 = acc0
 3585: 1			;               r4 = acc1
 3586: 1			;
 3587: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3588: 1			;                                  -4194176 tot +4194304
 3589: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3590: 1			; vernietigt:  niets
 3591: 1			;*******************************************************************************
 3592: 1  0BF9	12 08 F5	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3593: 1  0BFC	12 08 DC	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3594: 1  0BFF	12 0C 06	                lcall    mul816          ;8bit x 16 bit product
 3595: 1  0C02	12 08 6F	                lcall    magsig32        ;abs. waarde naar 2's complement
 3596: 1  0C05	22		                ret
 3597: 1
 3598: 1			;*******************************************************************************
 3599: 1			; mul816        (29,4us @16.777216MHz)
 3600: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3601: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3602: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3603: 1			; input:     r1,r0 = acc0
 3604: 1			;               r4 = acc1
 3605: 1			;
 3606: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3607: 1			;                           0..16711425 (000000h..feff01h)
 3608: 1			;
 3609: 1			; vernietigt:  niets
 3610: 1			;*******************************************************************************
 3611: 1  0C06	C0 E0		mul816:         push    acc             ;bewaar registers
 3612: 1  0C08	C0 F0		                push    b
 3613: 1  0C0A	C0 D0		                push    psw
 3614: 1  0C0C	EC		                mov     a,r4            ;neem acc1
 3615: 1  0C0D	88 F0		                mov     b,r0            ;neem lsb van acc0
 3616: 1  0C0F	A4		                mul     ab              ;maak product
 3617: 1  0C10	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3618: 1  0C11	C0 F0		                push    b               ;bewaar lsb van het product
 3619: 1  0C13	EC		                mov     a,r4            ;neem acc1
 3620: 1  0C14	89 F0		                mov     b,r1            ;neem msb can acc0
 3621: 1  0C16	A4		                mul     ab              ;maak product
 3622: 1  0C17	AA F0		                mov     r2,b            ;bewaar msb van product even
 3623: 1  0C19	F5 F0		                mov     b,a             ;verplaats lsb van product
 3624: 1  0C1B	D0 E0		                pop     acc             ;neem msb van vorig product
 3625: 1  0C1D	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3626: 1  0C1F	F9		                mov     r1,a            ;de middenste byte is klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3627: 1  0C20	EA		                mov     a,r2            ;tel nu de eventuele
 3628: 1  0C21	34 00		                addc    a,#0            ;carry bij de msb
 3629: 1  0C23	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3630: 1  0C24	7B 00		                mov     r3,#0
 3631: 1  0C26	D0 D0		                pop     psw
 3632: 1  0C28	D0 F0		                pop     b
 3633: 1  0C2A	D0 E0		                pop     acc
 3634: 1  0C2C	22		                ret
 3635: 1
 3636: 1			;*******************************************************************************
 3637: 1			; s_mac16        (145,1us @16.777216MHz)
 3638: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3639: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3640: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3641: 1			; input:     r7,r6 = acc1 (high word)
 3642: 1			;            r5,r4 = acc1 (low  word)
 3643: 1			;
 3644: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3645: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3646: 1			;                          -2147483648 tot +2147483647
 3647: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3648: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3649: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3650: 1			;
 3651: 1			; vernietigt:  niets
 3652: 1			;*******************************************************************************
 3653: 1  0C2D	12 0B EC	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3654: 1  0C30	C0 E0		                push    acc
 3655: 1  0C32	C0 D0		                push    psw
 3656: 1  0C34	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3657: 1  0C35	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3658: 1  0C36	F8		                mov     r0,a
 3659: 1  0C37	ED		                mov     a,r5
 3660: 1  0C38	39		                addc    a,r1
 3661: 1  0C39	F9		                mov     r1,a
 3662: 1  0C3A	EE		                mov     a,r6
 3663: 1  0C3B	3A		                addc    a,r2
 3664: 1  0C3C	FA		                mov     r2,a
 3665: 1  0C3D	EF		                mov     a,r7
 3666: 1  0C3E	3B		                addc    a,r3
 3667: 1  0C3F	FB		                mov     r3,a
 3668: 1  0C40	20 D2 06	                jb      ov,s_mac161
 3669: 1  0C43	D0 D0		                pop     psw
 3670: 1  0C45	C3		                clr     c                ;ok, 32bit som binnen bereik
 3671: 1  0C46	D0 E0		                pop     acc
 3672: 1  0C48	22		                ret
 3673: 1  0C49	D0 D0		s_mac161:       pop     psw
 3674: 1  0C4B	D3		                setb    c                ;fout! 32bit som buiten bereik
 3675: 1  0C4C	D0 E0		                pop     acc
 3676: 1  0C4E	22		                ret
 3677: 1
 3678: 1
 3679: 1			;*******************************************************************************
 3680: 1			; s_div8        (78us @16.777216MHz)
 3681: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3682: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3683: 1			; input:    r0 = acc0 deeltal (2's compl)
 3684: 1			;           r4 = acc1 deler   (2's compl)
 3685: 1			;
 3686: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3687: 1			;           r4 = rest (2's compl)
 3688: 1			;           cy=1 bij acc1=0 (deling door nul)
 3689: 1			;            cy=0 in andere gevallen
 3690: 1			;
 3691: 1			; vernietigt: niets
 3692: 1			;*******************************************************************************
 3693: 1  0C4F	12 08 C3	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3694: 1  0C52	12 08 DC	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3695: 1  0C55	12 0C 61	                lcall   div8
 3696: 1  0C58	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3697: 1  0C5A	12 07 FB	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3698: 1  0C5D	12 08 15	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3699: 1  0C60	22		s_div81:        ret
 3700: 1
 3701: 1			;*******************************************************************************
 3702: 1			; div8        (19,4us @16.777216MHz)
 3703: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3704: 1			; absolute waarde
 3705: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3706: 1			; input:    r0 = acc0 deeltal
 3707: 1			;           r4 = acc1 deler
 3708: 1			;
 3709: 1			; output:   r0 = quotient van deling acc0/acc1
 3710: 1			;           r4 = rest
 3711: 1			;           cy=1 bij acc1=0 (deling door nul)
 3712: 1			;            cy=0 in andere gevallen
 3713: 1			;
 3714: 1			; vernietigt: niets
 3715: 1			;*******************************************************************************
 3716: 1  0C61	C0 E0		div8:           push    acc             ;bewaar registers
 3717: 1  0C63	C0 F0		                push    b
 3718: 1  0C65	C0 D0		                push    psw
 3719: 1  0C67	EC		                mov     a,r4            ;neem deler
 3720: 1  0C68	60 0F		                jz      div81           ;deling door nul?
 3721: 1  0C6A	E8		                mov     a,r0            ;nee, neem deeltal
 3722: 1  0C6B	8C F0		                mov     b,r4            ;en deler
 3723: 1  0C6D	84		                div     ab              ;en maak deling
 3724: 1  0C6E	F8		                mov     r0,a            ;bewaar quotient in acc0
 3725: 1  0C6F	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3726: 1  0C71	D0 D0		                pop     psw             ;herstel registers
 3727: 1  0C73	D0 F0		                pop     b
 3728: 1  0C75	D0 E0		                pop     acc
 3729: 1  0C77	C3		                clr     c                ;geen deling door nul
 3730: 1  0C78	22		                ret
 3731: 1
 3732: 1  0C79	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3733: 1  0C7B	D0 F0		                pop     b
 3734: 1  0C7D	D0 E0		                pop     acc
 3735: 1  0C7F	D3		                setb    c
 3736: 1  0C80	22		                ret
 3737: 1
 3738: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3739: 1			;*******************************************************************************
 3740: 1			; s_div16        (469,1us @16.777216MHz)
 3741: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3742: 1			; 2's Complement Format
 3743: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3744: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3745: 1			;           r5, r4 = acc1 deler   (2's compl)
 3746: 1			;
 3747: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3748: 1			;           r5, r4 = rest
 3749: 1			;           cy=1 bij acc1=0 (deling door nul)
 3750: 1			;            cy=0 in andere gevallen
 3751: 1			;
 3752: 1			; vernietigt: niets
 3753: 1			;*******************************************************************************
 3754: 1  0C81	C0 E0		s_div16:        push    acc
 3755: 1  0C83	C0 D0		                push    psw
 3756: 1  0C85	ED		                mov     a,r5            ;neem msb van deler
 3757: 1  0C86	4C		                orl     a,r4            ;combineer met lsb van deler
 3758: 1  0C87	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3759: 1  0C89	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3760: 1  0C8B	D0 E0		                pop     acc
 3761: 1  0C8D	D3		                setb    C               ;fout, deling door nul!
 3762: 1  0C8E	22		                ret
 3763: 1
 3764: 1  0C8F	12 08 F5	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3765: 1  0C92	12 09 15	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3766: 1  0C95	12 0C A4	                lcall   div16
 3767: 1  0C98	12 08 2F	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3768: 1  0C9B	12 08 4F	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3769: 1  0C9E	D0 D0		                pop     psw
 3770: 1  0CA0	C3		                clr     C               ;delig ok
 3771: 1  0CA1	D0 E0		                pop     acc
 3772: 1  0CA3	22		                ret                     ;klaar
 3773: 1
 3774: 1			;*******************************************************************************
 3775: 1			; div16            (405,1us @16.777216MHz)
 3776: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3777: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3778: 1			; input:    r1, r0 = Deeltal (acc0)
 3779: 1			;           r5, r4 = Deler   (acc1)
 3780: 1			;
 3781: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3782: 1			;           r5, r4 = rest van de deling acc0/acc1
 3783: 1			;            cy=1 bij deling door nul (acc1=0)
 3784: 1			;            cy=0 bij normale deling
 3785: 1			;
 3786: 1			; vernietigt: niets
 3787: 1			;*******************************************************************************
 3788: 1
 3789: 1  0CA4	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3790: 1  0CA6	C0 D0		                push    psw
 3791: 1			;check voor deling door nul
 3792: 1  0CA8	EC		                mov     a,r4           ;neem lsb deler
 3793: 1  0CA9	4D		                orl     a,r5           ;combineer met msb van deler
 3794: 1  0CAA	70 06		                jnz     div160         ;niet nul, dan verder werken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3795: 1  0CAC	D0 D0		                pop     psw            ;als nul, dikke snul
 3796: 1  0CAE	D3		                setb    c              ;terug met errorstatus
 3797: 1  0CAF	D0 E0		                pop     acc
 3798: 1  0CB1	22		                ret
 3799: 1
 3800: 1  0CB2	C0 F0		div160:         push    b              ;registers verder bewaren
 3801: 1  0CB4	EF		                mov     a,r7
 3802: 1  0CB5	C0 E0		                push    acc            ;push r7 op stack
 3803: 1  0CB7	EE		                mov     a,r6
 3804: 1  0CB8	C0 E0		                push    acc            ;push r6 op stack
 3805: 1  0CBA	EB		                mov     a,r3
 3806: 1  0CBB	C0 E0		                push    acc            ;push r3 op stack
 3807: 1  0CBD	EA		                mov     a,r2
 3808: 1  0CBE	C0 E0		                push    acc            ;push r2 op stack
 3809: 1  0CC0	C0 83		                push    dph
 3810: 1  0CC2	C0 82		                push    dpl
 3811: 1
 3812: 1  0CC4	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3813: 1  0CC6	7B 00		                mov     r3,#0
 3814: 1  0CC8	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3815: 1  0CCA	7E 00		                mov     r6,#0
 3816: 1  0CCC	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3817: 1
 3818: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3819: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3820: 1			;het aantal significante bits af in de lusteller b
 3821: 1
 3822: 1  0CCF	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3823: 1  0CD0	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3824: 1  0CD3	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3825: 1  0CD4	E8		                mov     a,r0            ;lsb van deeltal nemen
 3826: 1  0CD5	33		                rlc     a                ;en opschuiven
 3827: 1  0CD6	F8		                mov     r0,a
 3828: 1  0CD7	E9		                mov     a,r1            ;msb van deeltal nemen
 3829: 1  0CD8	33		                rlc     a
 3830: 1  0CD9	F9		                mov     r1,a
 3831: 1  0CDA	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3832: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3833: 1  0CDD	7C 00		                mov     r4,#0
 3834: 1  0CDF	7D 00		                mov     r5,#0
 3835: 1  0CE1	80 2E		                sjmp    div164          ;klaar!
 3836: 1
 3837: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3838: 1
 3839: 1  0CE3	C3		div162:            clr     C            ;start met carry op nul
 3840: 1  0CE4	E8		                mov     a,r0            ;schuif deeltal naar links
 3841: 1  0CE5	33		                rlc     a
 3842: 1  0CE6	F8		                mov     r0,a
 3843: 1  0CE7	E9		                mov     a,r1
 3844: 1  0CE8	33		                rlc     a
 3845: 1  0CE9	F9		                mov     r1,a
 3846: 1  0CEA	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3847: 1  0CEB	33		                rlc     a               ;gedeeltelijke rest
 3848: 1  0CEC	FE		                mov     r6,a
 3849: 1  0CED	EF		                mov     a,r7
 3850: 1  0CEE	33		                rlc     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3851: 1  0CEF	FF		                mov     r7,a
 3852: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3853: 1  0CF0	EE		                mov     a,r6
 3854: 1  0CF1	C3		                clr     C
 3855: 1  0CF2	9C		                subb    a,r4
 3856: 1  0CF3	F5 82		                mov     dpl,a
 3857: 1  0CF5	EF		                mov     a,r7
 3858: 1  0CF6	9D		                subb    a,r5
 3859: 1  0CF7	F5 83		                mov     dph,a
 3860: 1  0CF9	40 04		                jc      div163
 3861: 1  0CFB	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3862: 1  0CFD	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3863: 1
 3864: 1  0CFF	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3865: 1  0D00	EA		                mov     a,r2            ;binnenschuiven
 3866: 1  0D01	33		                rlc     a
 3867: 1  0D02	FA		                mov     r2,a
 3868: 1  0D03	EB		                mov     a,r3
 3869: 1  0D04	33		                rlc     a
 3870: 1  0D05	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 3871: 1  0D06	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3872: 1
 3873: 1  0D09	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3874: 1  0D0A	F9		                mov     r1,a
 3875: 1  0D0B	EA		                mov     a,r2
 3876: 1  0D0C	F8		                mov     r0,a
 3877: 1  0D0D	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3878: 1  0D0E	FD		                mov     r5,a
 3879: 1  0D0F	EE		                mov     a,r6
 3880: 1  0D10	FC		                mov     r4,a
 3881: 1
 3882: 1  0D11	D0 82		div164:         pop     dpl             ;registers herstellen
 3883: 1  0D13	D0 83		                pop     dph
 3884: 1  0D15	D0 E0		                pop     acc
 3885: 1  0D17	FA		                mov     r2,a            ;r2 van stack halen
 3886: 1  0D18	D0 E0		                pop     acc
 3887: 1  0D1A	FB		                mov     r3,a            ;r3 van stack halen
 3888: 1  0D1B	D0 E0		                pop     acc
 3889: 1  0D1D	FE		                mov     r6,a            ;r6 van stack halen
 3890: 1  0D1E	D0 E0		                pop     acc
 3891: 1  0D20	FF		                mov     r7,a            ;r7 van stack halen
 3892: 1  0D21	D0 F0		                pop     b
 3893: 1  0D23	D0 D0		                pop     psw
 3894: 1  0D25	C3		                clr     c               ;deling ok
 3895: 1  0D26	D0 E0		                pop     acc
 3896: 1  0D28	22		                ret
 3897: 1
 3898: 1
 3899: 1			;*******************************************************************************
 3900: 1			; s_div32        (2,15ms @16.777216MHz)
 3901: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3902: 1			; 2's Complement Format
 3903: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3904: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3905: 1			;
 3906: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3907: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3908: 1			;
 3909: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3910: 1			;           r7,r6,r5, r4 = rest
 3911: 1			;           cy=1 bij acc1=0 (deling door nul)
 3912: 1			;            cy=0 in andere gevallen
 3913: 1			;
 3914: 1			; vernietigt: niets
 3915: 1			;*******************************************************************************
 3916: 1  0D29	C0 E0		s_div32:        push    acc
 3917: 1  0D2B	C0 D0		                push    psw
 3918: 1  0D2D	EF		                mov     a,r7            ;neem msb van deler
 3919: 1  0D2E	4E		                orl     a,r6            ;combineer met lsb's van deler
 3920: 1  0D2F	4D		                orl     a,r5
 3921: 1  0D30	4C		                orl     a,r4
 3922: 1  0D31	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3923: 1  0D33	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3924: 1  0D35	D0 E0		                pop     acc
 3925: 1  0D37	D3		                setb    C                ;fout, deling door nul!
 3926: 1  0D38	22		                ret
 3927: 1
 3928: 1  0D39	12 09 55	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3929: 1  0D3C	12 09 7F	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3930: 1  0D3F	12 0D 4E	                lcall   div32            ;deel 32bit/32bit
 3931: 1  0D42	12 08 6F	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3932: 1  0D45	12 08 99	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3933: 1  0D48	D0 D0		                pop     psw
 3934: 1  0D4A	C3		                clr     C                ;delig ok
 3935: 1  0D4B	D0 E0		                pop     acc
 3936: 1  0D4D	22		                ret                        ;klaar
 3937: 1
 3938: 1
 3939: 1			;*******************************************************************************
 3940: 1			; div32        (2,09ms @16.777216MHz)
 3941: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3942: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3943: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3944: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3945: 1			;
 3946: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 3947: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3948: 1			;            cy=1 bij deling door nul (acc1=0)
 3949: 1			;            cy=0 bij normale deling
 3950: 1			;
 3951: 1			; vernietigt: niets
 3952: 1			;*******************************************************************************
 3953: 1  0D4E	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3954: 1  0D50	C0 D0		                push    psw
 3955: 1			;check voor deling door nul
 3956: 1  0D52	EF		                mov     a,r7            ;neem msb van deler
 3957: 1  0D53	4E		                orl     a,r6            ;combineer met lsb's van deler
 3958: 1  0D54	4D		                orl     a,r5
 3959: 1  0D55	4C		                orl     a,r4
 3960: 1  0D56	70 06		                jnz     div320          ;niet nul, dan verder werken
 3961: 1  0D58	D0 D0		                pop     psw             ;als nul, dikke snul
 3962: 1  0D5A	D3		                setb    c               ;terug met errorstatus

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3963: 1  0D5B	D0 E0		                pop     acc
 3964: 1  0D5D	22		                ret
 3965: 1
 3966: 1  0D5E	C0 F0		div320:         push    b                ;registers verder bewaren
 3967: 1  0D60	C0 83		                push    dph
 3968: 1  0D62	C0 82		                push    dpl
 3969: 1
 3970: 1  0D64	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3971: 1
 3972: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3973: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3974: 1			;het aantal significante bits af in de lusteller b
 3975: 1
 3976: 1  0D67	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3977: 1  0D68	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3978: 1  0D6B	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3979: 1  0D6C	E8		                mov     a,r0            ;lsb van deeltal nemen
 3980: 1  0D6D	33		                rlc     a               ;en opschuiven
 3981: 1  0D6E	F8		                mov     r0,a
 3982: 1  0D6F	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 3983: 1  0D70	33		                rlc     a
 3984: 1  0D71	F9		                mov     r1,a
 3985: 1  0D72	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3986: 1  0D73	33		                rlc     a
 3987: 1  0D74	FA		                mov     r2,a
 3988: 1  0D75	EB		                mov     a,r3           ;lsb van deeltal nemen
 3989: 1  0D76	33		                rlc     a
 3990: 1  0D77	FB		                mov     r3,a
 3991: 1  0D78	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3992: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3993: 1  0D7B	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3994: 1  0D7D	7E 00		                mov     r6,#0
 3995: 1  0D7F	7D 00		                mov     r5,#0
 3996: 1  0D81	7C 00		                mov     r4,#0
 3997: 1  0D83	02 0E 4C	                ljmp    div324           ;klaar!
 3998: 1
 3999: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 4000: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 4001: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 4002: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 4003: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 4004: 1
 4005: 1  0D86			div320b:
 4006: 1  0D86	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 4007: 1
 4008: 1  0D89	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 4009: 1  0D8B	24 0C		                add     a,#12           ;met 12 plaatsen
 4010: 1  0D8D	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 4011: 1
 4012: 1  0D8F	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 4013: 1  0D90	C0 E0		                push    acc
 4014: 1  0D92	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 4015: 1  0D93	C0 E0		                push    acc
 4016: 1
 4017: 1  0D95	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 4018: 1  0D97	08		                inc     r0              ;de deler

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4019: 1  0D98	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 4020: 1  0D9A	24 05		                add     a,#5            ;het tijdelijk verschil X
 4021: 1  0D9C	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 4022: 1  0D9D	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 4023: 1  0D9F	24 09		                add     a,#9            ;quotient
 4024: 1  0DA1	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 4025: 1
 4026: 1			;Eenmalig de variabelen op stack initaliseren
 4027: 1			;Tijdelijk quotient op nul zetten
 4028: 1
 4029: 1  0DA3	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 4030: 1  0DA5	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 4031: 1  0DA6	C0 F0		                push    b                ;loopteller deling bewaren
 4032: 1  0DA8	75 F0 04	                mov     b,#4
 4033: 1  0DAB	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 4034: 1  0DAD	09		                inc     r1
 4035: 1  0DAE	D5 F0 FA	                djnz    b,div320c
 4036: 1  0DB1	D0 F0		                pop     b                ;loopteller deling ophalen
 4037: 1  0DB3	19		                dec     r1
 4038: 1  0DB4	19		                dec     r1
 4039: 1  0DB5	19		                dec     r1
 4040: 1  0DB6	19		                dec     r1               ;pointer weer op startadres quotient
 4041: 1  0DB7	C9		                xch     a,r1             ;weer omwisselen
 4042: 1  0DB8	C5 82		                xch     a,dpl
 4043: 1
 4044: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 4045: 1  0DBA	EC		                mov     a,r4
 4046: 1  0DBB	F6		                mov     @r0,a
 4047: 1  0DBC	08		                inc     r0
 4048: 1  0DBD	ED		                mov     a,r5
 4049: 1  0DBE	F6		                mov     @r0,a
 4050: 1  0DBF	08		                inc     r0
 4051: 1  0DC0	EE		                mov     a,r6
 4052: 1  0DC1	F6		                mov     @r0,a
 4053: 1  0DC2	08		                inc     r0
 4054: 1  0DC3	EF		                mov     a,r7
 4055: 1  0DC4	F6		                mov     @r0,a
 4056: 1  0DC5	18		                dec     r0             ;pointer herstellen naar lsb van deler
 4057: 1  0DC6	18		                dec     r0
 4058: 1  0DC7	18		                dec     r0
 4059: 1
 4060: 1  0DC8	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 4061: 1  0DCA	7E 00		                mov     r6,#0
 4062: 1  0DCC	7D 00		                mov     r5,#0
 4063: 1  0DCE	7C 00		                mov     r4,#0
 4064: 1
 4065: 1
 4066: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 4067: 1  0DD0	C3		div322:         clr     C               ;start met carry op nul
 4068: 1
 4069: 1  0DD1	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 4070: 1  0DD3	33		                rlc     a
 4071: 1  0DD4	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 4072: 1  0DD6	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 4073: 1  0DD8	D0 E0		                pop     acc             ;r1 van deeltal van stack
 4074: 1  0DDA	33		                rlc     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4075: 1  0DDB	C0 E0		                push    acc             ;en weer bewaren
 4076: 1  0DDD	05 81		                inc     sp              ;stackpointer weer corrigeren
 4077: 1
 4078: 1  0DDF	EA		                mov     a,r2
 4079: 1  0DE0	33		                rlc     a
 4080: 1  0DE1	FA		                mov     r2,a
 4081: 1  0DE2	EB		                mov     a,r3
 4082: 1  0DE3	33		                rlc     a
 4083: 1  0DE4	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 4084: 1
 4085: 1  0DE5	EC		                mov     a,r4            ;schuif carry van deeltal in de
 4086: 1  0DE6	33		                rlc     a               ;gedeeltelijke rest r7..r4
 4087: 1  0DE7	FC		                mov     r4,a
 4088: 1  0DE8	ED		                mov     a,r5
 4089: 1  0DE9	33		                rlc     a
 4090: 1  0DEA	FD		                mov     r5,a
 4091: 1  0DEB	EE		                mov     a,r6
 4092: 1  0DEC	33		                rlc     a
 4093: 1  0DED	FE		                mov     r6,a
 4094: 1  0DEE	EF		                mov     a,r7
 4095: 1  0DEF	33		                rlc     a
 4096: 1  0DF0	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 4097: 1
 4098: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 4099: 1
 4100: 1  0DF1	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 4101: 1  0DF2	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 4102: 1  0DF3	96		                subb    a,@r0           ;trek er de lsb deler af
 4103: 1  0DF4	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4104: 1  0DF5	08		                inc     r0              ;pointers aanpassen
 4105: 1  0DF6	09		                inc     r1
 4106: 1  0DF7	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4107: 1  0DF8	96		                subb    a,@r0           ;trek er volgende byte deler af
 4108: 1  0DF9	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4109: 1  0DFA	08		                inc     r0              ;pointers aanpassen
 4110: 1  0DFB	09		                inc     r1
 4111: 1  0DFC	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4112: 1  0DFD	96		                subb    a,@r0           ;trek er volgende byte deler af
 4113: 1  0DFE	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4114: 1  0DFF	08		                inc     r0              ;pointers aanpassen
 4115: 1  0E00	09		                inc     r1
 4116: 1  0E01	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4117: 1  0E02	96		                subb    a,@r0           ;trek er msb deler af
 4118: 1  0E03	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4119: 1  0E04	18		                dec     r0              ;pointers herstellen naar lsb's
 4120: 1  0E05	18		                dec     r0
 4121: 1  0E06	18		                dec     r0
 4122: 1  0E07	19		                dec     r1
 4123: 1  0E08	19		                dec     r1
 4124: 1  0E09	19		                dec     r1
 4125: 1
 4126: 1  0E0A	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4127: 1  0E0C	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4128: 1  0E0D	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4129: 1  0E0E	09		                inc     r1
 4130: 1  0E0F	E7		                mov     a,@r1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4131: 1  0E10	FD		                mov     r5,a
 4132: 1  0E11	09		                inc     r1
 4133: 1  0E12	E7		                mov     a,@r1
 4134: 1  0E13	FE		                mov     r6,a
 4135: 1  0E14	09		                inc     r1
 4136: 1  0E15	E7		                mov     a,@r1
 4137: 1  0E16	FF		                mov     r7,a
 4138: 1  0E17	19		                dec     r1              ;met pointer weer naar lsb van
 4139: 1  0E18	19		                dec     r1              ;het tijdelijk verschil wijzen
 4140: 1  0E19	19		                dec     r1
 4141: 1
 4142: 1
 4143: 1  0E1A	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4144: 1  0E1B	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4145: 1  0E1D	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4146: 1  0E1E	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4147: 1  0E20	E7		                mov     a,@r1           ;neem lsb van qoutient
 4148: 1  0E21	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4149: 1  0E22	F7		                mov     @r1,a
 4150: 1  0E23	09		                inc     r1              ;volgende byte
 4151: 1  0E24	E7		                mov     a,@r1
 4152: 1  0E25	33		                rlc     a
 4153: 1  0E26	F7		                mov     @r1,a
 4154: 1  0E27	09		                inc     r1              ;volgende byte
 4155: 1  0E28	E7		                mov     a,@r1
 4156: 1  0E29	33		                rlc     a
 4157: 1  0E2A	F7		                mov     @r1,a
 4158: 1  0E2B	09		                inc     r1              ;volgende byte
 4159: 1  0E2C	E7		                mov     a,@r1
 4160: 1  0E2D	33		                rlc     a
 4161: 1  0E2E	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4162: 1  0E2F	19		                dec     r1
 4163: 1  0E30	19		                dec     r1
 4164: 1  0E31	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4165: 1  0E32	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4166: 1  0E34	C9		                xch     a,r1            ;r1=pointer naar verschil
 4167: 1  0E35	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4168: 1
 4169: 1  0E37	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4170: 1
 4171: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4172: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4173: 1
 4174: 1  0E3A	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4175: 1  0E3C	18		                dec     r0
 4176: 1  0E3D	18		                dec     r0
 4177: 1  0E3E	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4178: 1  0E3F	FB		                mov     r3,a            ;en verplaatsen
 4179: 1  0E40	18		                dec     r0              ;volgende byte
 4180: 1  0E41	E6		                mov     a,@r0
 4181: 1  0E42	FA		                mov     r2,a
 4182: 1  0E43	18		                dec     r0              ;volgende byte
 4183: 1  0E44	E6		                mov     a,@r0
 4184: 1  0E45	F9		                mov     r1,a
 4185: 1  0E46	18		                dec     r0              ;volgende byte
 4186: 1  0E47	E6		                mov     a,@r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4187: 1  0E48	F8		                mov     r0,a            ;laatste byte verplaatst!
 4188: 1
 4189: 1  0E49	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4190: 1			                                         ;weer vrijgeven
 4191: 1
 4192: 1
 4193: 1  0E4C	D0 82		div324:         pop     dpl             ;registers herstellen
 4194: 1  0E4E	D0 83		                pop     dph
 4195: 1  0E50	D0 F0		                pop     b
 4196: 1  0E52	D0 D0		                pop     psw
 4197: 1  0E54	C3		                clr     c               ;normale deling
 4198: 1  0E55	D0 E0		                pop     acc
 4199: 1  0E57	22		                ret
 4200: 1
 4201: 1			;*******************************************************************************
 4202: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4203: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4204: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4205: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4206: 1			;
 4207: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4208: 1			;
 4209: 1			; input:     r5,r4 = acc1 (low word product)
 4210: 1			;            r7,r6 = acc1 (high word product)
 4211: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4212: 1			;
 4213: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4214: 1			;            r7,r6,r5,r4 = acc1 = rest
 4215: 1			;                          -2147483648 tot +2147483647
 4216: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4217: 1			;             cy=1 bij deling door nul (acc0=0)
 4218: 1			;             cy=0 bij normale deling
 4219: 1			;
 4220: 1			; vernietigt:  niets
 4221: 1			;*******************************************************************************
 4222: 1  0E58	C0 E0		s_muldiv:       push    acc
 4223: 1  0E5A	C0 D0		                push    psw
 4224: 1  0E5C	E8		                mov     a,r0            ;neem msb van deler
 4225: 1  0E5D	49		                orl     a,r1            ;combineer met lsb's van deler
 4226: 1  0E5E	4A		                orl     a,r2
 4227: 1  0E5F	4B		                orl     a,r3
 4228: 1  0E60	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4229: 1  0E62	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4230: 1  0E64	D0 E0		                pop     acc
 4231: 1  0E66	D3		                setb    C               ;fout, deling door nul!
 4232: 1  0E67	22		                ret
 4233: 1
 4234: 1  0E68	12 09 15	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4235: 1  0E6B	12 09 35	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4236: 1  0E6E	12 0E 7D	                lcall    muldiv          ;maak product en daarna de deling
 4237: 1  0E71	12 08 6F	                lcall    magsig32        ;quotient naar 2's complement
 4238: 1  0E74	12 08 99	                lcall    magsig32acc1    ;rest naar 2's complement
 4239: 1  0E77	D0 D0		                pop     psw
 4240: 1  0E79	C3		                clr     c                ;deling is ok
 4241: 1  0E7A	D0 E0		                pop    acc
 4242: 1  0E7C	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4243: 1
 4244: 1			;*******************************************************************************
 4245: 1			; muldiv        (2,0ms @16.777216MHz)
 4246: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4247: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4248: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4249: 1			; 32bit rest in acc1.
 4250: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4251: 1			;
 4252: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4253: 1			;
 4254: 1			; input:     r5,r4 = acc1 (low word product)
 4255: 1			;            r7,r6 = acc1 (high word product)
 4256: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4257: 1			;
 4258: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4259: 1			;            r7,r6,r5,r4 = acc1 = rest
 4260: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4261: 1			;             cy=1 bij deling door nul (acc0=0)
 4262: 1			;             cy=0 bij normale deling
 4263: 1			;
 4264: 1			; vernietigt:  niets
 4265: 1			;*******************************************************************************
 4266: 1  0E7D	C0 E0		muldiv:         push    acc
 4267: 1  0E7F	C0 D0		                push    psw
 4268: 1  0E81	E8		                mov     a,r0            ;neem msb van deler
 4269: 1  0E82	49		                orl     a,r1            ;combineer met lsb's van deler
 4270: 1  0E83	4A		                orl     a,r2
 4271: 1  0E84	4B		                orl     a,r3
 4272: 1  0E85	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4273: 1  0E87	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4274: 1  0E89	D0 E0		                pop     acc
 4275: 1  0E8B	D3		                setb    C               ;fout, deling door nul!
 4276: 1  0E8C	22		                ret
 4277: 1
 4278: 1  0E8D	12 0B 7E	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4279: 1  0E90	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4280: 1  0E91	C0 E0		                push    acc
 4281: 1  0E93	ED		                mov     a,r5
 4282: 1  0E94	C0 E0		                push    acc
 4283: 1  0E96	EE		                mov     a,r6
 4284: 1  0E97	C0 E0		                push    acc
 4285: 1  0E99	EF		                mov     a,r7
 4286: 1  0E9A	C0 E0		                push    acc             ;product staat nu op stack
 4287: 1
 4288: 1  0E9C	E8		                mov     a,r0            ;deler in acc1 stoppen
 4289: 1  0E9D	FC		                mov     r4,a
 4290: 1  0E9E	E9		                mov     a,r1
 4291: 1  0E9F	FD		                mov     r5,a
 4292: 1  0EA0	EA		                mov     a,r2
 4293: 1  0EA1	FE		                mov     r6,a
 4294: 1  0EA2	EB		                mov     a,r3
 4295: 1  0EA3	FF		                mov     r7,a            ;deler zit volledig in acc1
 4296: 1
 4297: 1  0EA4	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4298: 1  0EA6	FB		                mov     r3,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4299: 1  0EA7	D0 E0		                pop     acc
 4300: 1  0EA9	FA		                mov     r2,a
 4301: 1  0EAA	D0 E0		                pop     acc
 4302: 1  0EAC	F9		                mov     r1,a
 4303: 1  0EAD	D0 E0		                pop     acc
 4304: 1  0EAF	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4305: 1  0EB0	12 0D 4E	                lcall   div32           ;maak deling
 4306: 1
 4307: 1  0EB3	D0 D0		                pop     psw            ;herstel registers
 4308: 1  0EB5	D0 E0		                pop     acc
 4309: 1  0EB7	C3		                clr     C              ;resultaat ok!
 4310: 1  0EB8	22		                ret
 4311: 1
 4312: 1			;*******************************************************************************
 4313: 1			; mul16_pi        (257,1us @16.777216MHz)
 4314: 1			; acc0 = acc0 x pi
 4315: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4316: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4317: 1			;
 4318: 1			; input:     r1,r0 = acc0 (low word)
 4319: 1			;
 4320: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4321: 1			;
 4322: 1			; vernietigt:  niets
 4323: 1			;*******************************************************************************
 4324: 1  0EB9	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4325: 1  0EBB	C0 D0		                push    psw
 4326: 1  0EBD	EC		                mov     a,r4
 4327: 1  0EBE	C0 E0		                push    acc
 4328: 1  0EC0	ED		                mov     a,r5
 4329: 1  0EC1	C0 E0		                push    acc
 4330: 1  0EC3	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4331: 1  0EC5	7C 0F		                mov     r4,#0fH
 4332: 1  0EC7	12 0B 19	                lcall   mul16           ;acc0 = acc0 x acc1
 4333: 1  0ECA	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4334: 1  0ECC	12 10 B5	                lcall   shiftright32    ;om te delen door 2^14
 4335: 1  0ECF	D0 E0		                pop     acc
 4336: 1  0ED1	FD		                mov     r5,a
 4337: 1  0ED2	D0 E0		                pop     acc
 4338: 1  0ED4	FC		                mov     r4,a
 4339: 1  0ED5	D0 D0		                pop     psw
 4340: 1  0ED7	D0 E0		                pop     acc
 4341: 1  0ED9	22		                ret
 4342: 1
 4343: 1			;*******************************************************************************
 4344: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4345: 1			; acc0 = acc0 x 1/pi
 4346: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4347: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4348: 1			;
 4349: 1			; input:     r1,r0 = acc0 (low word)
 4350: 1			;
 4351: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4352: 1			;
 4353: 1			; vernietigt:  niets
 4354: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4355: 1  0EDA	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4356: 1  0EDC	C0 D0		                push    psw
 4357: 1  0EDE	EC		                mov     a,r4
 4358: 1  0EDF	C0 E0		                push    acc
 4359: 1  0EE1	ED		                mov     a,r5
 4360: 1  0EE2	C0 E0		                push    acc
 4361: 1  0EE4	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4362: 1  0EE6	7C 7D		                mov     r4,#07dH
 4363: 1  0EE8	12 0B 19	                lcall    mul16          ;acc0 = acc0 x acc1
 4364: 1  0EEB	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4365: 1  0EED	12 10 B5	                lcall   shiftright32    ;om te delen door 2^16
 4366: 1  0EF0	D0 E0		                pop     acc
 4367: 1  0EF2	FD		                mov     r5,a
 4368: 1  0EF3	D0 E0		                pop     acc
 4369: 1  0EF5	FC		                mov     r4,a
 4370: 1  0EF6	D0 D0		                pop     psw
 4371: 1  0EF8	D0 E0		                pop     acc
 4372: 1  0EFA	22		                ret
 4373: 1
 4374: 1			;*******************************************************************************
 4375: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4376: 1			; acc0 = acc0 x sqrt2
 4377: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4378: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4379: 1			;
 4380: 1			; input:     r1,r0 = acc0 (low word)
 4381: 1			;
 4382: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4383: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4384: 1			;
 4385: 1			; vernietigt:  niets
 4386: 1			;*******************************************************************************
 4387: 1  0EFB	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4388: 1  0EFD	C0 D0		                push    psw
 4389: 1  0EFF	EC		                mov     a,r4
 4390: 1  0F00	C0 E0		                push    acc
 4391: 1  0F02	ED		                mov     a,r5
 4392: 1  0F03	C0 E0		                push    acc
 4393: 1  0F05	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4394: 1  0F07	7C 05		                mov     r4,#005H
 4395: 1  0F09	12 0B 19	                lcall   mul16           ;acc0 = acc0 x acc1
 4396: 1  0F0C	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4397: 1  0F0E	12 10 B5	                lcall   shiftright32    ;om te delen door 2^15
 4398: 1  0F11	D0 E0		                pop     acc
 4399: 1  0F13	FD		                mov     r5,a
 4400: 1  0F14	D0 E0		                pop     acc
 4401: 1  0F16	FC		                mov     r4,a
 4402: 1  0F17	D0 D0		                pop     psw
 4403: 1  0F19	D0 E0		                pop     acc
 4404: 1  0F1B	22		                ret
 4405: 1
 4406: 1
 4407: 1
 4408: 1			;*******************************************************************************
 4409: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4410: 1			; acc0 = acc0 x 1/sqrt2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4411: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4412: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4413: 1			;
 4414: 1			; input:     r1,r0 = acc0 (low word)
 4415: 1			;
 4416: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4417: 1			;
 4418: 1			; vernietigt:  niets
 4419: 1			;*******************************************************************************
 4420: 1  0F1C	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4421: 1  0F1E	C0 D0		                push    psw
 4422: 1  0F20	EC		                mov     a,r4
 4423: 1  0F21	C0 E0		                push    acc
 4424: 1  0F23	ED		                mov     a,r5
 4425: 1  0F24	C0 E0		                push    acc
 4426: 1  0F26	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4427: 1  0F28	7C 05		                mov     r4,#005H
 4428: 1  0F2A	12 0B 19	                lcall   mul16           ;acc0 = acc0 x acc1
 4429: 1  0F2D	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4430: 1  0F2F	12 10 B5	                lcall   shiftright32    ;om te delen door 2^16
 4431: 1  0F32	D0 E0		                pop     acc
 4432: 1  0F34	FD		                mov     r5,a
 4433: 1  0F35	D0 E0		                pop     acc
 4434: 1  0F37	FC		                mov     r4,a
 4435: 1  0F38	D0 D0		                pop     psw
 4436: 1  0F3A	D0 E0		                pop     acc
 4437: 1  0F3C	22		                ret
 4438: 1
 4439: 1			;*******************************************************************************
 4440: 1			; mul16_10        (98,7us @16.777216MHz)
 4441: 1			; acc0 = acc0 x 10
 4442: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4443: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4444: 1			;
 4445: 1			; input:     r1,r0 = acc0 (low word)
 4446: 1			;
 4447: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4448: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4449: 1			; vernietigt:  niets
 4450: 1			;*******************************************************************************
 4451: 1  0F3D	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4452: 1  0F3F	C0 D0		                push    psw
 4453: 1  0F41	EC		                mov     a,r4
 4454: 1  0F42	C0 E0		                push    acc
 4455: 1  0F44	7C 01		                mov     r4,#1           ;acc0 x2
 4456: 1  0F46	12 10 E1	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4457: 1  0F49	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4458: 1  0F4A	C0 E0		                push    acc
 4459: 1  0F4C	EA		                mov     a,r2
 4460: 1  0F4D	C0 E0		                push    acc
 4461: 1  0F4F	E9		                mov     a,r1
 4462: 1  0F50	C0 E0		                push    acc
 4463: 1  0F52	E8		                mov     a,r0
 4464: 1  0F53	C0 E0		                push    acc             ;acc0 op stack
 4465: 1  0F55	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4466: 1  0F57	12 10 E1	                lcall   shiftleft32     ;acc0 =acc0 x4

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4467: 1  0F5A	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4468: 1  0F5C	28		                add     a,r0            ;tel bij huidige acc0
 4469: 1  0F5D	F8		                mov     r0,a
 4470: 1  0F5E	D0 E0		                pop     acc
 4471: 1  0F60	39		                addc    a,r1
 4472: 1  0F61	F9		                mov     r1,a
 4473: 1  0F62	D0 E0		                pop     acc
 4474: 1  0F64	3A		                addc    a,r2
 4475: 1  0F65	FA		                mov     r2,a
 4476: 1  0F66	D0 E0		                pop     acc
 4477: 1  0F68	3B		                addc    a,r3
 4478: 1  0F69	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4479: 1
 4480: 1
 4481: 1  0F6A	D0 E0		                pop     acc
 4482: 1  0F6C	FC		                mov     r4,a
 4483: 1  0F6D	D0 D0		                pop     psw
 4484: 1  0F6F	D0 E0		                pop     acc
 4485: 1  0F71	22		                ret
 4486: 1
 4487: 1			;*******************************************************************************
 4488: 1			; mul16_100        (169,1us @16.777216MHz)
 4489: 1			; acc0 = acc0 x 100
 4490: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4491: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4492: 1			;
 4493: 1			; input:     r1,r0 = acc0 (low word)
 4494: 1			;
 4495: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4496: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4497: 1			; vernietigt:  niets
 4498: 1			;*******************************************************************************
 4499: 1  0F72	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4500: 1  0F74	C0 D0		                push    psw
 4501: 1  0F76	EC		                mov     a,r4
 4502: 1  0F77	C0 E0		                push    acc
 4503: 1  0F79	7C 02		                mov     r4,#2           ;acc0 x4
 4504: 1  0F7B	12 10 E1	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4505: 1  0F7E	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4506: 1  0F7F	C0 E0		                push    acc
 4507: 1  0F81	EA		                mov     a,r2
 4508: 1  0F82	C0 E0		                push    acc
 4509: 1  0F84	E9		                mov     a,r1
 4510: 1  0F85	C0 E0		                push    acc
 4511: 1  0F87	E8		                mov     a,r0
 4512: 1  0F88	C0 E0		                push    acc             ;acc0 op stack
 4513: 1
 4514: 1  0F8A	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4515: 1  0F8C	12 10 E1	                lcall   shiftleft32     ;acc0 =acc0 x8
 4516: 1  0F8F	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4517: 1  0F90	C0 E0		                push    acc
 4518: 1  0F92	EA		                mov     a,r2
 4519: 1  0F93	C0 E0		                push    acc
 4520: 1  0F95	E9		                mov     a,r1
 4521: 1  0F96	C0 E0		                push    acc
 4522: 1  0F98	E8		                mov     a,r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4523: 1  0F99	C0 E0		                push    acc             ;acc0 op stack
 4524: 1
 4525: 1  0F9B	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4526: 1  0F9D	12 10 E1	                lcall   shiftleft32     ;acc0 =acc0 x2
 4527: 1  0FA0	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4528: 1  0FA2	28		                add     a,r0            ;tel bij huidige acc0
 4529: 1  0FA3	F8		                mov     r0,a
 4530: 1  0FA4	D0 E0		                pop     acc
 4531: 1  0FA6	39		                addc    a,r1
 4532: 1  0FA7	F9		                mov     r1,a
 4533: 1  0FA8	D0 E0		                pop     acc
 4534: 1  0FAA	3A		                addc    a,r2
 4535: 1  0FAB	FA		                mov     r2,a
 4536: 1  0FAC	D0 E0		                pop     acc
 4537: 1  0FAE	3B		                addc    a,r3
 4538: 1  0FAF	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4539: 1
 4540: 1  0FB0	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4541: 1  0FB2	28		                add     a,r0            ;tel bij huidige acc0
 4542: 1  0FB3	F8		                mov     r0,a
 4543: 1  0FB4	D0 E0		                pop     acc
 4544: 1  0FB6	39		                addc    a,r1
 4545: 1  0FB7	F9		                mov     r1,a
 4546: 1  0FB8	D0 E0		                pop     acc
 4547: 1  0FBA	3A		                addc    a,r2
 4548: 1  0FBB	FA		                mov     r2,a
 4549: 1  0FBC	D0 E0		                pop     acc
 4550: 1  0FBE	3B		                addc    a,r3
 4551: 1  0FBF	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4552: 1
 4553: 1  0FC0	D0 E0		                pop     acc
 4554: 1  0FC2	FC		                mov     r4,a
 4555: 1  0FC3	D0 D0		                pop     psw
 4556: 1  0FC5	D0 E0		                pop     acc
 4557: 1  0FC7	22		                ret
 4558: 1
 4559: 1			;*******************************************************************************
 4560: 1			; sqrt32        (2,99ms @16.777216MHz)
 4561: 1			; acc0 = acc0 ^(1/2)
 4562: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4563: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4564: 1			;
 4565: 1			; input:     r3,r2,r1,r0 = acc0
 4566: 1			;
 4567: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4568: 1			;
 4569: 1			; vernietigt:  niets
 4570: 1			;*******************************************************************************
 4571: 1  0FC8	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4572: 1  0FCA	C0 F0		                push    b
 4573: 1  0FCC	C0 D0		                push    psw
 4574: 1  0FCE	C0 82		                push    dpl
 4575: 1  0FD0	C0 83		                push    dph
 4576: 1  0FD2	EC		                mov     a,r4
 4577: 1  0FD3	C0 E0		                push    acc
 4578: 1  0FD5	ED		                mov     a,r5

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4579: 1  0FD6	C0 E0		                push    acc
 4580: 1  0FD8	EE		                mov     a,r6
 4581: 1  0FD9	C0 E0		                push    acc
 4582: 1  0FDB	EF		                mov     a,r7
 4583: 1  0FDC	C0 E0		                push    acc
 4584: 1
 4585: 1  0FDE	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4586: 1  0FE0	7D 00		                mov     r5,#0
 4587: 1  0FE2	7E 00		                mov     r6,#0
 4588: 1  0FE4	7F 00		                mov     r7,#0
 4589: 1  0FE6	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4590: 1  0FE9	75 83 00	                mov     dph,#0
 4591: 1  0FEC	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4592: 1			;hier start het algorithme voor het berekenen van de wortel
 4593: 1  0FEF	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4594: 1  0FF1	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4595: 1  0FF4	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4596: 1  0FF5	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4597: 1  0FF6	33		                rlc     a                ;getest worden om een wortelbit te
 4598: 1  0FF7	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4599: 1  0FF8	E9		                mov     a,r1            ;met nullen!
 4600: 1  0FF9	33		                rlc     a
 4601: 1  0FFA	F9		                mov     r1,a
 4602: 1  0FFB	EA		                mov     a,r2
 4603: 1  0FFC	33		                rlc     a
 4604: 1  0FFD	FA		                mov     r2,a
 4605: 1  0FFE	EB		                mov     a,r3
 4606: 1  0FFF	33		                rlc     a
 4607: 1  1000	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4608: 1
 4609: 1  1001	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4610: 1  1002	33		                rlc     a
 4611: 1  1003	FC		                mov     r4,a
 4612: 1  1004	ED		                mov     a,r5
 4613: 1  1005	33		                rlc     a
 4614: 1  1006	FD		                mov     r5,a
 4615: 1  1007	EE		                mov     a,r6
 4616: 1  1008	33		                rlc     a
 4617: 1  1009	FE		                mov     r6,a
 4618: 1  100A	EF		                mov     a,r7
 4619: 1  100B	33		                rlc     a
 4620: 1  100C	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4621: 1  100D	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4622: 1
 4623: 1  1010	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4624: 1
 4625: 1  1012	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4626: 1  1013	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4627: 1  1015	33		                rlc     a
 4628: 1  1016	F5 82		                mov     dpl,a
 4629: 1  1018	E5 83		                mov     a,dph
 4630: 1  101A	33		                rlc     a
 4631: 1  101B	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4632: 1
 4633: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4634: 1  101D	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4635: 1  101E	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4636: 1  1020	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4637: 1  1021	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4638: 1  1023	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4639: 1  1024	C0 E0		                push    acc             ;van acc1
 4640: 1  1026	EB		                mov     a,r3
 4641: 1  1027	C0 E0		                push    acc
 4642: 1  1029	EC		                mov     a,r4
 4643: 1  102A	C0 E0		                push    acc
 4644: 1  102C	ED		                mov     a,r5
 4645: 1  102D	C0 E0		                push    acc
 4646: 1  102F	EE		                mov     a,r6
 4647: 1  1030	C0 E0		                push    acc
 4648: 1  1032	EF		                mov     a,r7
 4649: 1  1033	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4650: 1
 4651: 1  1035	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4652: 1  1037	AD 83		                mov     r5,dph
 4653: 1  1039	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4654: 1  103B	AF 83		                mov     r7,dph
 4655: 1  103D	12 0B 7E	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4656: 1
 4657: 1  1040	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4658: 1  1042	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4659: 1  1043	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4660: 1  1045	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4661: 1  1046	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4662: 1  1048	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4663: 1  1049	D0 E0		                pop     acc             ;de stack...
 4664: 1  104B	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4665: 1
 4666: 1  104C	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4667: 1  104D	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4668: 1  104E	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4669: 1  104F	E9		                mov     a,r1            ;in acc1.
 4670: 1  1050	9D		                subb    a,r5            ;We doen dit door de carry van het
 4671: 1  1051	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4672: 1  1052	9E		                subb    a,r6
 4673: 1  1053	EB		                mov     a,r3
 4674: 1  1054	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4675: 1  1055	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4676: 1			                                        ;wortel behouden
 4677: 1  1057	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4678: 1  1059	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4679: 1  105B	F5 82		                mov     dpl,a          ;wortel aanpassen
 4680: 1
 4681: 1  105D	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4682: 1  105F	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4683: 1  1061	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4684: 1
 4685: 1  1063	D0 E0		                pop     acc            ;haal acc1 weer op
 4686: 1  1065	FF		                mov     r7,a
 4687: 1  1066	D0 E0		                pop     acc
 4688: 1  1068	FE		                mov     r6,a
 4689: 1  1069	D0 E0		                pop     acc
 4690: 1  106B	FD		                mov     r5,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4691: 1  106C	D0 E0		                pop     acc
 4692: 1  106E	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4693: 1
 4694: 1  106F	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4695: 1  1071	FB		                mov     r3,a
 4696: 1  1072	D0 E0		                pop     acc
 4697: 1  1074	FA		                mov     r2,a
 4698: 1  1075	D0 E0		                pop     acc
 4699: 1  1077	F9		                mov     r1,a
 4700: 1  1078	D0 E0		                pop     acc
 4701: 1  107A	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4702: 1
 4703: 1  107B	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4704: 1  107E	80 03		                sjmp    sqrt325
 4705: 1  1080	02 0F EF	sqrt324:        ljmp    sqrt320        ;uit acc0
 4706: 1
 4707: 1  1083	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4708: 1  1085	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4709: 1
 4710: 1  1087	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4711: 1  1089	FF		                mov     r7,a
 4712: 1  108A	D0 E0		                pop     acc
 4713: 1  108C	FE		                mov     r6,a
 4714: 1  108D	D0 E0		                pop     acc
 4715: 1  108F	FD		                mov     r5,a
 4716: 1  1090	D0 E0		                pop     acc
 4717: 1  1092	FC		                mov     r4,a           ;acc1 is hersteld
 4718: 1  1093	D0 83		                pop     dph
 4719: 1  1095	D0 82		                pop     dpl
 4720: 1  1097	D0 D0		                pop     psw
 4721: 1  1099	D0 F0		                pop     b
 4722: 1  109B	D0 E0		                pop     acc
 4723: 1
 4724: 1  109D	22		                ret                    ;eindelijk klaar...
 4725: 1
 4726: 1			;*******************************************************************************
 4727: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4728: 1			; acc0 = acc0 ^(1/2)
 4729: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4730: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4731: 1			;                           (-2147483648 tot +2147483647)
 4732: 1			; input:     r3,r2,r1,r0 = acc0
 4733: 1			;
 4734: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4735: 1			;            CY = 1 als acc0 negatief is
 4736: 1			; vernietigt:  niets
 4737: 1			;*******************************************************************************
 4738: 1  109E	C0 E0		s_sqrt32:       push    acc
 4739: 1  10A0	C0 D0		                push    psw
 4740: 1  10A2	EB		                mov     a,r3
 4741: 1  10A3	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4742: 1  10A6	D0 D0		                pop     psw
 4743: 1  10A8	D3		                setb    c                ;als negatief dan error
 4744: 1  10A9	D0 E0		                pop     acc
 4745: 1  10AB	22		                ret
 4746: 1  10AC	D0 D0		s_sqrt321:      pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4747: 1  10AE	D0 E0		                pop     acc
 4748: 1  10B0	12 0F C8	                lcall   sqrt32            ;wortel trekken
 4749: 1  10B3	C3		                clr     c                 ;wortel ok
 4750: 1  10B4	22		                ret                       ;klaar
 4751: 1
 4752: 1			;*******************************************************************************
 4753: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4754: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4755: 1			; (logical shift)
 4756: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4757: 1			;
 4758: 1			; input:     r3,r2,r1,r0 = acc0
 4759: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4760: 1			;
 4761: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4762: 1			;            CY=1 als N>=32
 4763: 1			; vernietigt:  niets
 4764: 1			;*******************************************************************************
 4765: 1  10B5	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4766: 1  10B7	C0 D0		                push    psw
 4767: 1  10B9	EC		                mov     a,r4            ;neem aantal shifts
 4768: 1  10BA	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4769: 1  10BD	40 06		shiftright1:    jc      shiftright2
 4770: 1  10BF	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4771: 1  10C1	D3		                setb    c               ;N buiten bereik
 4772: 1  10C2	D0 E0		                pop     acc
 4773: 1  10C4	22		                ret
 4774: 1
 4775: 1  10C5	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4776: 1  10C7	8C F0		                mov     b,r4            ;lusteller initialiseren
 4777: 1  10C9	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4778: 1  10CA	EB		                mov     a,r3            ;start bij msb
 4779: 1  10CB	13		                rrc     a
 4780: 1  10CC	FB		                mov     r3,a
 4781: 1  10CD	EA		                mov     a,r2
 4782: 1  10CE	13		                rrc     a
 4783: 1  10CF	FA		                mov     r2,a
 4784: 1  10D0	E9		                mov     a,r1
 4785: 1  10D1	13		                rrc     a
 4786: 1  10D2	F9		                mov     r1,a
 4787: 1  10D3	E8		                mov     a,r0
 4788: 1  10D4	13		                rrc     a
 4789: 1  10D5	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4790: 1  10D6	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4791: 1  10D9	D0 F0		                pop     b               ;registers herstellen
 4792: 1  10DB	D0 D0		                pop     psw
 4793: 1  10DD	C3		                clr     c               ;N is binnen bereik
 4794: 1  10DE	D0 E0		                pop     acc
 4795: 1  10E0	22		                ret
 4796: 1
 4797: 1			;*******************************************************************************
 4798: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4799: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4800: 1			; (logical shift)
 4801: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4802: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4803: 1			; input:     r3,r2,r1,r0 = acc0
 4804: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4805: 1			;
 4806: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4807: 1			;
 4808: 1			; vernietigt:  niets
 4809: 1			;*******************************************************************************
 4810: 1  10E1	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4811: 1  10E3	C0 D0		                push    psw
 4812: 1  10E5	EC		                mov     a,r4            ;neem aantal shifts
 4813: 1  10E6	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4814: 1  10E9	40 06		shiftleft1:     jc      shiftleft2
 4815: 1  10EB	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4816: 1  10ED	D3		                setb    c               ;N buiten bereik
 4817: 1  10EE	D0 E0		                pop     acc
 4818: 1  10F0	22		                ret
 4819: 1
 4820: 1  10F1	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4821: 1  10F3	8C F0		                mov     b,r4            ;lusteller initialiseren
 4822: 1  10F5	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4823: 1  10F6	E8		                mov     a,r0            ;start bij lsb
 4824: 1  10F7	33		                rlc     a
 4825: 1  10F8	F8		                mov     r0,a
 4826: 1  10F9	E9		                mov     a,r1
 4827: 1  10FA	33		                rlc     a
 4828: 1  10FB	F9		                mov     r1,a
 4829: 1  10FC	EA		                mov     a,r2
 4830: 1  10FD	33		                rlc     a
 4831: 1  10FE	FA		                mov     r2,a
 4832: 1  10FF	EB		                mov     a,r3
 4833: 1  1100	33		                rlc     a
 4834: 1  1101	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4835: 1  1102	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4836: 1  1105	D0 F0		                pop     b               ;registers herstellen
 4837: 1  1107	D0 D0		                pop     psw
 4838: 1  1109	C3		                clr     c               ;N is binnen bereik
 4839: 1  110A	D0 E0		                pop     acc
 4840: 1  110C	22		                ret
 4841: 1
 4842: 1			;*******************************************************************************
 4843: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4844: 1			; (arithmetic shift)
 4845: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4846: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4847: 1			; niet van teken!
 4848: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4849: 1			;                       (-2147483648 tot +2147483647)
 4850: 1			;
 4851: 1			; input:     r3,r2,r1,r0 = acc0
 4852: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4853: 1			;
 4854: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4855: 1			;            CY=1 als N>=31
 4856: 1			; vernietigt:  niets
 4857: 1			;*******************************************************************************
 4858: 1  110D	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4859: 1  110F	C0 D0		                push    psw
 4860: 1  1111	EC		                mov     a,r4            ;neem aantal shifts
 4861: 1  1112	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4862: 1  1115	40 06		s_shiftright1:  jc      s_shiftright2
 4863: 1  1117	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4864: 1  1119	D3		                setb    c               ;N buiten bereik
 4865: 1  111A	D0 E0		                pop     acc
 4866: 1  111C	22		                ret
 4867: 1
 4868: 1  111D	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4869: 1  111F	8C F0		                mov     b,r4            ;lusteller initialiseren
 4870: 1  1121	EB		                mov     a,r3
 4871: 1  1122	20 E7 04	                jb      acc.7,s_shiftright20
 4872: 1  1125	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4873: 1  1127	80 02		                sjmp    s_shiftright3
 4874: 1  1129	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4875: 1
 4876: 1  112B	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4877: 1  112D	EB		                mov     a,r3            ;start bij msb
 4878: 1  112E	13		                rrc     a
 4879: 1  112F	FB		                mov     r3,a
 4880: 1  1130	EA		                mov     a,r2
 4881: 1  1131	13		                rrc     a
 4882: 1  1132	FA		                mov     r2,a
 4883: 1  1133	E9		                mov     a,r1
 4884: 1  1134	13		                rrc     a
 4885: 1  1135	F9		                mov     r1,a
 4886: 1  1136	E8		                mov     a,r0
 4887: 1  1137	13		                rrc     a
 4888: 1  1138	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4889: 1  1139	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4890: 1  113C	D0 F0		                pop     b               ;registers herstellen
 4891: 1  113E	D0 D0		                pop     psw
 4892: 1  1140	C3		                clr     c               ;N is binnen bereik
 4893: 1  1141	D0 E0		                pop     acc
 4894: 1  1143	22		                ret
 4895: 1
 4896: 1			;*******************************************************************************
 4897: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4898: 1			; (arithmetic shift)
 4899: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4900: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 4901: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4902: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4903: 1			;                       (-2147483648 tot +2147483647)
 4904: 1			;
 4905: 1			; input:     r3,r2,r1,r0 = acc0
 4906: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4907: 1			;
 4908: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4909: 1			;            CY=1 als N>=31
 4910: 1			; vernietigt:  niets
 4911: 1			;*******************************************************************************
 4912: 1  1144	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 4913: 1  1146	C0 D0		                push    psw
 4914: 1  1148	EC		                mov     a,r4            ;neem aantal shifts

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4915: 1  1149	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4916: 1  114C	40 06		s_shiftleft1:   jc      s_shiftleft2
 4917: 1  114E	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4918: 1  1150	D3		                setb    c               ;N buiten bereik
 4919: 1  1151	D0 E0		                pop     acc
 4920: 1  1153	22		                ret
 4921: 1
 4922: 1  1154	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4923: 1  1156	8C F0		                mov     b,r4            ;lusteller initialiseren
 4924: 1
 4925: 1
 4926: 1
 4927: 1  1158	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4928: 1  1159	E8		                mov     a,r0             ;start bij lsb
 4929: 1  115A	33		                rlc     a
 4930: 1  115B	F8		                mov     r0,a
 4931: 1  115C	E9		                mov     a,r1
 4932: 1  115D	33		                rlc     a
 4933: 1  115E	F9		                mov     r1,a
 4934: 1  115F	EA		                mov     a,r2
 4935: 1  1160	33		                rlc     a
 4936: 1  1161	FA		                mov     r2,a
 4937: 1  1162	EB		                mov     a,r3
 4938: 1  1163	33		                rlc     a
 4939: 1  1164	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4940: 1  1166	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4941: 1  1167	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4942: 1  116A	D0 F0		                pop     b                ;registers herstellen
 4943: 1  116C	D0 D0		                pop     psw
 4944: 1  116E	C3		                clr     c                ;N is binnen bereik
 4945: 1  116F	D0 E0		                pop     acc
 4946: 1  1171	22		                ret
 4947: 1
 4948: 1			;*******************************************************************************
 4949: 1			; s_cmp16    (29,5us @16.777216MHz)
 4950: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4951: 1			;
 4952: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4953: 1			;
 4954: 1			; input:     r1,r0 = acc0
 4955: 1			;            r5,r4 = acc1
 4956: 1			;
 4957: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4958: 1			;             f0=0,cy=0  als acc0 > acc1
 4959: 1			;             f0=1 cy=0    als acc1 = acc0
 4960: 1			;
 4961: 1			; vernietigt:  niets
 4962: 1			;*******************************************************************************
 4963: 1  1172	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4964: 1  1174	C0 D0		                push    psw
 4965: 1  1176	E8		                mov     a,r0
 4966: 1  1177	C0 E0		                push    acc
 4967: 1  1179	E9		                mov     a,r1
 4968: 1  117A	C0 E0		                push    acc
 4969: 1
 4970: 1  117C	E9		                mov     a,r1            ;neem msb van acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4971: 1  117D	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4972: 1  117E	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4973: 1  1181	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4974: 1			                                        ;negatief is
 4975: 1  1182	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4976: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4977: 1
 4978: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4979: 1			;acc0>acc1
 4980: 1  1185	D0 E0		s_cmp160:       pop     acc
 4981: 1  1187	F9		                mov     r1,a
 4982: 1  1188	D0 E0		                pop     acc
 4983: 1  118A	F8		                mov     r0,a
 4984: 1  118B	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4985: 1  118D	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4986: 1  118F	C3		                clr     c               ;geef dit aan in de outputstatus
 4987: 1  1190	D0 E0		                pop     acc
 4988: 1  1192	22		                ret
 4989: 1			;acc0<acc1
 4990: 1  1193	D0 E0		s_cmp161:       pop     acc
 4991: 1  1195	F9		                mov     r1,a
 4992: 1  1196	D0 E0		                pop     acc
 4993: 1  1198	F8		                mov     r0,a
 4994: 1  1199	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4995: 1  119B	D3		                setb    c               ;groter dan acc0
 4996: 1  119C	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4997: 1  119E	D0 E0		                pop     acc
 4998: 1  11A0	22		                ret
 4999: 1			;gelijk teken, maak verschil
 5000: 1  11A1	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 5001: 1  11A2	E8		                mov     a,r0            ;acc0-acc1
 5002: 1  11A3	9C		                subb    a,r4
 5003: 1  11A4	F8		                mov     r0,a
 5004: 1  11A5	E9		                mov     a,r1
 5005: 1  11A6	9D		                subb    a,r5
 5006: 1  11A7	F9		                mov     r1,a
 5007: 1  11A8	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 5008: 1  11AB	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5009: 1  11AC	60 02		                jz      s_cmp163        ;acc0=acc1
 5010: 1  11AE	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 5011: 1			;acc0=acc1
 5012: 1  11B0	D0 E0		s_cmp163:       pop     acc
 5013: 1  11B2	F9		                mov     r1,a
 5014: 1  11B3	D0 E0		                pop     acc
 5015: 1  11B5	F8		                mov     r0,a
 5016: 1  11B6	D0 D0		                pop     psw             ;acc0=acc1
 5017: 1  11B8	C3		                clr     c               ;geef dit aan in de outputstatus
 5018: 1  11B9	D2 D5		                setb    f0
 5019: 1  11BB	D0 E0		                pop     acc
 5020: 1  11BD	22		                ret
 5021: 1
 5022: 1			;*******************************************************************************
 5023: 1			; cmp16            (19,9us @16.777216MHz)
 5024: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 5025: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5026: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 5027: 1			;
 5028: 1			; input:     r1,r0 = acc0
 5029: 1			;            r5,r4 = acc1
 5030: 1			;
 5031: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5032: 1			;             f0=0,cy=0  als acc0 > acc1
 5033: 1			;             f0=1 cy=0    als acc1 = acc0
 5034: 1			;
 5035: 1			; vernietigt:  niets
 5036: 1			;*******************************************************************************
 5037: 1  11BE	C0 E0		cmp16:          push    acc             ;bewaar registers
 5038: 1  11C0	C0 F0		                push    b
 5039: 1  11C2	C0 D0		                push    psw
 5040: 1
 5041: 1  11C4	C3		                clr     c               ;vergelijk acc0 met acc1
 5042: 1  11C5	E9		                mov     a,r1            ;eerst de msb's
 5043: 1  11C6	8D F0		                mov     b,r5            ;test r1-r5
 5044: 1  11C8	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 5045: 1
 5046: 1  11CB	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 5047: 1  11CC	8C F0		                mov     b,r4            ;test r0-r4
 5048: 1  11CE	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 5049: 1			;acc0=acc1
 5050: 1  11D1	D0 D0		                pop     psw
 5051: 1  11D3	D2 D5		                setb    f0
 5052: 1  11D5	C3		                clr     c
 5053: 1  11D6	D0 F0		                pop     b
 5054: 1  11D8	D0 E0		                pop     acc
 5055: 1  11DA	22		                ret
 5056: 1  11DB	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 5057: 1			;acc0>acc1
 5058: 1  11DD	D0 D0		                pop     psw
 5059: 1  11DF	C2 D5		                clr     f0
 5060: 1  11E1	C3		                clr     c
 5061: 1  11E2	D0 F0		                pop     b
 5062: 1  11E4	D0 E0		                pop     acc
 5063: 1  11E6	22		                ret
 5064: 1			;acc0<acc1
 5065: 1  11E7	D0 D0		cmp162:         pop     psw
 5066: 1  11E9	D3		                setb    c
 5067: 1  11EA	C2 D5		                clr     f0
 5068: 1  11EC	D0 F0		                pop     b
 5069: 1  11EE	D0 E0		                pop     acc
 5070: 1  11F0	22		                ret
 5071: 1
 5072: 1			;*******************************************************************************
 5073: 1			; s_cmp32        (44,3us @16.777216MHz)
 5074: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 5075: 1			;
 5076: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 5077: 1			;                         -2147483648 tot +2147483647
 5078: 1			; input:     r1,r0 = acc0
 5079: 1			;            r5,r4 = acc1
 5080: 1			;
 5081: 1			; output:    f0=0,cy=1  als acc0 < acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5082: 1			;             f0=0,cy=0  als acc0 > acc1
 5083: 1			;             f0=1 cy=0    als acc1 = acc0
 5084: 1			;
 5085: 1			; vernietigt:  niets
 5086: 1			;*******************************************************************************
 5087: 1  11F1	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 5088: 1  11F3	C0 D0		                push    psw
 5089: 1  11F5	E8		                mov     a,r0
 5090: 1  11F6	C0 E0		                push    acc
 5091: 1  11F8	E9		                mov     a,r1
 5092: 1  11F9	C0 E0		                push    acc
 5093: 1  11FB	EA		                mov     a,r2
 5094: 1  11FC	C0 E0		                push    acc
 5095: 1  11FE	EB		                mov     a,r3
 5096: 1  11FF	C0 E0		                push    acc
 5097: 1
 5098: 1  1201	EB		                mov     a,r3            ;neem msb van acc0
 5099: 1  1202	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 5100: 1  1203	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 5101: 1  1205	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 5102: 1  1207	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 5103: 1  1208	A2 E7		                mov     c,acc.7         ;negatief is
 5104: 1  120A	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 5105: 1			                                        ;acc1 positief. Dus acc1>acc0
 5106: 1			;acc0>acc1
 5107: 1  120C	D0 E0		s_cmp320:       pop     acc
 5108: 1  120E	FB		                mov     r3,a
 5109: 1  120F	D0 E0		                pop     acc
 5110: 1  1211	FA		                mov     r2,a
 5111: 1  1212	D0 E0		                pop     acc
 5112: 1  1214	F9		                mov     r1,a
 5113: 1  1215	D0 E0		                pop     acc
 5114: 1  1217	F8		                mov     r0,a
 5115: 1  1218	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5116: 1  121A	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5117: 1  121C	C3		                clr     c               ;geef dit aan in de outputstatus
 5118: 1  121D	D0 E0		                pop     acc
 5119: 1  121F	22		                ret
 5120: 1			;acc0<acc1
 5121: 1  1220	D0 E0		s_cmp321:       pop     acc
 5122: 1  1222	FB		                mov     r3,a
 5123: 1  1223	D0 E0		                pop     acc
 5124: 1  1225	FA		                mov     r2,a
 5125: 1  1226	D0 E0		                pop     acc
 5126: 1  1228	F9		                mov     r1,a
 5127: 1  1229	D0 E0		                pop     acc
 5128: 1  122B	F8		                mov     r0,a
 5129: 1  122C	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5130: 1  122E	D3		                setb    c               ;groter dan acc0
 5131: 1  122F	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5132: 1  1231	D0 E0		                pop     acc
 5133: 1  1233	22		                ret
 5134: 1			;gelijk teken, maak verschil
 5135: 1  1234	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5136: 1  1235	E8		                mov     a,r0            ;acc0-acc1
 5137: 1  1236	9C		                subb    a,r4

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5138: 1  1237	F8		                mov     r0,a
 5139: 1  1238	E9		                mov     a,r1
 5140: 1  1239	9D		                subb    a,r5
 5141: 1  123A	F9		                mov     r1,a
 5142: 1  123B	EA		                mov     a,r2
 5143: 1  123C	9E		                subb    a,r6
 5144: 1  123D	FA		                mov     r2,a
 5145: 1  123E	EB		                mov     a,r3
 5146: 1  123F	9F		                subb    a,r7
 5147: 1  1240	FB		                mov     r3,a
 5148: 1  1241	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5149: 1  1244	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5150: 1  1245	49		                orl     a,r1
 5151: 1  1246	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5152: 1  1247	60 02		                jz      s_cmp323        ;acc0=acc1
 5153: 1  1249	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5154: 1			;acc0=acc1
 5155: 1  124B	D0 E0		s_cmp323:       pop     acc
 5156: 1  124D	FB		                mov     r3,a
 5157: 1  124E	D0 E0		                pop     acc
 5158: 1  1250	FA		                mov     r2,a
 5159: 1  1251	D0 E0		                pop     acc
 5160: 1  1253	F9		                mov     r1,a
 5161: 1  1254	D0 E0		                pop     acc
 5162: 1  1256	F8		                mov     r0,a
 5163: 1  1257	D0 D0		                pop     psw             ;acc0=acc1
 5164: 1  1259	C3		                clr     c               ;geef dit aan in de outputstatus
 5165: 1  125A	D2 D5		                setb    f0
 5166: 1  125C	D0 E0		                pop     acc
 5167: 1  125E	22		                ret
 5168: 1
 5169: 1			;*******************************************************************************
 5170: 1			; cmp32        (27,14us @16.777216MHz)
 5171: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5172: 1			;
 5173: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5174: 1			;
 5175: 1			; input:     r3,r2,r1,r0 = acc0
 5176: 1			;            r7,r6,r5,r4 = acc1
 5177: 1			;
 5178: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5179: 1			;            f0=0,cy=0  als acc0 > acc1
 5180: 1			;            f0=1 cy=0    als acc1 = acc0
 5181: 1			;
 5182: 1			; vernietigt:  niets
 5183: 1			;*******************************************************************************
 5184: 1  125F	C0 E0		cmp32:          push    acc             ;bewaar registers
 5185: 1  1261	C0 F0		                push    b
 5186: 1  1263	C0 D0		                push    psw
 5187: 1
 5188: 1  1265	C3		                clr     c               ;vergelijk acc0 met acc1
 5189: 1  1266	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5190: 1  1267	8F F0		                mov     b,r7            ;test r3-r7
 5191: 1  1269	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5192: 1
 5193: 1  126C	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5194: 1  126D	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5195: 1  126F	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5196: 1
 5197: 1  1272	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5198: 1  1273	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5199: 1  1275	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5200: 1
 5201: 1  1278	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5202: 1  1279	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5203: 1  127B	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5204: 1			;acc0=acc1
 5205: 1  127E	D0 D0		                pop     psw
 5206: 1  1280	D2 D5		                setb    f0
 5207: 1  1282	C3		                clr     c
 5208: 1  1283	D0 F0		                pop     b
 5209: 1  1285	D0 E0		                pop     acc
 5210: 1  1287	22		                ret
 5211: 1  1288	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5212: 1			;acc0>acc1, indien cy=0
 5213: 1  128A	D0 D0		                pop     psw
 5214: 1  128C	C2 D5		                clr     f0
 5215: 1  128E	C3		                clr     c
 5216: 1  128F	D0 F0		                pop     b
 5217: 1  1291	D0 E0		                pop     acc
 5218: 1  1293	22		                ret
 5219: 1			;acc0<acc1
 5220: 1  1294	D0 D0		cmp322:         pop     psw
 5221: 1  1296	D3		                setb    c
 5222: 1  1297	C2 D5		                clr     f0
 5223: 1  1299	D0 F0		                pop     b
 5224: 1  129B	D0 E0		                pop     acc
 5225: 1  129D	22		                ret
 5226: 1
 5227: 1
 5228: 1			;*******************************************************************************
 5229: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5230: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5231: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5232: 1			; adres zitten.
 5233: 1			;
 5234: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5235: 1			;
 5236: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5237: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5238: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5239: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5240: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5241: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5242: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5243: 1			;                cy = 0  lookup is ok
 5244: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5245: 1			; vernietigt:  niets
 5246: 1			;*******************************************************************************
 5247: 1  129E	C0 E0		table_lu:       push    acc             ;bewaren registers
 5248: 1  12A0	C0 D0		                push    psw
 5249: 1  12A2	C0 82		                push    dpl

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5250: 1  12A4	C0 83		                push    dph
 5251: 1
 5252: 1  12A6	A2 D5		                mov     c,f0            ;byte of word items?
 5253: 1  12A8	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5254: 1			;tabel met byte items
 5255: 1  12AA	E5 82		                mov     a,dpl           ;datapointer plus index
 5256: 1  12AC	28		                add     a,r0
 5257: 1  12AD	F5 82		                mov     dpl,a
 5258: 1  12AF	E5 83		                mov     a,dph
 5259: 1  12B1	39		                addc    a,r1
 5260: 1  12B2	F5 83		                mov     dph,a
 5261: 1  12B4	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5262: 1  12B6	A2 D1		                mov     c,f1            ;code of datageheugen?
 5263: 1  12B8	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5264: 1
 5265: 1			;bytetabel in codegeheugen
 5266: 1  12BA	74 00		                mov     a,#0
 5267: 1  12BC	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5268: 1  12BD	F8		                mov     r0,a            ;en stop in acc0
 5269: 1  12BE	79 00		                mov     r1,#0
 5270: 1  12C0	02 13 1F	                ljmp    table_lu4       ;en klaar
 5271: 1
 5272: 1			;bytetabel in datageheugen
 5273: 1  12C3	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5274: 1  12C4	F8		                mov     r0,a            ;en stop in acc0
 5275: 1  12C5	79 00		                mov     r1,#0
 5276: 1  12C7	02 13 1F	                ljmp    table_lu4       ;en klaar
 5277: 1
 5278: 1  12CA	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5279: 1  12CC	D0 82		                pop     dpl
 5280: 1  12CE	D0 D0		                pop     psw
 5281: 1  12D0	D3		                setb    c              ;foutstatus teruggeven!
 5282: 1  12D1	D0 E0		                pop     acc
 5283: 1  12D3	22		                ret
 5284: 1
 5285: 1			;tabel met word items
 5286: 1  12D4	E8		table_lu2:      mov     a,r0            ;index op stack
 5287: 1  12D5	C0 E0		                push    acc
 5288: 1  12D7	E9		                mov     a,r1
 5289: 1  12D8	C0 E0		                push    acc
 5290: 1
 5291: 1  12DA	C3		                clr      c              ;index maal 2 (word items)
 5292: 1  12DB	E8		                mov     a,r0
 5293: 1  12DC	33		                rlc     a
 5294: 1  12DD	F8		                mov     r0,a
 5295: 1  12DE	E9		                mov     a,r1
 5296: 1  12DF	33		                rlc     a
 5297: 1  12E0	F9		                mov     r1,a
 5298: 1
 5299: 1  12E1	E5 82		                mov     a,dpl           ;datapointer plus index
 5300: 1  12E3	28		                add     a,r0
 5301: 1  12E4	F5 82		                mov     dpl,a
 5302: 1  12E6	E5 83		                mov     a,dph
 5303: 1  12E8	39		                addc    a,r1
 5304: 1  12E9	F5 83		                mov     dph,a
 5305: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5306: 1  12EB	D0 E0		                pop     acc             ;index weer van stack
 5307: 1  12ED	F9		                mov     r1,a
 5308: 1  12EE	D0 E0		                pop     acc
 5309: 1  12F0	F8		                mov     r0,a
 5310: 1
 5311: 1  12F1	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5312: 1  12F3	A2 D1		                mov     c,f1            ;code of datageheugen?
 5313: 1  12F5	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5314: 1			;wordtabel in codegeheugen
 5315: 1  12F7	74 00		                mov     a,#0
 5316: 1  12F9	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5317: 1  12FA	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5318: 1  12FB	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5319: 1  12FD	24 01		                add     a,#1
 5320: 1  12FF	F5 82		                mov     dpl,a
 5321: 1  1301	E5 83		                mov     a,dph
 5322: 1  1303	34 00		                addc    a,#0
 5323: 1  1305	F5 83		                mov     dph,a
 5324: 1  1307	74 00		                mov     a,#0
 5325: 1  1309	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5326: 1  130A	F9		                mov     r1,a            ;msb in acc0 stoppen
 5327: 1  130B	80 12		                sjmp    table_lu4        ;en klaar
 5328: 1			;wordtabel    in datageheugen
 5329: 1  130D	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5330: 1  130E	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5331: 1  130F	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5332: 1  1311	24 01		                add     a,#1
 5333: 1  1313	F5 82		                mov     dpl,a
 5334: 1  1315	E5 83		                mov     a,dph
 5335: 1  1317	34 00		                addc    a,#0
 5336: 1  1319	F5 83		                mov     dph,a
 5337: 1  131B	74 00		                mov     a,#0
 5338: 1  131D	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5339: 1  131E	F9		                mov     r1,a            ;msb in acc0 stoppen
 5340: 1			                                        ;en klaar
 5341: 1
 5342: 1  131F	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5343: 1  1321	D0 82		                pop     dpl
 5344: 1  1323	D0 D0		                pop     psw
 5345: 1  1325	D0 E0		                pop     acc
 5346: 1  1327	22		                ret
 5347: 1
 5348: 1
 5349: 1
 5350: 1			;*******************************************************************************
 5351: 1			; Cordic        (2,11ms @16.777216MHz)
 5352: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5353: 1			; waarde (2's complement) opgegeven hoek.
 5354: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5355: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5356: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5357: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5358: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5359: 1			; als geschaalde getallen ter beschikking komen.
 5360: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5361: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5362: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5363: 1			;
 5364: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5365: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5366: 1			;            cy = 0 : hoek binnen bereik
 5367: 1			;            cy = 1 : error, hoek buiten bereik
 5368: 1			;            nauwkeurigheid: 12 msbits
 5369: 1			; vernietigt:  niets
 5370: 1			;*******************************************************************************
 5371: 1  1328	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5372: 1  132A	C0 D0		                push    psw
 5373: 1  132C	C0 83		                push    dph
 5374: 1  132E	C0 82		                push    dpl
 5375: 1  1330	C0 F0		                push    b
 5376: 1
 5377: 1  1332	EF		                mov     a,r7
 5378: 1  1333	C0 E0		                push    acc
 5379: 1  1335	EE		                mov     a,r6
 5380: 1  1336	C0 E0		                push    acc
 5381: 1  1338	ED		                mov     a,r5
 5382: 1  1339	C0 E0		                push    acc
 5383: 1  133B	EC		                mov     a,r4
 5384: 1  133C	C0 E0		                push    acc
 5385: 1
 5386: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5387: 1			;en niet groter dan pi/2 radialen (6478h)
 5388: 1  133E	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5389: 1  1340	7D 64		                mov     r5,#64h
 5390: 1  1342	12 11 BE	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5391: 1  1345	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5392: 1  1348	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5393: 1  134A	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5394: 1
 5395: 1  134C	C2 A0		cordic000:      clr     p2.0
 5396: 1  134E	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5397: 1  1350	7D 9B		                mov     r5,#9bh
 5398: 1  1352	12 11 BE	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5399: 1  1355	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5400: 1  1358	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5401: 1  135A	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5402: 1
 5403: 1  135C	C2 A1		cordic_error:   clr     p2.1
 5404: 1  135E	02 14 10	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5405: 1
 5406: 1			;Hoek is -pi/2 resultaat gekend
 5407: 1  1361	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5408: 1  1363	7A 00		                mov     r2,#000h
 5409: 1  1365	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5410: 1  1367	78 00		                mov     r0,#000h
 5411: 1  1369	C3		                clr     c
 5412: 1  136A	02 14 10	                ljmp    cordic40        ;en klaar
 5413: 1			;hoek is +pi/2 resultaat gekend
 5414: 1  136D	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5415: 1  136F	7A FF		                mov     r2,#0ffh
 5416: 1  1371	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5417: 1  1373	78 00		                mov     r0,#000h

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5418: 1  1375	C3		                clr     c
 5419: 1  1376	02 14 10	                ljmp    cordic40        ;en klaar
 5420: 1
 5421: 1  1379	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5422: 1  137B	7D 00		                mov     r5,#00h
 5423: 1  137D	12 11 BE	                lcall   cmp16            ;vergelijk de hoeken
 5424: 1  1380	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5425: 1  1383	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5426: 1			;hoek is 0, resultaat gekend
 5427: 1  1385	C2 A7		cordic_nul:     clr     p2.7
 5428: 1  1387	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5429: 1  1389	7A 00		                mov     r2,#000h
 5430: 1  138B	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5431: 1  138D	78 FF		                mov     r0,#0ffh
 5432: 1  138F	C3		                clr     c
 5433: 1  1390	02 14 10	                ljmp    cordic40        ;en klaar
 5434: 1
 5435: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5436: 1  1393	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5437: 1  1394	C0 E0		                push    acc
 5438: 1  1396	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5439: 1  1397	C0 E0		                push    acc
 5440: 1
 5441: 1  1399	7B 00		                mov     r3,#00h         ;y=0
 5442: 1  139B	7A 00		                mov     r2,#00h
 5443: 1  139D	79 26		                mov     r1,#026h        ;x = K * 2^14
 5444: 1  139F	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5445: 1
 5446: 1  13A1	75 F0 00	                mov     b,#00h          ;loopteller=0
 5447: 1
 5448: 1  13A4	90 14 68	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5449: 1
 5450: 1  13A7	EB		cordic1:        mov     a,r3            ;sry=y
 5451: 1  13A8	FF		                mov     r7,a
 5452: 1  13A9	EA		                mov     a,r2
 5453: 1  13AA	FE		                mov     r6,a
 5454: 1  13AB	E9		                mov     a,r1            ;srx=x
 5455: 1  13AC	FD		                mov     r5,a
 5456: 1  13AD	E8		                mov     a,r0
 5457: 1  13AE	FC		                mov     r4,a
 5458: 1
 5459: 1  13AF	12 14 2F	                lcall   cordic5          ;srx en sry >> loopteller
 5460: 1
 5461: 1  13B2	D0 E0		                pop     acc
 5462: 1  13B4	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5463: 1
 5464: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5465: 1  13B7	C3		                clr     c
 5466: 1  13B8	E8		                mov     a,r0            ;bereken x=x-sry
 5467: 1  13B9	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5468: 1  13BA	F8		                mov     r0,a
 5469: 1  13BB	E9		                mov     a,r1
 5470: 1  13BC	9F		                subb    a,r7
 5471: 1  13BD	F9		                mov     r1,a
 5472: 1
 5473: 1  13BE	EA		                mov     a,r2            ;bereken y=y+srx

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5474: 1  13BF	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5475: 1  13C0	FA		                mov     r2,a
 5476: 1  13C1	EB		                mov     a,r3
 5477: 1  13C2	3D		                addc    a,r5
 5478: 1  13C3	FB		                mov     r3,a
 5479: 1
 5480: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5481: 1  13C4	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5482: 1  13C6	93		                movc    a,@a+dptr
 5483: 1  13C7	A3		                inc     dptr
 5484: 1  13C8	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5485: 1  13C9	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5486: 1  13CB	C3		                clr     c               ;verklein de hoek
 5487: 1  13CC	9C		                subb    a,r4
 5488: 1  13CD	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5489: 1  13CF	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5490: 1
 5491: 1  13D1	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5492: 1  13D3	93		                movc    a,@a+dptr
 5493: 1  13D4	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5494: 1  13D5	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5495: 1  13D6	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5496: 1  13D8	9D		                subb    a,r5            ;verklein de hoek
 5497: 1  13D9	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5498: 1
 5499: 1			;loopteller incrementeren en testen op einde van de iteratie
 5500: 1  13DB	05 F0		cordic2:        inc     b               ;loopteller++
 5501: 1  13DD	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5502: 1  13DF	65 F0		                xrl     a,b             ;test op gelijkheid
 5503: 1  13E1	60 28		                jz      cordic4         ;ja klaar!
 5504: 1  13E3	02 13 A7	                ljmp    cordic1         ;nee, nog even verder...
 5505: 1
 5506: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5507: 1  13E6	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5508: 1  13E7	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5509: 1  13E8	F8		                mov     r0,a
 5510: 1  13E9	E9		                mov     a,r1
 5511: 1  13EA	3F		                addc    a,r7
 5512: 1  13EB	F9		                mov     r1,a
 5513: 1
 5514: 1  13EC	C3		                clr     c
 5515: 1  13ED	EA		                mov     a,r2            ;bereken y=y-srx
 5516: 1  13EE	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5517: 1  13EF	FA		                mov     r2,a
 5518: 1  13F0	EB		                mov     a,r3
 5519: 1  13F1	9D		                subb    a,r5
 5520: 1  13F2	FB		                mov     r3,a
 5521: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5522: 1  13F3	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5523: 1  13F5	93		                movc    a,@a+dptr
 5524: 1  13F6	A3		                inc     dptr
 5525: 1  13F7	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5526: 1  13F8	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5527: 1  13FA	2C		                add     a,r4            ;vergroot de hoek
 5528: 1  13FB	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5529: 1  13FD	05 81		                inc     sp              ;wijs weer naar msb van de hoek

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5530: 1
 5531: 1  13FF	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5532: 1  1401	93		                movc    a,@a+dptr
 5533: 1  1402	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5534: 1  1403	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5535: 1  1404	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5536: 1  1406	3D		                addc    a,r5            ;vergroot de hoek
 5537: 1  1407	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5538: 1
 5539: 1  1409	80 D0		                sjmp    cordic2
 5540: 1
 5541: 1  140B	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5542: 1  140D	D0 E0		                pop     acc             ;dummy hoek van stack
 5543: 1  140F	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5544: 1
 5545: 1  1410	D0 E0		cordic40:       pop     acc
 5546: 1  1412	FC		                mov     r4,a
 5547: 1  1413	D0 E0		                pop     acc
 5548: 1  1415	FD		                mov     r5,a
 5549: 1  1416	D0 E0		                pop     acc
 5550: 1  1418	FE		                mov     r6,a
 5551: 1  1419	D0 E0		                pop     acc
 5552: 1  141B	FF		                mov     r7,a
 5553: 1  141C	D0 F0		                pop     b
 5554: 1  141E	D0 82		                pop     dpl
 5555: 1  1420	D0 83		                pop     dph
 5556: 1  1422	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5557: 1  1424	D0 D0		                pop     psw
 5558: 1  1426	D0 E0		                pop     acc
 5559: 1  1428	22		                ret
 5560: 1
 5561: 1  1429	D0 D0		cordic41:       pop     psw
 5562: 1  142B	D3		                setb    c
 5563: 1  142C	D0 E0		                pop     acc
 5564: 1  142E	22		                ret
 5565: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5566: 1			;over het aantal posities aangegeven in het B register.
 5567: 1  142F	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5568: 1  1431	74 00		                mov     a,#0            ;test of loopteller=0
 5569: 1  1433	65 F0		                xrl     a,b
 5570: 1  1435	60 2E		                jz      cordic52        ;klaar
 5571: 1
 5572: 1  1437	ED		                mov     a,r5            ;test teken van srx
 5573: 1  1438	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5574: 1  143B	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5575: 1  143D	80 02		                sjmp    cordic50
 5576: 1  143F	D2 D5		cordic5a:       setb    f0
 5577: 1  1441	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5578: 1  1443	ED		                mov     a,r5            ;eerst de msb
 5579: 1  1444	13		                rrc     a
 5580: 1  1445	FD		                mov     r5,a
 5581: 1  1446	EC		                mov     a,r4            ;dan de lsb
 5582: 1  1447	13		                rrc     a
 5583: 1  1448	FC		                mov     r4,a
 5584: 1  1449	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5585: 1  144C	D0 F0		                pop     b               ;haal de loopteller van stack

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5586: 1  144E	C0 F0		                push    b               ;en bewaar hem weer
 5587: 1  1450	EF		                mov     a,r7            ;test teken van sry
 5588: 1  1451	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5589: 1  1454	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5590: 1  1456	80 02		                sjmp    cordic51
 5591: 1  1458	D2 D5		cordic5b:       setb    f0
 5592: 1  145A	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5593: 1  145C	EF		                mov     a,r7            ;eerst de msb
 5594: 1  145D	13		                rrc     a
 5595: 1  145E	FF		                mov     r7,a
 5596: 1  145F	EE		                mov     a,r6            ;dan de lsb
 5597: 1  1460	13		                rrc     a
 5598: 1  1461	FE		                mov     r6,a
 5599: 1  1462	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5600: 1
 5601: 1  1465	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5602: 1  1467	22		                ret
 5603: 1
 5604: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5605: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5606: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5607: 1  1468	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5608: 1  146A	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5609: 1  146C	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5610: 1  146E	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5611: 1  1470	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5612: 1  1472	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5613: 1  1474	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5614: 1  1476	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5615: 1  1478	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5616: 1  147A	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5617: 1  147C	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5618: 1  147E	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5619: 1  1480	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5620: 1  1482	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5621: 1  1484	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5622: 1
 5623: 1			endif        ;einde van aduc_math
 5624: 1			;******************************************************************************
 5625: 1
 5626: 1			ifdef        aduc_adc    ;A/D conversie routines
 5627: 1			;*******************************************************************************
 5628: 1			; ADuCADC_mide
 5629: 1			; Geschreven door [dp] op 5/1/2014
 5630: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5631: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5632: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5633: 1			; bron instellen.
 5634: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5635: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5636: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5637: 1			;
 5638: 1			;*******************************************************************************
 5639: 1
 5640: 1			;*******************************************************************************
 5641: 1			; adc_init

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5642: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5643: 1			; -  4 track&hold clockperiodes
 5644: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5645: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5646: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5647: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5648: 1			;
 5649: 1			; input: R0 =  0  : Interne referentiebron
 5650: 1			;        R0 <> 0  : Externe referentiebron
 5651: 1			;
 5652: 1			; Deze routine vernietigt niets
 5653: 1			;*******************************************************************************
 5654: 1  1486	C0 E0		adc_init:       push    acc                 ;registers op stack
 5655: 1  1488	C0 D0		                push    psw
 5656: 1  148A	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5657: 1  148D	E8		                mov     a,r0                ;welke referentiebron?
 5658: 1  148E	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5659: 1  1490	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5660: 1  1493	D0 D0		adc_init1:      pop     psw
 5661: 1  1495	D0 E0		                pop     acc
 5662: 1  1497	22		                ret
 5663: 1
 5664: 1			;*******************************************************************************
 5665: 1			; adc_single
 5666: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5667: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5668: 1			; (2's complement) formaat van de meetwaarde.
 5669: 1			; _____________________________________________________________
 5670: 1			; resolutie  |     unsigned      |           signed            |
 5671: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5672: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5673: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5674: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5675: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5676: 1			; _____________________________________________________________
 5677: 1			;
 5678: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5679: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5680: 1			; De ingangsparameter wordt doorgegeven via R0.
 5681: 1			;
 5682: 1			; input:
 5683: 1			;             7    6    5    4    3    2    1    0
 5684: 1			;           _______________________________________
 5685: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5686: 1			;           ---------------------------------------
 5687: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5688: 1			;                                         1000b = temp.sensor
 5689: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5690: 1			;                                   10b = 12 bits, 11b = 12 bits
 5691: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5692: 1			;
 5693: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5694: 1			;         cy=0  bij conversie ok
 5695: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5696: 1			;
 5697: 1			; Deze routine vernietigt niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5698: 1			;*******************************************************************************
 5699: 1  1498	C0 E0		adc_single:     push    acc                 ;registers op stack
 5700: 1  149A	C0 D0		                push    psw
 5701: 1  149C	C0 F0		                push    b
 5702: 1  149E	E8		                mov     a,r0                ;neem inputparameter
 5703: 1  149F	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5704: 1  14A1	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5705: 1  14A4	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5706: 1  14A6	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5707: 1  14A8	D2 DC		                setb    sconv               ;start een meting
 5708: 1  14AA	E8		                mov     a,r0                ;neem parameter terug
 5709: 1  14AB	A2 E6		                mov     c,acc.6
 5710: 1  14AD	92 D5		                mov     f0,c                ;bewaar format bit
 5711: 1  14AF	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5712: 1  14B2	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5713: 1  14B5	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5714: 1  14B8	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5715: 1			;*******************************************************************************
 5716: 1			;8 bit resultaat gevraagd
 5717: 1			;*******************************************************************************
 5718: 1  14BB	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5719: 1  14BD	C4		                swap    a                    ;swap nibbles
 5720: 1  14BE	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5721: 1  14C0	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5722: 1  14C2	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5723: 1  14C4	C4		                swap    a
 5724: 1  14C5	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5725: 1  14C7	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5726: 1			;8 bit unsigned formaat
 5727: 1  14CA	79 00		                mov     r1,#00h              ;unsigned
 5728: 1  14CC	F8		                mov     r0,a
 5729: 1  14CD	80 63		                sjmp    adc_single42
 5730: 1			;8 bit signed formaat
 5731: 1  14CF	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5732: 1  14D2	24 80		                add     a,#80h                ;negatief getal van maken
 5733: 1  14D4	F8		                mov     r0,a
 5734: 1  14D5	79 FF		                mov     r1,#0ffh
 5735: 1  14D7	80 59		                sjmp    adc_single42
 5736: 1  14D9	C3		adc_single20:   clr     c
 5737: 1  14DA	94 80		                subb    a,#80h                ;positief deel verkleinen
 5738: 1  14DC	F8		                mov     r0,a
 5739: 1  14DD	79 00		                mov     r1,#00h
 5740: 1  14DF	80 51		                sjmp    adc_single42
 5741: 1
 5742: 1  14E1	02 15 3A	adc_single21:   ljmp    adc_single43
 5743: 1			;*******************************************************************************
 5744: 1			;10 bit resultaat gevraagd
 5745: 1			;*******************************************************************************
 5746: 1  14E4	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5747: 1  14E6	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5748: 1  14E8	03		                rr     a              ;naar msbits roteren
 5749: 1  14E9	03		                rr     a
 5750: 1  14EA	F5 F0		                mov    b,a            ;even bewaren
 5751: 1  14EC	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5752: 1  14EE	03		                rr     a              ;twee plaatsen opschuiven
 5753: 1  14EF	03		                rr     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5754: 1  14F0	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5755: 1  14F2	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5756: 1  14F4	F5 F0		                mov    b,a            ;low byte even bewaren
 5757: 1  14F6	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5758: 1  14F8	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5759: 1  14FA	03		                rr     a               ;en op hun plaats schuiven
 5760: 1  14FB	03		                rr     a
 5761: 1  14FC	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5762: 1			;10 bit unsigned formaat
 5763: 1  14FF	F9		                mov    r1,a            ;unsigned
 5764: 1  1500	A8 F0		                mov    r0,b
 5765: 1  1502	80 2E		                sjmp   adc_single42
 5766: 1			;10 bit signed formaat
 5767: 1  1504	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5768: 1  1507	24 FE		                add    a,#0feh             ;negatief getal van maken
 5769: 1  1509	F9		                mov    r1,a
 5770: 1  150A	A8 F0		                mov    r0,b
 5771: 1  150C	80 24		                sjmp   adc_single42
 5772: 1  150E	C3		adc_single31:   clr    c
 5773: 1  150F	94 02		                subb   a,#02h              ;positief deel verkleinen
 5774: 1  1511	F9		                mov    r1,a
 5775: 1  1512	A8 F0		                mov    r0,b
 5776: 1  1514	80 1C		                sjmp   adc_single42
 5777: 1
 5778: 1			;*******************************************************************************
 5779: 1			;12 bit resultaat gevraagd
 5780: 1			;*******************************************************************************
 5781: 1  1516	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5782: 1  1518	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5783: 1  151A	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5784: 1			;12 bit unsigned formaat
 5785: 1  151D	A8 D9		                mov    r0,adcdatal           ;unsigned
 5786: 1  151F	F9		                mov    r1,a
 5787: 1  1520	80 10		                sjmp   adc_single42
 5788: 1			;12 bit signed formaat
 5789: 1  1522	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5790: 1  1525	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5791: 1  1527	F9		                mov    r1,a
 5792: 1  1528	A8 D9		                mov    r0,adcdatal
 5793: 1  152A	80 06		                sjmp   adc_single42
 5794: 1  152C	C3		adc_single41:   clr    c
 5795: 1  152D	94 08		                subb   a,#08h                ;positief deel verkleinen
 5796: 1  152F	F9		                mov    r1,a
 5797: 1  1530	A8 D9		                mov    r0,adcdatal
 5798: 1  1532	D0 F0		adc_single42:   pop    b
 5799: 1  1534	D0 D0		                pop    psw
 5800: 1  1536	C3		                clr    c
 5801: 1  1537	D0 E0		                pop    acc
 5802: 1  1539	22		                ret
 5803: 1
 5804: 1  153A	D0 F0		adc_single43:   pop    b
 5805: 1  153C	D0 D0		                pop    psw
 5806: 1  153E	D3		                setb   c
 5807: 1  153F	D0 E0		                pop    acc
 5808: 1  1541	22		                ret
 5809: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5810: 1			endif        ;einde van aduc_adc
 5811: 1			;*******************************************************************************
 5812: 1
 5813: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5814: 1			;******************************************************************************
 5815: 1			; ADuCKEY_mide.inc
 5816: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5817: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5818: 1			;
 5819: 1			;     V2.0      V1.1
 5820: 1			;                           |   |   |   |
 5821: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5822: 1			;                   |       |   |   |   |
 5823: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5824: 1			;                   |       |   |   |   |
 5825: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5826: 1			;                   |       |   |   |   |
 5827: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5828: 1			;                   |       |   |   |   |
 5829: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5830: 1			;                   |           |   |   |
 5831: 1			;     P0.5      P3.5|-K2--------|   |   |
 5832: 1			;                   |               |   |
 5833: 1			;     P0.6      P3.6|-K3------------|   |
 5834: 1			;                   |                   |
 5835: 1			;     P0.7      P3.7|-K4----------------|
 5836: 1			;
 5837: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5838: 1			; gebruikt.
 5839: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5840: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5841: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5842: 1			; en als ingang wordt aangeboden.
 5843: 1			;
 5844: 1			;                                  ___                 ___
 5845: 1			;                     ____________|   |  |------------|   |
 5846: 1			;              ____  |   ____     |   |  |   ____     |   |
 5847: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5848: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5849: 1			; '1'= toets  | cl |    | cl |              | cl |
 5850: 1			;  ingedrukt  |____|    |____|              |____|
 5851: 1			;                |         |                   |
 5852: 1			;      CLOCK     |         |                   |
 5853: 1			;         _______|_________|___________________|
 5854: 1			;
 5855: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 5856: 1			;
 5857: 1			;              MAP0      MAP1                 MAP2         MAP3
 5858: 1			;
 5859: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5860: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5861: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5862: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5863: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 5864: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5865: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5866: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5867: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5868: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5869: 1			;
 5870: 1			;          MAP0    MAP1          MAP2    MAP3
 5871: 1			;         _______________       _______________
 5872: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 5873: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5874: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5875: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5876: 1			;
 5877: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5878: 1			;         | | | | | | | |       | | | | | | | |
 5879: 1			;        K K K K K K K K       K K K K K K K K
 5880: 1			;         O O O O O O O O       O O O O O O O O
 5881: 1			;         L L L L L L L L       L L L L L L L L
 5882: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5883: 1			;
 5884: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 5885: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 5886: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5887: 1			; van bitmaps van voor naar achter.
 5888: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5889: 1			;
 5890: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5891: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5892: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5893: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 5894: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5895: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5896: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5897: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5898: 1			; deze toetswaarde weer.
 5899: 1			;
 5900: 1			;
 5901: 1			;
 5902: 1			;******************************************************************************
 5903: 1
 5904: 1
 5905: 1			;******************************************************************************
 5906: 1			; key_init
 5907: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 5908: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5909: 1			; input: niets
 5910: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 5911: 1			;         (map0,map1,map2,map3 =0)
 5912: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5913: 1			; Deze routine vernietigt niets
 5914: 1			;******************************************************************************
 5915: 1
 5916: 1  1542	C0 E0		Key_init:       push    acc          ;bewaar registers
 5917: 1  1544	C0 D0		                push    psw
 5918: 1  1546	E8		                mov     a,r0
 5919: 1  1547	C0 E0		                push    acc
 5920: 1  1549	E9		                mov     a,r1
 5921: 1  154A	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5922: 1  154C	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5923: 1  154E	79 09		                mov     r1,#9        ;9 bytes in de maps
 5924: 1  1550	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5925: 1  1552	08		                inc     r0           ;volgende byte nemen
 5926: 1  1553	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5927: 1  1555	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5928: 1  1557	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 5929: 1  1559	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5930: 1  155C	D0 E0		                pop     acc          ;herstel registers
 5931: 1  155E	F9		                mov     r1,a
 5932: 1  155F	D0 E0		                pop     acc
 5933: 1  1561	F8		                mov     r0,a
 5934: 1  1562	D0 D0		                pop     psw
 5935: 1  1564	D0 E0		                pop     acc
 5936: 1  1566	22		                ret                    ;terug naar caller
 5937: 1			;******************************************************************************
 5938: 1
 5939: 1
 5940: 1			;******************************************************************************
 5941: 1			; toets_flank
 5942: 1			; Deze routine detecteert de indrukflank van een toets.
 5943: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5944: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5945: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5946: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5947: 1			; minder dan 20ms duurt.
 5948: 1			; input : niets
 5949: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5950: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5951: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5952: 1			;
 5953: 1			; Deze routine vernietigt geen registers.
 5954: 1			;******************************************************************************
 5955: 1  1567	C0 E0		Toets_flank:    push    acc
 5956: 1  1569	C0 D0		                push    psw
 5957: 1  156B	12 15 85	                lcall   Keyscan
 5958: 1  156E	12 16 01	                lcall   Keyedge
 5959: 1  1571	D0 D0		                pop     psw
 5960: 1  1573	D0 E0		                pop     acc
 5961: 1  1575	22		                ret
 5962: 1
 5963: 1			;******************************************************************************
 5964: 1			; toets_ingedrukt
 5965: 1			; Deze routine detecteert een ingedrukte toets.
 5966: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5967: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5968: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5969: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5970: 1			; minder dan 20ms duurt.
 5971: 1			; input : niets
 5972: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5973: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5974: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5975: 1			;
 5976: 1			; Deze routine vernietigt geen registers.
 5977: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5978: 1  1576	C0 E0		Toets_ingedrukt:push    acc
 5979: 1  1578	C0 D0		                push    psw
 5980: 1  157A	12 15 85	                lcall   Keyscan
 5981: 1  157D	12 15 E8	                lcall   Keydown
 5982: 1  1580	D0 D0		                pop     psw
 5983: 1  1582	D0 E0		                pop     acc
 5984: 1  1584	22		                ret
 5985: 1
 5986: 1
 5987: 1			;******************************************************************************
 5988: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5989: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5990: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5991: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5992: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5993: 1			; zoals aangegeven in het blokschema van het algorithme.
 5994: 1			; input : niets
 5995: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5996: 1			;         ervan weergeven
 5997: 1			;
 5998: 1			; Deze routine vernietigt geen registers
 5999: 1			;******************************************************************************
 6000: 1
 6001: 1  1585	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 6002: 1  1587	C0 D0		                push    psw
 6003: 1  1589	C0 F0		                push    b
 6004: 1  158B	E8		                mov     a,r0
 6005: 1  158C	C0 E0		                push    acc
 6006: 1  158E	E9		                mov     a,r1
 6007: 1  158F	C0 E0		                push    acc
 6008: 1  1591	EA		                mov     a,r2
 6009: 1  1592	C0 E0		                push    acc
 6010: 1  1594	EE		                mov     a,r6
 6011: 1  1595	C0 E0		                push    acc
 6012: 1
 6013: 1  1597	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 6014: 1  1599	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 6015: 1  159C	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6016: 1  159E	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 6017: 1
 6018: 1  15A0			Scanloop:
 6019: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 6020: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 6021: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 6022: 1			                mov     p0.0,c
 6023: 1			                mov     c,acc.1
 6024: 1			                mov     p0.1,c
 6025: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 6026: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 6027: 1			endif
 6028: 1
 6029: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 6030: 1  15A0	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 6031: 1			                                      ;een rij-lijn
 6032: 1			endif
 6033: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6034: 1			; Eerst de flipflops implementeren.
 6035: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 6036: 1			; te lezen van de kolomlijnen
 6037: 1  15A2	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 6038: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 6039: 1  15A3	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 6040: 1  15A4	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 6041: 1  15A5	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 6042: 1  15A6	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 6043: 1  15A8	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 6044: 1  15A9	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 6045: 1  15AA	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 6046: 1  15AC	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 6047: 1  15AD	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 6048: 1  15AE	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 6049: 1  15AF	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 6050: 1  15B0	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 6051: 1  15B2	FA		                mov     r2,a          ;even bewaren in register
 6052: 1
 6053: 1
 6054: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 6055: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 6056: 1			                                      ;poort3 kolomlijnen
 6057: 1			endif
 6058: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 6059: 1  15B3	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 6060: 1			                                     ;poort0 kolomlijnen
 6061: 1			endif
 6062: 1  15B5	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 6063: 1  15B6	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 6064: 1  15B8	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 6065: 1  15B9	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 6066: 1
 6067: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 6068: 1			; Nu volgen de logische functies uit het blokschema
 6069: 1
 6070: 1  15BA	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 6071: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 6072: 1  15BB	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 6073: 1  15BC	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 6074: 1  15BD	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 6075: 1  15BE	54 0F		                anl     a,#00001111b ;low nibble houden
 6076: 1  15C0	FA		                mov     r2,a         ;resultaat bewaren
 6077: 1  15C1	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 6078: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 6079: 1  15C2	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 6080: 1  15C3	C4		                swap    a            ;map2 naar low nibble schuiven
 6081: 1  15C4	5A		                anl     a,r2         ;combineren met output vorige and poort
 6082: 1  15C5	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 6083: 1  15C7	FA		                mov     r2,a         ;even bewaren
 6084: 1  15C8	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 6085: 1  15C9	54 F0		                anl     a,#11110000b ;map2 overhouden
 6086: 1  15CB	4A		                orl     a,r2         ;en combineren met nieuwe map3
 6087: 1  15CC	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 6088: 1
 6089: 1			; We gaan nu de volgende lijn scannen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6090: 1
 6091: 1  15CD	EE		                mov     a,r6         ;scanpatroon nemen
 6092: 1  15CE	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 6093: 1  15CF	FE		                mov     r6,a         ;scanpatroon bewaren
 6094: 1
 6095: 1  15D0	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 6096: 1  15D1	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 6097: 1  15D2	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 6098: 1  15D5	D0 E0		                pop     acc          ;herstel registers
 6099: 1  15D7	FE		                mov     r6,a
 6100: 1  15D8	D0 E0		                pop     acc
 6101: 1  15DA	FA		                mov     r2,a
 6102: 1  15DB	D0 E0		                pop     acc
 6103: 1  15DD	F9		                mov     r1,a
 6104: 1  15DE	D0 E0		                pop     acc
 6105: 1  15E0	F8		                mov     r0,a
 6106: 1  15E1	D0 F0		                pop     b
 6107: 1  15E3	D0 D0		                pop     psw
 6108: 1  15E5	D0 E0		                pop     acc
 6109: 1  15E7	22		                ret                    ;terug naar caller
 6110: 1			;******************************************************************************
 6111: 1
 6112: 1
 6113: 1			;******************************************************************************
 6114: 1			; Keydown, Keyedge (twee entry's)
 6115: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6116: 1			;
 6117: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6118: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6119: 1			; Er zijn twee detectie-modes:
 6120: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6121: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6122: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6123: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6124: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6125: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6126: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6127: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6128: 1			;
 6129: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6130: 1			; (flankdetectie mode).
 6131: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6132: 1			; (toets ingedrukt mode).
 6133: 1			;
 6134: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6135: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6136: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6137: 1			; geldt voor een standaard 4x4 keypad.
 6138: 1			;
 6139: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6140: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6141: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6142: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6143: 1			;
 6144: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6145: 1			; output: key = gedetecteerde toets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6146: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6147: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6148: 1			;
 6149: 1			; Deze routine vernietigt geen registers
 6150: 1			;******************************************************************************
 6151: 1
 6152: 1			;'Toets ingedrukt mode' enty van de routine
 6153: 1  15E8	C0 E0		Keydown:        push    acc            ;registers bewaren
 6154: 1  15EA	C0 D0		                push    psw
 6155: 1  15EC	C0 F0		                push    b
 6156: 1  15EE	C0 82		                push    dpl
 6157: 1  15F0	C0 83		                push    dph
 6158: 1  15F2	E8		                mov     a,r0
 6159: 1  15F3	C0 E0		                push    acc
 6160: 1  15F5	E9		                mov     a,r1
 6161: 1  15F6	C0 E0		                push    acc
 6162: 1  15F8	EA		                mov     a,r2
 6163: 1  15F9	C0 E0		                push    acc
 6164: 1  15FB	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6165: 1  15FD	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6166: 1  15FF	80 15		                sjmp    Key1           ;continue
 6167: 1
 6168: 1			;'Flankdetectiemode' entry van de routine
 6169: 1  1601	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6170: 1  1603	C0 D0		                push    psw
 6171: 1  1605	C0 F0		                push    b
 6172: 1  1607	C0 82		                push    dpl
 6173: 1  1609	C0 83		                push    dph
 6174: 1  160B	E8		                mov     a,r0
 6175: 1  160C	C0 E0		                push    acc
 6176: 1  160E	E9		                mov     a,r1
 6177: 1  160F	C0 E0		                push    acc
 6178: 1  1611	EA		                mov     a,r2
 6179: 1  1612	C0 E0		                push    acc
 6180: 1  1614	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6181: 1  1616	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6182: 1  1618	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6183: 1  161A	E6		                mov     a,@r0         ;map entry ophalen
 6184: 1  161B	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6185: 1  161E	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6186: 1  1620	C4		                swap    a             ;map1 en map0 omwisselen
 6187: 1  1621	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6188: 1  1623	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6189: 1  1624	33		                rlc     a             ;kolombit testen
 6190: 1  1625	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6191: 1  1627	33		                rlc    a              ;nee, dan verder roteren
 6192: 1  1628	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6193: 1  162A	08		                inc     r0            ;rijpointer in maps verder zetten
 6194: 1  162B	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6195: 1  162D	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6196: 1
 6197: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6198: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6199: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6200: 1
 6201: 1  162F	1A		toetsin:        dec     r2            ;rij-1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6202: 1  1630	19		                dec     r1            ;kolom-1
 6203: 1  1631	EA		                mov     a,r2          ;neem rij-1
 6204: 1  1632	23		                rl      a             ;(rij-1)x2
 6205: 1  1633	23		                rl      a              ;(rij-1)x4
 6206: 1  1634	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6207: 1  1635	90 16 53	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6208: 1  1638	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6209: 1  1639	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6210: 1  163B	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6211: 1  163D	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6212: 1  163F	D0 E0		                pop     acc            ;herstellen registers
 6213: 1  1641	FA		                mov     r2,a
 6214: 1  1642	D0 E0		                pop     acc
 6215: 1  1644	F9		                mov     r1,a
 6216: 1  1645	D0 E0		                pop     acc
 6217: 1  1647	F8		                mov     r0,a
 6218: 1  1648	D0 83		                pop     dph
 6219: 1  164A	D0 82		                pop     dpl
 6220: 1  164C	D0 F0		                pop     b
 6221: 1  164E	D0 D0		                pop     psw
 6222: 1  1650	D0 E0		                pop     acc
 6223: 1  1652	22		                ret                    ;terug naar caller
 6224: 1			;******************************************************************************
 6225: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6226: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6227: 1
 6228: 1  1653	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6229: 1  1654	30		                db    '0'    ;kolom2@rij4 toets
 6230: 1  1655	23		                db    '#'    ;kolom3@rij4 toets
 6231: 1  1656	44		                db    'D'    ;kolom4@rij4 toets
 6232: 1
 6233: 1  1657	37		                db    '7'    ;kolom1@rij3 toets
 6234: 1  1658	38		                db    '8'    ;kolom2@rij3 toets
 6235: 1  1659	39		                db    '9'    ;kolom3@rij3 toets
 6236: 1  165A	43		                db    'C'    ;kolom4@rij3 toets
 6237: 1
 6238: 1  165B	34		                db    '4'    ;kolom1@rij2 toets
 6239: 1  165C	35		                db    '5'    ;kolom2@rij2 toets
 6240: 1  165D	36		                db    '6'    ;kolom3@rij2 toets
 6241: 1  165E	42		                db    'B'    ;kolom4@rij2 toets
 6242: 1
 6243: 1  165F	31		                db    '1'    ;kolom1@rij1 toets
 6244: 1  1660	32		                db    '2'    ;kolom2@rij1 toets
 6245: 1  1661	33		                db    '3'    ;kolom3@rij1 toets
 6246: 1  1662	41		                db    'A'    ;kolom4@rij1 toets
 6247: 1
 6248: 1			;******************************************************************************
 6249: 1			; switch_init
 6250: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6251: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6252: 1			; input : niets
 6253: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6254: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6255: 1			;
 6256: 1			; Deze routine vernietigt niets
 6257: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6258: 1
 6259: 1  1663	C0 E0		switch_init:    push    acc
 6260: 1  1665	C0 D0		                push    psw
 6261: 1  1667	C0 F0		                push    b
 6262: 1  1669	E8		                mov     a,r0         ;bewaar registers
 6263: 1  166A	C0 E0		                push    acc
 6264: 1
 6265: 1  166C	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6266: 1  166E	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6267: 1  1671	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6268: 1  1673	08		                inc     r0           ;volgende byte nemen
 6269: 1  1674	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6270: 1  1677	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6271: 1  1679	C2 03		                clr     negvalid
 6272: 1  167B	C2 04		                clr     posvalid
 6273: 1
 6274: 1  167D	D0 E0		                pop     acc
 6275: 1  167F	F8		                mov     r0,a
 6276: 1  1680	D0 F0		                pop     b
 6277: 1  1682	D0 D0		                pop     psw
 6278: 1  1684	D0 E0		                pop     acc
 6279: 1  1686	22		                ret                   ;terug naar caller
 6280: 1
 6281: 1			;******************************************************************************
 6282: 1			; read_switch
 6283: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6284: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6285: 1			; Deze routine werkt volgens onderstaand blokschema.
 6286: 1			;
 6287: 1			;                                  ___                    ___
 6288: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6289: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6290: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6291: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6292: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6293: 1			;             |____|    |____|              |____|  ----o| 3 |
 6294: 1			;                |         |                   |      |  |   |
 6295: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6296: 1			;         _______*_________*___________________|       --|___|---- posedge
 6297: 1			;
 6298: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6299: 1			;                              (swvalid-flag)
 6300: 1			;            switch1   switch2    debounce      closed
 6301: 1			;
 6302: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6303: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6304: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6305: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6306: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6307: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6308: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6309: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6310: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6311: 1			; een detector voor positieve flanken (posedge).
 6312: 1			;
 6313: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111



 Line  I  Addr  Code            Source

 6314: 1			;         bij aduc832v1.1 :
 6315: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6316: 1			;         bij aduc832v2.0 :
 6317: 1			;         als f0=0 dan: schakelaars op p0
 6318: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6319: 1			;
 6320: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6321: 1			;         geactualiseerd.
 6322: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6323: 1			;                  schakelaars weergeeft
 6324: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6325: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6326: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6327: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6328: 1			;                  werd gedetecteerd op een schakelaar.
 6329: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6330: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6331: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6332: 1			;                  werd gedetecteerd op een schakelaar.
 6333: 1			;
 6334: 1			;
 6335: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6336: 1			; en flags te initialiseren.
 6337: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6338: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6339: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6340: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6341: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6342: 1			; bijhorende flag resetten.
 6343: 1			;
 6344: 1			; Deze routine vernietigt niets
 6345: 1			;******************************************************************************
 6346: 1  1687	C0 E0		read_switch:    push    acc            ;registers bewaren
 6347: 1  1689	C0 D0		                push    psw
 6348: 1  168B	C0 F0		                push    b
 6349: 1			;Flipflops uitvoeren is bytes doorschuiven
 6350: 1  168D	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6351: 1  1690	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6352: 1
 6353: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6354: 1			                clr      a
 6355: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6356: 1			                mov     acc.0,c
 6357: 1			                mov     c,p0.1
 6358: 1			                mov     acc.1,c
 6359: 1			                mov     b,a            ;even bewaren
 6360: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6361: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6362: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6363: 1			endif        ;einde aduc832_v1_1
 6364: 1
 6365: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6366: 1  1693	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6367: 1  1696	E5 80		                mov     a,p0           ;lees de schakelaars
 6368: 1  1698	80 04		                sjmp    lowlogic
 6369: 1  169A	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112



 Line  I  Addr  Code            Source

 6370: 1  169C	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6371: 1			endif        ;einde aduc832_2_0
 6372: 1
 6373: 1  169E	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6374: 1  169F	F5 40		                mov     switch1,a      ;en sample opslaan
 6375: 1
 6376: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6377: 1
 6378: 1  16A1	E5 40		                mov     a,switch1      ;neem laatste sample
 6379: 1  16A3	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6380: 1  16A5	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6381: 1  16A7	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6382: 1			;negatieve flankdetectie
 6383: 1  16A9	E5 43		                mov     a,closed      ;neem 3de FF
 6384: 1  16AB	F4		                cpl     a             ;complementeer
 6385: 1  16AC	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6386: 1  16AE	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6387: 1  16B0	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6388: 1  16B2	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6389: 1  16B4	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6390: 1			;positieve flankdetectie
 6391: 1  16B6	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6392: 1  16B8	F4		                cpl     a             ;complementeer
 6393: 1  16B9	55 43		                anl     a,closed      ;combineer met 3de FF
 6394: 1  16BB	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6395: 1  16BD	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6396: 1  16BF	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6397: 1  16C1	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6398: 1  16C3	D0 D0		                pop     psw
 6399: 1  16C5	D0 E0		                pop     acc
 6400: 1  16C7	22		                ret
 6401: 1
 6402: 1			endif    ;einde van aduc_key
 6403: 1
 6404: 1
 6405:				end





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 150
ACC				  DATA	      E0	  69
ADCBUFFER			  CODE	    007C	 233
ADCCON1				  DATA	      EF	  72
ADCCON2				  DATA	      D8	  65
ADCCON3				  DATA	      F5	  78
ADCDATAH			  DATA	      DA	  67
ADCDATAL			  DATA	      D9	  66
ADCGAINH			  DATA	      F4	  77
ADCGAINL			  DATA	      F3	  76
ADCI				  BIT	      DF	 159
ADCOFSH				  DATA	      F2	  75
ADCOFSL				  DATA	      F1	  74
ADC_INIT			  CODE	    1486	5654
ADC_INIT1			  CODE	    1493	5660
ADC_SINGLE			  CODE	    1498	5699
ADC_SINGLE1			  CODE	    14A4	5705
ADC_SINGLE2			  CODE	    14CF	5731
ADC_SINGLE20			  CODE	    14D9	5736
ADC_SINGLE21			  CODE	    14E1	5742
ADC_SINGLE3			  CODE	    14E4	5746
ADC_SINGLE30			  CODE	    1504	5767
ADC_SINGLE31			  CODE	    150E	5772
ADC_SINGLE4			  CODE	    1516	5781
ADC_SINGLE40			  CODE	    1522	5789
ADC_SINGLE41			  CODE	    152C	5794
ADC_SINGLE42			  CODE	    1532	5798
ADC_SINGLE43			  CODE	    153A	5804
ADD16				  CODE	    09DD	3006
ADD161				  CODE	    09F1	3022
ADD32				  CODE	    0A2F	3103
ADD321				  CODE	    0A49	3127
ADUC832_V2_0			  NUMBER    0001	 312
ADUC_ADC			  NUMBER    0001	 333
ADUC_I2C			  NUMBER    0001	 330
ADUC_KEY			  NUMBER    0001	 334
ADUC_LCD			  NUMBER    0001	 327
ADUC_MATH			  NUMBER    0001	 332
ADUC_SIO			  NUMBER    0001	 331
ASCBINTRANS			  CODE	    068D	2059
ASCBINTRANS1			  CODE	    06A2	2070
ASCBINTRANS2			  CODE	    06A1	2069
ASCBINTRANS3			  CODE	    0695	2063
ASCBINTRANS4			  CODE	    069E	2067
ASCCTR				  CODE	    0664	2005
ASCCTR1				  CODE	    0667	2006
ASCCTR2				  CODE	    066C	2008
ASCCTR3				  CODE	    0670	2011

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII1				  CODE	    06A3	2081
ASCII2				  CODE	    06A8	2095
ASCII21				  CODE	    06BA	2104
ASCII4				  CODE	    06BD	2118
ASCII41				  CODE	    06CC	2125
B				  DATA	      F0	  73
BACKLIGHT			  BIT	      F6	 479
BACKSP				  NUMBER    0008	1704
BAR				  CODE	    009B	 258
BARCHARS			  CODE	    034D	1105
BAREINDE			  CODE	    0374	1148
BARLCD				  CODE	    02E8	1026
BARLCD1				  CODE	    0323	1060
BARLCD2				  CODE	    032A	1065
BARLCD3				  CODE	    0333	1073
BARLCD4				  CODE	    0338	1077
BARLCDE				  CODE	    0340	1082
BARLCD_1			  CODE	    0303	1042
BATRANS				  CODE	    067F	2041
BATRANS1			  CODE	    0684	2043
BATRANS2			  CODE	    0688	2045
BCDHEX16			  CODE	    0742	2320
BCDHEX161			  CODE	    0750	2328
BCDHEX1611			  CODE	    0759	2332
BCDHEX1612			  CODE	    0763	2337
BCDHEX1613			  CODE	    076C	2341
BCDHEX162			  CODE	    07B7	2395
BCDHEX8				  CODE	    06CD	2211
BCDHEX81			  CODE	    06DB	2219
BCDHEX811			  CODE	    06E4	2223
BCDHEX82			  CODE	    0706	2247
BDELETE				  CODE	    063F	1971
BDELETE1			  CODE	    064D	1979
BDELETE2			  CODE	    0660	1990
BDELETE3			  CODE	    0651	1981
BEEP				  NUMBER    0007	1705
BLANK				  NUMBER    0020	1699
BUILD				  CODE	    0375	1180
BUILD1				  CODE	    038D	1222
BUILD2				  CODE	    039C	1229
BUILD3				  CODE	    0390	1223
BUILD_ADR			  CODE	    0383	1217
BUZZER				  BIT	      F7	 480
CAP2				  BIT	      C8	 136
CCONV				  BIT	      DD	 157
CFG832				  DATA	      AF	  38
CGRAM				  NUMBER    0040	 495
CHIPID				  DATA	      C2	  52
CLEARDISP			  NUMBER    0001	 485
CLOSED				  NUMBER    0043	 399
CMP16				  CODE	    11BE	5037
CMP161				  CODE	    11DB	5056
CMP162				  CODE	    11E7	5065
CMP32				  CODE	    125F	5184
CMP321				  CODE	    1288	5211
CMP322				  CODE	    1294	5220

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CNT2				  BIT	      C9	 137
CORDIC				  CODE	    1328	5371
CORDIC0				  CODE	    1393	5436
CORDIC00			  CODE	    1379	5421
CORDIC000			  CODE	    134C	5395
CORDIC1				  CODE	    13A7	5450
CORDIC2				  CODE	    13DB	5500
CORDIC3				  CODE	    13E6	5507
CORDIC4				  CODE	    140B	5541
CORDIC40			  CODE	    1410	5545
CORDIC41			  CODE	    1429	5561
CORDIC5				  CODE	    142F	5567
CORDIC50			  CODE	    1441	5577
CORDIC51			  CODE	    145A	5592
CORDIC52			  CODE	    1465	5601
CORDIC5A			  CODE	    143F	5576
CORDIC5B			  CODE	    1458	5591
CORDIC_ATAN			  CODE	    1468	5607
CORDIC_ERROR			  CODE	    135C	5403
CORDIC_MIN90			  CODE	    1361	5407
CORDIC_NUL			  CODE	    1385	5427
CORDIC_PLUS90			  CODE	    136D	5414
CPHA				  BIT	      FA	 174
CPOL				  BIT	      FB	 175
CR				  NUMBER    000D	1702
CS0				  BIT	      D8	 152
CS1				  BIT	      D9	 153
CS2				  BIT	      DA	 154
CS3				  BIT	      DB	 155
CURSATHOM			  NUMBER    0002	 486
CURSOROFF			  NUMBER    000C	 491
CURSORONB			  NUMBER    000F	 492
CURSORONN			  NUMBER    000E	 493
CY				  BIT	      D7	 151
D0				  BIT	      ED	 161
D0EN				  BIT	      EB	 160
D1				  BIT	      EF	 163
D1EN				  BIT	      EE	 162
DAC0H				  DATA	      FA	  82
DAC0L				  DATA	      F9	  81
DAC1H				  DATA	      FC	  84
DAC1L				  DATA	      FB	  83
DACCON				  DATA	      FD	  85
DCON				  DATA	      E8	  70
DDRAM				  NUMBER    0080	 496
DEBOUNCE			  NUMBER    0042	 398
DELAY2MS			  CODE	    03AA	1246
DELAY2MS1			  CODE	    03B0	1249
DELAY60US			  CODE	    03BB	1266
DELAY60US1			  CODE	    03CD	1280
DELAY60US2			  CODE	    03CB	1279
DIPSWITCH			  NUMBER    0001	 352
DISPDPTR			  CODE	    0595	1813
DISPDPTRLCD			  CODE	    01AF	 701
DISPLAYOF			  NUMBER    0008	 490
DISPLAYON			  NUMBER    0001	 489

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DIV16				  CODE	    0CA4	3789
DIV160				  CODE	    0CB2	3800
DIV161				  CODE	    0CD0	3823
DIV162				  CODE	    0CE3	3839
DIV163				  CODE	    0CFF	3864
DIV164				  CODE	    0D11	3882
DIV32				  CODE	    0D4E	3953
DIV320				  CODE	    0D5E	3966
DIV320A				  CODE	    0D68	3977
DIV320B				  CODE	    0D86	4005
DIV320C				  CODE	    0DAB	4033
DIV322				  CODE	    0DD0	4067
DIV323				  CODE	    0E1A	4143
DIV324				  CODE	    0E4C	4193
DIV8				  CODE	    0C61	3716
DIV81				  CODE	    0C79	3732
DMA				  BIT	      DE	 158
DMAH				  DATA	      D3	  62
DMAL				  DATA	      D2	  61
DMAP				  DATA	      D4	  63
DPCON				  DATA	      A7	  34
DPH				  DATA	      83	  11
DPL				  DATA	      82	  10
DPP				  DATA	      84	  12
E				  BIT	      F1	 477
EA				  BIT	      AF	 111
EADC				  BIT	      AE	 110
EADRH				  DATA	      C7	  54
EADRL				  DATA	      C6	  53
ECON				  DATA	      B9	  46
EDATA1				  DATA	      BC	  47
EDATA2				  DATA	      BD	  48
EDATA3				  DATA	      BE	  49
EDATA4				  DATA	      BF	  50
ENDBUF				  NUMBER    007F	1711
ENTRYMODE			  NUMBER    0006	 488
ES				  BIT	      AC	 108
ET0				  BIT	      A9	 105
ET1				  BIT	      AB	 107
ET2				  BIT	      AD	 109
EX0				  BIT	      A8	 104
EX1				  BIT	      AA	 106
EXEN2				  BIT	      CB	 139
EXF2				  BIT	      CE	 142
F0				  BIT	      D5	 149
F1				  BIT	      D1	 145
FF				  NUMBER    000C	1701
FUNCTIONS			  NUMBER    0028	 494
GEMIDDELDE			  CODE	    00B2	 272
HEXBCD16			  CODE	    07C0	2431
HEXBCD161			  CODE	    07CE	2438
HEXBCD16_U			  CODE	    07C3	2432
HEXBCD8				  CODE	    070F	2272
HEXBCD81			  CODE	    0719	2277
HEXBCD82			  CODE	    071E	2279
HEXBCD83			  CODE	    0728	2285

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBUF2LCD			  CODE	    028B	 967
HEXBUF2LCD1			  CODE	    02AF	 983
HEXBUF2LCDE			  CODE	    02C6	 994
HEXBUFTXT			  CODE	    02D4	1003
HOUR				  DATA	      A5	  32
HTHSEC				  DATA	      A2	  29
I2CADD				  DATA	      9B	  24
I2CCON				  DATA	      E8	  71
I2CDAT				  DATA	      9A	  23
I2CI				  BIT	      E8	 164
I2CINBYTEA1			  CODE	    0417	1388
I2CINBYTEACK			  CODE	    0410	1385
I2CINBYTEN1			  CODE	    0438	1412
I2CINBYTENACK			  CODE	    0431	1409
I2CINIT				  CODE	    03D5	1330
I2CM				  BIT	      EB	 167
I2COUTBYTE			  CODE	    03F0	1362
I2COUTBYTE1			  CODE	    03F7	1365
I2CPCF8574			  NUMBER    0040	1321
I2CPCF8574A			  NUMBER    0070	1322
I2CRCVDATA			  CODE	    0492	1514
I2CRCVDATA1			  CODE	    04B1	1532
I2CRCVDATA2			  CODE	    04BA	1536
I2CRCVDATA3			  CODE	    04C1	1541
I2CRCVERROR			  CODE	    04CD	1549
I2CRS				  BIT	      EA	 166
I2CSENDDATA			  CODE	    0452	1452
I2CSENDDATA1			  CODE	    0471	1469
I2CSENDERROR			  CODE	    0487	1482
I2CSTART			  CODE	    03DE	1339
I2CSTOP				  CODE	    03E7	1348
I2CTX				  BIT	      E9	 165
IE				  DATA	      A8	  35
IE0				  BIT	      89	  87
IE1				  BIT	      8B	  89
IEIP2				  DATA	      A9	  36
INBUFA				  CODE	    0604	1928
INBUFA1				  CODE	    061B	1945
INBUFA2				  CODE	    060A	1931
INBUFA3				  CODE	    0628	1951
INBUFA4				  CODE	    0621	1947
INBUFA5				  CODE	    063B	1959
INBUFA6				  CODE	    0631	1955
INBUFA7				  CODE	    0623	1948
INBYTE				  CODE	    05E4	1896
INBYTE1				  CODE	    0601	1908
INCHAR				  CODE	    05DC	1880
INITLCD				  CODE	    00DF	 511
INITLCD1			  CODE	    00F0	 528
INITSIO				  CODE	    0542	1725
INITSIO1			  CODE	    054B	1729
INITSIOE			  CODE	    0561	1746
INT0				  BIT	      B2	 114
INT1				  BIT	      B3	 115
INTVAL				  DATA	      A6	  33
INT_ROUT			  CODE	    0064	 221

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
IP				  DATA	      B8	  45
ISPI				  BIT	      FF	 179
IT0				  BIT	      88	  86
IT1				  BIT	      8A	  88
KEY				  NUMBER    0038	 385
KEY1				  CODE	    1616	6181
KEY2				  CODE	    1623	6188
KEYDOWN				  CODE	    15E8	6153
KEYEDGE				  CODE	    1601	6169
KEYFLAGS			  NUMBER    0020	 360
KEYINIT1			  CODE	    1550	5924
KEYMAP				  NUMBER    0030	 379
KEYMODE				  BIT	      01	 364
KEYSCAN				  CODE	    1585	6001
KEYVALID			  BIT	      00	 362
KEY_INIT			  CODE	    1542	5916
KOLOMLOOP			  CODE	    1625	6190
LCDBUZOFF			  CODE	    0531	1670
LCDBUZON			  CODE	    0524	1654
LCDLIGHTOFF			  CODE	    0517	1638
LCDLIGHTON			  CODE	    050A	1621
LCDPORT				  NUMBER    00F0	 476
LCDTOPORT			  CODE	    04F1	1595
LF				  NUMBER    000A	1703
LOOP				  CODE	    005F	 217
LOOPTILOOP			  CODE	    00BB	 276
LOWLOGIC			  CODE	    169E	6373
LOWUPTR				  CODE	    0672	2025
LOWUPTR1			  CODE	    0675	2026
LOWUPTR2			  CODE	    067E	2030
LOWUPTR3			  CODE	    067A	2028
MAGSIG16			  CODE	    082F	2543
MAGSIG16A			  CODE	    0840	2552
MAGSIG16ACC1			  CODE	    084F	2576
MAGSIG16ACC1A			  CODE	    0860	2585
MAGSIG16ACC1B			  CODE	    085B	2582
MAGSIG16ACC1C			  CODE	    086A	2593
MAGSIG16B			  CODE	    083B	2549
MAGSIG16C			  CODE	    084A	2560
MAGSIG32			  CODE	    086F	2610
MAGSIG32A			  CODE	    0880	2619
MAGSIG32ACC1			  CODE	    0899	2655
MAGSIG32ACC1A			  CODE	    08AA	2664
MAGSIG32ACC1B			  CODE	    08A5	2661
MAGSIG32ACC1C			  CODE	    08BE	2681
MAGSIG32B			  CODE	    087B	2616
MAGSIG32C			  CODE	    0894	2636
MAGSIG8				  CODE	    07FB	2484
MAGSIG8A			  CODE	    080C	2493
MAGSIG8ACC1			  CODE	    0815	2514
MAGSIG8ACC1A			  CODE	    0826	2523
MAGSIG8ACC1B			  CODE	    0821	2520
MAGSIG8ACC1C			  CODE	    082A	2527
MAGSIG8B			  CODE	    0807	2490
MAGSIG8C			  CODE	    0810	2497
MAP01PTR			  NUMBER    0030	 381

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MAP23PTR			  NUMBER    0034	 384
MATRIX				  NUMBER    0001	 350
MCO				  BIT	      ED	 169
MDE				  BIT	      EE	 170
MDI				  BIT	      EC	 168
MDO				  BIT	      EF	 171
MIN				  DATA	      A4	  31
MUL16				  CODE	    0B19	3375
MUL16ACC1			  CODE	    0B7E	3464
MUL16_10			  CODE	    0F3D	4451
MUL16_100			  CODE	    0F72	4499
MUL16_I_PI			  CODE	    0EDA	4355
MUL16_I_SQRT2			  CODE	    0F1C	4420
MUL16_PI			  CODE	    0EB9	4324
MUL16_SQRT2			  CODE	    0EFB	4387
MUL816				  CODE	    0C06	3611
MULDIV				  CODE	    0E7D	4266
MULDIV1				  CODE	    0E8D	4278
NEGEDGE				  NUMBER    0044	 400
NEGVALID			  BIT	      03	 369
NOKEY				  CODE	    163D	6211
OUTBYTE				  CODE	    0581	1793
OUTBYTELCD			  CODE	    019E	 682
OUTC				  CODE	    024B	 888
OUTCHAR				  CODE	    0565	1760
OUTCHAR1			  CODE	    0567	1761
OUTCHARLCD			  CODE	    013D	 597
OUTCHARLCD1			  CODE	    0144	 600
OUTCHARLCD2			  CODE	    014E	 604
OUTCHARLCD2_0			  CODE	    0149	 602
OUTCHARLCD3			  CODE	    0157	 614
OUTCHARLCD4			  CODE	    015E	 618
OUTCHARLCD5			  CODE	    0165	 622
OUTCHARLCD6			  CODE	    016C	 626
OUTCHARLCD7			  CODE	    0173	 630
OUTCHARLCD8			  CODE	    017A	 638
OUTCHARLCD9			  CODE	    017F	 646
OUTCHARLCDE			  CODE	    0182	 647
OUTD				  CODE	    0211	 810
OUTHNIBC			  CODE	    0261	 930
OUTHNIBD			  CODE	    0221	 858
OUTMSGA				  CODE	    05A8	1832
OUTMSGA1			  CODE	    05BD	1843
OUTMSGA2			  CODE	    05B0	1836
OUTMSGALCD			  CODE	    01C2	 725
OUTMSGALCD1			  CODE	    01CA	 732
OUTMSGALCDE			  CODE	    01D5	 742
OUTNIB				  CODE	    056D	1774
OUTNIBLCD			  CODE	    0187	 661
OUTNIBLCD1			  CODE	    0192	 666
OUTNIBLCDE			  CODE	    0196	 668
OV				  BIT	      D2	 146
P				  BIT	      D0	 144
P0				  DATA	      80	   8
P1				  DATA	      90	  20
P2				  DATA	      A0	  27

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
P3				  DATA	      B0	  39
PADC				  BIT	      BE	 126
PCF8574A			  NUMBER    0001	1324
PCON				  DATA	      87	  13
PLLCON				  DATA	      D7	  64
PORTTOLCD			  CODE	    04D8	1567
POSEDGE				  NUMBER    0045	 401
POSVALID			  BIT	      04	 371
PRE0				  BIT	      C4	 132
PRE1				  BIT	      C5	 133
PRE2				  BIT	      C6	 134
PRE3				  BIT	      C7	 135
PS				  BIT	      BC	 124
PSI				  BIT	      BF	 127
PSMCON				  DATA	      DF	  68
PSW				  DATA	      D0	  60
PT0				  BIT	      B9	 121
PT1				  BIT	      BB	 123
PT2				  BIT	      BD	 125
PWM0H				  DATA	      B2	  41
PWM0L				  DATA	      B1	  40
PWM1H				  DATA	      B4	  43
PWM1L				  DATA	      B3	  42
PWMCON				  DATA	      AE	  37
PX0				  BIT	      B8	 120
PX1				  BIT	      BA	 122
RAMLSB				  NUMBER    0070	 185
RAMMSB				  NUMBER    0071	 184
RB8				  BIT	      9A	  98
RCAP2H				  DATA	      CB	  57
RCAP2L				  DATA	      CA	  56
RCLK				  BIT	      CD	 141
RD				  BIT	      B7	 119
READ_PORT3			  CODE	    169A	6369
READ_SWITCH			  CODE	    1687	6346
READ_SWITCH1			  CODE	    16B6	6391
READ_SWITCH2			  CODE	    16C1	6397
REGTOLCD			  CODE	    01DE	 762
REGTOLCD1			  CODE	    01EF	 772
REGTOLCD2			  CODE	    01FD	 782
REN				  BIT	      9C	 100
RI				  BIT	      98	  96
RIJLOOP				  CODE	    1618	6182
RS				  BIT	      F0	 478
RS0				  BIT	      D3	 147
RS1				  BIT	      D4	 148
RXD				  BIT	      B0	 112
SBUF				  DATA	      99	  22
SCANLOOP			  CODE	    15A0	6018
SCON				  DATA	      98	  21
SCONV				  BIT	      DC	 156
SEC				  DATA	      A3	  30
SHIFTLEFT1			  CODE	    10E9	4814
SHIFTLEFT2			  CODE	    10F1	4820
SHIFTLEFT3			  CODE	    10F5	4822
SHIFTLEFT32			  CODE	    10E1	4810

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SHIFTRIGHT1			  CODE	    10BD	4769
SHIFTRIGHT2			  CODE	    10C5	4775
SHIFTRIGHT3			  CODE	    10C9	4777
SHIFTRIGHT32			  CODE	    10B5	4765
SIGMAG16ACC0			  CODE	    08F5	2754
SIGMAG16ACC0A			  CODE	    0904	2763
SIGMAG16ACC1			  CODE	    0915	2789
SIGMAG16ACC1A			  CODE	    0924	2798
SIGMAG16ACC1H			  CODE	    0935	2824
SIGMAG16ACC1HA			  CODE	    0944	2833
SIGMAG32ACC0			  CODE	    0955	2861
SIGMAG32ACC0A			  CODE	    0964	2870
SIGMAG32ACC1			  CODE	    097F	2905
SIGMAG32ACC1A			  CODE	    098E	2914
SIGMAG8ACC0			  CODE	    08C3	2698
SIGMAG8ACC0A			  CODE	    08D2	2706
SIGMAG8ACC1			  CODE	    08DC	2726
SIGMAG8ACC1A			  CODE	    08EB	2734
SM0				  BIT	      9F	 103
SM1				  BIT	      9E	 102
SM2				  BIT	      9D	 101
SP				  DATA	      81	   9
SPE				  BIT	      FD	 177
SPH				  DATA	      B7	  44
SPICON				  DATA	      F8	  80
SPIDAT				  DATA	      F7	  79
SPIM				  BIT	      FC	 176
SPR0				  BIT	      F8	 172
SPR1				  BIT	      F9	 173
SQRT32				  CODE	    0FC8	4571
SQRT320				  CODE	    0FEF	4593
SQRT321				  CODE	    0FF4	4595
SQRT322				  CODE	    1057	4677
SQRT323				  CODE	    105D	4681
SQRT324				  CODE	    1080	4705
SQRT3240			  CODE	    107B	4703
SQRT325				  CODE	    1083	4707
STACK_INIT			  NUMBER    0090	 182
START				  CODE	    002E	 193
STARTBUFFER			  NUMBER    0080	 183
STRTBUF				  NUMBER    0054	1710
SUB16				  CODE	    0A8F	3213
SUB161				  CODE	    0AA4	3230
SUB32				  CODE	    0AF6	3330
SUB321				  CODE	    0B11	3355
SWINIT				  CODE	    1671	6267
SWITCH1				  NUMBER    0040	 396
SWITCH2				  NUMBER    0041	 397
SWITCHMAP			  NUMBER    0040	 395
SWITCH_INIT			  CODE	    1663	6259
SWVALID				  BIT	      02	 367
S_ADD16				  CODE	    09A9	2951
S_ADD161			  CODE	    09CD	2977
S_ADD162			  CODE	    09D1	2979
S_ADD163			  CODE	    09D7	2984
S_ADD32				  CODE	    09F9	3044

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_ADD321			  CODE	    0A21	3075
S_ADD322			  CODE	    0A23	3076
S_ADD323			  CODE	    0A29	3081
S_CMP16				  CODE	    1172	4963
S_CMP160			  CODE	    1185	4980
S_CMP161			  CODE	    1193	4990
S_CMP162			  CODE	    11A1	5000
S_CMP163			  CODE	    11B0	5012
S_CMP32				  CODE	    11F1	5087
S_CMP320			  CODE	    120C	5107
S_CMP321			  CODE	    1220	5121
S_CMP322			  CODE	    1234	5135
S_CMP323			  CODE	    124B	5155
S_DIV16				  CODE	    0C81	3754
S_DIV161			  CODE	    0C8F	3764
S_DIV32				  CODE	    0D29	3916
S_DIV321			  CODE	    0D39	3928
S_DIV8				  CODE	    0C4F	3693
S_DIV81				  CODE	    0C60	3699
S_MAC16				  CODE	    0C2D	3653
S_MAC161			  CODE	    0C49	3673
S_MUL16				  CODE	    0BDF	3555
S_MUL16ACC1			  CODE	    0BEC	3573
S_MUL816			  CODE	    0BF9	3592
S_MULDIV			  CODE	    0E58	4222
S_MULDIV1			  CODE	    0E68	4234
S_SHIFTLEFT1			  CODE	    114C	4916
S_SHIFTLEFT2			  CODE	    1154	4922
S_SHIFTLEFT3			  CODE	    1158	4927
S_SHIFTLEFT32			  CODE	    1144	4912
S_SHIFTRIGHT1			  CODE	    1115	4862
S_SHIFTRIGHT2			  CODE	    111D	4868
S_SHIFTRIGHT20			  CODE	    1129	4874
S_SHIFTRIGHT3			  CODE	    112B	4876
S_SHIFTRIGHT32			  CODE	    110D	4858
S_SQRT32			  CODE	    109E	4738
S_SQRT321			  CODE	    10AC	4746
S_SUB16				  CODE	    0A51	3149
S_SUB161			  CODE	    0A7F	3184
S_SUB162			  CODE	    0A83	3186
S_SUB163			  CODE	    0A89	3191
S_SUB32				  CODE	    0AAC	3252
S_SUB321			  CODE	    0AE8	3302
S_SUB322			  CODE	    0AEA	3303
S_SUB323			  CODE	    0AF0	3308
T0				  BIT	      B4	 116
T1				  BIT	      B5	 117
T2				  BIT	      90	  94
T2CON				  DATA	      C8	  55
T2EX				  BIT	      91	  95
T3CON				  DATA	      9E	  25
T3FD				  DATA	      9D	  26
TABLE_LU			  CODE	    129E	5247
TABLE_LU1			  CODE	    12C3	5273
TABLE_LU2			  CODE	    12D4	5286
TABLE_LU3			  CODE	    130D	5329

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 123



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TABLE_LU4			  CODE	    131F	5342
TABLE_LU_10			  CODE	    12CA	5278
TB8				  BIT	      9B	  99
TCLK				  BIT	      CC	 140
TCON				  DATA	      88	  14
TELLER				  NUMBER    0072	 186
TF0				  BIT	      8D	  91
TF1				  BIT	      8F	  93
TF2				  BIT	      CF	 143
TH0				  DATA	      8C	  18
TH1				  DATA	      8D	  19
TH2				  DATA	      CD	  59
TI				  BIT	      99	  97
TIMECON				  DATA	      A1	  28
TL0				  DATA	      8A	  16
TL1				  DATA	      8B	  17
TL2				  DATA	      CC	  58
TMOD				  DATA	      89	  15
TODAC				  CODE	    0092	 252
TOETSIN				  CODE	    162F	6201
TOETSTABEL			  CODE	    1653	6228
TOETS_FLANK			  CODE	    1567	5955
TOETS_INGEDRUKT			  CODE	    1576	5978
TR0				  BIT	      8C	  90
TR1				  BIT	      8E	  92
TR2				  BIT	      CA	 138
TXD				  BIT	      B1	 113
WCOL				  BIT	      FE	 178
WDCON				  DATA	      C0	  51
WDE				  BIT	      C1	 129
WDIR				  BIT	      C3	 131
WDS				  BIT	      C2	 130
WDWR				  BIT	      C0	 128
WISSEN				  CODE	    053E	1707
WR				  BIT	      B6	 118
XOFF				  NUMBER    0013	1700
XONXOFF				  CODE	    05C6	1860
XONXOFF1			  CODE	    05D2	1866
XONXOFF2			  CODE	    05CD	1863
XONXOFF3			  CODE	    05D7	1868
