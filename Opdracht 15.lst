
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 15.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 15.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 15.lst



 Line  I  Addr  Code            Source

    1:				$nolist
  179:
  180:		N      007F	stack_init	equ	07fh
  181:		N      0000			org	0000h
  182:
  183:	  0000	02 00 03			ljmp	start
  184:
  185:	  0003	75 81 7F	start:		mov	sp,#stack_init
  186:	  0006	D2 A8				setb	ex0
  187:	  0008	D2 8C				setb	TR0
  188:	  000A	D2 AF				setb	ea
  189:	  000C	D2 A9				setb	et0
  190:
  191:	  000E	85 8C A0	int0_rout:	mov 	p2,th0
  192:	  0011	80 FB				jmp	int0_rout
  193:
  194:				$include (c:/aduc800_mideA.inc)
  195: 1			;******************************************************************************
  196: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  197: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  198: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  199: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  200: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  201: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  202: 1			;******************************************************************************
  203: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  204: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  205: 1			;******************************************************************************
  206: 1
  207: 1
  208: 1			;******************************************************************************
  209: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  210: 1			; hebben voor onze toepassing. Door een module te definieren via het
  211: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  212: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  213: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  214: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  215: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  216: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  217: 1			; definities.
  218: 1			;******************************************************************************
  219: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  220: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  221: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  222: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  223: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  224: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  225: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  226: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  227: 1
  228: 1			ifdef    aduc_key
  229: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  230: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  231: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  232: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  233: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  234: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  235: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  236: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  237: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  238: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  239: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  240: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  241: 1			;definities wel gemaakt worden.
  242: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  243: 1			                            ;anders commentaar van maken!
  244: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  245: 1			                            ;gelezen, anders commentaar van maken!
  246: 1			;******************************************************************************
  247: 1			;Declaraties van de flags voor de aduc_key driver.
  248: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  249: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  250: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  251: 1			;switch_init en read_switch.
  252: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  253: 1			                                ;bereik = 20h-2fh!
  254: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  255: 1			                                   ;een geldige waarde bevat
  256: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  257: 1			                                   ;die de detectie mode aangeeft
  258: 1			;declaratie van de read_switch flags
  259: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  260: 1			                                   ;ontdenderde schakelaars zijn
  261: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  262: 1			                                   ;flanken zijn
  263: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  264: 1			                                   ;flanken zijn
  265: 1			ifdef    matrix        ;matrix keyboard
  266: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  267: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  268: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  269: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  270: 1			;toepassing.
  271: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  272: 1			                                ;geheugenbuffer
  273: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  274: 1			                                ;debounce en de flankdetectie samples stockeren
  275: 1			                                ;de eerste 4 bytes dienen voor debouncing
  276: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  277: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  278: 1			                                ;toetswaarde aangeeft
  279: 1			                                ;bij een geldige keyvalid flag ('1')
  280: 1			endif    ;einde matrix keyboard
  281: 1
  282: 1			ifdef    dipswitch
  283: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  284: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  285: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  286: 1			;toepassing
  287: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  288: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  289: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  290: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  291: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  292: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  293: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  294: 1			endif    ;einde dipswitch
  295: 1			;******************************************************************************
  296: 1			endif    ;einde aduc_key
  297: 1
  298: 1
  299: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  300: 1
  301: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  302: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  303: 1			endif                               ;dus doen we dit hier nog eens!
  304: 1			;******************************************************************************
  305: 1
  306: 1			;******************************************************************************
  307: 1			;
  308: 1			; ADuc_lcd.inc
  309: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  310: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  311: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  312: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  313: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  314: 1			; het plaatsen van de cursor op een correcte plaats).
  315: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  316: 1			; display gebruiken.
  317: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  318: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  319: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  320: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  321: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  322: 1			;
  323: 1			; Versie ADuC832v1.1:
  324: 1			; Hier is het LCD verbonden met pinnen van poort0
  325: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  326: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  327: 1			;
  328: 1			; Versie ADuC832v2.2:
  329: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  330: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  331: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  332: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  333: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  334: 1			;
  335: 1			;
  336: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  337: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  338: 1			;  aduclcd0.inc
  339: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  340: 1			;  aduclcd1.inc
  341: 1			;    -00dh en 00ah worden door outchar verwerkt
  342: 1			;    -bij de init wordt het display anders opgestart
  343: 1			;
  344: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  345: 1			;  van gebruik en uitgebreid  met :
  346: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  347: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  348: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  349: 1			;    debug doeleinden
  350: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  351: 1			;    user codes aan te maken
  352: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  353: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  354: 1			;
  355: 1			; Beschikbare routines:
  356: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  357: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  358: 1			; build_adr, delay2ms, delay60us
  359: 1			;******************************************************************************
  360: 1
  361: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  362: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  363: 1			e             bit    lcdport.2            ;enable
  364: 1			rs            bit    lcdport.3            ;register select
  365: 1			endif    ;einde aduc832_v1_1
  366: 1
  367: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  368: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  369: 1	B	 F1	e             bit    lcdport.1            ;enable
  370: 1	B	 F0	rs            bit    lcdport.0            ;register select
  371: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  372: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  373: 1			endif    ;einde aduc832_v2_0
  374: 1
  375: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  376: 1			;het uitvoeren van de overeenkomstige commando's.
  377: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  378: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  379: 1
  380: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  381: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  382: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  383: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  384: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  385: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  386: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  387: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  388: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  389: 1
  390: 1			;******************************************************************************
  391: 1			;
  392: 1			; initlcd
  393: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  394: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  395: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  396: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  397: 1			; Na initialisering wordt het scherm leeg gemaakt.
  398: 1			;
  399: 1			; registergebruik: geen
  400: 1			;
  401: 1			;******************************************************************************
  402: 1
  403: 1  0013	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  404: 1  0015	C0 D0		              push   psw
  405: 1  0017	C0 F0		              push   b
  406: 1			ifdef  aduc832_v1_1
  407: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  408: 1			                                   ;let op:twee laagste bits worden
  409: 1			                                   ;niet gebruikt
  410: 1			endif
  411: 1
  412: 1			ifdef    aduc832_v2_0
  413: 1  0019	12 03 09	              lcall  i2cinit              ;LCD via een I2C bus
  414: 1  001C	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  415: 1			                                          ;buzzer en backlight  op 1 gezet
  416: 1  001F	12 04 0C	              lcall  porttolcd            ;data uit b naar het scherm
  417: 1			endif
  418: 1
  419: 1  0022	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  420: 1  0024	12 02 DE	initlcd1:     lcall  delay2ms
  421: 1  0027	D5 E0 FA	              djnz   acc,initlcd1
  422: 1  002A	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  423: 1  002C	12 01 95	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  424: 1  002F	12 02 DE	              lcall  delay2ms      ;om het display altijd opgestart
  425: 1  0032	74 30		              mov    a,#00110000b  ;te krijgen.
  426: 1  0034	12 01 95	              lcall  outhnibc
  427: 1  0037	12 02 DE	              lcall  delay2ms
  428: 1  003A	74 30		              mov    a,#00110000b
  429: 1  003C	12 01 95	              lcall  outhnibc
  430: 1  003F	12 02 DE	              lcall  delay2ms
  431: 1  0042	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  432: 1  0044	12 01 95	              lcall  outhnibc      ;hoge nibble naar het controleregister
  433: 1  0047	12 02 DE	              lcall  delay2ms      ;niet nodig volgens datasheet
  434: 1  004A	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  435: 1  004C	12 01 7F	              lcall  outc          ;naar display
  436: 1  004F	12 02 DE	              lcall  delay2ms      ;is iets te lang volgens datasheet
  437: 1  0052	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  438: 1  0054	12 01 7F	              lcall  outc
  439: 1  0057	12 02 DE	              lcall  delay2ms      ;ook deze delay is iets te lang
  440: 1  005A	74 01		              mov    a,#displayon  ;clear display and home cursor
  441: 1  005C	12 01 7F	              lcall  outc
  442: 1  005F	12 02 DE	              lcall  delay2ms      ;deze wachttijd is bijna juist
  443: 1  0062	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  444: 1  0064	12 01 7F	              lcall  outc

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  445: 1  0067	12 02 DE	              lcall  delay2ms      ;wachten weer veel te lang
  446: 1  006A	D0 F0		              pop    b
  447: 1  006C	D0 D0		              pop    psw           ;registers terug in orde zetten
  448: 1  006E	D0 E0		              pop    acc
  449: 1  0070	22		              ret                  ;einde van de initialisatie
  450: 1
  451: 1			;******************************************************************************
  452: 1			;
  453: 1			; outcharlcd
  454: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  455: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  456: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  457: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  458: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  459: 1			; De controlekarakters komen overeen met volgende acties:
  460: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  461: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  462: 1			;              (line feed+ carriage return!)
  463: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  464: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  465: 1			;      011h   =cursor on, blink mode
  466: 1			;      012h   =cursor on, no blink mode
  467: 1			;      013h   =cursor off
  468: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  469: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  470: 1			;              van het LCD
  471: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  472: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  473: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  474: 1			; positie 6 (C5H-80H=45H)
  475: 1			;
  476: 1			; Deze routine vernietigt geen registers
  477: 1			;
  478: 1			;******************************************************************************
  479: 1
  480: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  481: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  482: 1			; dataregister van het scherm.
  483: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  484: 1			; controlebyte doorsturen naar het LCD.
  485: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  486: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  487: 1			; naar de LCD sturen.
  488: 1
  489: 1  0071	C0 E0		outcharlcd:   push   acc           ;registers op stack
  490: 1  0073	C0 D0		              push   psw
  491: 1  0075	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  492: 1  0078	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  493: 1  007A	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  494: 1  007D	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  495: 1  007F	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  496: 1  0082	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  497: 1
  498: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  499: 1			; Als het een commando is, moeten we het uitvoeren.
  500: 1			; Indien niet, gewoon terug zonder actie!

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  501: 1
  502: 1  0084	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  503: 1  0087	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  504: 1  0089	80 28		              sjmp   outcharlcd9          ;afsluiten
  505: 1
  506: 1  008B	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  507: 1  008E	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  508: 1  0090	80 21		              sjmp   outcharlcd9
  509: 1
  510: 1  0092	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  511: 1  0095	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  512: 1  0097	80 1A		              sjmp   outcharlcd9
  513: 1
  514: 1  0099	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  515: 1  009C	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  516: 1  009E	80 13		              sjmp   outcharlcd9
  517: 1
  518: 1  00A0	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  519: 1  00A3	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  520: 1  00A5	80 0C		              sjmp   outcharlcd9
  521: 1
  522: 1  00A7	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  523: 1  00AA	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  524: 1  00AC	80 05		              sjmp   outcharlcd9
  525: 1
  526: 1
  527: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  528: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  529: 1
  530: 1  00AE	12 01 45	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  531: 1  00B1	80 03		              sjmp   outcharlcde   ;einde routine
  532: 1
  533: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  534: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  535: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  536: 1			; op dat adres te zetten.
  537: 1
  538: 1  00B3	12 01 7F	outcharlcd9:  lcall  outc          ;klaar
  539: 1  00B6	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  540: 1  00B8	D0 E0		              pop    acc
  541: 1  00BA	22		              ret
  542: 1
  543: 1			;******************************************************************************
  544: 1			;
  545: 1			; outniblcd
  546: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  547: 1			; op het lcd scherm.
  548: 1			;
  549: 1			; de routine vernietigt geen registers
  550: 1			;
  551: 1			;******************************************************************************
  552: 1
  553: 1  00BB	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  554: 1  00BD	C0 D0		              push   psw
  555: 1  00BF	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  556: 1  00C1	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  557: 1  00C3	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  558: 1  00C6	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  559: 1  00C8	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  560: 1  00CA	12 01 45	outniblcde:   lcall  outd          ;naar het scherm
  561: 1  00CD	D0 D0		              pop    psw
  562: 1  00CF	D0 E0		              pop    acc
  563: 1  00D1	22		              ret
  564: 1
  565: 1			;******************************************************************************
  566: 1			;
  567: 1			; outbytelcd
  568: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  569: 1			;
  570: 1			; de routine vernietigt geen registers
  571: 1			;
  572: 1			;******************************************************************************
  573: 1
  574: 1  00D2	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  575: 1  00D4	C0 D0		              push   psw
  576: 1  00D6	C4		              swap   a             ;bitjes omruilen
  577: 1  00D7	12 00 BB	              lcall  outniblcd
  578: 1  00DA	C4		              swap   a             ;nog eens
  579: 1  00DB	12 00 BB	              lcall  outniblcd
  580: 1  00DE	D0 D0		              pop    psw
  581: 1  00E0	D0 E0		              pop    acc
  582: 1  00E2	22		              ret
  583: 1
  584: 1			;******************************************************************************
  585: 1			;
  586: 1			; dispdptrlcd
  587: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  588: 1			;
  589: 1			; de routine vernietigt geen registers
  590: 1			;
  591: 1			;******************************************************************************
  592: 1
  593: 1  00E3	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  594: 1  00E5	C0 D0		              push   psw
  595: 1  00E7	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  596: 1  00E9	12 00 D2	              lcall  outbytelcd
  597: 1  00EC	E5 82		              mov    a,dpl         ;dan het lage deel
  598: 1  00EE	12 00 D2	              lcall  outbytelcd
  599: 1  00F1	D0 D0		              pop    psw
  600: 1  00F3	D0 E0		              pop    acc
  601: 1  00F5	22		              ret
  602: 1
  603: 1			;******************************************************************************
  604: 1			;
  605: 1			; outmsgalcd
  606: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  607: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  608: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  609: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  610: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  611: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  612: 1			;

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  613: 1			; de routine vernietigt geen registers
  614: 1			;
  615: 1			;******************************************************************************
  616: 1
  617: 1  00F6	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  618: 1  00F8	C0 D0		              push   psw
  619: 1  00FA	C0 83		              push   dph           ;ook de data pointer
  620: 1  00FC	C0 82		              push   dpl
  621: 1
  622: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  623: 1
  624: 1  00FE	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  625: 1  00FF	93		              movc   a,@a+dptr     ;waarde lezen
  626: 1  0100	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  627: 1
  628: 1			; de code is niet 0 dus versturen met outchar
  629: 1
  630: 1  0102	12 00 71	              lcall  outcharlcd    ;weg er mee
  631: 1  0105	A3		              inc    dptr          ;naar volgende ascii code wijzen
  632: 1  0106	02 00 FE	              ljmp   outmsgalcd1   ;lus sluiten
  633: 1
  634: 1  0109	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  635: 1  010B	D0 83		              pop    dph
  636: 1  010D	D0 D0		              pop    psw
  637: 1  010F	D0 E0		              pop    acc
  638: 1  0111	22		              ret
  639: 1
  640: 1			;******************************************************************************
  641: 1			;
  642: 1			; regtolcd
  643: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  644: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  645: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  646: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  647: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  648: 1			;
  649: 1			; de routine vernietigt geen registers
  650: 1			;
  651: 1			;******************************************************************************
  652: 1
  653: 1
  654: 1  0112	C0 E0		regtolcd:     push   acc           ;registers op de stack
  655: 1  0114	C0 D0		              push   psw
  656: 1  0116	E8		              mov    a,r0
  657: 1  0117	C0 E0		              push   acc
  658: 1  0119	E9		              mov    a,r1
  659: 1  011A	C0 E0		              push   acc
  660: 1  011C	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  661: 1  011E	12 00 71	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  662: 1			                                   ;plaats
  663: 1  0121	79 00		              mov    r1,#000h      ;werkt als loopcounter
  664: 1  0123	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  665: 1  0124	12 00 71	              lcall  outcharlcd    ;weg er mee
  666: 1  0127	08		              inc    r0
  667: 1  0128	09		              inc    r1
  668: 1  0129	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  669: 1			                                          ;nieuwe lijn genomen worden
  670: 1  012C	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  671: 1  012E	12 00 71	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  672: 1			                                   ;plaats
  673: 1
  674: 1  0131	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  675: 1  0132	12 00 71	              lcall  outcharlcd    ;weg er mee
  676: 1  0135	08		              inc    r0
  677: 1  0136	09		              inc    r1
  678: 1  0137	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  679: 1  013A	D0 E0		              pop    acc
  680: 1  013C	F9		              mov    r1,a
  681: 1  013D	D0 E0		              pop    acc
  682: 1  013F	F8		              mov    r0,a
  683: 1  0140	D0 D0		              pop    psw           ;registers herstellen
  684: 1  0142	D0 E0		              pop    acc
  685: 1  0144	22		              ret
  686: 1
  687: 1			;******************************************************************************
  688: 1			;
  689: 1			; outd
  690: 1			; Is een routine die naar het data register van het display een
  691: 1			; volledige byte stuurt.
  692: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  693: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  694: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  695: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  696: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  697: 1			;
  698: 1			; De routine vernietigt geen registers.
  699: 1			;
  700: 1			;******************************************************************************
  701: 1
  702: 1  0145	C0 E0		outd:         push   acc           ;registers op stack zetten
  703: 1  0147	C0 D0		              push   psw
  704: 1  0149	12 01 55	              lcall  outhnibd      ;hoogste vier bits verzenden
  705: 1			ifdef     aduc832_v1_1
  706: 1			              lcall  delay60us     ;niet echt nodig
  707: 1			endif
  708: 1  014C	C4		              swap   a             ;bitjes omruilen
  709: 1  014D	12 01 55	              lcall  outhnibd      ;naar het scherm sturen
  710: 1
  711: 1			ifdef    aduc832_v1_1
  712: 1			              lcall  delay60us     ;altijd goed
  713: 1			endif
  714: 1
  715: 1  0150	D0 D0		              pop    psw           ;registers terug herstellen
  716: 1  0152	D0 E0		              pop    acc
  717: 1  0154	22		              ret
  718: 1
  719: 1			;******************************************************************************
  720: 1			;
  721: 1			; outhnibd
  722: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  723: 1			; lcd scherm.
  724: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  725: 1			; de routine vernietigt geen registers.
  726: 1			;
  727: 1			;******************************************************************************
  728: 1			ifdef     aduc832_v1_1
  729: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  730: 1			              push   psw
  731: 1			              setb   rs            ;controle lijn in orde
  732: 1			              clr    e             ;deselectie display
  733: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  734: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  735: 1			              mov     c,acc.6      ;afblijven!
  736: 1			              mov     lcdport.6,c
  737: 1			              mov     c,acc.5
  738: 1			              mov     lcdport.5,c
  739: 1			              mov     c,acc.4
  740: 1			              mov     lcdport.4,c
  741: 1			              setb   e             ;display enabelen
  742: 1			              nop                  ;450ns is normaal gezien voldoende
  743: 1			              clr    e             ;display deselecteren
  744: 1			              pop    psw           ;registers herstellen
  745: 1			              pop    acc
  746: 1			              ret
  747: 1			endif
  748: 1
  749: 1			ifdef    aduc832_v2_0
  750: 1  0155	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  751: 1  0157	C0 D0		              push   psw
  752: 1  0159	C0 F0		              push   b             ;werkregister
  753: 1  015B	12 04 25	              lcall  lcdtoport     ;lees de expander naar b register
  754: 1  015E	D2 F0		              setb   rs            ;controle lijn in orde
  755: 1  0160	C2 F1		              clr    e             ;deselectie display
  756: 1  0162	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  757: 1  0164	03		              rr     a             ;bits op juiste plaats zetten
  758: 1  0165	03		              rr     a             ;voor b reg
  759: 1  0166	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  760: 1  0169	42 F0		              orl    b,a           ;bij elkaar voegen
  761: 1  016B	12 04 0C	              lcall  porttolcd     ;naar expander
  762: 1  016E	D2 F1		              setb   e             ;display enabelen
  763: 1  0170	12 04 0C	              lcall  porttolcd
  764: 1  0173	C2 F1		              clr    e             ;display deselecteren
  765: 1  0175	12 04 0C	              lcall  porttolcd
  766: 1  0178	D0 F0		              pop    b
  767: 1  017A	D0 D0		              pop    psw           ;registers herstellen
  768: 1  017C	D0 E0		              pop    acc
  769: 1  017E	22		              ret
  770: 1			endif
  771: 1			;******************************************************************************
  772: 1			;
  773: 1			; outc
  774: 1			; Is een routine die naar het controleregister van het display een
  775: 1			; volledige byte (commando) stuurt.
  776: 1			; De routine vernietigt geen registers.
  777: 1			;
  778: 1			;******************************************************************************
  779: 1
  780: 1  017F	C0 E0		outc:         push   acc           ;registers op stack zetten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  781: 1  0181	C0 D0		              push   psw
  782: 1  0183	12 01 95	              lcall  outhnibc      ;hoogste vier bits verzenden
  783: 1  0186	12 02 DE	              lcall  delay2ms      ;niet echt nodig
  784: 1  0189	C4		              swap   a             ;bitjes omruilen
  785: 1  018A	12 01 95	              lcall  outhnibc      ;naar het scherm sturen
  786: 1  018D	12 02 DE	              lcall  delay2ms      ;altijd goed voor traagste commando
  787: 1  0190	D0 D0		              pop    psw           ;registers terug herstellen
  788: 1  0192	D0 E0		              pop    acc
  789: 1  0194	22		              ret
  790: 1
  791: 1			;******************************************************************************
  792: 1			;
  793: 1			; outhnibc
  794: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  795: 1			; het lcd scherm.
  796: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  797: 1			; de routine vernietigt geen registers.
  798: 1			;
  799: 1			;******************************************************************************
  800: 1			ifdef     aduc832_v1_1
  801: 1			outhnibc:     push   acc           ;registers op stack plaatsen
  802: 1			              push   psw
  803: 1			              clr    rs            ;controle lijn in orde
  804: 1			              clr    e             ;deselectie display
  805: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  806: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  807: 1			              mov     c,acc.6      ;afblijven!
  808: 1			              mov     lcdport.6,c
  809: 1			              mov     c,acc.5
  810: 1			              mov     lcdport.5,c
  811: 1			              mov     c,acc.4
  812: 1			              mov     lcdport.4,c
  813: 1			              setb   e             ;display enabelen
  814: 1			              nop                  ;450ns is normaal gezien voldoende
  815: 1			              clr    e             ;display deselecteren
  816: 1			              pop    psw           ;registers herstellen
  817: 1			              pop    acc
  818: 1			              ret
  819: 1			endif
  820: 1
  821: 1			ifdef    aduc832_v2_0
  822: 1  0195	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
  823: 1  0197	C0 D0		              push   psw
  824: 1  0199	C0 F0		              push   b             ;werkregister
  825: 1  019B	12 04 25	              lcall  lcdtoport     ;lees de expander naar b register
  826: 1  019E	C2 F0		              clr    rs            ;controle lijn in orde
  827: 1  01A0	C2 F1		              clr    e             ;deselectie display
  828: 1  01A2	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  829: 1  01A4	03		              rr     a             ;bits op juiste plaats zetten
  830: 1  01A5	03		              rr     a             ;voor b reg
  831: 1  01A6	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  832: 1  01A9	42 F0		              orl    b,a           ;bij elkaar voegen
  833: 1  01AB	12 04 0C	              lcall  porttolcd     ;naar expnder
  834: 1  01AE	D2 F1		              setb   e             ;display enabelen
  835: 1  01B0	12 04 0C	              lcall  porttolcd
  836: 1  01B3	C2 F1		              clr    e             ;display deselecteren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  837: 1  01B5	12 04 0C	              lcall  porttolcd
  838: 1  01B8	D0 F0		              pop    b
  839: 1  01BA	D0 D0		              pop    psw           ;registers herstellen
  840: 1  01BC	D0 E0		              pop    acc
  841: 1  01BE	22		              ret
  842: 1			endif
  843: 1
  844: 1			;******************************************************************************
  845: 1			; hexbuf2lcd
  846: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  847: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  848: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  849: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  850: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  851: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  852: 1			;
  853: 1			; ADR| HEX DATA  |
  854: 1			; 42 |AF 2D 23 5A|
  855: 1			;
  856: 1			; Deze routine vernietigt geen registers
  857: 1			;******************************************************************************
  858: 1
  859: 1  01BF	C0 E0		hexbuf2lcd:   push   acc
  860: 1  01C1	C0 F0		              push   b
  861: 1  01C3	C0 D0		              push   psw
  862: 1  01C5	C0 82		              push   dpl
  863: 1  01C7	C0 83		              push   dph
  864: 1  01C9	E8		              mov     a,r0
  865: 1  01CA	C0 E0		              push   acc
  866: 1  01CC	90 02 08	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
  867: 1  01CF	12 00 F6	              lcall   outmsgalcd
  868: 1  01D2	E8		              mov    a,r0            ;neem pointerwaarde
  869: 1  01D3	12 00 D2	              lcall  outbytelcd      ;byte afdrukken als startadres
  870: 1  01D6	74 20		              mov    a,#' '          ;spatie afdrukken
  871: 1  01D8	12 00 71	              lcall  outcharlcd
  872: 1  01DB	74 7C		              mov    a,#'|'          ;pipe afdrukken
  873: 1  01DD	12 00 71	              lcall  outcharlcd
  874: 1  01E0	75 F0 04	              mov    b,#4            ;bytecounter=4
  875: 1  01E3	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  876: 1  01E4	12 00 D2	              lcall  outbytelcd      ;byte naar buiten
  877: 1  01E7	74 20		              mov    a,#' '          ;neem whitespace char
  878: 1  01E9	12 00 71	              lcall  outcharlcd       ;druk af
  879: 1  01EC	08		              inc    r0              ;volgende byte
  880: 1  01ED	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
  881: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  882: 1  01F0	74 CF		              mov    a,#0cfh         ;adres laatste char
  883: 1  01F2	12 00 71	              lcall   outcharlcd
  884: 1  01F5	74 7C		              mov    a,#'|'          ;neem pipe
  885: 1  01F7	12 00 71	              lcall  outcharlcd      ;ascii code afdrukken
  886: 1  01FA	D0 E0		hexbuf2lcde:  pop    acc
  887: 1  01FC	F8		              mov   r0,a
  888: 1  01FD	D0 83		              pop   dph
  889: 1  01FF	D0 82		              pop   dpl
  890: 1  0201	D0 D0		              pop   psw
  891: 1  0203	D0 F0		              pop   b
  892: 1  0205	D0 E0		              pop   acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  893: 1  0207	22		              ret
  894: 1			                        ;'0123456789abcdef'
  895: 1  0208	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  020C	52 7C 20 48
       1  0210	45 58 20 44
       1  0214	41 54 41 20
       1  0218	20 7C C0 00
  896: 1
  897: 1
  898: 1			;******************************************************************************
  899: 1			; barlcd
  900: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
  901: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
  902: 1			; de inhoud van A
  903: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
  904: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
  905: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
  906: 1			; aangemaakt in de LCD CGRAM.
  907: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
  908: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
  909: 1			;       lcall build
  910: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
  911: 1			;       mov     a, #42h     ;de startlocatie is 42h
  912: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
  913: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
  914: 1			;
  915: 1			; Deze routine vernietigt geen registers.
  916: 1			;******************************************************************************
  917: 1
  918: 1  021C	C0 82		barlcd:       push   dpl
  919: 1  021E	88 82		              mov     dpl,r0
  920: 1  0220	C0 82		              push   dpl
  921: 1  0222	C0 E0		              push   acc            ;bewaar startlocatie
  922: 1  0224	C0 D0		              push   psw            ;bewaar status
  923: 1  0226	C0 F0		              push   b              ;bewaar aantal bar's
  924: 1  0228	F5 F0		              mov    b,a            ;bewaar startlocatie
  925: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
  926: 1  022A	E8		              mov    a,r0           ;neem maximum aantal bar's
  927: 1  022B	C0 F0		              push   b              ;bewaar startadres
  928: 1  022D	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
  929: 1  0230	84		              div    ab             ;bereken dus het aantal nodige blokjes
  930: 1  0231	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
  931: 1  0232	E5 F0		              mov    a,b            ;neem restbars
  932: 1  0234	60 01		              jz     barlcd_1       ;als nul dan verder
  933: 1  0236	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
  934: 1  0237	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
  935: 1  0239	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
  936: 1  023B	12 00 71	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
  937: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
  938: 1  023E	74 13		              mov    a,#13h         ;cursor off
  939: 1  0240	12 00 71	              lcall  outcharlcd     ;stuur naar LCD
  940: 1  0243	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
  941: 1  0245	C0 F0		              push   b              ;en weer bewaren
  942: 1  0247	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
  943: 1  0249	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
  944: 1  024B	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  945: 1  024E	84		              div    ab             ;A=aantal volle blokjes, B=rest
  946: 1  024F	C0 F0		              push   b              ;bewaar rest
  947: 1  0251	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
  948: 1  0253	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
  949: 1
  950: 1			;Druk de volle 5x8 blokjes af van de bargraph
  951: 1  0255	74 04		              mov    a,#4           ;neem code voor vol blokje
  952: 1  0257	12 01 45	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
  953: 1  025A	18		              dec    r0             ;verminder karaktersteller
  954: 1  025B	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
  955: 1
  956: 1			;Druk het onvolledige blokje (rest) af
  957: 1  025E	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
  958: 1  0260	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
  959: 1  0262	14		              dec    a              ;converteer rest naar code voor de
  960: 1			                                    ;overeenkomende bar's
  961: 1  0263	12 01 45	              lcall  outd           ;druk resterende bar's af
  962: 1  0266	18		              dec    r0             ;verminder karakterteller
  963: 1
  964: 1			;Test of we aan het einde van de bargraph zitten..
  965: 1  0267	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
  966: 1  026A	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
  967: 1
  968: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
  969: 1  026C	74 20		barlcd4:      mov    a,#' '         ;neem spatie
  970: 1  026E	12 01 45	              lcall  outd           ;en druk af
  971: 1  0271	18		              dec    r0             ;karakterteller verminderen
  972: 1  0272	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
  973: 1
  974: 1  0274	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
  975: 1  0276	D0 D0		              pop    psw            ;haal status weer
  976: 1  0278	D0 E0		              pop    acc            ;haal startlocatie weer
  977: 1  027A	D0 82		              pop    dpl
  978: 1  027C	A8 82		              mov    r0,dpl
  979: 1  027E	D0 82		              pop    dpl
  980: 1  0280	22		              ret
  981: 1
  982: 1
  983: 1
  984: 1			;******************************************************************************
  985: 1			; barchars
  986: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
  987: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
  988: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
  989: 1			; kunnen pas daarna worden gebruikt.
  990: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
  991: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
  992: 1			; (max. 3 extra char's).
  993: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
  994: 1			; opgeslagen met MSB=1.
  995: 1			;******************************************************************************
  996: 1
  997: 1  0281	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
  998: 1  0282	10		              db 00010000b
  999: 1  0283	10		              db 00010000b
 1000: 1  0284	10		              db 00010000b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

 1001: 1  0285	10		              db 00010000b
 1002: 1  0286	10		              db 00010000b
 1003: 1  0287	10		              db 00010000b
 1004: 1  0288	10		              db 00010000b
 1005: 1
 1006: 1  0289	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1007: 1  028A	18		              db 00011000b
 1008: 1  028B	18		              db 00011000b
 1009: 1  028C	18		              db 00011000b
 1010: 1  028D	18		              db 00011000b
 1011: 1  028E	18		              db 00011000b
 1012: 1  028F	18		              db 00011000b
 1013: 1  0290	18		              db 00011000b
 1014: 1
 1015: 1  0291	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1016: 1  0292	1C		              db 00011100b
 1017: 1  0293	1C		              db 00011100b
 1018: 1  0294	1C		              db 00011100b
 1019: 1  0295	1C		              db 00011100b
 1020: 1  0296	1C		              db 00011100b
 1021: 1  0297	1C		              db 00011100b
 1022: 1  0298	1C		              db 00011100b
 1023: 1
 1024: 1  0299	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1025: 1  029A	1E		              db 00011110b
 1026: 1  029B	1E		              db 00011110b
 1027: 1  029C	1E		              db 00011110b
 1028: 1  029D	1E		              db 00011110b
 1029: 1  029E	1E		              db 00011110b
 1030: 1  029F	1E		              db 00011110b
 1031: 1  02A0	1E		              db 00011110b
 1032: 1
 1033: 1  02A1	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1034: 1  02A2	1F		              db 00011111b
 1035: 1  02A3	1F		              db 00011111b
 1036: 1  02A4	1F		              db 00011111b
 1037: 1  02A5	1F		              db 00011111b
 1038: 1  02A6	1F		              db 00011111b
 1039: 1  02A7	1F		              db 00011111b
 1040: 1  02A8	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1041: 1
 1042: 1			;******************************************************************************
 1043: 1			;
 1044: 1			; build
 1045: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1046: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1047: 1			; overeen komen met de ASCII codes 00h-07h.
 1048: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1049: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1050: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1051: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1052: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1053: 1			;
 1054: 1			; De routine vernietigt geen registers.
 1055: 1			;
 1056: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1057: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1058: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1059: 1			;      lcall  outcharlcd         ; druk de karakter af
 1060: 1			;
 1061: 1			;eigenkarakter:
 1062: 1			;      db 00001110b
 1063: 1			;      db 00001010b
 1064: 1			;      db 00001110b
 1065: 1			;      db 00000100b
 1066: 1			;      db 00011111b
 1067: 1			;      db 00000100b
 1068: 1			;      db 00001010b
 1069: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1070: 1			;******************************************************************************
 1071: 1
 1072: 1  02A9	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1073: 1  02AB	C0 D0		              push   psw
 1074: 1  02AD	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1075: 1  02AF	12 02 B7	              lcall  build_adr
 1076: 1  02B2	D0 D0		              pop    psw
 1077: 1  02B4	D0 E0		              pop    acc
 1078: 1  02B6	22		              ret                  ;terug
 1079: 1
 1080: 1			;******************************************************************************
 1081: 1			; build_adr
 1082: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1083: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1084: 1			; die overeen komen met de ASCII codes 00h-07h.
 1085: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1086: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1087: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1088: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1089: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1090: 1			;
 1091: 1			; De routine vernietigt geen registers.
 1092: 1			;
 1093: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1094: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1095: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1096: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1097: 1			;      lcall  outcharlcd        ; druk de karakter af
 1098: 1			;
 1099: 1			;eigenkarakters:
 1100: 1			;      db 00001110b
 1101: 1			;      db 00001010b
 1102: 1			;      db 00001110b
 1103: 1			;       db 00000100b
 1104: 1			;      db 00011111b
 1105: 1			;      db 00000100b
 1106: 1			;      db 00001010b
 1107: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1108: 1			;******************************************************************************
 1109: 1  02B7	C0 E0		build_adr:      push   acc
 1110: 1  02B9	C0 D0		              push   psw
 1111: 1  02BB	C0 83		              push   dph
 1112: 1  02BD	C0 82		              push   dpl

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1113: 1  02BF	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1114: 1  02C1	12 01 7F	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1115: 1  02C4	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1116: 1  02C6	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1117: 1  02C7	12 01 45	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1118: 1  02CA	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1119: 1  02CD	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1120: 1  02CE	80 F4		              sjmp   build3
 1121: 1  02D0	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1122: 1  02D2	12 01 7F	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1123: 1  02D5	D0 82		              pop    dpl
 1124: 1  02D7	D0 83		              pop    dph
 1125: 1  02D9	D0 D0		              pop    psw
 1126: 1  02DB	D0 E0		              pop    acc
 1127: 1  02DD	22		              ret
 1128: 1
 1129: 1			;******************************************************************************
 1130: 1			;
 1131: 1			; delay2ms
 1132: 1			; Is een vertragingsroutine van 2ms.
 1133: 1			;
 1134: 1			; De routine vernietigt geen registers.
 1135: 1			;
 1136: 1			;******************************************************************************
 1137: 1
 1138: 1  02DE	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1139: 1  02E0	C0 D0		              push   psw
 1140: 1  02E2	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1141: 1  02E4	12 02 EF	delay2ms1:    lcall  delay60us
 1142: 1  02E7	D5 E0 FA	              djnz   acc,delay2ms1
 1143: 1  02EA	D0 D0		              pop    psw           ;registers herstellen
 1144: 1  02EC	D0 E0		              pop    acc
 1145: 1  02EE	22		              ret
 1146: 1
 1147: 1			;******************************************************************************
 1148: 1			;
 1149: 1			; delay60us.
 1150: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1151: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1152: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1153: 1			;
 1154: 1			; de routine vernietigt geen registers.
 1155: 1			;
 1156: 1			;******************************************************************************
 1157: 1
 1158: 1  02EF	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1159: 1  02F1	C0 D0		              push   psw
 1160: 1  02F3	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1161: 1  02F5	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1162: 1
 1163: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1164: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1165: 1
 1166: 1  02F7	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1167: 1  02FA	D0 E0		              pop    acc           ;registers herstellen
 1168: 1  02FC	D0 D0		              pop    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1169: 1  02FE	22		              ret
 1170: 1
 1171: 1  02FF	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1172: 1  0301	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1173: 1  0304	D0 D0		              pop    psw
 1174: 1  0306	D0 E0		              pop    acc
 1175: 1  0308	22		              ret
 1176: 1
 1177: 1			endif        ;einde van aduc_lcd
 1178: 1
 1179: 1
 1180: 1
 1181: 1
 1182: 1			ifdef aduc_i2c
 1183: 1			;******************************************************************************
 1184: 1			;
 1185: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1186: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1187: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1188: 1			;
 1189: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1190: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1191: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1192: 1			;
 1193: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1194: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1195: 1			;
 1196: 1			; Beschikbare routines:
 1197: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1198: 1			; i2cstart     :verzenden van een start conditie
 1199: 1			; i2cstop      :verzenden van een stop conditie
 1200: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1201: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1202: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1203: 1			;               negende klokpuls
 1204: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1205: 1			;               negende klokpuls
 1206: 1			;
 1207: 1			; Toevoeging [dp]
 1208: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1209: 1			;               een slavedevice
 1210: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1211: 1			;               en plaatst deze in een geheugenbuffer
 1212: 1			;******************************************************************************
 1213: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1214: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1215: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1216: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1217: 1
 1218: 1			;******************************************************************************
 1219: 1			; i2cinit
 1220: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1221: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1222: 1  0309	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1223: 1  030B	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1224: 1  030D	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1225: 1  030F	D2 EB		                setb    i2cm            ;master mode inschakelen
 1226: 1  0311	22		                ret
 1227: 1			;******************************************************************************
 1228: 1			; i2cstart
 1229: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1230: 1			;******************************************************************************
 1231: 1  0312	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1232: 1  0314	C2 EF		                clr     mdo             ;data moet laag worden
 1233: 1  0316	D2 EE		                setb    mde             ;data pin enable
 1234: 1  0318	C2 ED		                clr     mco             ;klok laag maken
 1235: 1  031A	22		                ret
 1236: 1			;******************************************************************************
 1237: 1			; i2cstop
 1238: 1			; Dit is een subroutine die de stop conditie opwekt.
 1239: 1			;******************************************************************************
 1240: 1  031B	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1241: 1  031D	D2 EE		                setb    mde             ;data mag naar buiten
 1242: 1  031F	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1243: 1  0321	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1244: 1  0323	22		                ret
 1245: 1
 1246: 1			;******************************************************************************
 1247: 1			; i2coutbyte
 1248: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1249: 1			; De routine vernietigt geen registers.
 1250: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1251: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1252: 1			;         uitvoeren van de routine.
 1253: 1			;******************************************************************************
 1254: 1  0324	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1255: 1  0326	C0 F0		                push    b
 1256: 1  0328	75 F0 08	                mov     b,#008h         ;loopcounter
 1257: 1  032B	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1258: 1  032C	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1259: 1  032E	D2 EE		                setb    mde             ;pin als output activeren
 1260: 1  0330	D2 ED		                setb    mco             ;klokpukls hoog
 1261: 1  0332	C2 ED		                clr     mco             ;klokpuls laag
 1262: 1  0334	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1263: 1  0337	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1264: 1  0339	D2 ED		                setb    mco             ;klokpuls hoog
 1265: 1  033B	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1266: 1  033D	C2 ED		                clr     mco             ;klokpuls terug laag
 1267: 1  033F	D0 F0		                pop     b
 1268: 1  0341	D0 E0		                pop     acc             ;registers herstellen
 1269: 1  0343	22		                ret
 1270: 1
 1271: 1			;******************************************************************************
 1272: 1			; i2cinbyteack
 1273: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1274: 1			; De routine vernietigt geen registers. De routine zal als
 1275: 1			; negende bit een ack verzenden.
 1276: 1			;******************************************************************************
 1277: 1  0344	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1278: 1  0346	C0 D0		                push    psw
 1279: 1  0348	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1280: 1  034B	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1281: 1  034D	D2 ED		                setb    mco             ;klokpuls hoog
 1282: 1  034F	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1283: 1  0351	C2 ED		                clr     mco             ;klokpuls terug laag
 1284: 1  0353	33		                rlc     a               ;in accu shiften
 1285: 1  0354	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1286: 1  0357	C3		                clr     c               ;ack verzenden
 1287: 1  0358	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1288: 1  035A	D2 EE		                setb    mde             ;pin als output activeren
 1289: 1  035C	D2 ED		                setb    mco             ;klokpukls hoog
 1290: 1  035E	C2 ED		                clr     mco             ;klokpuls laag
 1291: 1  0360	D0 D0		                pop     psw             ;registers herstellen
 1292: 1  0362	D0 F0		                pop     b
 1293: 1  0364	22		                ret
 1294: 1
 1295: 1			;******************************************************************************
 1296: 1			; i2cinbytenack
 1297: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1298: 1			; De routine vernietigt geen registers. De routine zal als
 1299: 1			; negende bit een nack verzenden.
 1300: 1			;******************************************************************************
 1301: 1  0365	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1302: 1  0367	C0 D0		                push    psw
 1303: 1  0369	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1304: 1  036C	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1305: 1  036E	D2 ED		                setb    mco             ;klokpuls hoog
 1306: 1  0370	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1307: 1  0372	C2 ED		                clr     mco             ;klokpuls terug laag
 1308: 1  0374	33		                rlc     a               ;in accu shiften
 1309: 1  0375	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1310: 1  0378	D3		                setb    c               ;nack verzenden
 1311: 1  0379	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1312: 1  037B	D2 EE		                setb    mde             ;pin als output activeren
 1313: 1  037D	D2 ED		                setb    mco             ;klokpukls hoog
 1314: 1  037F	C2 ED		                clr     mco             ;klokpuls laag
 1315: 1  0381	D0 D0		                pop     psw             ;registers herstellen
 1316: 1  0383	D0 F0		                pop     b
 1317: 1  0385	22		                ret
 1318: 1
 1319: 1			;******************************************************************************
 1320: 1			; i2csenddata
 1321: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1322: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1323: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1324: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1325: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1326: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1327: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1328: 1			;
 1329: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1330: 1			; pointer naar deze data.  .
 1331: 1
 1332: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1333: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1334: 1			;         B       = aantal te versturen bytes (minimum 1)
 1335: 1			;         R0      = startadres van te versturen datablok
 1336: 1			;
 1337: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1338: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1339: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1340: 1			;               verzonden byte waarvoor er geen ack kwam.
 1341: 1			;
 1342: 1			; Deze routine vernietigt niets...
 1343: 1			;******************************************************************************
 1344: 1  0386	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1345: 1  0388	C0 D0		                    push   psw
 1346: 1  038A	E8		                    mov    a,r0
 1347: 1  038B	C0 E0		                    push   acc           ;r0 op stack
 1348: 1
 1349: 1  038D	12 03 12	                    lcall  i2cstart      ;genereer startconditie
 1350: 1  0390	E5 83		                    mov    a,dph         ;neem adresbyte
 1351: 1  0392	12 03 24	                    lcall  i2coutbyte    ;en verstuur naar slave
 1352: 1  0395	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1353: 1  0397	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1354: 1  0399	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1355: 1  039B	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1356: 1			;10 bit adressering!
 1357: 1  039E	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1358: 1  03A0	12 03 24	                    lcall  i2coutbyte    ;en verstuur naar slave
 1359: 1  03A3	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1360: 1			;7 bit adressering!
 1361: 1  03A5	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1362: 1  03A6	12 03 24	                    lcall  i2coutbyte    ;en verstuur naar slave
 1363: 1  03A9	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1364: 1  03AB	08		                    inc    r0            ;volgende byte
 1365: 1  03AC	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1366: 1  03AF	12 03 1B	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1367: 1  03B2	D0 E0		                    pop    acc
 1368: 1  03B4	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1369: 1  03B5	D0 D0		                    pop    psw
 1370: 1  03B7	C3		                    clr    c             ;alles is ok!
 1371: 1  03B8	D0 E0		                    pop    acc
 1372: 1  03BA	22		                    ret
 1373: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1374: 1  03BB	12 03 1B	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1375: 1  03BE	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1376: 1  03C0	D0 D0		                    pop    psw
 1377: 1  03C2	D3		                    setb   c            ;terug met foutmelding
 1378: 1  03C3	D0 E0		                    pop    acc
 1379: 1  03C5	22		                    ret
 1380: 1
 1381: 1			;******************************************************************************
 1382: 1			; i2crcvdata
 1383: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1384: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1385: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1386: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1387: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1388: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1389: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1390: 1			;
 1391: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1392: 1			; is een pointer naar de start van dit ontvangen datablok.
 1393: 1			;
 1394: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1395: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1396: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1397: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1398: 1			;
 1399: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1400: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1401: 1			;               het adres, wordt de CY bit geset bij return.
 1402: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1403: 1			;
 1404: 1			; Deze routine vernietigt verder niets...
 1405: 1			;******************************************************************************
 1406: 1  03C6	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1407: 1  03C8	C0 D0		                    push    psw
 1408: 1  03CA	E8		                    mov     a,r0            ;r0 op stack
 1409: 1  03CB	C0 E0		                    push    acc
 1410: 1
 1411: 1  03CD	12 03 12	                    lcall   i2cstart        ;genereer startconditie
 1412: 1  03D0	E5 83		                    mov     a,dph           ;neem adresbyte
 1413: 1  03D2	12 03 24	                    lcall   i2coutbyte      ;en verstuur naar slave
 1414: 1  03D5	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1415: 1  03D7	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1416: 1  03D9	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1417: 1  03DB	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1418: 1			;10 bit adressering!
 1419: 1  03DE	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1420: 1  03E0	12 03 24	                    lcall   i2coutbyte      ;en verstuur naar slave
 1421: 1  03E3	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1422: 1			;7 bit adressering!
 1423: 1
 1424: 1  03E5	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1425: 1  03E8	12 03 65	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1426: 1  03EB	F6		                    mov     @r0,a           ;en deze ook bewaren
 1427: 1  03EC	80 07		                    sjmp    i2crcvdata3
 1428: 1  03EE	12 03 44	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1429: 1  03F1	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1430: 1  03F2	08		                    inc     r0              ;pointer verhogen
 1431: 1  03F3	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1432: 1
 1433: 1  03F5	12 03 1B	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1434: 1  03F8	D0 E0		                    pop     acc
 1435: 1  03FA	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1436: 1  03FB	D0 D0		                    pop     psw
 1437: 1  03FD	C3		                    clr     c               ;alles is ok!
 1438: 1  03FE	D0 E0		                    pop     acc
 1439: 1  0400	22		                    ret
 1440: 1			;fout: geen ack gekregen bij het versturen van het adres
 1441: 1  0401	12 03 1B	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1442: 1  0404	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1443: 1  0406	D0 D0		                    pop        psw
 1444: 1  0408	D3		                    setb    c               ;terug met foutmelding
 1445: 1  0409	D0 E0		                    pop        acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1446: 1  040B	22		                    ret
 1447: 1
 1448: 1
 1449: 1			;******************************************************************************
 1450: 1			;
 1451: 1			; porttolcd
 1452: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1453: 1			; scherm stuurt via de port expander.
 1454: 1			;
 1455: 1			; Gebruikt geen registers
 1456: 1			;
 1457: 1			;******************************************************************************
 1458: 1
 1459: 1  040C	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1460: 1  040E	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1461: 1  0410	12 03 12	              lcall  i2cstart      ;vertrokken
 1462: 1			ifdef    pcf8574
 1463: 1			              mov    a,#01000000b  ;schrijven naar expander
 1464: 1			endif
 1465: 1			ifdef    pcf8574A
 1466: 1  0413	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1467: 1			endif
 1468: 1  0415	12 03 24	              lcall  i2coutbyte    ;weg er mee
 1469: 1  0418	E5 F0		              mov    a,b           ;data verzenden
 1470: 1  041A	12 03 24	              lcall  i2coutbyte
 1471: 1  041D	12 03 1B	              lcall  i2cstop       ;transactie sluiten
 1472: 1  0420	D0 D0		              pop    psw
 1473: 1  0422	D0 E0		              pop    acc
 1474: 1  0424	22		              ret
 1475: 1
 1476: 1			;******************************************************************************
 1477: 1			;
 1478: 1			; lcdtoport
 1479: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1480: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1481: 1			; aansturen van de buzzer en backlight.
 1482: 1			;
 1483: 1			; output: b register
 1484: 1			;
 1485: 1			;******************************************************************************
 1486: 1
 1487: 1  0425	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1488: 1  0427	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1489: 1  0429	12 03 12	              lcall  i2cstart      ;vertrokken
 1490: 1			ifdef    pcf8574
 1491: 1			              mov    a,#01000000b  ;schrijven naar expander
 1492: 1			endif
 1493: 1			ifdef    pcf8574A
 1494: 1  042C	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1495: 1			endif
 1496: 1  042E	12 03 24	              lcall  i2coutbyte    ;weg er mee
 1497: 1  0431	12 03 65	              lcall  i2cinbytenack ;data inlezen
 1498: 1  0434	12 03 1B	              lcall  i2cstop
 1499: 1  0437	F5 F0		              mov    b,a
 1500: 1  0439	D0 D0		              pop    psw
 1501: 1  043B	D0 E0		              pop    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1502: 1  043D	22		              ret
 1503: 1
 1504: 1			;******************************************************************************
 1505: 1			;
 1506: 1			; lcdlighton
 1507: 1			; Dit is een subroutine die de backlight inschakeld
 1508: 1			;
 1509: 1			; Gebruikt geen registers
 1510: 1			;
 1511: 1			;******************************************************************************
 1512: 1
 1513: 1  043E	C0 F0		lcdlighton:   push   b
 1514: 1  0440	12 04 25	              lcall  lcdtoport     ;expander lezen
 1515: 1  0443	C2 F6		              clr    b.6           ;licht aan doen
 1516: 1  0445	12 04 0C	              lcall  porttolcd     ;expander schrijven
 1517: 1  0448	D0 F0		              pop    b
 1518: 1  044A	22		              ret
 1519: 1
 1520: 1
 1521: 1			;******************************************************************************
 1522: 1			;
 1523: 1			; lcdlightoff
 1524: 1			; Dit is een subroutine die de backlight uitschakeld
 1525: 1			;
 1526: 1			; Gebruikt geen registers
 1527: 1			;
 1528: 1			;******************************************************************************
 1529: 1
 1530: 1  044B	C0 F0		lcdlightoff:  push   b
 1531: 1  044D	12 04 25	              lcall  lcdtoport     ;expander lezen
 1532: 1  0450	D2 F6		              setb   b.6           ;licht uit doen
 1533: 1  0452	12 04 0C	              lcall  porttolcd     ;expander schrijven
 1534: 1  0455	D0 F0		              pop    b
 1535: 1  0457	22		              ret
 1536: 1
 1537: 1			;******************************************************************************
 1538: 1			;
 1539: 1			; lcdbuzon
 1540: 1			; Dit is een subroutine die de buzzer inschakeld
 1541: 1			;
 1542: 1			; Gebruikt geen registers
 1543: 1			;
 1544: 1			;******************************************************************************
 1545: 1
 1546: 1  0458	C0 F0		lcdbuzon:     push   b
 1547: 1  045A	12 04 25	              lcall  lcdtoport     ;expander lezen
 1548: 1  045D	C2 F7		              clr    b.7           ;buzzer aan doen
 1549: 1  045F	12 04 0C	              lcall  porttolcd     ;expander schrijven
 1550: 1  0462	D0 F0		              pop    b
 1551: 1  0464	22		              ret
 1552: 1
 1553: 1			;******************************************************************************
 1554: 1			;
 1555: 1			; lcdbuzoff
 1556: 1			; Dit is een subroutine die de buzzer uitschakeld
 1557: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1558: 1			; Gebruikt geen registers
 1559: 1			;
 1560: 1			;******************************************************************************
 1561: 1
 1562: 1  0465	C0 F0		lcdbuzoff:    push   b
 1563: 1  0467	12 04 25	              lcall  lcdtoport     ;expander lezen
 1564: 1  046A	D2 F7		              setb   b.7           ;buzzer aan doen
 1565: 1  046C	12 04 0C	              lcall  porttolcd     ;expander schrijven
 1566: 1  046F	D0 F0		              pop    b
 1567: 1  0471	22		              ret
 1568: 1
 1569: 1			endif    ;einde aduc_i2c
 1570: 1			;******************************************************************************
 1571: 1
 1572: 1
 1573: 1
 1574: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1575: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1576: 1			;
 1577: 1			; ADuCsio.inc
 1578: 1			; Is een include file voor de ADuC832 microcontroller.
 1579: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1580: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1581: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1582: 1			; afwijking van de standaard routines is de initsio subroutine.
 1583: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1584: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1585: 1			; zijn.
 1586: 1			;
 1587: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1588: 1			;
 1589: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1590: 1
 1591: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1592: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1593: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1594: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1595: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1596: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1597: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1598: 1
 1599: 1  0472	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1600: 1			                                                        ;van het scherm
 1601: 1
 1602: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1603: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1604: 1
 1605: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1606: 1			;
 1607: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1608: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1609: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1610: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1611: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1612: 1			;
 1613: 1			; de routine gebruikt de psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1614: 1			;
 1615: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1616: 1
 1617: 1  0476	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1618: 1  0478	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1619: 1  047A	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1620: 1  047C	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1621: 1  047F	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1622: 1
 1623: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1624: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1625: 1
 1626: 1  0481	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1627: 1  0484	F4		              cpl    a             ;bitbangen om laten uit te komen
 1628: 1  0485	C3		              clr    c             ;verder doen
 1629: 1  0486	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1630: 1  0488	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1631: 1  048A	24 80		              add    a,#080h       ;nu alles in orde
 1632: 1  048C	F5 9E		              mov    t3con,a       ;baud rate klaar
 1633: 1  048E	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1634: 1  0491	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1635: 1  0492	D0 E0		              pop    acc
 1636: 1  0494	22		              ret
 1637: 1
 1638: 1  0495	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1639: 1  0496	D0 E0		              pop    acc
 1640: 1  0498	22		              ret
 1641: 1
 1642: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1643: 1			;
 1644: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1645: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1646: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1647: 1			;
 1648: 1			; de routine gebruikt geen registers.
 1649: 1			;
 1650: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1651: 1
 1652: 1  0499	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1653: 1  049B	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1654: 1  049E	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1655: 1  04A0	22		              RET
 1656: 1
 1657: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1658: 1			;
 1659: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1660: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1661: 1			;
 1662: 1			; de routine gebruikt geen registers.
 1663: 1			;
 1664: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1665: 1
 1666: 1  04A1	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1667: 1  04A3	C0 D0		              push   psw
 1668: 1  04A5	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1669: 1  04A7	12 05 B3	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1670: 1  04AA	12 04 99	              LCALL  OUTCHAR       ;VERSTUREN
 1671: 1  04AD	12 04 FA	              LCALL  XONXOFF       ;FLOW CONTROL
 1672: 1  04B0	D0 D0		              pop    psw           ;registers herstellen
 1673: 1  04B2	D0 E0		              pop    acc
 1674: 1  04B4	22		              RET
 1675: 1
 1676: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1677: 1			;
 1678: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1679: 1			; WORDT XONXOFF GEBRUIKT.
 1680: 1			;
 1681: 1			; de routine gebruikt geen registers.
 1682: 1			;
 1683: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1684: 1
 1685: 1  04B5	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1686: 1  04B7	C0 D0		              push   psw
 1687: 1  04B9	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1688: 1  04BB	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1689: 1  04BC	12 04 A1	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1690: 1  04BF	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1691: 1  04C1	12 04 A1	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1692: 1  04C4	D0 D0		              pop    psw           ;registers herstellen
 1693: 1  04C6	D0 E0		              pop    acc
 1694: 1  04C8	22		              RET
 1695: 1
 1696: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1697: 1			;
 1698: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1699: 1			; VAN DE CURSOR.
 1700: 1			;
 1701: 1			; de routine gebruikt geen registers.
 1702: 1			;
 1703: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1704: 1
 1705: 1  04C9	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1706: 1  04CB	C0 D0		              push   psw
 1707: 1  04CD	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1708: 1  04CF	12 04 B5	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1709: 1  04D2	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1710: 1  04D4	12 04 B5	              LCALL  OUTBYTE       ;WEG ER MEE
 1711: 1  04D7	D0 D0		              pop    psw           ;registers herstellen
 1712: 1  04D9	D0 E0		              pop    acc
 1713: 1  04DB	22		              RET                  ;EINDE
 1714: 1
 1715: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1716: 1			;
 1717: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1718: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1719: 1			;
 1720: 1			; de routine gebruikt geen registers.
 1721: 1			;
 1722: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1723: 1
 1724: 1  04DC	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1725: 1  04DE	C0 D0		              push   psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1726: 1  04E0	C0 82		              push   dpl
 1727: 1  04E2	C0 83		              push   dph
 1728: 1  04E4	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1729: 1  04E5	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1730: 1  04E6	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1731: 1  04E8	12 04 99	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1732: 1  04EB	12 04 FA	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1733: 1  04EE	A3		              INC    DPTR          ;DPTR AANPASSEN
 1734: 1  04EF	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1735: 1  04F1	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1736: 1  04F3	D0 82		              pop    dpl
 1737: 1  04F5	D0 D0		              pop    psw
 1738: 1  04F7	D0 E0		              pop    acc
 1739: 1  04F9	22		              RET                  ;EINDE ROUTINE
 1740: 1
 1741: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1742: 1			;
 1743: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1744: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1745: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1746: 1			; VERDER DOORGEGEVEN.
 1747: 1			;
 1748: 1			; de routine gebruikt geen registers.
 1749: 1			;
 1750: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1751: 1
 1752: 1  04FA	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1753: 1  04FC	C0 D0		              push   psw
 1754: 1  04FE	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1755: 1  0501	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 1756: 1  0503	D0 E0		              pop    acc
 1757: 1  0505	22		              RET                  ;ANDERS EINDE
 1758: 1  0506	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1759: 1  0508	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1760: 1  050B	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1761: 1  050E	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1762: 1
 1763: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1764: 1			;
 1765: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1766: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1767: 1			;
 1768: 1			; de routine gebruikt de accu.
 1769: 1			;
 1770: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1771: 1
 1772: 1  0510	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 1773: 1  0513	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 1774: 1  0515	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1775: 1  0517	22		              RET
 1776: 1
 1777: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1778: 1			;
 1779: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1780: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1781: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1782: 1			; DE CARRY OP 1 GEZET WORDEN.
 1783: 1			;
 1784: 1			; De routine gebruikt de accu EN PSW.
 1785: 1			;
 1786: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1787: 1
 1788: 1  0518	C0 F0		INBYTE:       PUSH     B
 1789: 1  051A	12 05 10	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1790: 1  051D	12 05 A6	              LCALL  LOWUPTR
 1791: 1  0520	12 05 C1	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1792: 1  0523	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1793: 1  0525	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1794: 1  0526	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1795: 1  0528	12 05 10	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1796: 1  052B	12 05 A6	              LCALL  LOWUPTR
 1797: 1  052E	12 05 C1	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1798: 1  0531	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1799: 1  0533	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1800: 1  0535	D0 F0		INBYTE1:      POP     B
 1801: 1  0537	22		              RET
 1802: 1
 1803: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1804: 1			;
 1805: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1806: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1807: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1808: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1809: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1810: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1811: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 1812: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1813: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1814: 1			; bepalen.
 1815: 1			;
 1816: 1			; De routine gebruikt  r0 .
 1817: 1			;
 1818: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1819: 1
 1820: 1  0538	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1821: 1  053A	C0 D0		              push   psw
 1822: 1  053C	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1823: 1  053E	12 05 10	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 1824: 1  0541	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1825: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 1826: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1827: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1828: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 1829: 1			; GEVOERD.
 1830: 1  0543	12 05 A6	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1831: 1  0546	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1832: 1  0549	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1833: 1  054A	D0 D0		              pop    psw                  ;registers herstellen
 1834: 1  054C	D0 E0		              pop    acc
 1835: 1  054E	22		              RET                         ;EINDE VAN DE ROUTINE
 1836: 1
 1837: 1  054F	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1838: 1  0552	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1839: 1  0555	74 07		INBUFA4:      MOV    A,#BEEP
 1840: 1  0557	12 04 99	INBUFA7:      LCALL  OUTCHAR
 1841: 1  055A	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1842: 1
 1843: 1  055C	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1844: 1  055D	90 04 72	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1845: 1  0560	12 04 DC	              LCALL  OUTMSGA
 1846: 1  0563	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 1847: 1  0565	12 05 98	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1848: 1  0568	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1849: 1  056A	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1850: 1  056D	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1851: 1  056F	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1852: 1  0570	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1853: 1  0571	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1854: 1
 1855: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1856: 1			;
 1857: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1858: 1			;
 1859: 1			; De routine gebruikt niets.
 1860: 1			;
 1861: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1862: 1
 1863: 1  0573	C0 E0		BDELETE:      PUSH     ACC
 1864: 1  0575	C0 D0		              PUSH     PSW
 1865: 1  0577	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1866: 1  0578	C0 E0		              PUSH     ACC
 1867: 1  057A	E9		              MOV     A,R1
 1868: 1  057B	C0 E0		              PUSH     ACC
 1869: 1  057D	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1870: 1  057F	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1871: 1  0581	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1872: 1  0582	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1873: 1  0585	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1874: 1  0586	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1875: 1  0589	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1876: 1  058B	F9		              MOV     R1,A
 1877: 1  058C	D0 E0		              POP     ACC
 1878: 1  058E	F8		              MOV     R0,A
 1879: 1  058F	D0 D0		              POP     PSW
 1880: 1  0591	D0 E0		              POP     ACC
 1881: 1  0593	22		              RET                         ;EINDE VAN DE ROUTINE
 1882: 1  0594	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1883: 1  0595	09		              INC    R1
 1884: 1  0596	80 ED		              SJMP   BDELETE3
 1885: 1
 1886: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1887: 1			;
 1888: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1889: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1890: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1891: 1			; AANZIEN.
 1892: 1			;
 1893: 1			; De routine gebruikt de accu en de psw.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1894: 1			;
 1895: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1896: 1
 1897: 1  0598	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 1898: 1  059B	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 1899: 1  059D	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 1900: 1  05A0	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 1901: 1  05A2	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 1902: 1  05A3	22		              RET
 1903: 1  05A4	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 1904: 1  05A5	22		              RET
 1905: 1
 1906: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1907: 1			;
 1908: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 1909: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 1910: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 1911: 1			; AANGEPAST WORDEN.
 1912: 1			;
 1913: 1			; De routine gebruikt de accu en psw .
 1914: 1			;
 1915: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1916: 1
 1917: 1  05A6	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 1918: 1  05A9	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 1919: 1  05AB	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 1920: 1  05AE	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 1921: 1  05B0	94 20		              SUBB   A,#020H              ;OMZETTING
 1922: 1  05B2	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 1923: 1
 1924: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1925: 1			;
 1926: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 1927: 1			; ASCII CODE.
 1928: 1			;
 1929: 1			; De routine gebruikt de accu .
 1930: 1			;
 1931: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1932: 1
 1933: 1  05B3	C0 D0		BATRANS:      PUSH   PSW
 1934: 1  05B5	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 1935: 1  05B8	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 1936: 1  05BA	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 1937: 1  05BC	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 1938: 1  05BE	D0 D0		              POP     PSW
 1939: 1  05C0	22		              RET
 1940: 1
 1941: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1942: 1			;
 1943: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 1944: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 1945: 1			; GEVAL WORDT DE CARRY GEZET.
 1946: 1			;
 1947: 1			; De routine gebruikt de accu en de psw.
 1948: 1			;
 1949: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1950: 1
 1951: 1  05C1	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 1952: 1  05C2	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 1953: 1  05C4	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 1954: 1  05C6	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 1955: 1  05C9	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 1956: 1  05CB	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 1957: 1  05CD	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 1958: 1  05CF	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 1959: 1  05D2	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 1960: 1  05D3	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 1961: 1  05D5	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 1962: 1  05D6	22		ASCBINTRANS1: RET
 1963: 1
 1964: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1965: 1			;
 1966: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 1967: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 1968: 1			;
 1969: 1			; De routine gebruikt de accu en de psw.
 1970: 1			;
 1971: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1972: 1
 1973: 1  05D7	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 1974: 1  05D8	12 05 C1	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 1975: 1  05DB	22		              RET                         ;EINDE OMZETTING
 1976: 1
 1977: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1978: 1			;
 1979: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 1980: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 1981: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 1982: 1			;
 1983: 1			; De routine gebruikt de accu, r0.
 1984: 1			;
 1985: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1986: 1
 1987: 1  05DC	C0 F0		ASCII2:       PUSH   B
 1988: 1  05DE	12 05 D7	              LCALL  ASCII1               ;OMZETTEN
 1989: 1  05E1	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 1990: 1  05E3	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 1991: 1  05E4	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 1992: 1  05E6	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 1993: 1  05E7	12 05 D7	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 1994: 1  05EA	40 02		              JC     ASCII21               ;WEG ALS C=1
 1995: 1  05EC	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 1996: 1  05EE	D0 F0		ASCII21:      POP     B
 1997: 1  05F0	22		              RET
 1998: 1
 1999: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2000: 1			;
 2001: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2002: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2003: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2004: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2005: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2006: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2007: 1			;
 2008: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2009: 1
 2010: 1  05F1	12 05 DC	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2011: 1  05F4	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2012: 1  05F6	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2013: 1  05F8	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2014: 1  05F9	12 05 DC	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2015: 1  05FC	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2016: 1  05FE	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2017: 1  0600	22		ASCII41:      RET
 2018: 1
 2019: 1			endif        ;einde van aduc_sio
 2020: 1			;*******************************************************************************
 2021: 1
 2022: 1
 2023: 1			ifdef        aduc_math    ;rekenkundige routines
 2024: 1			;*******************************************************************************
 2025: 1			; aduc_math
 2026: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2027: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2028: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2029: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2030: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2031: 1			; zoals aangegeven:
 2032: 1			;
 2033: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2034: 1			;        ---------------------------
 2035: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2036: 1			;        ---------------------------                             statusbit = f0
 2037: 1			;        ---------------------------
 2038: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2039: 1			;        ---------------------------
 2040: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2041: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2042: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2043: 1			; return en moeten hiervoor worden gereserveerd.
 2044: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2045: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2046: 1			; en unsigned getallen.
 2047: 1			;
 2048: 1			; Beschikbare routines:
 2049: 1			;
 2050: 1			; Conversie routines:
 2051: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2052: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2053: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2054: 1			;
 2055: 1			; Som:
 2056: 1			; s_add16, add16, s_add32, add32
 2057: 1			;
 2058: 1			; Verschil:
 2059: 1			; s_sub16, sub16, s_sub32, sub32
 2060: 1			;
 2061: 1			; Vermenigvuldigen:

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2062: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2063: 1			;
 2064: 1			; Delen:
 2065: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2066: 1			;
 2067: 1			; Vemenigvuldig met factor:
 2068: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2069: 1			;
 2070: 1			; Vierkantswortel:
 2071: 1			; sqrt32, s_sqrt32
 2072: 1			;
 2073: 1			; Schuiven:
 2074: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2075: 1			;
 2076: 1			; Vergelijken:
 2077: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2078: 1			;
 2079: 1			; Tabel lookup:
 2080: 1			; table_lu
 2081: 1			;
 2082: 1			; Gonemetrische functies:
 2083: 1			; Cordic = sinus,cosinus
 2084: 1			;
 2085: 1			;*******************************************************************************
 2086: 1
 2087: 1			;*******************************************************************************
 2088: 1			;
 2089: 1			; bcdhex8     (45,77us @16.777216MHz)
 2090: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2091: 1			; naar een 2's complement hex getal.
 2092: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2093: 1			; een waarde 00h tot 63h.
 2094: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2095: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2096: 1			; input:      R0 = waarde tussen 00h en 99h.
 2097: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2098: 1			; output:     R0 = 2's complement waarde
 2099: 1			;             cy=1 bij out of range van r0
 2100: 1			;             cy=0 bij conversie ok
 2101: 1			; vernietigt: niets
 2102: 1			;*******************************************************************************
 2103: 1  0601	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2104: 1  0603	C0 D0		              push   psw
 2105: 1  0605	C0 F0		              push   b
 2106: 1
 2107: 1  0607	E8		              mov    a,r0                 ;neem te converteren waarde
 2108: 1  0608	F5 F0		              mov    b,a
 2109: 1  060A	54 0F		              anl    a,#0fh
 2110: 1  060C	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2111: 1  060F	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2112: 1  0611	E5 F0		              mov    a,b
 2113: 1  0613	54 F0		              anl    a,#0f0h
 2114: 1  0615	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2115: 1  0618	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2116: 1
 2117: 1  061A	E8		              mov    a,r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2118: 1  061B	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2119: 1  061D	C4		              swap   a
 2120: 1  061E	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2121: 1  0621	A4		              mul    ab
 2122: 1  0622	F5 F0		              mov    b,a                  ;bewaar dit product even
 2123: 1  0624	E8		              mov    a,r0
 2124: 1  0625	54 0F		              anl    a,#00fh
 2125: 1  0627	F8		              mov    r0,a
 2126: 1  0628	E5 F0		              mov    a,b
 2127: 1  062A	28		              add    a,r0                 ;eenheden er bijtellen
 2128: 1  062B	F8		              mov    r0,a
 2129: 1
 2130: 1  062C	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2131: 1  062E	12 07 2F	              lcall  magsig8              ;omzetten naar 2's complement
 2132: 1
 2133: 1  0631	D0 F0		              pop    b
 2134: 1  0633	D0 D0		              pop    psw
 2135: 1  0635	C2 D7		              clr    cy                   ;geen fout
 2136: 1  0637	D0 E0		              pop    acc
 2137: 1  0639	22		              ret
 2138: 1
 2139: 1  063A	D0 F0		bcdhex82:     pop    b
 2140: 1  063C	D0 D0		              pop    psw
 2141: 1  063E	D2 D7		              setb   cy                   ;fout! r0 out of range
 2142: 1  0640	D0 E0		              pop    acc
 2143: 1  0642	22		              ret
 2144: 1
 2145: 1			;*******************************************************************************
 2146: 1			;
 2147: 1			; hexbcd8     (38,4us @16.777216MHz)
 2148: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2149: 1			; naar een 8bit bcd getal.
 2150: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2151: 1			; bcdgetal van 00h tot +99h.
 2152: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2153: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2154: 1			; bcdgetal 00h tot -99h
 2155: 1			;
 2156: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2157: 1			;
 2158: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2159: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2160: 1			;             cy=1 bij out of range van r0
 2161: 1			;             cy=0 bij conversie ok
 2162: 1			; vernietigt: niets
 2163: 1			;*******************************************************************************
 2164: 1  0643	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2165: 1  0645	C0 D0		                push    psw
 2166: 1  0647	C0 F0		                push    b
 2167: 1  0649	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2168: 1  064A	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2169: 1  064D	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2170: 1  064F	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2171: 1  0652	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2172: 1  0654	D0 F0		                pop     b
 2173: 1  0656	D0 D0		                pop     psw             ;jammer maar helaas fout...

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2174: 1  0658	D3		                setb    c
 2175: 1  0659	D0 E0		                pop     acc
 2176: 1  065B	22		                ret
 2177: 1  065C	12 07 F7	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2178: 1  065F	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2179: 1  0660	75 F0 0A	                mov     b,#10
 2180: 1  0663	84		                div     ab
 2181: 1  0664	C4		                swap    a
 2182: 1  0665	25 F0		                add     a,b
 2183: 1  0667	F8		                mov     r0,a
 2184: 1  0668	D0 F0		                pop     b               ;registers herstellen
 2185: 1  066A	D0 E0		                pop     acc             ;psw van stack halen
 2186: 1  066C	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2187: 1  066E	92 E5		                mov     acc.5,c
 2188: 1  0670	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2189: 1  0672	C3		                clr     c               ;status: conversie ok
 2190: 1  0673	D0 E0		                pop     acc
 2191: 1  0675	22		                ret
 2192: 1
 2193: 1
 2194: 1
 2195: 1			;*******************************************************************************
 2196: 1			;
 2197: 1			; bcdhex16    (86,6us @16.777216MHz)
 2198: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2199: 1			; omzetten naar een 2's complement hex getal.
 2200: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2201: 1			; naareen waarde 0000h tot 270fh.
 2202: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2203: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2204: 1			; van -270fh).
 2205: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2206: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2207: 1			; output:     R1,R0 = 2's complement waarde
 2208: 1			;             cy=1 bij out of range van r1,r0
 2209: 1			;             cy=0 bij conversie ok
 2210: 1			; vernietigt: niets
 2211: 1			;*******************************************************************************
 2212: 1  0676	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2213: 1  0678	C0 D0		              push   psw
 2214: 1  067A	C0 F0		              push   b
 2215: 1
 2216: 1  067C	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2217: 1  067D	F5 F0		              mov    b,a
 2218: 1  067F	54 0F		              anl    a,#0fh
 2219: 1  0681	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2220: 1  0684	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2221: 1  0686	E5 F0		              mov    a,b
 2222: 1  0688	54 F0		              anl    a,#0f0h
 2223: 1  068A	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2224: 1  068D	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2225: 1  068F	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2226: 1  0690	F5 F0		              mov    b,a
 2227: 1  0692	54 0F		              anl    a,#0fh
 2228: 1  0694	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2229: 1  0697	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2230: 1  0699	E5 F0		              mov    a,b
 2231: 1  069B	54 F0		              anl    a,#0f0h
 2232: 1  069D	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2233: 1  06A0	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2234: 1
 2235: 1  06A2	E8		              mov    a,r0                  ;neem low byte voor conversie
 2236: 1  06A3	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2237: 1  06A5	C0 E0		              push   acc                   ;en even bewaren
 2238: 1
 2239: 1  06A7	E8		              mov    a,r0
 2240: 1  06A8	C4		              swap   a
 2241: 1  06A9	54 0F		              anl    a,#00fh              ;tientallen
 2242: 1  06AB	75 F0 0A	              mov    b,#00ah              ;maal tien
 2243: 1  06AE	A4		              mul    ab                   ;
 2244: 1  06AF	D0 F0		              pop    b                    ;neem eenheden
 2245: 1  06B1	25 F0		              add    a,b                  ;tel bij tientallen
 2246: 1  06B3	C0 E0		              push   acc                  ;weer bewaren
 2247: 1
 2248: 1  06B5	E9		              mov    a,r1                 ;neem high byte voor conversie
 2249: 1  06B6	54 F0		              anl    a,#0f0h
 2250: 1  06B8	C4		              swap   a
 2251: 1  06B9	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2252: 1
 2253: 1  06BB	E9		              mov    a,r1                  ;neem high byte voor conversie
 2254: 1  06BC	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2255: 1  06BE	75 F0 64	              mov    b,#100d              ;en maal honderd
 2256: 1  06C1	A4		              mul    ab
 2257: 1  06C2	A9 F0		              mov    r1,b
 2258: 1  06C4	F8		              mov    r0,a
 2259: 1
 2260: 1  06C5	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2261: 1  06C7	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2262: 1  06CA	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2263: 1  06CB	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2264: 1  06CE	A4		              mul    ab
 2265: 1  06CF	28		              add    a,r0                 ;tel honderdtallen bij de
 2266: 1  06D0	F8		              mov    r0,a                 ;duizendtallen
 2267: 1  06D1	E9		              mov    a,r1
 2268: 1  06D2	35 F0		              addc   a,b
 2269: 1  06D4	F9		              mov    r1,a
 2270: 1
 2271: 1  06D5	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2272: 1  06D7	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2273: 1  06D8	F8		              mov    r0,a                 ;duizendtallen
 2274: 1  06D9	74 00		              mov    a,#000h
 2275: 1  06DB	39		              addc   a,r1
 2276: 1  06DC	F9		              mov    r1,a                 ;omzetting klaar
 2277: 1
 2278: 1  06DD	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2279: 1  06DF	12 07 63	              lcall  magsig16             ;omzetten naar 2's complement
 2280: 1
 2281: 1  06E2	D0 F0		              pop    b
 2282: 1  06E4	D0 D0		              pop    psw
 2283: 1  06E6	C2 D7		              clr    cy                   ;geen fout
 2284: 1  06E8	D0 E0		              pop    acc
 2285: 1  06EA	22		              ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2286: 1
 2287: 1  06EB	D0 F0		bcdhex162:    pop    b
 2288: 1  06ED	D0 D0		              pop    psw
 2289: 1  06EF	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2290: 1  06F1	D0 E0		              pop    acc
 2291: 1  06F3	22		              ret
 2292: 1
 2293: 1			;*******************************************************************************
 2294: 1			;
 2295: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2296: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2297: 1			; naar een 24bit bcd getal.
 2298: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2299: 1			; bcdgetal van 000000h tot +032767h.
 2300: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2301: 1			; naar een bcdgetal 000000h tot -032768h
 2302: 1			;
 2303: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2304: 1			;
 2305: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2306: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2307: 1			;
 2308: 1			; vernietigt: niets
 2309: 1			;*******************************************************************************
 2310: 1			;
 2311: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2312: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2313: 1			; naar een 24bit bcd getal.
 2314: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2315: 1			; bcdgetal van 000000h tot 065535h.
 2316: 1			;
 2317: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2318: 1			;
 2319: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2320: 1			;
 2321: 1			; vernietigt: niets
 2322: 1			;*******************************************************************************
 2323: 1  06F4	12 08 29	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2324: 1  06F7	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2325: 1  06F9	C0 D0		                push   psw
 2326: 1  06FB	C0 F0		                push   b
 2327: 1  06FD	C0 82		                push   dpl
 2328: 1
 2329: 1  06FF	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2330: 1  0702	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2331: 1  0704	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2332: 1  0706	12 0B D8	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2333: 1  0709	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2334: 1  070A	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2335: 1			                                        ;dus eerst eenheden, dan tientallen
 2336: 1			                                        ;honderdtallen, duizendtallen en
 2337: 1			                                        ;tienduizendtallen
 2338: 1  070C	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2339: 1
 2340: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2341: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2342: 1  070F	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2343: 1  0711	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2344: 1  0712	D0 E0		                pop    acc              ;duizendtallen ophalen
 2345: 1  0714	C4		                swap   a                ;en combineren met de
 2346: 1  0715	F5 82		                mov    dpl,a
 2347: 1  0717	D0 E0		                pop    acc              ;honderdtallen van de stack
 2348: 1  0719	25 82		                add    a,dpl
 2349: 1  071B	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2350: 1  071C	D0 E0		                pop    acc              ;tientallen van de stack halen
 2351: 1  071E	C4		                swap   a
 2352: 1  071F	F5 82		                mov    dpl,a
 2353: 1  0721	D0 E0		                pop    acc              ;en combineren met de eenheden
 2354: 1  0723	25 82		                add    a,dpl
 2355: 1  0725	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2356: 1
 2357: 1  0726	D0 82		                pop    dpl              ;registers herstellen
 2358: 1  0728	D0 F0		                pop    b
 2359: 1  072A	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2360: 1  072C	D0 E0		                pop    acc
 2361: 1  072E	22		                ret
 2362: 1
 2363: 1			;*******************************************************************************
 2364: 1			; magsig8        (13,6us @16.777216MHz)
 2365: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2366: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2367: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2368: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2369: 1			;           (f0 en f1 zijn 1 als negatief)
 2370: 1			;
 2371: 1			; output:   r0 = 2's complement
 2372: 1			;
 2373: 1			; vernietigt: niets
 2374: 1			;*******************************************************************************
 2375: 1
 2376: 1  072F	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2377: 1  0731	C0 D0		               push   psw
 2378: 1  0733	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2379: 1  0736	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2380: 1  0739	80 09		               sjmp   magsig8c
 2381: 1
 2382: 1  073B	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2383: 1  073E	80 04		               sjmp   magsig8c
 2384: 1
 2385: 1  0740	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2386: 1  0741	F4		               cpl    a                  ;complementeer abs waarde
 2387: 1  0742	04		               inc    a                  ;r0 = complement(r0)+1
 2388: 1  0743	F8		               mov    r0,a               ;bewaar in 2's complement
 2389: 1  0744	D0 D0		magsig8c:      pop    psw
 2390: 1  0746	D0 E0		               pop    acc
 2391: 1  0748	22		               ret                        ;klaar
 2392: 1
 2393: 1			;*******************************************************************************
 2394: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2395: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2396: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2397: 1			; input:    r4 = acc1 absolute waarde (0..80h)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2398: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2399: 1			;           (f0 en f1 zijn 1 als negatief)
 2400: 1			;
 2401: 1			; output:   r4 = 2's complement
 2402: 1			;
 2403: 1			; vernietigt: niets
 2404: 1			;*******************************************************************************
 2405: 1
 2406: 1  0749	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2407: 1  074B	C0 D0		               push    psw
 2408: 1  074D	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2409: 1  0750	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2410: 1  0753	80 EF		               sjmp    magsig8c
 2411: 1
 2412: 1  0755	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2413: 1  0758	80 04		               sjmp    magsig8acc1c
 2414: 1
 2415: 1  075A	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2416: 1  075B	F4		               cpl     a                 ;complementeer abs waarde
 2417: 1  075C	04		               inc     a                 ;r4 = complement(r0)+1
 2418: 1  075D	FC		               mov     r4,a              ;bewaar in 2's complement
 2419: 1  075E	D0 D0		magsig8acc1c:  pop     psw
 2420: 1  0760	D0 E0		               pop     acc
 2421: 1  0762	22		               ret                       ;klaar
 2422: 1
 2423: 1			;*******************************************************************************
 2424: 1			; magsig16        (16,6us @16.777216MHz)
 2425: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2426: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2427: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2428: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2429: 1			;           (f0 en f1 zijn 1 als negatief)
 2430: 1			;
 2431: 1			; output:   r1,r0 = 2's complement
 2432: 1			;
 2433: 1			; vernietigt: niets
 2434: 1			;*******************************************************************************
 2435: 1  0763	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2436: 1  0765	C0 D0		               push    psw
 2437: 1  0767	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2438: 1  076A	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2439: 1  076D	80 0F		               sjmp    magsig16c
 2440: 1
 2441: 1  076F	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2442: 1  0772	80 0A		               sjmp    magsig16c
 2443: 1
 2444: 1  0774	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2445: 1  0775	F4		               cpl     a                ;complementeer het dan
 2446: 1  0776	24 01		               add     a, #1            ;en tel er 1 bij
 2447: 1  0778	F8		               mov     r0,a
 2448: 1  0779	E9		               mov     a,r1             ;neem volgende byte
 2449: 1  077A	F4		               cpl     a                ;complementeer en tel carry erbij
 2450: 1  077B	34 00		               addc    a,#0
 2451: 1  077D	F9		               mov     r1,a
 2452: 1  077E	D0 D0		magsig16c:     pop     psw
 2453: 1  0780	D0 E0		               pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2454: 1  0782	22		               ret
 2455: 1
 2456: 1			;*******************************************************************************
 2457: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2458: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2459: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2460: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2461: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2462: 1			;           (f0 en f1 zijn 1 als negatief)
 2463: 1			;
 2464: 1			; output:   r5,r4 = 2's complement
 2465: 1			;
 2466: 1			; vernietigt: niets
 2467: 1			;*******************************************************************************
 2468: 1  0783	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2469: 1  0785	C0 D0		                push    psw
 2470: 1  0787	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2471: 1  078A	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2472: 1  078D	80 0F		                sjmp    magsig16acc1c
 2473: 1
 2474: 1  078F	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2475: 1  0792	80 0A		                sjmp    magsig16acc1c
 2476: 1
 2477: 1  0794	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2478: 1  0795	F4		                cpl     a                   ;complementeer het dan
 2479: 1  0796	24 01		                add     a,#1                ;en tel er 1 bij
 2480: 1  0798	FC		                mov     r4,a
 2481: 1  0799	ED		                mov     a,r5                ;neem volgende byte
 2482: 1  079A	F4		                cpl     a                   ;complementeer en tel carry erbij
 2483: 1  079B	34 00		                addc    a,#0
 2484: 1  079D	FD		                mov     r5,a
 2485: 1  079E	D0 D0		magsig16acc1c:  pop     psw
 2486: 1  07A0	D0 E0		                pop     acc
 2487: 1  07A2	22		                ret
 2488: 1
 2489: 1			;*******************************************************************************
 2490: 1			; magsig32        (22,2us @16.777216MHz)
 2491: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2492: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2493: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2494: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2495: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2496: 1			;           (f0 en f1 zijn 1 als negatief)
 2497: 1			;
 2498: 1			; output:   r3,r2,r1,r0 = 2's complement
 2499: 1			;
 2500: 1			; vernietigt: niets
 2501: 1			;*******************************************************************************
 2502: 1  07A3	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2503: 1  07A5	C0 D0		               push    psw
 2504: 1  07A7	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2505: 1  07AA	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2506: 1  07AD	80 19		               sjmp    magsig32c
 2507: 1
 2508: 1  07AF	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2509: 1  07B2	80 14		               sjmp    magsig32c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2510: 1
 2511: 1  07B4	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2512: 1  07B5	F4		               cpl     a                 ;complementeer het dan
 2513: 1  07B6	24 01		               add     a,#1             ;en tel er 1 bij
 2514: 1  07B8	F8		               mov     r0,a
 2515: 1  07B9	E9		               mov     a,r1             ;neem volgende byte
 2516: 1  07BA	F4		               cpl     a                 ;complementeer en tel carry erbij
 2517: 1  07BB	34 00		               addc    a,#0
 2518: 1  07BD	F9		               mov     r1,a
 2519: 1  07BE	EA		               mov     a,r2            ;neem volgende byte
 2520: 1  07BF	F4		               cpl     a                ;complementeer en tel carry erbij
 2521: 1  07C0	34 00		               addc    a,#0
 2522: 1  07C2	FA		               mov     r2,a
 2523: 1  07C3	EB		               mov     a,r3            ;neem volgende byte
 2524: 1  07C4	F4		               cpl     a                ;complementeer en tel carry erbij
 2525: 1  07C5	34 00		               addc    a,#0
 2526: 1  07C7	FB		               mov     r3,a
 2527: 1
 2528: 1  07C8	D0 D0		magsig32c:     pop     psw
 2529: 1  07CA	D0 E0		               pop     acc
 2530: 1  07CC	22		               ret
 2531: 1
 2532: 1
 2533: 1
 2534: 1			;*******************************************************************************
 2535: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2536: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2537: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2538: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2539: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2540: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2541: 1			;           (f0 en f1 zijn 1 als negatief)
 2542: 1			;
 2543: 1			; output:   r7,r6,r5,r4 = 2's complement
 2544: 1			;
 2545: 1			; vernietigt: niets
 2546: 1			;*******************************************************************************
 2547: 1  07CD	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2548: 1  07CF	C0 D0		               push    psw
 2549: 1  07D1	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2550: 1  07D4	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2551: 1  07D7	80 19		               sjmp    magsig32acc1c
 2552: 1
 2553: 1  07D9	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2554: 1  07DC	80 14		               sjmp    magsig32acc1c
 2555: 1
 2556: 1  07DE	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2557: 1  07DF	F4		               cpl     a                 ;complementeer het dan
 2558: 1  07E0	24 01		               add     a,#1             ;en tel er 1 bij
 2559: 1  07E2	FC		               mov     r4,a
 2560: 1  07E3	ED		               mov     a,r5             ;neem volgende byte
 2561: 1  07E4	F4		               cpl     a                 ;complementeer en tel carry erbij
 2562: 1  07E5	34 00		               addc    a,#0
 2563: 1  07E7	FD		               mov     r5,a
 2564: 1  07E8	EE		               mov     a,r6             ;neem volgende byte
 2565: 1  07E9	F4		               cpl     a                 ;complementeer en tel carry erbij

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2566: 1  07EA	34 00		               addc    a,#0
 2567: 1  07EC	FE		               mov     r6,a
 2568: 1  07ED	EF		               mov     a,r7             ;neem volgende byte
 2569: 1  07EE	F4		               cpl     a                ;complementeer en tel carry erbij
 2570: 1  07EF	34 00		               addc    a,#0
 2571: 1  07F1	FF		               mov     r7,a
 2572: 1
 2573: 1  07F2	D0 D0		magsig32acc1c: pop     psw
 2574: 1  07F4	D0 E0		               pop     acc
 2575: 1  07F6	22		               ret
 2576: 1
 2577: 1
 2578: 1			;*******************************************************************************
 2579: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2580: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2581: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2582: 1			; input:     r0 = 2's complement byte in acc0
 2583: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2584: 1			; output:    r0 = absolute waarde
 2585: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2586: 1			;
 2587: 1			; vernietigt: niets
 2588: 1			;*******************************************************************************
 2589: 1
 2590: 1  07F7	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2591: 1  07F9	C0 D0		                push    psw
 2592: 1  07FB	E8		                mov     a,r0               ;neem lsb van acc0
 2593: 1  07FC	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2594: 1  07FF	D0 D0		                pop     psw
 2595: 1  0801	C2 D5		                clr     f0                 ;nee, positief...klaar
 2596: 1  0803	D0 E0		                pop     acc
 2597: 1  0805	22		                ret
 2598: 1  0806	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2599: 1  0807	04		                inc     a                   ;een erbij
 2600: 1  0808	F8		                mov     r0,a               ;bewaar
 2601: 1  0809	D0 D0		                pop     psw
 2602: 1  080B	D2 D5		                setb    f0                 ;f0=1 als negatief
 2603: 1  080D	D0 E0		                pop     acc
 2604: 1  080F	22		                ret
 2605: 1
 2606: 1			;*******************************************************************************
 2607: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2608: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2609: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2610: 1			; input:     r4 = 2's complement byte in acc1
 2611: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2612: 1			; output:    r4 = absolute waarde
 2613: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2614: 1			;
 2615: 1			; vernietigt: niets
 2616: 1			;*******************************************************************************
 2617: 1
 2618: 1  0810	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2619: 1  0812	C0 D0		                push    psw
 2620: 1  0814	EC		                mov     a,r4               ;neem lsb van acc0
 2621: 1  0815	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2622: 1  0818	D0 D0		                pop     psw
 2623: 1  081A	C2 D1		                clr     f1                 ;nee, positief...klaar
 2624: 1  081C	D0 E0		                pop     acc
 2625: 1  081E	22		                ret
 2626: 1  081F	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2627: 1  0820	04		                inc     a                   ;een erbij
 2628: 1  0821	FC		                mov     r4,a               ;bewaar
 2629: 1  0822	D0 D0		                pop     psw
 2630: 1  0824	D2 D1		                setb    f1                 ;f0=1 als negatief
 2631: 1  0826	D0 E0		                pop     acc
 2632: 1  0828	22		                ret
 2633: 1
 2634: 1			;*******************************************************************************
 2635: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2636: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2637: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2638: 1			; input:     r1,r0 = 2's complement word in acc0
 2639: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2640: 1			; output:    r1,r0 = absolute waarde
 2641: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2642: 1			;
 2643: 1			; vernietigt: niets
 2644: 1			;*******************************************************************************
 2645: 1
 2646: 1  0829	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2647: 1  082B	C0 D0		                push    psw
 2648: 1  082D	E9		                mov     a,r1               ; neem msb van acc0
 2649: 1  082E	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2650: 1  0831	D0 D0		                pop     psw
 2651: 1  0833	C2 D5		                clr     f0                 ;f0=0 als positief
 2652: 1  0835	D0 E0		                pop     acc
 2653: 1  0837	22		                ret                        ;klaar
 2654: 1
 2655: 1  0838	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2656: 1  0839	F4		                cpl     a                  ;complementeren
 2657: 1  083A	24 01		                add     a,#1               ;en een bijtellen
 2658: 1  083C	F8		                mov     r0,a
 2659: 1  083D	E9		                mov     a,r1
 2660: 1  083E	F4		                cpl     a                  ;complement eer volgende byte
 2661: 1  083F	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2662: 1  0841	F9		                mov     r1,a
 2663: 1  0842	D0 D0		                pop     psw
 2664: 1  0844	D2 D5		                setb    f0                 ;f0=1 als negatief
 2665: 1  0846	D0 E0		                pop     acc
 2666: 1  0848	22		                ret
 2667: 1
 2668: 1
 2669: 1			;*******************************************************************************
 2670: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2671: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2672: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2673: 1			; input:     r5,r4 = 2's complement word in acc1
 2674: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2675: 1			; output:    r5,r4 = absolute waarde
 2676: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2677: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2678: 1			; vernietigt: niets
 2679: 1			;*******************************************************************************
 2680: 1
 2681: 1  0849	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2682: 1  084B	C0 D0		                push    psw
 2683: 1  084D	ED		                mov     a,r5               ;neem msb van acc1
 2684: 1  084E	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2685: 1  0851	D0 D0		                pop     psw
 2686: 1  0853	C2 D1		                clr     f1                 ;f1=0 als positief
 2687: 1  0855	D0 E0		                pop    acc
 2688: 1  0857	22		                ret                        ;klaar
 2689: 1
 2690: 1  0858	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2691: 1  0859	F4		                cpl     a                   ;complementeren
 2692: 1  085A	24 01		                add     a,#1               ;en een bijtellen
 2693: 1  085C	FC		                mov     r4,a
 2694: 1  085D	ED		                mov     a,r5
 2695: 1  085E	F4		                cpl     a                  ;complementeer volgende byte
 2696: 1  085F	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2697: 1  0861	FD		                mov     r5,a
 2698: 1  0862	D0 D0		                pop     psw
 2699: 1  0864	D2 D1		                setb    f1                ;f1=1 als negatief
 2700: 1  0866	D0 E0		                pop     acc
 2701: 1  0868	22		                ret
 2702: 1
 2703: 1
 2704: 1			;*******************************************************************************
 2705: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2706: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2707: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2708: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2709: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2710: 1			; output:    r7,r6 = absolute waarde
 2711: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2712: 1			;
 2713: 1			; vernietigt: niets
 2714: 1			;*******************************************************************************
 2715: 1
 2716: 1  0869	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2717: 1  086B	C0 D0		                push    psw
 2718: 1  086D	EF		                mov     a,r7                ; neem msb van acc1 high
 2719: 1  086E	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2720: 1  0871	D0 D0		                pop     psw
 2721: 1  0873	C2 D5		                clr     f0                  ;f0=0 als positief
 2722: 1  0875	D0 E0		                pop     acc
 2723: 1  0877	22		                ret                         ;klaar
 2724: 1
 2725: 1  0878	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2726: 1  0879	F4		                cpl     a                   ;complementeren
 2727: 1  087A	24 01		                add     a,#1               ;en een bijtellen
 2728: 1  087C	FE		                mov     r6,a
 2729: 1  087D	EF		                mov     a,r7
 2730: 1  087E	F4		                cpl     a                  ;complementeer volgende byte
 2731: 1  087F	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2732: 1  0881	FF		                mov     r7,a
 2733: 1  0882	D0 D0		                pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2734: 1  0884	D2 D5		                setb    f0                ;f0=1 als negatief
 2735: 1  0886	D0 E0		                pop     acc
 2736: 1  0888	22		                ret
 2737: 1
 2738: 1
 2739: 1			;*******************************************************************************
 2740: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2741: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2742: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 2743: 1			;
 2744: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2745: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2746: 1			;            (-2147483648 tot +2147483647)
 2747: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2748: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2749: 1			;
 2750: 1			; vernietigt: niets
 2751: 1			;*******************************************************************************
 2752: 1
 2753: 1  0889	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2754: 1  088B	C0 D0		                push    psw
 2755: 1  088D	EB		                mov     a,r3               ;neem msb van acc0
 2756: 1  088E	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2757: 1  0891	D0 D0		                pop     psw                ;nee, positief
 2758: 1  0893	C2 D5		                clr     f0
 2759: 1  0895	D0 E0		                pop     acc
 2760: 1  0897	22		                ret                        ;klaar
 2761: 1
 2762: 1  0898	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2763: 1  0899	F4		                cpl     a                  ;complementeren
 2764: 1  089A	24 01		                add     a,#1               ;en een bijtellen
 2765: 1  089C	F8		                mov     r0,a
 2766: 1  089D	E9		                mov     a,r1               ;neem volgende byte
 2767: 1  089E	F4		                cpl     a                  ;complementeer volgende byte
 2768: 1  089F	34 00		                addc    a,#0
 2769: 1  08A1	F9		                mov     r1,a
 2770: 1  08A2	EA		                mov     a,r2               ;neem volgende byte
 2771: 1  08A3	F4		                cpl     a                  ;complementeer volgende byte
 2772: 1  08A4	34 00		                addc    a,#0
 2773: 1  08A6	FA		                mov     r2,a
 2774: 1  08A7	EB		                mov     a,r3               ;neem volgende byte
 2775: 1  08A8	F4		                cpl     a                  ;complementeer volgende byte
 2776: 1  08A9	34 00		                addc    a,#0
 2777: 1  08AB	FB		                mov     r3,a
 2778: 1  08AC	D0 D0		                pop     psw
 2779: 1  08AE	D2 D5		                setb    f0                 ;negatief: f0=1
 2780: 1  08B0	D0 E0		                pop     acc
 2781: 1  08B2	22		                ret                        ;klaar
 2782: 1
 2783: 1			;*******************************************************************************
 2784: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2785: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2786: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2787: 1			;
 2788: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2789: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2790: 1			;            (-2147483648 tot +2147483647)
 2791: 1			; output:    r7,r6,r5,r4 = absolute waarde
 2792: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2793: 1			;
 2794: 1			; vernietigt: niets
 2795: 1			;*******************************************************************************
 2796: 1
 2797: 1  08B3	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2798: 1  08B5	C0 D0		                push    psw
 2799: 1  08B7	EF		                mov     a,r7               ;neem msb van acc0
 2800: 1  08B8	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2801: 1  08BB	D0 D0		                pop     psw                ;nee, positief
 2802: 1  08BD	C2 D1		                clr     f1
 2803: 1  08BF	D0 E0		                pop     acc
 2804: 1  08C1	22		                ret                        ;klaar
 2805: 1
 2806: 1  08C2	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2807: 1  08C3	F4		                cpl     a                   ;complementeren
 2808: 1  08C4	24 01		                add     a,#1               ;en een bijtellen
 2809: 1  08C6	FC		                mov     r4,a
 2810: 1  08C7	ED		                mov     a,r5               ;neem volgende byte
 2811: 1  08C8	F4		                cpl     a                  ;complementeer volgende byte
 2812: 1  08C9	34 00		                addc    a,#0
 2813: 1  08CB	FD		                mov     r5,a
 2814: 1  08CC	EE		                mov     a,r6               ;neem volgende byte
 2815: 1  08CD	F4		                cpl     a                  ;complementeer volgende byte
 2816: 1  08CE	34 00		                addc    a,#0
 2817: 1  08D0	FE		                mov     r6,a
 2818: 1  08D1	EF		                mov     a,r7               ;neem volgende byte
 2819: 1  08D2	F4		                cpl     a                  ;complementeer volgende byte
 2820: 1  08D3	34 00		                addc    a,#0
 2821: 1  08D5	FF		                mov     r7,a
 2822: 1  08D6	D0 D0		                pop     psw
 2823: 1  08D8	D2 D1		                setb    f1                 ;negatief: f0=1
 2824: 1  08DA	D0 E0		                pop     acc
 2825: 1  08DC	22		                ret                        ;klaar
 2826: 1
 2827: 1
 2828: 1			;*******************************************************************************
 2829: 1			; s_add16        (19,35us @16.777216MHz)
 2830: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2831: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2832: 1			; input:     r1,r0 = acc0
 2833: 1			;            r5,r4 = acc1
 2834: 1			;
 2835: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2836: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2837: 1			;                  gebruik van r3,r2 is niet nodig
 2838: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2839: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2840: 1			;
 2841: 1			; vernietigt:  niets
 2842: 1			;*******************************************************************************
 2843: 1  08DD	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2844: 1  08DF	C0 D0		               push    psw
 2845: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2846: 1  08E1	E8		               mov     a,r0           ;tel de soft accumulators op
 2847: 1  08E2	2C		               add     a,r4           ;low byte eerst
 2848: 1  08E3	F8		               mov     r0,a           ;resultaat bewaren
 2849: 1  08E4	E9		               mov     a,r1           ;nu de high bytes
 2850: 1  08E5	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2851: 1  08E6	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2852: 1
 2853: 1  08E7	92 D5		               mov     f0,c
 2854: 1  08E9	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 2855: 1  08EB	92 D1		               mov     f1,c
 2856: 1  08ED	A2 D5		               mov     c,f0           ;herstel carrybit
 2857: 1
 2858: 1  08EF	74 00		               mov     a,#00h
 2859: 1  08F1	34 00		               addc    a,#00h
 2860: 1  08F3	FA		               mov     r2,a            ;24bit resultaat klaar
 2861: 1
 2862: 1  08F4	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2863: 1
 2864: 1  08F7	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2865: 1  08F8	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2866: 1  08FB	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 2867: 1  08FD	7B FF		               mov     r3,#0ffh
 2868: 1  08FF	80 04		               sjmp    s_add162
 2869: 1  0901	7A 00		s_add161:      mov     r2,#00h
 2870: 1  0903	7B 00		               mov     r3,#00h
 2871: 1  0905	D0 D0		s_add162:      pop     psw
 2872: 1  0907	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2873: 1  0908	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2874: 1  090A	22		               ret
 2875: 1
 2876: 1  090B	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2877: 1  090D	C3		               clr     c
 2878: 1  090E	D0 E0		               pop     acc
 2879: 1  0910	22		               ret
 2880: 1
 2881: 1			;*******************************************************************************
 2882: 1			; add16        (13,6us @16.777216MHz)
 2883: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2884: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2885: 1			; input:     r1,r0 = acc0
 2886: 1			;            r5,r4 = acc1
 2887: 1			;
 2888: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2889: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 2890: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2891: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 2892: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 2893: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 2894: 1			;
 2895: 1			; vernietigt:  niets
 2896: 1			;*******************************************************************************
 2897: 1
 2898: 1  0911	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 2899: 1  0913	C0 D0		               push    psw
 2900: 1  0915	E8		               mov     a,r0           ;tel de soft accumulators op
 2901: 1  0916	2C		               add     a,r4           ;low byte eerst

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2902: 1  0917	F8		               mov     r0,a           ;resultaat bewaren
 2903: 1  0918	E9		               mov     a,r1           ;nu de high bytes
 2904: 1  0919	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2905: 1  091A	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2906: 1  091B	50 08		               jnc     add161          ;geen 24 bit resultaat
 2907: 1
 2908: 1  091D	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 2909: 1  091F	D0 D0		               pop     psw
 2910: 1  0921	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2911: 1  0922	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 2912: 1  0924	22		               ret
 2913: 1
 2914: 1  0925	7A 00		add161:        mov     r2,#00h
 2915: 1  0927	D0 D0		               pop     psw
 2916: 1  0929	C3		               clr     c               ;aangeven aan de gebruiker dat het
 2917: 1  092A	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 2918: 1  092C	22		               ret
 2919: 1
 2920: 1			;*******************************************************************************
 2921: 1			; s_add32        (28,0us @16.777216MHz)
 2922: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2923: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 2924: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2925: 1			; input:     r3,r2,r1,r0 = acc0
 2926: 1			;            r7,r6,r5,r4 = acc1
 2927: 1			;
 2928: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2929: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2930: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 2931: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 2932: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 2933: 1			;
 2934: 1			; vernietigt:  niets
 2935: 1			;*******************************************************************************
 2936: 1  092D	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 2937: 1  092F	C0 D0		               push    psw
 2938: 1
 2939: 1  0931	E8		               mov     a,r0           ;tel de soft accumulators op
 2940: 1  0932	2C		               add     a,r4           ;low byte eerst
 2941: 1  0933	F8		               mov     r0,a           ;resultaat bewaren
 2942: 1  0934	E9		               mov     a,r1           ;nu de hogere bytes
 2943: 1  0935	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2944: 1  0936	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2945: 1
 2946: 1  0937	EA		               mov     a,r2           ;derde bytes optellen
 2947: 1  0938	3E		               addc    a,r6           ;optellen met eventuele overdracht
 2948: 1  0939	FA		               mov     r2,a           ;24bit resultaat is klaar
 2949: 1  093A	EB		               mov     a,r3           ;nu de ms bytes
 2950: 1  093B	3F		               addc    a,r7           ;optellen met eventuele overdracht
 2951: 1  093C	FB		               mov     r3,a           ;32 bit resultaat is klaar
 2952: 1
 2953: 1  093D	92 D5		               mov     f0,c
 2954: 1  093F	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 2955: 1  0941	92 D1		               mov     f1,c
 2956: 1  0943	A2 D5		               mov     c,f0           ;herstel carrybit
 2957: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2958: 1  0945	74 00		               mov     a,#00h
 2959: 1  0947	34 00		               addc    a,#00h
 2960: 1  0949	FC		               mov     r4,a            ;40bit resultaat klaar
 2961: 1
 2962: 1  094A	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 2963: 1  094D	EC		               mov     a,r4            ;ja, sign extention toepassen!
 2964: 1  094E	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 2965: 1  0951	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 2966: 1  0953	80 02		               sjmp    s_add322
 2967: 1  0955	7C 00		s_add321:      mov     r4,#00h
 2968: 1  0957	D0 D0		s_add322:      pop     psw
 2969: 1  0959	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2970: 1  095A	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 2971: 1  095C	22		               ret
 2972: 1
 2973: 1  095D	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 2974: 1  095F	C3		               clr     c
 2975: 1  0960	D0 E0		               pop     acc
 2976: 1  0962	22		               ret
 2977: 1
 2978: 1
 2979: 1			;*******************************************************************************
 2980: 1			; add32        (18,0us @16.777216MHz)
 2981: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 2982: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 2983: 1			; input:     r3,r2,r1,r0 = acc0
 2984: 1			;            r7,r6,r5,r4 = acc1
 2985: 1			;
 2986: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 2987: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 2988: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2989: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 2990: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 2991: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 2992: 1			;
 2993: 1			; vernietigt:  niets
 2994: 1			;*******************************************************************************
 2995: 1  0963	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 2996: 1  0965	C0 D0		               push    psw
 2997: 1  0967	E8		               mov     a,r0           ;tel de soft accumulators op
 2998: 1  0968	2C		               add     a,r4           ;low byte eerst
 2999: 1  0969	F8		               mov     r0,a           ;resultaat bewaren
 3000: 1  096A	E9		               mov     a,r1           ;nu de hogere bytes
 3001: 1  096B	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3002: 1  096C	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3003: 1
 3004: 1  096D	EA		               mov     a,r2           ;derde bytes optellen
 3005: 1  096E	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3006: 1  096F	FA		               mov     r2,a           ;24bit resultaat is klaar
 3007: 1  0970	EB		               mov     a,r3           ;nu de ms bytes
 3008: 1  0971	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3009: 1  0972	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3010: 1
 3011: 1  0973	50 08		               jnc     add321          ;geen 40 bit resultaat
 3012: 1
 3013: 1  0975	7C 01		               mov     r4,#01h         ;40bit resultaat klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3014: 1  0977	D0 D0		               pop     psw
 3015: 1  0979	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3016: 1  097A	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3017: 1  097C	22		               ret
 3018: 1
 3019: 1  097D	7C 00		add321:        mov     r4,#00h
 3020: 1  097F	D0 D0		               pop     psw
 3021: 1  0981	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3022: 1  0982	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3023: 1  0984	22		               ret
 3024: 1
 3025: 1
 3026: 1			;*******************************************************************************
 3027: 1			; s_sub16        (24,4us @16.777216MHz)
 3028: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3029: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3030: 1			; input:     r1,r0 = acc0
 3031: 1			;            r5,r4 = acc1
 3032: 1			;
 3033: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3034: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3035: 1			;                  gebruik van r3,r2 is niet nodig
 3036: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3037: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3038: 1			;
 3039: 1			; vernietigt:  niets
 3040: 1			;*******************************************************************************
 3041: 1  0985	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3042: 1  0987	C0 D0		                push    psw
 3043: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3044: 1
 3045: 1  0989	EC		                mov   	a,r4            ;verander het teken van acc1
 3046: 1  098A	F4		                cpl    	a               ;door het 2's complement te nemen
 3047: 1  098B	24 01		                add   	a,#1
 3048: 1  098D	FC		                mov    	r4,a
 3049: 1  098E	ED		                mov    	a,r5
 3050: 1  098F	F4		                cpl    	a
 3051: 1  0990	34 00		                addc	a,#0
 3052: 1  0992	FD		                mov    	r5,a
 3053: 1			;acc0+acc1
 3054: 1  0993	E8						mov		a,r0
 3055: 1  0994	2C						add		a,r4
 3056: 1  0995	F8						mov		r0,a
 3057: 1  0996	E9						mov		a,r1
 3058: 1  0997	3D						addc	a,r5
 3059: 1  0998	F9						mov		r1,a
 3060: 1
 3061: 1  0999	92 D5		                mov    f0,c
 3062: 1  099B	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3063: 1  099D	92 D1		                mov    f1,c
 3064: 1  099F	A2 D5		                mov    c,f0            ;herstel carrybit
 3065: 1
 3066: 1  09A1	74 00		                mov    a,#00h
 3067: 1  09A3	34 00		                addc   a,#00h
 3068: 1  09A5	FA		                mov    r2,a            ;24bit resultaat klaar
 3069: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3070: 1  09A6	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3071: 1  09A9	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3072: 1  09AA	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3073: 1  09AD	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3074: 1  09AF	7B FF		                mov    r3,#0ffh
 3075: 1  09B1	80 04		                sjmp   s_sub162
 3076: 1  09B3	7A 00		s_sub161:       mov    r2,#00h
 3077: 1  09B5	7B 00		                mov    r3,#00h
 3078: 1  09B7	D0 D0		s_sub162:       pop    psw
 3079: 1  09B9	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3080: 1  09BA	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3081: 1  09BC	22		                ret
 3082: 1
 3083: 1  09BD	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3084: 1  09BF	C3		                clr    c
 3085: 1  09C0	D0 E0		                pop    acc
 3086: 1  09C2	22		                ret
 3087: 1
 3088: 1			;*******************************************************************************
 3089: 1			; sub16            (14,4us @16.777216MHz)
 3090: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3091: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3092: 1			; input:     r1,r0 = acc0
 3093: 1			;            r5,r4 = acc1
 3094: 1			;
 3095: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3096: 1			;            bij een underflow r2 op ffh zetten
 3097: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3098: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3099: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3100: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3101: 1			;
 3102: 1			; vernietigt:  niets
 3103: 1			;*******************************************************************************
 3104: 1
 3105: 1  09C3	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3106: 1  09C5	C0 D0		                push    psw
 3107: 1  09C7	C3		                clr     c
 3108: 1  09C8	E8		                mov     a,r0            ;tel de soft accumulators op
 3109: 1  09C9	9C		                subb    a,r4            ;low byte eerst
 3110: 1  09CA	F8		                mov     r0,a            ;resultaat bewaren
 3111: 1  09CB	E9		                mov     a,r1            ;nu de high bytes
 3112: 1  09CC	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3113: 1  09CD	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3114: 1  09CE	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3115: 1
 3116: 1  09D0	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3117: 1  09D2	D0 D0		                pop     psw
 3118: 1  09D4	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3119: 1  09D5	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3120: 1  09D7	22		                ret
 3121: 1
 3122: 1  09D8	7A 00		sub161:         mov     r2,#00h
 3123: 1  09DA	D0 D0		                pop     psw
 3124: 1  09DC	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3125: 1  09DD	D0 E0		                pop     acc             ;resultaat 16 bits groot is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3126: 1  09DF	22		                ret
 3127: 1
 3128: 1			;*******************************************************************************
 3129: 1			; s_sub32        (27,2us @16.777216MHz)
 3130: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3131: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3132: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3133: 1			; input:     r3,r2,r1,r0 = acc0
 3134: 1			;            r7,r6,r5,r4 = acc1
 3135: 1			;
 3136: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3137: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3138: 1			;                  gebruik van r4 is niet nodig
 3139: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3140: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3141: 1			;
 3142: 1			; vernietigt:  niets
 3143: 1			;*******************************************************************************
 3144: 1  09E0	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3145: 1  09E2	C0 D0		                push   psw
 3146: 1
 3147: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3148: 1
 3149: 1  09E4	EC		                mov    	a,r4            ;verander het teken van acc1
 3150: 1  09E5	F4		                cpl    	a               ;door het 2's complement te nemen
 3151: 1  09E6	24 01		                add    	a,#1
 3152: 1  09E8	FC		                mov    	r4,a
 3153: 1  09E9	ED		                mov    	a,r5
 3154: 1  09EA	F4		                cpl    	a
 3155: 1  09EB	34 00		                addc	a,#0
 3156: 1  09ED	FD		                mov    	r5,a
 3157: 1  09EE	EE		                mov    	a,r6
 3158: 1  09EF	F4		                cpl    	a
 3159: 1  09F0	34 00		                addc   	a,#0
 3160: 1  09F2	FE		                mov    	r6,a
 3161: 1  09F3	EF		                mov    	a,r7
 3162: 1  09F4	F4		                cpl    	a
 3163: 1  09F5	34 00		                addc   	a,#0
 3164: 1  09F7	FF		                mov    	r7,a
 3165: 1			;acc0+acc1
 3166: 1  09F8	E8						mov		a,r0
 3167: 1  09F9	2C						add		a,r4
 3168: 1  09FA	F8						mov		r0,a
 3169: 1  09FB	E9						mov		a,r1
 3170: 1  09FC	3D						addc	a,r5
 3171: 1  09FD	F9						mov		r1,a
 3172: 1  09FE	EA						mov		a,r2
 3173: 1  09FF	3E						addc	a,r6
 3174: 1  0A00	FA						mov		r2,a
 3175: 1  0A01	EB						mov		a,r3
 3176: 1  0A02	3F						addc	a,r7
 3177: 1  0A03	FB						mov		r3,a
 3178: 1
 3179: 1  0A04	92 D5		                mov   f0,c
 3180: 1  0A06	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3181: 1  0A08	92 D1		                mov   f1,c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3182: 1  0A0A	A2 D5		                mov   c,f0            ;herstel carrybit
 3183: 1
 3184: 1  0A0C	74 00		                mov   a,#00h
 3185: 1  0A0E	34 00		                addc  a,#00h
 3186: 1  0A10	FC		                mov   r4,a            ;40bit resultaat klaar
 3187: 1
 3188: 1  0A11	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3189: 1
 3190: 1  0A14	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3191: 1  0A15	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3192: 1  0A18	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3193: 1  0A1A	80 02		                sjmp   s_sub322
 3194: 1  0A1C	7C 00		s_sub321:       mov   r4,#00h
 3195: 1  0A1E	D0 D0		s_sub322:       pop   psw
 3196: 1  0A20	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3197: 1  0A21	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3198: 1  0A23	22		                ret
 3199: 1
 3200: 1  0A24	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3201: 1  0A26	C3		                clr   c
 3202: 1  0A27	D0 E0		                pop   acc
 3203: 1  0A29	22		                ret
 3204: 1
 3205: 1
 3206: 1			;*******************************************************************************
 3207: 1			; sub32        (18,7us @16.777216MHz)
 3208: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3209: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3210: 1			; input:     r3,r2,r1,r0 = acc0
 3211: 1			;            r7,r6,r5,r4 = acc1
 3212: 1			;
 3213: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3214: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3215: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3216: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3217: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3218: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3219: 1			;
 3220: 1			; vernietigt:  niets
 3221: 1			;*******************************************************************************
 3222: 1  0A2A	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3223: 1  0A2C	C0 D0		               push    psw
 3224: 1  0A2E	C3		               clr       c
 3225: 1  0A2F	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3226: 1  0A30	9C		               subb    a,r4           ;low byte eerst
 3227: 1  0A31	F8		               mov     r0,a           ;resultaat bewaren
 3228: 1  0A32	E9		               mov     a,r1           ;nu de hogere bytes
 3229: 1  0A33	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3230: 1  0A34	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3231: 1
 3232: 1  0A35	EA		               mov     a,r2           ;derde bytes optellen
 3233: 1  0A36	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3234: 1  0A37	FA		               mov     r2,a           ;24bit resultaat is klaar
 3235: 1  0A38	EB		               mov     a,r3           ;nu de ms bytes
 3236: 1  0A39	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3237: 1  0A3A	FB		               mov     r3,a           ;32 bit resultaat is klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3238: 1
 3239: 1  0A3B	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3240: 1
 3241: 1  0A3D	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3242: 1  0A3F	D0 D0		               pop     psw
 3243: 1  0A41	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3244: 1  0A42	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3245: 1  0A44	22		               ret
 3246: 1
 3247: 1  0A45	7C 00		sub321:        mov     r4,#00h
 3248: 1  0A47	D0 D0		               pop     psw
 3249: 1  0A49	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3250: 1  0A4A	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3251: 1  0A4C	22		               ret
 3252: 1
 3253: 1
 3254: 1
 3255: 1			;*******************************************************************************
 3256: 1			; mul16        (71,2us @16.777216MHz)
 3257: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3258: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3259: 1			; input:     r1,r0 = acc0
 3260: 1			;            r5,r4 = acc1
 3261: 1			;
 3262: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3263: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3264: 1			;
 3265: 1			; vernietigt:  niets
 3266: 1			;*******************************************************************************
 3267: 1  0A4D	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3268: 1  0A4F	C0 D0		                push    psw
 3269: 1  0A51	C0 F0		                push    b
 3270: 1  0A53	C0 82		                push    dpl
 3271: 1  0A55	C0 83		                push    dph
 3272: 1
 3273: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3274: 1
 3275: 1  0A57	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3276: 1  0A59	89 83		                mov     dph,r1
 3277: 1  0A5B	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3278: 1  0A5D	08		                inc     r0              ;pointer naar eerste vrije plaats
 3279: 1  0A5E	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3280: 1  0A60	E5 81		                mov     a,sp            ;plaats alloceren
 3281: 1  0A62	24 03		                add     a,#3            ;3 bytes nodig
 3282: 1  0A64	F5 81		                mov     sp,a            ;stackpointer verzetten
 3283: 1
 3284: 1  0A66	E5 82		                mov     a,dpl            ;acc0 lsb
 3285: 1  0A68	8C F0		                mov     b,r4            ;acc1 lsb
 3286: 1  0A6A	A4		                mul     ab
 3287: 1  0A6B	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3288: 1  0A6C	08		                inc     r0
 3289: 1  0A6D	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3290: 1
 3291: 1  0A6F	E5 83		                mov     a,dph            ;acc0 msb
 3292: 1  0A71	8C F0		                mov     b,r4            ;acc1 lsb
 3293: 1  0A73	A4		                mul     ab

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3294: 1
 3295: 1  0A74	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3296: 1  0A75	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3297: 1  0A76	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3298: 1  0A78	34 00		                addc    a,#0
 3299: 1  0A7A	08		                inc     r0               ;bewaar als tussenresultaat
 3300: 1  0A7B	F6		                mov     @r0,a
 3301: 1
 3302: 1  0A7C	E5 82		                mov     a,dpl            ;acc0 lsb
 3303: 1  0A7E	8D F0		                mov     b,r5             ;acc1 msb
 3304: 1  0A80	A4		                mul     ab
 3305: 1  0A81	18		                dec     r0
 3306: 1  0A82	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3307: 1  0A83	F6		                mov     @r0,a            ;en bewaar weer
 3308: 1  0A84	08		                inc     r0
 3309: 1  0A85	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3310: 1  0A87	36		                addc    a,@r0
 3311: 1  0A88	F6		                mov     @r0,a            ;en bewaar weer
 3312: 1  0A89	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3313: 1
 3314: 1  0A8B	E5 83		                mov     a,dph            ;acc0 msb
 3315: 1  0A8D	8D F0		                mov     b,r5             ;acc1 msb
 3316: 1  0A8F	A4		                mul     AB
 3317: 1  0A90	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3318: 1  0A91	FA		                mov     r2,a
 3319: 1  0A92	E5 F0		                mov     a,b
 3320: 1  0A94	34 00		                addc    a,#0
 3321: 1
 3322: 1  0A96	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3323: 1  0A98	34 00		                addc    a,#0
 3324: 1
 3325: 1  0A9A	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3326: 1  0A9B	18		                dec     r0
 3327: 1  0A9C	86 83		                mov     dph,@r0
 3328: 1  0A9E	18		                dec     r0
 3329: 1  0A9F	86 82		                mov     dpl,@r0
 3330: 1
 3331: 1  0AA1	89 81		                mov     sp,r1            ;zet stackpointer terug
 3332: 1  0AA3	A9 83		                mov     r1,dph
 3333: 1  0AA5	A8 82		                mov     r0,dpl
 3334: 1
 3335: 1  0AA7	D0 83		                pop     dph              ;herstel de bewaarde registers
 3336: 1  0AA9	D0 82		                pop     dpl
 3337: 1  0AAB	D0 F0		                pop     b
 3338: 1  0AAD	D0 D0		                pop     psw
 3339: 1  0AAF	D0 E0		                pop     acc
 3340: 1  0AB1	22		                ret
 3341: 1
 3342: 1
 3343: 1
 3344: 1			;*******************************************************************************
 3345: 1			; mul16acc1        (71,2us @16.777216MHz)
 3346: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3347: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3348: 1			; input:     r5,r4 = acc1 low
 3349: 1			;            r7,r6 = acc1 high

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3350: 1			;
 3351: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3352: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3353: 1			;
 3354: 1			; vernietigt:  niets
 3355: 1			;*******************************************************************************
 3356: 1  0AB2	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3357: 1  0AB4	C0 D0		                push    psw
 3358: 1  0AB6	C0 F0		                push    b
 3359: 1  0AB8	C0 82		                push    dpl
 3360: 1  0ABA	C0 83		                push    dph
 3361: 1
 3362: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3363: 1
 3364: 1  0ABC	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3365: 1  0ABE	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3366: 1
 3367: 1  0AC0	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3368: 1  0AC2	08		                inc     r0               ;pointer naar eerste vrije plaats
 3369: 1  0AC3	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3370: 1  0AC5	E5 81		                mov     a,sp             ;plaats alloceren
 3371: 1  0AC7	24 03		                add     a,#3             ;3 bytes nodig
 3372: 1  0AC9	F5 81		                mov     sp,a             ;stackpointer verzetten
 3373: 1
 3374: 1  0ACB	EC		                mov     a,r4             ;acc1 low lsb
 3375: 1  0ACC	8E F0		                mov     b,r6             ;acc1 high lsb
 3376: 1  0ACE	A4		                mul     ab
 3377: 1  0ACF	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3378: 1  0AD0	08		                inc     r0
 3379: 1  0AD1	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3380: 1
 3381: 1  0AD3	ED		                mov     a,r5             ;acc1 low msb
 3382: 1  0AD4	8E F0		                mov     b,r6             ;acc1 high lsb
 3383: 1  0AD6	A4		                mul     ab
 3384: 1
 3385: 1  0AD7	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3386: 1  0AD8	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3387: 1  0AD9	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3388: 1  0ADB	34 00		                addc    a,#0
 3389: 1  0ADD	08		                inc     r0               ;bewaar als tussenresultaat
 3390: 1  0ADE	F6		                mov     @r0,a
 3391: 1
 3392: 1  0ADF	EC		                mov     a,r4             ;acc1 low lsb
 3393: 1  0AE0	8F F0		                mov     b,r7             ;acc1 high msb
 3394: 1  0AE2	A4		                mul     ab
 3395: 1  0AE3	18		                dec     r0
 3396: 1  0AE4	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3397: 1  0AE5	F6		                mov     @r0,a            ;en bewaar weer
 3398: 1  0AE6	08		                inc     r0
 3399: 1  0AE7	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3400: 1  0AE9	36		                addc    a,@r0
 3401: 1  0AEA	F6		                mov     @r0,a            ;en bewaar weer
 3402: 1  0AEB	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3403: 1
 3404: 1  0AED	ED		                mov     a,r5             ;acc1 low msb
 3405: 1  0AEE	8F F0		                mov     b,r7             ;acc1 high msb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3406: 1  0AF0	A4		                mul     AB
 3407: 1
 3408: 1  0AF1	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3409: 1  0AF2	FE		                mov     r6,a             ;deze byte van product is al klaar
 3410: 1  0AF3	E5 F0		                mov     a,b
 3411: 1  0AF5	34 00		                addc    a,#0
 3412: 1  0AF7	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3413: 1  0AF9	34 00		                addc    a,#0
 3414: 1
 3415: 1  0AFB	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3416: 1  0AFC	18		                dec     r0
 3417: 1  0AFD	E6		                mov     a,@r0
 3418: 1  0AFE	FD		                mov     r5,a
 3419: 1  0AFF	18		                dec     r0
 3420: 1  0B00	E6		                mov     a,@r0
 3421: 1  0B01	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3422: 1
 3423: 1  0B02	89 81		                mov     sp,r1            ;zet stackpointer terug
 3424: 1  0B04	A9 83		                mov     r1,dph
 3425: 1  0B06	A8 82		                mov     r0,dpl
 3426: 1
 3427: 1  0B08	D0 83		                pop     dph              ;herstel de bewaarde registers
 3428: 1  0B0A	D0 82		                pop     dpl
 3429: 1  0B0C	D0 F0		                pop     b
 3430: 1  0B0E	D0 D0		                pop     psw
 3431: 1  0B10	D0 E0		                pop     acc
 3432: 1  0B12	22		                ret
 3433: 1
 3434: 1			;*******************************************************************************
 3435: 1			; s_mul16        (121,1us @16.777216MHz)
 3436: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3437: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3438: 1			; input:     r1,r0 = acc0
 3439: 1			;            r5,r4 = acc1
 3440: 1			;
 3441: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3442: 1			;                                  -1073709056 tot +1073741824
 3443: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3444: 1			;
 3445: 1			; vernietigt:  niets
 3446: 1			;*******************************************************************************
 3447: 1  0B13	12 08 29	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3448: 1  0B16	12 08 49	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3449: 1  0B19	12 0A 4D	                lcall    mul16           ;maak product
 3450: 1  0B1C	12 07 A3	                lcall    magsig32        ;maak 2's complement formaat
 3451: 1  0B1F	22		                ret                      ;klaar
 3452: 1
 3453: 1			;*******************************************************************************
 3454: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3455: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3456: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3457: 1			; input:     r5,r4 = acc1 low
 3458: 1			;            r7,r6 = acc1 high
 3459: 1			;
 3460: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3461: 1			;                                  -1073709056 tot +1073741824

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3462: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3463: 1			; vernietigt:  niets
 3464: 1			;*******************************************************************************
 3465: 1  0B20	12 08 49	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3466: 1  0B23	12 08 69	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3467: 1  0B26	12 0A B2	                lcall    mul16acc1       ;maak product
 3468: 1  0B29	12 07 CD	                lcall    magsig32acc1    ;maak 2's complement formaat
 3469: 1  0B2C	22		                ret                      ;klaar
 3470: 1
 3471: 1			;*******************************************************************************
 3472: 1			; s_mul816        (83,5us @16.777216MHz)
 3473: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3474: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3475: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3476: 1			; input:     r1,r0 = acc0
 3477: 1			;               r4 = acc1
 3478: 1			;
 3479: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3480: 1			;                                  -4194176 tot +4194304
 3481: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3482: 1			; vernietigt:  niets
 3483: 1			;*******************************************************************************
 3484: 1  0B2D	12 08 29	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3485: 1  0B30	12 08 10	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3486: 1  0B33	12 0B 3A	                lcall    mul816          ;8bit x 16 bit product
 3487: 1  0B36	12 07 A3	                lcall    magsig32        ;abs. waarde naar 2's complement
 3488: 1  0B39	22		                ret
 3489: 1
 3490: 1			;*******************************************************************************
 3491: 1			; mul816        (29,4us @16.777216MHz)
 3492: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3493: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3494: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3495: 1			; input:     r1,r0 = acc0
 3496: 1			;               r4 = acc1
 3497: 1			;
 3498: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3499: 1			;                           0..16711425 (000000h..feff01h)
 3500: 1			;
 3501: 1			; vernietigt:  niets
 3502: 1			;*******************************************************************************
 3503: 1  0B3A	C0 E0		mul816:         push    acc             ;bewaar registers
 3504: 1  0B3C	C0 F0		                push    b
 3505: 1  0B3E	C0 D0		                push    psw
 3506: 1  0B40	EC		                mov     a,r4            ;neem acc1
 3507: 1  0B41	88 F0		                mov     b,r0            ;neem lsb van acc0
 3508: 1  0B43	A4		                mul     ab              ;maak product
 3509: 1  0B44	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3510: 1  0B45	C0 F0		                push    b               ;bewaar lsb van het product
 3511: 1  0B47	EC		                mov     a,r4            ;neem acc1
 3512: 1  0B48	89 F0		                mov     b,r1            ;neem msb can acc0
 3513: 1  0B4A	A4		                mul     ab              ;maak product
 3514: 1  0B4B	AA F0		                mov     r2,b            ;bewaar msb van product even
 3515: 1  0B4D	F5 F0		                mov     b,a             ;verplaats lsb van product
 3516: 1  0B4F	D0 E0		                pop     acc             ;neem msb van vorig product

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3517: 1  0B51	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3518: 1  0B53	F9		                mov     r1,a            ;de middenste byte is klaar
 3519: 1  0B54	EA		                mov     a,r2            ;tel nu de eventuele
 3520: 1  0B55	34 00		                addc    a,#0            ;carry bij de msb
 3521: 1  0B57	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3522: 1  0B58	7B 00		                mov     r3,#0
 3523: 1  0B5A	D0 D0		                pop     psw
 3524: 1  0B5C	D0 F0		                pop     b
 3525: 1  0B5E	D0 E0		                pop     acc
 3526: 1  0B60	22		                ret
 3527: 1
 3528: 1			;*******************************************************************************
 3529: 1			; s_mac16        (145,1us @16.777216MHz)
 3530: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3531: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3532: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3533: 1			; input:     r7,r6 = acc1 (high word)
 3534: 1			;            r5,r4 = acc1 (low  word)
 3535: 1			;
 3536: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3537: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3538: 1			;                          -2147483648 tot +2147483647
 3539: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3540: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3541: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3542: 1			;
 3543: 1			; vernietigt:  niets
 3544: 1			;*******************************************************************************
 3545: 1  0B61	12 0B 20	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3546: 1  0B64	C0 E0		                push    acc
 3547: 1  0B66	C0 D0		                push    psw
 3548: 1  0B68	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3549: 1  0B69	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3550: 1  0B6A	F8		                mov     r0,a
 3551: 1  0B6B	ED		                mov     a,r5
 3552: 1  0B6C	39		                addc    a,r1
 3553: 1  0B6D	F9		                mov     r1,a
 3554: 1  0B6E	EE		                mov     a,r6
 3555: 1  0B6F	3A		                addc    a,r2
 3556: 1  0B70	FA		                mov     r2,a
 3557: 1  0B71	EF		                mov     a,r7
 3558: 1  0B72	3B		                addc    a,r3
 3559: 1  0B73	FB		                mov     r3,a
 3560: 1  0B74	20 D2 06	                jb      ov,s_mac161
 3561: 1  0B77	D0 D0		                pop     psw
 3562: 1  0B79	C3		                clr     c                ;ok, 32bit som binnen bereik
 3563: 1  0B7A	D0 E0		                pop     acc
 3564: 1  0B7C	22		                ret
 3565: 1  0B7D	D0 D0		s_mac161:       pop     psw
 3566: 1  0B7F	D3		                setb    c                ;fout! 32bit som buiten bereik
 3567: 1  0B80	D0 E0		                pop     acc
 3568: 1  0B82	22		                ret
 3569: 1
 3570: 1
 3571: 1			;*******************************************************************************
 3572: 1			; s_div8        (78us @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3573: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3574: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3575: 1			; input:    r0 = acc0 deeltal (2's compl)
 3576: 1			;           r4 = acc1 deler   (2's compl)
 3577: 1			;
 3578: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3579: 1			;           r4 = rest (2's compl)
 3580: 1			;           cy=1 bij acc1=0 (deling door nul)
 3581: 1			;            cy=0 in andere gevallen
 3582: 1			;
 3583: 1			; vernietigt: niets
 3584: 1			;*******************************************************************************
 3585: 1  0B83	12 07 F7	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3586: 1  0B86	12 08 10	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3587: 1  0B89	12 0B 95	                lcall   div8
 3588: 1  0B8C	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3589: 1  0B8E	12 07 2F	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3590: 1  0B91	12 07 49	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3591: 1  0B94	22		s_div81:        ret
 3592: 1
 3593: 1			;*******************************************************************************
 3594: 1			; div8        (19,4us @16.777216MHz)
 3595: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3596: 1			; absolute waarde
 3597: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3598: 1			; input:    r0 = acc0 deeltal
 3599: 1			;           r4 = acc1 deler
 3600: 1			;
 3601: 1			; output:   r0 = quotient van deling acc0/acc1
 3602: 1			;           r4 = rest
 3603: 1			;           cy=1 bij acc1=0 (deling door nul)
 3604: 1			;            cy=0 in andere gevallen
 3605: 1			;
 3606: 1			; vernietigt: niets
 3607: 1			;*******************************************************************************
 3608: 1  0B95	C0 E0		div8:           push    acc             ;bewaar registers
 3609: 1  0B97	C0 F0		                push    b
 3610: 1  0B99	C0 D0		                push    psw
 3611: 1  0B9B	EC		                mov     a,r4            ;neem deler
 3612: 1  0B9C	60 0F		                jz      div81           ;deling door nul?
 3613: 1  0B9E	E8		                mov     a,r0            ;nee, neem deeltal
 3614: 1  0B9F	8C F0		                mov     b,r4            ;en deler
 3615: 1  0BA1	84		                div     ab              ;en maak deling
 3616: 1  0BA2	F8		                mov     r0,a            ;bewaar quotient in acc0
 3617: 1  0BA3	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3618: 1  0BA5	D0 D0		                pop     psw             ;herstel registers
 3619: 1  0BA7	D0 F0		                pop     b
 3620: 1  0BA9	D0 E0		                pop     acc
 3621: 1  0BAB	C3		                clr     c                ;geen deling door nul
 3622: 1  0BAC	22		                ret
 3623: 1
 3624: 1  0BAD	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3625: 1  0BAF	D0 F0		                pop     b
 3626: 1  0BB1	D0 E0		                pop     acc
 3627: 1  0BB3	D3		                setb    c
 3628: 1  0BB4	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3629: 1
 3630: 1
 3631: 1			;*******************************************************************************
 3632: 1			; s_div16        (469,1us @16.777216MHz)
 3633: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3634: 1			; 2's Complement Format
 3635: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3636: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3637: 1			;           r5, r4 = acc1 deler   (2's compl)
 3638: 1			;
 3639: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3640: 1			;           r5, r4 = rest
 3641: 1			;           cy=1 bij acc1=0 (deling door nul)
 3642: 1			;            cy=0 in andere gevallen
 3643: 1			;
 3644: 1			; vernietigt: niets
 3645: 1			;*******************************************************************************
 3646: 1  0BB5	C0 E0		s_div16:        push    acc
 3647: 1  0BB7	C0 D0		                push    psw
 3648: 1  0BB9	ED		                mov     a,r5            ;neem msb van deler
 3649: 1  0BBA	4C		                orl     a,r4            ;combineer met lsb van deler
 3650: 1  0BBB	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3651: 1  0BBD	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3652: 1  0BBF	D0 E0		                pop     acc
 3653: 1  0BC1	D3		                setb    C               ;fout, deling door nul!
 3654: 1  0BC2	22		                ret
 3655: 1
 3656: 1  0BC3	12 08 29	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3657: 1  0BC6	12 08 49	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3658: 1  0BC9	12 0B D8	                lcall   div16
 3659: 1  0BCC	12 07 63	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3660: 1  0BCF	12 07 83	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3661: 1  0BD2	D0 D0		                pop     psw
 3662: 1  0BD4	C3		                clr     C               ;delig ok
 3663: 1  0BD5	D0 E0		                pop     acc
 3664: 1  0BD7	22		                ret                     ;klaar
 3665: 1
 3666: 1			;*******************************************************************************
 3667: 1			; div16            (405,1us @16.777216MHz)
 3668: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3669: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3670: 1			; input:    r1, r0 = Deeltal (acc0)
 3671: 1			;           r5, r4 = Deler   (acc1)
 3672: 1			;
 3673: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3674: 1			;           r5, r4 = rest van de deling acc0/acc1
 3675: 1			;            cy=1 bij deling door nul (acc1=0)
 3676: 1			;            cy=0 bij normale deling
 3677: 1			;
 3678: 1			; vernietigt: niets
 3679: 1			;*******************************************************************************
 3680: 1
 3681: 1  0BD8	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3682: 1  0BDA	C0 D0		                push    psw
 3683: 1			;check voor deling door nul
 3684: 1  0BDC	EC		                mov     a,r4           ;neem lsb deler

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3685: 1  0BDD	4D		                orl     a,r5           ;combineer met msb van deler
 3686: 1  0BDE	70 06		                jnz     div160         ;niet nul, dan verder werken
 3687: 1  0BE0	D0 D0		                pop     psw            ;als nul, dikke snul
 3688: 1  0BE2	D3		                setb    c              ;terug met errorstatus
 3689: 1  0BE3	D0 E0		                pop     acc
 3690: 1  0BE5	22		                ret
 3691: 1
 3692: 1  0BE6	C0 F0		div160:         push    b              ;registers verder bewaren
 3693: 1  0BE8	EF		                mov     a,r7
 3694: 1  0BE9	C0 E0		                push    acc            ;push r7 op stack
 3695: 1  0BEB	EE		                mov     a,r6
 3696: 1  0BEC	C0 E0		                push    acc            ;push r6 op stack
 3697: 1  0BEE	EB		                mov     a,r3
 3698: 1  0BEF	C0 E0		                push    acc            ;push r3 op stack
 3699: 1  0BF1	EA		                mov     a,r2
 3700: 1  0BF2	C0 E0		                push    acc            ;push r2 op stack
 3701: 1  0BF4	C0 83		                push    dph
 3702: 1  0BF6	C0 82		                push    dpl
 3703: 1
 3704: 1  0BF8	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3705: 1  0BFA	7B 00		                mov     r3,#0
 3706: 1  0BFC	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3707: 1  0BFE	7E 00		                mov     r6,#0
 3708: 1  0C00	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3709: 1
 3710: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3711: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3712: 1			;het aantal significante bits af in de lusteller b
 3713: 1
 3714: 1  0C03	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3715: 1  0C04	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3716: 1  0C07	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3717: 1  0C08	E8		                mov     a,r0            ;lsb van deeltal nemen
 3718: 1  0C09	33		                rlc     a                ;en opschuiven
 3719: 1  0C0A	F8		                mov     r0,a
 3720: 1  0C0B	E9		                mov     a,r1            ;msb van deeltal nemen
 3721: 1  0C0C	33		                rlc     a
 3722: 1  0C0D	F9		                mov     r1,a
 3723: 1  0C0E	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3724: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3725: 1  0C11	7C 00		                mov     r4,#0
 3726: 1  0C13	7D 00		                mov     r5,#0
 3727: 1  0C15	80 2E		                sjmp    div164          ;klaar!
 3728: 1
 3729: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3730: 1
 3731: 1  0C17	C3		div162:            clr     C            ;start met carry op nul
 3732: 1  0C18	E8		                mov     a,r0            ;schuif deeltal naar links
 3733: 1  0C19	33		                rlc     a
 3734: 1  0C1A	F8		                mov     r0,a
 3735: 1  0C1B	E9		                mov     a,r1
 3736: 1  0C1C	33		                rlc     a
 3737: 1  0C1D	F9		                mov     r1,a
 3738: 1  0C1E	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3739: 1  0C1F	33		                rlc     a               ;gedeeltelijke rest
 3740: 1  0C20	FE		                mov     r6,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3741: 1  0C21	EF		                mov     a,r7
 3742: 1  0C22	33		                rlc     a
 3743: 1  0C23	FF		                mov     r7,a
 3744: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3745: 1  0C24	EE		                mov     a,r6
 3746: 1  0C25	C3		                clr     C
 3747: 1  0C26	9C		                subb    a,r4
 3748: 1  0C27	F5 82		                mov     dpl,a
 3749: 1  0C29	EF		                mov     a,r7
 3750: 1  0C2A	9D		                subb    a,r5
 3751: 1  0C2B	F5 83		                mov     dph,a
 3752: 1  0C2D	40 04		                jc      div163
 3753: 1  0C2F	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3754: 1  0C31	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3755: 1
 3756: 1  0C33	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3757: 1  0C34	EA		                mov     a,r2            ;binnenschuiven
 3758: 1  0C35	33		                rlc     a
 3759: 1  0C36	FA		                mov     r2,a
 3760: 1  0C37	EB		                mov     a,r3
 3761: 1  0C38	33		                rlc     a
 3762: 1  0C39	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 3763: 1  0C3A	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3764: 1
 3765: 1  0C3D	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3766: 1  0C3E	F9		                mov     r1,a
 3767: 1  0C3F	EA		                mov     a,r2
 3768: 1  0C40	F8		                mov     r0,a
 3769: 1  0C41	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3770: 1  0C42	FD		                mov     r5,a
 3771: 1  0C43	EE		                mov     a,r6
 3772: 1  0C44	FC		                mov     r4,a
 3773: 1
 3774: 1  0C45	D0 82		div164:         pop     dpl             ;registers herstellen
 3775: 1  0C47	D0 83		                pop     dph
 3776: 1  0C49	D0 E0		                pop     acc
 3777: 1  0C4B	FA		                mov     r2,a            ;r2 van stack halen
 3778: 1  0C4C	D0 E0		                pop     acc
 3779: 1  0C4E	FB		                mov     r3,a            ;r3 van stack halen
 3780: 1  0C4F	D0 E0		                pop     acc
 3781: 1  0C51	FE		                mov     r6,a            ;r6 van stack halen
 3782: 1  0C52	D0 E0		                pop     acc
 3783: 1  0C54	FF		                mov     r7,a            ;r7 van stack halen
 3784: 1  0C55	D0 F0		                pop     b
 3785: 1  0C57	D0 D0		                pop     psw
 3786: 1  0C59	C3		                clr     c               ;deling ok
 3787: 1  0C5A	D0 E0		                pop     acc
 3788: 1  0C5C	22		                ret
 3789: 1
 3790: 1
 3791: 1			;*******************************************************************************
 3792: 1			; s_div32        (2,15ms @16.777216MHz)
 3793: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3794: 1			; 2's Complement Format
 3795: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3796: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3797: 1			;
 3798: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 3799: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3800: 1			;
 3801: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3802: 1			;           r7,r6,r5, r4 = rest
 3803: 1			;           cy=1 bij acc1=0 (deling door nul)
 3804: 1			;            cy=0 in andere gevallen
 3805: 1			;
 3806: 1			; vernietigt: niets
 3807: 1			;*******************************************************************************
 3808: 1  0C5D	C0 E0		s_div32:        push    acc
 3809: 1  0C5F	C0 D0		                push    psw
 3810: 1  0C61	EF		                mov     a,r7            ;neem msb van deler
 3811: 1  0C62	4E		                orl     a,r6            ;combineer met lsb's van deler
 3812: 1  0C63	4D		                orl     a,r5
 3813: 1  0C64	4C		                orl     a,r4
 3814: 1  0C65	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3815: 1  0C67	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3816: 1  0C69	D0 E0		                pop     acc
 3817: 1  0C6B	D3		                setb    C                ;fout, deling door nul!
 3818: 1  0C6C	22		                ret
 3819: 1
 3820: 1  0C6D	12 08 89	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3821: 1  0C70	12 08 B3	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3822: 1  0C73	12 0C 82	                lcall   div32            ;deel 32bit/32bit
 3823: 1  0C76	12 07 A3	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3824: 1  0C79	12 07 CD	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3825: 1  0C7C	D0 D0		                pop     psw
 3826: 1  0C7E	C3		                clr     C                ;delig ok
 3827: 1  0C7F	D0 E0		                pop     acc
 3828: 1  0C81	22		                ret                        ;klaar
 3829: 1
 3830: 1
 3831: 1			;*******************************************************************************
 3832: 1			; div32        (2,09ms @16.777216MHz)
 3833: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3834: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3835: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3836: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3837: 1			;
 3838: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 3839: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3840: 1			;            cy=1 bij deling door nul (acc1=0)
 3841: 1			;            cy=0 bij normale deling
 3842: 1			;
 3843: 1			; vernietigt: niets
 3844: 1			;*******************************************************************************
 3845: 1  0C82	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3846: 1  0C84	C0 D0		                push    psw
 3847: 1			;check voor deling door nul
 3848: 1  0C86	EF		                mov     a,r7            ;neem msb van deler
 3849: 1  0C87	4E		                orl     a,r6            ;combineer met lsb's van deler
 3850: 1  0C88	4D		                orl     a,r5
 3851: 1  0C89	4C		                orl     a,r4
 3852: 1  0C8A	70 06		                jnz     div320          ;niet nul, dan verder werken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3853: 1  0C8C	D0 D0		                pop     psw             ;als nul, dikke snul
 3854: 1  0C8E	D3		                setb    c               ;terug met errorstatus
 3855: 1  0C8F	D0 E0		                pop     acc
 3856: 1  0C91	22		                ret
 3857: 1
 3858: 1  0C92	C0 F0		div320:         push    b                ;registers verder bewaren
 3859: 1  0C94	C0 83		                push    dph
 3860: 1  0C96	C0 82		                push    dpl
 3861: 1
 3862: 1  0C98	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3863: 1
 3864: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3865: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3866: 1			;het aantal significante bits af in de lusteller b
 3867: 1
 3868: 1  0C9B	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3869: 1  0C9C	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3870: 1  0C9F	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3871: 1  0CA0	E8		                mov     a,r0            ;lsb van deeltal nemen
 3872: 1  0CA1	33		                rlc     a               ;en opschuiven
 3873: 1  0CA2	F8		                mov     r0,a
 3874: 1  0CA3	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 3875: 1  0CA4	33		                rlc     a
 3876: 1  0CA5	F9		                mov     r1,a
 3877: 1  0CA6	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3878: 1  0CA7	33		                rlc     a
 3879: 1  0CA8	FA		                mov     r2,a
 3880: 1  0CA9	EB		                mov     a,r3           ;lsb van deeltal nemen
 3881: 1  0CAA	33		                rlc     a
 3882: 1  0CAB	FB		                mov     r3,a
 3883: 1  0CAC	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3884: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3885: 1  0CAF	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3886: 1  0CB1	7E 00		                mov     r6,#0
 3887: 1  0CB3	7D 00		                mov     r5,#0
 3888: 1  0CB5	7C 00		                mov     r4,#0
 3889: 1  0CB7	02 0D 80	                ljmp    div324           ;klaar!
 3890: 1
 3891: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 3892: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 3893: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 3894: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 3895: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 3896: 1
 3897: 1  0CBA			div320b:
 3898: 1  0CBA	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 3899: 1
 3900: 1  0CBD	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 3901: 1  0CBF	24 0C		                add     a,#12           ;met 12 plaatsen
 3902: 1  0CC1	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 3903: 1
 3904: 1  0CC3	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 3905: 1  0CC4	C0 E0		                push    acc
 3906: 1  0CC6	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 3907: 1  0CC7	C0 E0		                push    acc
 3908: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3909: 1  0CC9	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 3910: 1  0CCB	08		                inc     r0              ;de deler
 3911: 1  0CCC	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 3912: 1  0CCE	24 05		                add     a,#5            ;het tijdelijk verschil X
 3913: 1  0CD0	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 3914: 1  0CD1	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 3915: 1  0CD3	24 09		                add     a,#9            ;quotient
 3916: 1  0CD5	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 3917: 1
 3918: 1			;Eenmalig de variabelen op stack initaliseren
 3919: 1			;Tijdelijk quotient op nul zetten
 3920: 1
 3921: 1  0CD7	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 3922: 1  0CD9	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 3923: 1  0CDA	C0 F0		                push    b                ;loopteller deling bewaren
 3924: 1  0CDC	75 F0 04	                mov     b,#4
 3925: 1  0CDF	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 3926: 1  0CE1	09		                inc     r1
 3927: 1  0CE2	D5 F0 FA	                djnz    b,div320c
 3928: 1  0CE5	D0 F0		                pop     b                ;loopteller deling ophalen
 3929: 1  0CE7	19		                dec     r1
 3930: 1  0CE8	19		                dec     r1
 3931: 1  0CE9	19		                dec     r1
 3932: 1  0CEA	19		                dec     r1               ;pointer weer op startadres quotient
 3933: 1  0CEB	C9		                xch     a,r1             ;weer omwisselen
 3934: 1  0CEC	C5 82		                xch     a,dpl
 3935: 1
 3936: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 3937: 1  0CEE	EC		                mov     a,r4
 3938: 1  0CEF	F6		                mov     @r0,a
 3939: 1  0CF0	08		                inc     r0
 3940: 1  0CF1	ED		                mov     a,r5
 3941: 1  0CF2	F6		                mov     @r0,a
 3942: 1  0CF3	08		                inc     r0
 3943: 1  0CF4	EE		                mov     a,r6
 3944: 1  0CF5	F6		                mov     @r0,a
 3945: 1  0CF6	08		                inc     r0
 3946: 1  0CF7	EF		                mov     a,r7
 3947: 1  0CF8	F6		                mov     @r0,a
 3948: 1  0CF9	18		                dec     r0             ;pointer herstellen naar lsb van deler
 3949: 1  0CFA	18		                dec     r0
 3950: 1  0CFB	18		                dec     r0
 3951: 1
 3952: 1  0CFC	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 3953: 1  0CFE	7E 00		                mov     r6,#0
 3954: 1  0D00	7D 00		                mov     r5,#0
 3955: 1  0D02	7C 00		                mov     r4,#0
 3956: 1
 3957: 1
 3958: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 3959: 1  0D04	C3		div322:         clr     C               ;start met carry op nul
 3960: 1
 3961: 1  0D05	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 3962: 1  0D07	33		                rlc     a
 3963: 1  0D08	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 3964: 1  0D0A	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3965: 1  0D0C	D0 E0		                pop     acc             ;r1 van deeltal van stack
 3966: 1  0D0E	33		                rlc     a
 3967: 1  0D0F	C0 E0		                push    acc             ;en weer bewaren
 3968: 1  0D11	05 81		                inc     sp              ;stackpointer weer corrigeren
 3969: 1
 3970: 1  0D13	EA		                mov     a,r2
 3971: 1  0D14	33		                rlc     a
 3972: 1  0D15	FA		                mov     r2,a
 3973: 1  0D16	EB		                mov     a,r3
 3974: 1  0D17	33		                rlc     a
 3975: 1  0D18	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 3976: 1
 3977: 1  0D19	EC		                mov     a,r4            ;schuif carry van deeltal in de
 3978: 1  0D1A	33		                rlc     a               ;gedeeltelijke rest r7..r4
 3979: 1  0D1B	FC		                mov     r4,a
 3980: 1  0D1C	ED		                mov     a,r5
 3981: 1  0D1D	33		                rlc     a
 3982: 1  0D1E	FD		                mov     r5,a
 3983: 1  0D1F	EE		                mov     a,r6
 3984: 1  0D20	33		                rlc     a
 3985: 1  0D21	FE		                mov     r6,a
 3986: 1  0D22	EF		                mov     a,r7
 3987: 1  0D23	33		                rlc     a
 3988: 1  0D24	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 3989: 1
 3990: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 3991: 1
 3992: 1  0D25	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 3993: 1  0D26	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 3994: 1  0D27	96		                subb    a,@r0           ;trek er de lsb deler af
 3995: 1  0D28	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 3996: 1  0D29	08		                inc     r0              ;pointers aanpassen
 3997: 1  0D2A	09		                inc     r1
 3998: 1  0D2B	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 3999: 1  0D2C	96		                subb    a,@r0           ;trek er volgende byte deler af
 4000: 1  0D2D	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4001: 1  0D2E	08		                inc     r0              ;pointers aanpassen
 4002: 1  0D2F	09		                inc     r1
 4003: 1  0D30	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4004: 1  0D31	96		                subb    a,@r0           ;trek er volgende byte deler af
 4005: 1  0D32	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4006: 1  0D33	08		                inc     r0              ;pointers aanpassen
 4007: 1  0D34	09		                inc     r1
 4008: 1  0D35	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4009: 1  0D36	96		                subb    a,@r0           ;trek er msb deler af
 4010: 1  0D37	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4011: 1  0D38	18		                dec     r0              ;pointers herstellen naar lsb's
 4012: 1  0D39	18		                dec     r0
 4013: 1  0D3A	18		                dec     r0
 4014: 1  0D3B	19		                dec     r1
 4015: 1  0D3C	19		                dec     r1
 4016: 1  0D3D	19		                dec     r1
 4017: 1
 4018: 1  0D3E	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4019: 1  0D40	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4020: 1  0D41	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4021: 1  0D42	09		                inc     r1
 4022: 1  0D43	E7		                mov     a,@r1
 4023: 1  0D44	FD		                mov     r5,a
 4024: 1  0D45	09		                inc     r1
 4025: 1  0D46	E7		                mov     a,@r1
 4026: 1  0D47	FE		                mov     r6,a
 4027: 1  0D48	09		                inc     r1
 4028: 1  0D49	E7		                mov     a,@r1
 4029: 1  0D4A	FF		                mov     r7,a
 4030: 1  0D4B	19		                dec     r1              ;met pointer weer naar lsb van
 4031: 1  0D4C	19		                dec     r1              ;het tijdelijk verschil wijzen
 4032: 1  0D4D	19		                dec     r1
 4033: 1
 4034: 1
 4035: 1  0D4E	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4036: 1  0D4F	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4037: 1  0D51	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4038: 1  0D52	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4039: 1  0D54	E7		                mov     a,@r1           ;neem lsb van qoutient
 4040: 1  0D55	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4041: 1  0D56	F7		                mov     @r1,a
 4042: 1  0D57	09		                inc     r1              ;volgende byte
 4043: 1  0D58	E7		                mov     a,@r1
 4044: 1  0D59	33		                rlc     a
 4045: 1  0D5A	F7		                mov     @r1,a
 4046: 1  0D5B	09		                inc     r1              ;volgende byte
 4047: 1  0D5C	E7		                mov     a,@r1
 4048: 1  0D5D	33		                rlc     a
 4049: 1  0D5E	F7		                mov     @r1,a
 4050: 1  0D5F	09		                inc     r1              ;volgende byte
 4051: 1  0D60	E7		                mov     a,@r1
 4052: 1  0D61	33		                rlc     a
 4053: 1  0D62	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4054: 1  0D63	19		                dec     r1
 4055: 1  0D64	19		                dec     r1
 4056: 1  0D65	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4057: 1  0D66	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4058: 1  0D68	C9		                xch     a,r1            ;r1=pointer naar verschil
 4059: 1  0D69	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4060: 1
 4061: 1  0D6B	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4062: 1
 4063: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4064: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4065: 1
 4066: 1  0D6E	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4067: 1  0D70	18		                dec     r0
 4068: 1  0D71	18		                dec     r0
 4069: 1  0D72	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4070: 1  0D73	FB		                mov     r3,a            ;en verplaatsen
 4071: 1  0D74	18		                dec     r0              ;volgende byte
 4072: 1  0D75	E6		                mov     a,@r0
 4073: 1  0D76	FA		                mov     r2,a
 4074: 1  0D77	18		                dec     r0              ;volgende byte
 4075: 1  0D78	E6		                mov     a,@r0
 4076: 1  0D79	F9		                mov     r1,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4077: 1  0D7A	18		                dec     r0              ;volgende byte
 4078: 1  0D7B	E6		                mov     a,@r0
 4079: 1  0D7C	F8		                mov     r0,a            ;laatste byte verplaatst!
 4080: 1
 4081: 1  0D7D	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4082: 1			                                         ;weer vrijgeven
 4083: 1
 4084: 1
 4085: 1  0D80	D0 82		div324:         pop     dpl             ;registers herstellen
 4086: 1  0D82	D0 83		                pop     dph
 4087: 1  0D84	D0 F0		                pop     b
 4088: 1  0D86	D0 D0		                pop     psw
 4089: 1  0D88	C3		                clr     c               ;normale deling
 4090: 1  0D89	D0 E0		                pop     acc
 4091: 1  0D8B	22		                ret
 4092: 1
 4093: 1			;*******************************************************************************
 4094: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4095: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4096: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4097: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4098: 1			;
 4099: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4100: 1			;
 4101: 1			; input:     r5,r4 = acc1 (low word product)
 4102: 1			;            r7,r6 = acc1 (high word product)
 4103: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4104: 1			;
 4105: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4106: 1			;            r7,r6,r5,r4 = acc1 = rest
 4107: 1			;                          -2147483648 tot +2147483647
 4108: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4109: 1			;             cy=1 bij deling door nul (acc0=0)
 4110: 1			;             cy=0 bij normale deling
 4111: 1			;
 4112: 1			; vernietigt:  niets
 4113: 1			;*******************************************************************************
 4114: 1  0D8C	C0 E0		s_muldiv:       push    acc
 4115: 1  0D8E	C0 D0		                push    psw
 4116: 1  0D90	E8		                mov     a,r0            ;neem msb van deler
 4117: 1  0D91	49		                orl     a,r1            ;combineer met lsb's van deler
 4118: 1  0D92	4A		                orl     a,r2
 4119: 1  0D93	4B		                orl     a,r3
 4120: 1  0D94	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4121: 1  0D96	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4122: 1  0D98	D0 E0		                pop     acc
 4123: 1  0D9A	D3		                setb    C               ;fout, deling door nul!
 4124: 1  0D9B	22		                ret
 4125: 1
 4126: 1  0D9C	12 08 49	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4127: 1  0D9F	12 08 69	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4128: 1  0DA2	12 0D B1	                lcall    muldiv          ;maak product en daarna de deling
 4129: 1  0DA5	12 07 A3	                lcall    magsig32        ;quotient naar 2's complement
 4130: 1  0DA8	12 07 CD	                lcall    magsig32acc1    ;rest naar 2's complement
 4131: 1  0DAB	D0 D0		                pop     psw
 4132: 1  0DAD	C3		                clr     c                ;deling is ok

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4133: 1  0DAE	D0 E0		                pop    acc
 4134: 1  0DB0	22		                ret
 4135: 1
 4136: 1			;*******************************************************************************
 4137: 1			; muldiv        (2,0ms @16.777216MHz)
 4138: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4139: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4140: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4141: 1			; 32bit rest in acc1.
 4142: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4143: 1			;
 4144: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4145: 1			;
 4146: 1			; input:     r5,r4 = acc1 (low word product)
 4147: 1			;            r7,r6 = acc1 (high word product)
 4148: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4149: 1			;
 4150: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4151: 1			;            r7,r6,r5,r4 = acc1 = rest
 4152: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4153: 1			;             cy=1 bij deling door nul (acc0=0)
 4154: 1			;             cy=0 bij normale deling
 4155: 1			;
 4156: 1			; vernietigt:  niets
 4157: 1			;*******************************************************************************
 4158: 1  0DB1	C0 E0		muldiv:         push    acc
 4159: 1  0DB3	C0 D0		                push    psw
 4160: 1  0DB5	E8		                mov     a,r0            ;neem msb van deler
 4161: 1  0DB6	49		                orl     a,r1            ;combineer met lsb's van deler
 4162: 1  0DB7	4A		                orl     a,r2
 4163: 1  0DB8	4B		                orl     a,r3
 4164: 1  0DB9	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4165: 1  0DBB	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4166: 1  0DBD	D0 E0		                pop     acc
 4167: 1  0DBF	D3		                setb    C               ;fout, deling door nul!
 4168: 1  0DC0	22		                ret
 4169: 1
 4170: 1  0DC1	12 0A B2	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4171: 1  0DC4	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4172: 1  0DC5	C0 E0		                push    acc
 4173: 1  0DC7	ED		                mov     a,r5
 4174: 1  0DC8	C0 E0		                push    acc
 4175: 1  0DCA	EE		                mov     a,r6
 4176: 1  0DCB	C0 E0		                push    acc
 4177: 1  0DCD	EF		                mov     a,r7
 4178: 1  0DCE	C0 E0		                push    acc             ;product staat nu op stack
 4179: 1
 4180: 1  0DD0	E8		                mov     a,r0            ;deler in acc1 stoppen
 4181: 1  0DD1	FC		                mov     r4,a
 4182: 1  0DD2	E9		                mov     a,r1
 4183: 1  0DD3	FD		                mov     r5,a
 4184: 1  0DD4	EA		                mov     a,r2
 4185: 1  0DD5	FE		                mov     r6,a
 4186: 1  0DD6	EB		                mov     a,r3
 4187: 1  0DD7	FF		                mov     r7,a            ;deler zit volledig in acc1
 4188: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4189: 1  0DD8	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4190: 1  0DDA	FB		                mov     r3,a
 4191: 1  0DDB	D0 E0		                pop     acc
 4192: 1  0DDD	FA		                mov     r2,a
 4193: 1  0DDE	D0 E0		                pop     acc
 4194: 1  0DE0	F9		                mov     r1,a
 4195: 1  0DE1	D0 E0		                pop     acc
 4196: 1  0DE3	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4197: 1  0DE4	12 0C 82	                lcall   div32           ;maak deling
 4198: 1
 4199: 1  0DE7	D0 D0		                pop     psw            ;herstel registers
 4200: 1  0DE9	D0 E0		                pop     acc
 4201: 1  0DEB	C3		                clr     C              ;resultaat ok!
 4202: 1  0DEC	22		                ret
 4203: 1
 4204: 1			;*******************************************************************************
 4205: 1			; mul16_pi        (257,1us @16.777216MHz)
 4206: 1			; acc0 = acc0 x pi
 4207: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4208: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4209: 1			;
 4210: 1			; input:     r1,r0 = acc0 (low word)
 4211: 1			;
 4212: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4213: 1			;
 4214: 1			; vernietigt:  niets
 4215: 1			;*******************************************************************************
 4216: 1  0DED	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4217: 1  0DEF	C0 D0		                push    psw
 4218: 1  0DF1	EC		                mov     a,r4
 4219: 1  0DF2	C0 E0		                push    acc
 4220: 1  0DF4	ED		                mov     a,r5
 4221: 1  0DF5	C0 E0		                push    acc
 4222: 1  0DF7	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4223: 1  0DF9	7C 0F		                mov     r4,#0fH
 4224: 1  0DFB	12 0A 4D	                lcall   mul16           ;acc0 = acc0 x acc1
 4225: 1  0DFE	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4226: 1  0E00	12 0F E9	                lcall   shiftright32    ;om te delen door 2^14
 4227: 1  0E03	D0 E0		                pop     acc
 4228: 1  0E05	FD		                mov     r5,a
 4229: 1  0E06	D0 E0		                pop     acc
 4230: 1  0E08	FC		                mov     r4,a
 4231: 1  0E09	D0 D0		                pop     psw
 4232: 1  0E0B	D0 E0		                pop     acc
 4233: 1  0E0D	22		                ret
 4234: 1
 4235: 1			;*******************************************************************************
 4236: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4237: 1			; acc0 = acc0 x 1/pi
 4238: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4239: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4240: 1			;
 4241: 1			; input:     r1,r0 = acc0 (low word)
 4242: 1			;
 4243: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4244: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4245: 1			; vernietigt:  niets
 4246: 1			;*******************************************************************************
 4247: 1  0E0E	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4248: 1  0E10	C0 D0		                push    psw
 4249: 1  0E12	EC		                mov     a,r4
 4250: 1  0E13	C0 E0		                push    acc
 4251: 1  0E15	ED		                mov     a,r5
 4252: 1  0E16	C0 E0		                push    acc
 4253: 1  0E18	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4254: 1  0E1A	7C 7D		                mov     r4,#07dH
 4255: 1  0E1C	12 0A 4D	                lcall    mul16          ;acc0 = acc0 x acc1
 4256: 1  0E1F	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4257: 1  0E21	12 0F E9	                lcall   shiftright32    ;om te delen door 2^16
 4258: 1  0E24	D0 E0		                pop     acc
 4259: 1  0E26	FD		                mov     r5,a
 4260: 1  0E27	D0 E0		                pop     acc
 4261: 1  0E29	FC		                mov     r4,a
 4262: 1  0E2A	D0 D0		                pop     psw
 4263: 1  0E2C	D0 E0		                pop     acc
 4264: 1  0E2E	22		                ret
 4265: 1
 4266: 1			;*******************************************************************************
 4267: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4268: 1			; acc0 = acc0 x sqrt2
 4269: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4270: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4271: 1			;
 4272: 1			; input:     r1,r0 = acc0 (low word)
 4273: 1			;
 4274: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4275: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4276: 1			;
 4277: 1			; vernietigt:  niets
 4278: 1			;*******************************************************************************
 4279: 1  0E2F	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4280: 1  0E31	C0 D0		                push    psw
 4281: 1  0E33	EC		                mov     a,r4
 4282: 1  0E34	C0 E0		                push    acc
 4283: 1  0E36	ED		                mov     a,r5
 4284: 1  0E37	C0 E0		                push    acc
 4285: 1  0E39	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4286: 1  0E3B	7C 05		                mov     r4,#005H
 4287: 1  0E3D	12 0A 4D	                lcall   mul16           ;acc0 = acc0 x acc1
 4288: 1  0E40	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4289: 1  0E42	12 0F E9	                lcall   shiftright32    ;om te delen door 2^15
 4290: 1  0E45	D0 E0		                pop     acc
 4291: 1  0E47	FD		                mov     r5,a
 4292: 1  0E48	D0 E0		                pop     acc
 4293: 1  0E4A	FC		                mov     r4,a
 4294: 1  0E4B	D0 D0		                pop     psw
 4295: 1  0E4D	D0 E0		                pop     acc
 4296: 1  0E4F	22		                ret
 4297: 1
 4298: 1
 4299: 1
 4300: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4301: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4302: 1			; acc0 = acc0 x 1/sqrt2
 4303: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4304: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4305: 1			;
 4306: 1			; input:     r1,r0 = acc0 (low word)
 4307: 1			;
 4308: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4309: 1			;
 4310: 1			; vernietigt:  niets
 4311: 1			;*******************************************************************************
 4312: 1  0E50	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4313: 1  0E52	C0 D0		                push    psw
 4314: 1  0E54	EC		                mov     a,r4
 4315: 1  0E55	C0 E0		                push    acc
 4316: 1  0E57	ED		                mov     a,r5
 4317: 1  0E58	C0 E0		                push    acc
 4318: 1  0E5A	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4319: 1  0E5C	7C 05		                mov     r4,#005H
 4320: 1  0E5E	12 0A 4D	                lcall   mul16           ;acc0 = acc0 x acc1
 4321: 1  0E61	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4322: 1  0E63	12 0F E9	                lcall   shiftright32    ;om te delen door 2^16
 4323: 1  0E66	D0 E0		                pop     acc
 4324: 1  0E68	FD		                mov     r5,a
 4325: 1  0E69	D0 E0		                pop     acc
 4326: 1  0E6B	FC		                mov     r4,a
 4327: 1  0E6C	D0 D0		                pop     psw
 4328: 1  0E6E	D0 E0		                pop     acc
 4329: 1  0E70	22		                ret
 4330: 1
 4331: 1			;*******************************************************************************
 4332: 1			; mul16_10        (98,7us @16.777216MHz)
 4333: 1			; acc0 = acc0 x 10
 4334: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4335: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4336: 1			;
 4337: 1			; input:     r1,r0 = acc0 (low word)
 4338: 1			;
 4339: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4340: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4341: 1			; vernietigt:  niets
 4342: 1			;*******************************************************************************
 4343: 1  0E71	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4344: 1  0E73	C0 D0		                push    psw
 4345: 1  0E75	EC		                mov     a,r4
 4346: 1  0E76	C0 E0		                push    acc
 4347: 1  0E78	7C 01		                mov     r4,#1           ;acc0 x2
 4348: 1  0E7A	12 10 15	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4349: 1  0E7D	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4350: 1  0E7E	C0 E0		                push    acc
 4351: 1  0E80	EA		                mov     a,r2
 4352: 1  0E81	C0 E0		                push    acc
 4353: 1  0E83	E9		                mov     a,r1
 4354: 1  0E84	C0 E0		                push    acc
 4355: 1  0E86	E8		                mov     a,r0
 4356: 1  0E87	C0 E0		                push    acc             ;acc0 op stack

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4357: 1  0E89	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4358: 1  0E8B	12 10 15	                lcall   shiftleft32     ;acc0 =acc0 x4
 4359: 1  0E8E	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4360: 1  0E90	28		                add     a,r0            ;tel bij huidige acc0
 4361: 1  0E91	F8		                mov     r0,a
 4362: 1  0E92	D0 E0		                pop     acc
 4363: 1  0E94	39		                addc    a,r1
 4364: 1  0E95	F9		                mov     r1,a
 4365: 1  0E96	D0 E0		                pop     acc
 4366: 1  0E98	3A		                addc    a,r2
 4367: 1  0E99	FA		                mov     r2,a
 4368: 1  0E9A	D0 E0		                pop     acc
 4369: 1  0E9C	3B		                addc    a,r3
 4370: 1  0E9D	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4371: 1
 4372: 1
 4373: 1  0E9E	D0 E0		                pop     acc
 4374: 1  0EA0	FC		                mov     r4,a
 4375: 1  0EA1	D0 D0		                pop     psw
 4376: 1  0EA3	D0 E0		                pop     acc
 4377: 1  0EA5	22		                ret
 4378: 1
 4379: 1			;*******************************************************************************
 4380: 1			; mul16_100        (169,1us @16.777216MHz)
 4381: 1			; acc0 = acc0 x 100
 4382: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4383: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4384: 1			;
 4385: 1			; input:     r1,r0 = acc0 (low word)
 4386: 1			;
 4387: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4388: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4389: 1			; vernietigt:  niets
 4390: 1			;*******************************************************************************
 4391: 1  0EA6	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4392: 1  0EA8	C0 D0		                push    psw
 4393: 1  0EAA	EC		                mov     a,r4
 4394: 1  0EAB	C0 E0		                push    acc
 4395: 1  0EAD	7C 02		                mov     r4,#2           ;acc0 x4
 4396: 1  0EAF	12 10 15	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4397: 1  0EB2	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4398: 1  0EB3	C0 E0		                push    acc
 4399: 1  0EB5	EA		                mov     a,r2
 4400: 1  0EB6	C0 E0		                push    acc
 4401: 1  0EB8	E9		                mov     a,r1
 4402: 1  0EB9	C0 E0		                push    acc
 4403: 1  0EBB	E8		                mov     a,r0
 4404: 1  0EBC	C0 E0		                push    acc             ;acc0 op stack
 4405: 1
 4406: 1  0EBE	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4407: 1  0EC0	12 10 15	                lcall   shiftleft32     ;acc0 =acc0 x8
 4408: 1  0EC3	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4409: 1  0EC4	C0 E0		                push    acc
 4410: 1  0EC6	EA		                mov     a,r2
 4411: 1  0EC7	C0 E0		                push    acc
 4412: 1  0EC9	E9		                mov     a,r1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4413: 1  0ECA	C0 E0		                push    acc
 4414: 1  0ECC	E8		                mov     a,r0
 4415: 1  0ECD	C0 E0		                push    acc             ;acc0 op stack
 4416: 1
 4417: 1  0ECF	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4418: 1  0ED1	12 10 15	                lcall   shiftleft32     ;acc0 =acc0 x2
 4419: 1  0ED4	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4420: 1  0ED6	28		                add     a,r0            ;tel bij huidige acc0
 4421: 1  0ED7	F8		                mov     r0,a
 4422: 1  0ED8	D0 E0		                pop     acc
 4423: 1  0EDA	39		                addc    a,r1
 4424: 1  0EDB	F9		                mov     r1,a
 4425: 1  0EDC	D0 E0		                pop     acc
 4426: 1  0EDE	3A		                addc    a,r2
 4427: 1  0EDF	FA		                mov     r2,a
 4428: 1  0EE0	D0 E0		                pop     acc
 4429: 1  0EE2	3B		                addc    a,r3
 4430: 1  0EE3	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4431: 1
 4432: 1  0EE4	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4433: 1  0EE6	28		                add     a,r0            ;tel bij huidige acc0
 4434: 1  0EE7	F8		                mov     r0,a
 4435: 1  0EE8	D0 E0		                pop     acc
 4436: 1  0EEA	39		                addc    a,r1
 4437: 1  0EEB	F9		                mov     r1,a
 4438: 1  0EEC	D0 E0		                pop     acc
 4439: 1  0EEE	3A		                addc    a,r2
 4440: 1  0EEF	FA		                mov     r2,a
 4441: 1  0EF0	D0 E0		                pop     acc
 4442: 1  0EF2	3B		                addc    a,r3
 4443: 1  0EF3	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4444: 1
 4445: 1  0EF4	D0 E0		                pop     acc
 4446: 1  0EF6	FC		                mov     r4,a
 4447: 1  0EF7	D0 D0		                pop     psw
 4448: 1  0EF9	D0 E0		                pop     acc
 4449: 1  0EFB	22		                ret
 4450: 1
 4451: 1			;*******************************************************************************
 4452: 1			; sqrt32        (2,99ms @16.777216MHz)
 4453: 1			; acc0 = acc0 ^(1/2)
 4454: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4455: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4456: 1			;
 4457: 1			; input:     r3,r2,r1,r0 = acc0
 4458: 1			;
 4459: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4460: 1			;
 4461: 1			; vernietigt:  niets
 4462: 1			;*******************************************************************************
 4463: 1  0EFC	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4464: 1  0EFE	C0 F0		                push    b
 4465: 1  0F00	C0 D0		                push    psw
 4466: 1  0F02	C0 82		                push    dpl
 4467: 1  0F04	C0 83		                push    dph
 4468: 1  0F06	EC		                mov     a,r4

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4469: 1  0F07	C0 E0		                push    acc
 4470: 1  0F09	ED		                mov     a,r5
 4471: 1  0F0A	C0 E0		                push    acc
 4472: 1  0F0C	EE		                mov     a,r6
 4473: 1  0F0D	C0 E0		                push    acc
 4474: 1  0F0F	EF		                mov     a,r7
 4475: 1  0F10	C0 E0		                push    acc
 4476: 1
 4477: 1  0F12	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4478: 1  0F14	7D 00		                mov     r5,#0
 4479: 1  0F16	7E 00		                mov     r6,#0
 4480: 1  0F18	7F 00		                mov     r7,#0
 4481: 1  0F1A	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4482: 1  0F1D	75 83 00	                mov     dph,#0
 4483: 1  0F20	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4484: 1			;hier start het algorithme voor het berekenen van de wortel
 4485: 1  0F23	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4486: 1  0F25	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4487: 1  0F28	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4488: 1  0F29	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4489: 1  0F2A	33		                rlc     a                ;getest worden om een wortelbit te
 4490: 1  0F2B	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4491: 1  0F2C	E9		                mov     a,r1            ;met nullen!
 4492: 1  0F2D	33		                rlc     a
 4493: 1  0F2E	F9		                mov     r1,a
 4494: 1  0F2F	EA		                mov     a,r2
 4495: 1  0F30	33		                rlc     a
 4496: 1  0F31	FA		                mov     r2,a
 4497: 1  0F32	EB		                mov     a,r3
 4498: 1  0F33	33		                rlc     a
 4499: 1  0F34	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4500: 1
 4501: 1  0F35	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4502: 1  0F36	33		                rlc     a
 4503: 1  0F37	FC		                mov     r4,a
 4504: 1  0F38	ED		                mov     a,r5
 4505: 1  0F39	33		                rlc     a
 4506: 1  0F3A	FD		                mov     r5,a
 4507: 1  0F3B	EE		                mov     a,r6
 4508: 1  0F3C	33		                rlc     a
 4509: 1  0F3D	FE		                mov     r6,a
 4510: 1  0F3E	EF		                mov     a,r7
 4511: 1  0F3F	33		                rlc     a
 4512: 1  0F40	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4513: 1  0F41	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4514: 1
 4515: 1  0F44	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4516: 1
 4517: 1  0F46	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4518: 1  0F47	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4519: 1  0F49	33		                rlc     a
 4520: 1  0F4A	F5 82		                mov     dpl,a
 4521: 1  0F4C	E5 83		                mov     a,dph
 4522: 1  0F4E	33		                rlc     a
 4523: 1  0F4F	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4524: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4525: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4526: 1  0F51	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4527: 1  0F52	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4528: 1  0F54	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4529: 1  0F55	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4530: 1  0F57	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4531: 1  0F58	C0 E0		                push    acc             ;van acc1
 4532: 1  0F5A	EB		                mov     a,r3
 4533: 1  0F5B	C0 E0		                push    acc
 4534: 1  0F5D	EC		                mov     a,r4
 4535: 1  0F5E	C0 E0		                push    acc
 4536: 1  0F60	ED		                mov     a,r5
 4537: 1  0F61	C0 E0		                push    acc
 4538: 1  0F63	EE		                mov     a,r6
 4539: 1  0F64	C0 E0		                push    acc
 4540: 1  0F66	EF		                mov     a,r7
 4541: 1  0F67	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4542: 1
 4543: 1  0F69	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4544: 1  0F6B	AD 83		                mov     r5,dph
 4545: 1  0F6D	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4546: 1  0F6F	AF 83		                mov     r7,dph
 4547: 1  0F71	12 0A B2	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4548: 1
 4549: 1  0F74	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4550: 1  0F76	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4551: 1  0F77	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4552: 1  0F79	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4553: 1  0F7A	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4554: 1  0F7C	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4555: 1  0F7D	D0 E0		                pop     acc             ;de stack...
 4556: 1  0F7F	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4557: 1
 4558: 1  0F80	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4559: 1  0F81	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4560: 1  0F82	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4561: 1  0F83	E9		                mov     a,r1            ;in acc1.
 4562: 1  0F84	9D		                subb    a,r5            ;We doen dit door de carry van het
 4563: 1  0F85	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4564: 1  0F86	9E		                subb    a,r6
 4565: 1  0F87	EB		                mov     a,r3
 4566: 1  0F88	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4567: 1  0F89	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4568: 1			                                        ;wortel behouden
 4569: 1  0F8B	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4570: 1  0F8D	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4571: 1  0F8F	F5 82		                mov     dpl,a          ;wortel aanpassen
 4572: 1
 4573: 1  0F91	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4574: 1  0F93	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4575: 1  0F95	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4576: 1
 4577: 1  0F97	D0 E0		                pop     acc            ;haal acc1 weer op
 4578: 1  0F99	FF		                mov     r7,a
 4579: 1  0F9A	D0 E0		                pop     acc
 4580: 1  0F9C	FE		                mov     r6,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4581: 1  0F9D	D0 E0		                pop     acc
 4582: 1  0F9F	FD		                mov     r5,a
 4583: 1  0FA0	D0 E0		                pop     acc
 4584: 1  0FA2	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4585: 1
 4586: 1  0FA3	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4587: 1  0FA5	FB		                mov     r3,a
 4588: 1  0FA6	D0 E0		                pop     acc
 4589: 1  0FA8	FA		                mov     r2,a
 4590: 1  0FA9	D0 E0		                pop     acc
 4591: 1  0FAB	F9		                mov     r1,a
 4592: 1  0FAC	D0 E0		                pop     acc
 4593: 1  0FAE	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4594: 1
 4595: 1  0FAF	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4596: 1  0FB2	80 03		                sjmp    sqrt325
 4597: 1  0FB4	02 0F 23	sqrt324:        ljmp    sqrt320        ;uit acc0
 4598: 1
 4599: 1  0FB7	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4600: 1  0FB9	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4601: 1
 4602: 1  0FBB	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4603: 1  0FBD	FF		                mov     r7,a
 4604: 1  0FBE	D0 E0		                pop     acc
 4605: 1  0FC0	FE		                mov     r6,a
 4606: 1  0FC1	D0 E0		                pop     acc
 4607: 1  0FC3	FD		                mov     r5,a
 4608: 1  0FC4	D0 E0		                pop     acc
 4609: 1  0FC6	FC		                mov     r4,a           ;acc1 is hersteld
 4610: 1  0FC7	D0 83		                pop     dph
 4611: 1  0FC9	D0 82		                pop     dpl
 4612: 1  0FCB	D0 D0		                pop     psw
 4613: 1  0FCD	D0 F0		                pop     b
 4614: 1  0FCF	D0 E0		                pop     acc
 4615: 1
 4616: 1  0FD1	22		                ret                    ;eindelijk klaar...
 4617: 1
 4618: 1			;*******************************************************************************
 4619: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4620: 1			; acc0 = acc0 ^(1/2)
 4621: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4622: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4623: 1			;                           (-2147483648 tot +2147483647)
 4624: 1			; input:     r3,r2,r1,r0 = acc0
 4625: 1			;
 4626: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4627: 1			;            CY = 1 als acc0 negatief is
 4628: 1			; vernietigt:  niets
 4629: 1			;*******************************************************************************
 4630: 1  0FD2	C0 E0		s_sqrt32:       push    acc
 4631: 1  0FD4	C0 D0		                push    psw
 4632: 1  0FD6	EB		                mov     a,r3
 4633: 1  0FD7	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4634: 1  0FDA	D0 D0		                pop     psw
 4635: 1  0FDC	D3		                setb    c                ;als negatief dan error
 4636: 1  0FDD	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4637: 1  0FDF	22		                ret
 4638: 1  0FE0	D0 D0		s_sqrt321:      pop     psw
 4639: 1  0FE2	D0 E0		                pop     acc
 4640: 1  0FE4	12 0E FC	                lcall   sqrt32            ;wortel trekken
 4641: 1  0FE7	C3		                clr     c                 ;wortel ok
 4642: 1  0FE8	22		                ret                       ;klaar
 4643: 1
 4644: 1			;*******************************************************************************
 4645: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4646: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4647: 1			; (logical shift)
 4648: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4649: 1			;
 4650: 1			; input:     r3,r2,r1,r0 = acc0
 4651: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4652: 1			;
 4653: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4654: 1			;            CY=1 als N>=32
 4655: 1			; vernietigt:  niets
 4656: 1			;*******************************************************************************
 4657: 1  0FE9	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4658: 1  0FEB	C0 D0		                push    psw
 4659: 1  0FED	EC		                mov     a,r4            ;neem aantal shifts
 4660: 1  0FEE	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4661: 1  0FF1	40 06		shiftright1:    jc      shiftright2
 4662: 1  0FF3	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4663: 1  0FF5	D3		                setb    c               ;N buiten bereik
 4664: 1  0FF6	D0 E0		                pop     acc
 4665: 1  0FF8	22		                ret
 4666: 1
 4667: 1  0FF9	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4668: 1  0FFB	8C F0		                mov     b,r4            ;lusteller initialiseren
 4669: 1  0FFD	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4670: 1  0FFE	EB		                mov     a,r3            ;start bij msb
 4671: 1  0FFF	13		                rrc     a
 4672: 1  1000	FB		                mov     r3,a
 4673: 1  1001	EA		                mov     a,r2
 4674: 1  1002	13		                rrc     a
 4675: 1  1003	FA		                mov     r2,a
 4676: 1  1004	E9		                mov     a,r1
 4677: 1  1005	13		                rrc     a
 4678: 1  1006	F9		                mov     r1,a
 4679: 1  1007	E8		                mov     a,r0
 4680: 1  1008	13		                rrc     a
 4681: 1  1009	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4682: 1  100A	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4683: 1  100D	D0 F0		                pop     b               ;registers herstellen
 4684: 1  100F	D0 D0		                pop     psw
 4685: 1  1011	C3		                clr     c               ;N is binnen bereik
 4686: 1  1012	D0 E0		                pop     acc
 4687: 1  1014	22		                ret
 4688: 1
 4689: 1			;*******************************************************************************
 4690: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4691: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4692: 1			; (logical shift)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4693: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4694: 1			;
 4695: 1			; input:     r3,r2,r1,r0 = acc0
 4696: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4697: 1			;
 4698: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4699: 1			;
 4700: 1			; vernietigt:  niets
 4701: 1			;*******************************************************************************
 4702: 1  1015	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4703: 1  1017	C0 D0		                push    psw
 4704: 1  1019	EC		                mov     a,r4            ;neem aantal shifts
 4705: 1  101A	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4706: 1  101D	40 06		shiftleft1:     jc      shiftleft2
 4707: 1  101F	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4708: 1  1021	D3		                setb    c               ;N buiten bereik
 4709: 1  1022	D0 E0		                pop     acc
 4710: 1  1024	22		                ret
 4711: 1
 4712: 1  1025	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4713: 1  1027	8C F0		                mov     b,r4            ;lusteller initialiseren
 4714: 1  1029	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4715: 1  102A	E8		                mov     a,r0            ;start bij lsb
 4716: 1  102B	33		                rlc     a
 4717: 1  102C	F8		                mov     r0,a
 4718: 1  102D	E9		                mov     a,r1
 4719: 1  102E	33		                rlc     a
 4720: 1  102F	F9		                mov     r1,a
 4721: 1  1030	EA		                mov     a,r2
 4722: 1  1031	33		                rlc     a
 4723: 1  1032	FA		                mov     r2,a
 4724: 1  1033	EB		                mov     a,r3
 4725: 1  1034	33		                rlc     a
 4726: 1  1035	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4727: 1  1036	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4728: 1  1039	D0 F0		                pop     b               ;registers herstellen
 4729: 1  103B	D0 D0		                pop     psw
 4730: 1  103D	C3		                clr     c               ;N is binnen bereik
 4731: 1  103E	D0 E0		                pop     acc
 4732: 1  1040	22		                ret
 4733: 1
 4734: 1			;*******************************************************************************
 4735: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4736: 1			; (arithmetic shift)
 4737: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4738: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4739: 1			; niet van teken!
 4740: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4741: 1			;                       (-2147483648 tot +2147483647)
 4742: 1			;
 4743: 1			; input:     r3,r2,r1,r0 = acc0
 4744: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4745: 1			;
 4746: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4747: 1			;            CY=1 als N>=31
 4748: 1			; vernietigt:  niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4749: 1			;*******************************************************************************
 4750: 1  1041	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 4751: 1  1043	C0 D0		                push    psw
 4752: 1  1045	EC		                mov     a,r4            ;neem aantal shifts
 4753: 1  1046	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4754: 1  1049	40 06		s_shiftright1:  jc      s_shiftright2
 4755: 1  104B	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4756: 1  104D	D3		                setb    c               ;N buiten bereik
 4757: 1  104E	D0 E0		                pop     acc
 4758: 1  1050	22		                ret
 4759: 1
 4760: 1  1051	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4761: 1  1053	8C F0		                mov     b,r4            ;lusteller initialiseren
 4762: 1  1055	EB		                mov     a,r3
 4763: 1  1056	20 E7 04	                jb      acc.7,s_shiftright20
 4764: 1  1059	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4765: 1  105B	80 02		                sjmp    s_shiftright3
 4766: 1  105D	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4767: 1
 4768: 1  105F	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4769: 1  1061	EB		                mov     a,r3            ;start bij msb
 4770: 1  1062	13		                rrc     a
 4771: 1  1063	FB		                mov     r3,a
 4772: 1  1064	EA		                mov     a,r2
 4773: 1  1065	13		                rrc     a
 4774: 1  1066	FA		                mov     r2,a
 4775: 1  1067	E9		                mov     a,r1
 4776: 1  1068	13		                rrc     a
 4777: 1  1069	F9		                mov     r1,a
 4778: 1  106A	E8		                mov     a,r0
 4779: 1  106B	13		                rrc     a
 4780: 1  106C	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4781: 1  106D	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4782: 1  1070	D0 F0		                pop     b               ;registers herstellen
 4783: 1  1072	D0 D0		                pop     psw
 4784: 1  1074	C3		                clr     c               ;N is binnen bereik
 4785: 1  1075	D0 E0		                pop     acc
 4786: 1  1077	22		                ret
 4787: 1
 4788: 1			;*******************************************************************************
 4789: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4790: 1			; (arithmetic shift)
 4791: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4792: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 4793: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4794: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4795: 1			;                       (-2147483648 tot +2147483647)
 4796: 1			;
 4797: 1			; input:     r3,r2,r1,r0 = acc0
 4798: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4799: 1			;
 4800: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4801: 1			;            CY=1 als N>=31
 4802: 1			; vernietigt:  niets
 4803: 1			;*******************************************************************************
 4804: 1  1078	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4805: 1  107A	C0 D0		                push    psw
 4806: 1  107C	EC		                mov     a,r4            ;neem aantal shifts
 4807: 1  107D	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4808: 1  1080	40 06		s_shiftleft1:   jc      s_shiftleft2
 4809: 1  1082	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4810: 1  1084	D3		                setb    c               ;N buiten bereik
 4811: 1  1085	D0 E0		                pop     acc
 4812: 1  1087	22		                ret
 4813: 1
 4814: 1  1088	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4815: 1  108A	8C F0		                mov     b,r4            ;lusteller initialiseren
 4816: 1
 4817: 1
 4818: 1
 4819: 1  108C	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4820: 1  108D	E8		                mov     a,r0             ;start bij lsb
 4821: 1  108E	33		                rlc     a
 4822: 1  108F	F8		                mov     r0,a
 4823: 1  1090	E9		                mov     a,r1
 4824: 1  1091	33		                rlc     a
 4825: 1  1092	F9		                mov     r1,a
 4826: 1  1093	EA		                mov     a,r2
 4827: 1  1094	33		                rlc     a
 4828: 1  1095	FA		                mov     r2,a
 4829: 1  1096	EB		                mov     a,r3
 4830: 1  1097	33		                rlc     a
 4831: 1  1098	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4832: 1  109A	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4833: 1  109B	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4834: 1  109E	D0 F0		                pop     b                ;registers herstellen
 4835: 1  10A0	D0 D0		                pop     psw
 4836: 1  10A2	C3		                clr     c                ;N is binnen bereik
 4837: 1  10A3	D0 E0		                pop     acc
 4838: 1  10A5	22		                ret
 4839: 1
 4840: 1			;*******************************************************************************
 4841: 1			; s_cmp16    (29,5us @16.777216MHz)
 4842: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4843: 1			;
 4844: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4845: 1			;
 4846: 1			; input:     r1,r0 = acc0
 4847: 1			;            r5,r4 = acc1
 4848: 1			;
 4849: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4850: 1			;             f0=0,cy=0  als acc0 > acc1
 4851: 1			;             f0=1 cy=0    als acc1 = acc0
 4852: 1			;
 4853: 1			; vernietigt:  niets
 4854: 1			;*******************************************************************************
 4855: 1  10A6	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4856: 1  10A8	C0 D0		                push    psw
 4857: 1  10AA	E8		                mov     a,r0
 4858: 1  10AB	C0 E0		                push    acc
 4859: 1  10AD	E9		                mov     a,r1
 4860: 1  10AE	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4861: 1
 4862: 1  10B0	E9		                mov     a,r1            ;neem msb van acc0
 4863: 1  10B1	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4864: 1  10B2	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4865: 1  10B5	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4866: 1			                                        ;negatief is
 4867: 1  10B6	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4868: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4869: 1
 4870: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4871: 1			;acc0>acc1
 4872: 1  10B9	D0 E0		s_cmp160:       pop     acc
 4873: 1  10BB	F9		                mov     r1,a
 4874: 1  10BC	D0 E0		                pop     acc
 4875: 1  10BE	F8		                mov     r0,a
 4876: 1  10BF	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4877: 1  10C1	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4878: 1  10C3	C3		                clr     c               ;geef dit aan in de outputstatus
 4879: 1  10C4	D0 E0		                pop     acc
 4880: 1  10C6	22		                ret
 4881: 1			;acc0<acc1
 4882: 1  10C7	D0 E0		s_cmp161:       pop     acc
 4883: 1  10C9	F9		                mov     r1,a
 4884: 1  10CA	D0 E0		                pop     acc
 4885: 1  10CC	F8		                mov     r0,a
 4886: 1  10CD	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4887: 1  10CF	D3		                setb    c               ;groter dan acc0
 4888: 1  10D0	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4889: 1  10D2	D0 E0		                pop     acc
 4890: 1  10D4	22		                ret
 4891: 1			;gelijk teken, maak verschil
 4892: 1  10D5	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 4893: 1  10D6	E8		                mov     a,r0            ;acc0-acc1
 4894: 1  10D7	9C		                subb    a,r4
 4895: 1  10D8	F8		                mov     r0,a
 4896: 1  10D9	E9		                mov     a,r1
 4897: 1  10DA	9D		                subb    a,r5
 4898: 1  10DB	F9		                mov     r1,a
 4899: 1  10DC	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 4900: 1  10DF	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 4901: 1  10E0	60 02		                jz      s_cmp163        ;acc0=acc1
 4902: 1  10E2	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 4903: 1			;acc0=acc1
 4904: 1  10E4	D0 E0		s_cmp163:       pop     acc
 4905: 1  10E6	F9		                mov     r1,a
 4906: 1  10E7	D0 E0		                pop     acc
 4907: 1  10E9	F8		                mov     r0,a
 4908: 1  10EA	D0 D0		                pop     psw             ;acc0=acc1
 4909: 1  10EC	C3		                clr     c               ;geef dit aan in de outputstatus
 4910: 1  10ED	D2 D5		                setb    f0
 4911: 1  10EF	D0 E0		                pop     acc
 4912: 1  10F1	22		                ret
 4913: 1
 4914: 1			;*******************************************************************************
 4915: 1			; cmp16            (19,9us @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4916: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 4917: 1			;
 4918: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 4919: 1			;
 4920: 1			; input:     r1,r0 = acc0
 4921: 1			;            r5,r4 = acc1
 4922: 1			;
 4923: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4924: 1			;             f0=0,cy=0  als acc0 > acc1
 4925: 1			;             f0=1 cy=0    als acc1 = acc0
 4926: 1			;
 4927: 1			; vernietigt:  niets
 4928: 1			;*******************************************************************************
 4929: 1  10F2	C0 E0		cmp16:          push    acc             ;bewaar registers
 4930: 1  10F4	C0 F0		                push    b
 4931: 1  10F6	C0 D0		                push    psw
 4932: 1
 4933: 1  10F8	C3		                clr     c               ;vergelijk acc0 met acc1
 4934: 1  10F9	E9		                mov     a,r1            ;eerst de msb's
 4935: 1  10FA	8D F0		                mov     b,r5            ;test r1-r5
 4936: 1  10FC	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4937: 1
 4938: 1  10FF	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 4939: 1  1100	8C F0		                mov     b,r4            ;test r0-r4
 4940: 1  1102	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4941: 1			;acc0=acc1
 4942: 1  1105	D0 D0		                pop     psw
 4943: 1  1107	D2 D5		                setb    f0
 4944: 1  1109	C3		                clr     c
 4945: 1  110A	D0 F0		                pop     b
 4946: 1  110C	D0 E0		                pop     acc
 4947: 1  110E	22		                ret
 4948: 1  110F	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 4949: 1			;acc0>acc1
 4950: 1  1111	D0 D0		                pop     psw
 4951: 1  1113	C2 D5		                clr     f0
 4952: 1  1115	C3		                clr     c
 4953: 1  1116	D0 F0		                pop     b
 4954: 1  1118	D0 E0		                pop     acc
 4955: 1  111A	22		                ret
 4956: 1			;acc0<acc1
 4957: 1  111B	D0 D0		cmp162:         pop     psw
 4958: 1  111D	D3		                setb    c
 4959: 1  111E	C2 D5		                clr     f0
 4960: 1  1120	D0 F0		                pop     b
 4961: 1  1122	D0 E0		                pop     acc
 4962: 1  1124	22		                ret
 4963: 1
 4964: 1			;*******************************************************************************
 4965: 1			; s_cmp32        (44,3us @16.777216MHz)
 4966: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 4967: 1			;
 4968: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4969: 1			;                         -2147483648 tot +2147483647
 4970: 1			; input:     r1,r0 = acc0
 4971: 1			;            r5,r4 = acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4972: 1			;
 4973: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4974: 1			;             f0=0,cy=0  als acc0 > acc1
 4975: 1			;             f0=1 cy=0    als acc1 = acc0
 4976: 1			;
 4977: 1			; vernietigt:  niets
 4978: 1			;*******************************************************************************
 4979: 1  1125	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 4980: 1  1127	C0 D0		                push    psw
 4981: 1  1129	E8		                mov     a,r0
 4982: 1  112A	C0 E0		                push    acc
 4983: 1  112C	E9		                mov     a,r1
 4984: 1  112D	C0 E0		                push    acc
 4985: 1  112F	EA		                mov     a,r2
 4986: 1  1130	C0 E0		                push    acc
 4987: 1  1132	EB		                mov     a,r3
 4988: 1  1133	C0 E0		                push    acc
 4989: 1
 4990: 1  1135	EB		                mov     a,r3            ;neem msb van acc0
 4991: 1  1136	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 4992: 1  1137	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 4993: 1  1139	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 4994: 1  113B	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 4995: 1  113C	A2 E7		                mov     c,acc.7         ;negatief is
 4996: 1  113E	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 4997: 1			                                        ;acc1 positief. Dus acc1>acc0
 4998: 1			;acc0>acc1
 4999: 1  1140	D0 E0		s_cmp320:       pop     acc
 5000: 1  1142	FB		                mov     r3,a
 5001: 1  1143	D0 E0		                pop     acc
 5002: 1  1145	FA		                mov     r2,a
 5003: 1  1146	D0 E0		                pop     acc
 5004: 1  1148	F9		                mov     r1,a
 5005: 1  1149	D0 E0		                pop     acc
 5006: 1  114B	F8		                mov     r0,a
 5007: 1  114C	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5008: 1  114E	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5009: 1  1150	C3		                clr     c               ;geef dit aan in de outputstatus
 5010: 1  1151	D0 E0		                pop     acc
 5011: 1  1153	22		                ret
 5012: 1			;acc0<acc1
 5013: 1  1154	D0 E0		s_cmp321:       pop     acc
 5014: 1  1156	FB		                mov     r3,a
 5015: 1  1157	D0 E0		                pop     acc
 5016: 1  1159	FA		                mov     r2,a
 5017: 1  115A	D0 E0		                pop     acc
 5018: 1  115C	F9		                mov     r1,a
 5019: 1  115D	D0 E0		                pop     acc
 5020: 1  115F	F8		                mov     r0,a
 5021: 1  1160	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5022: 1  1162	D3		                setb    c               ;groter dan acc0
 5023: 1  1163	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5024: 1  1165	D0 E0		                pop     acc
 5025: 1  1167	22		                ret
 5026: 1			;gelijk teken, maak verschil
 5027: 1  1168	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5028: 1  1169	E8		                mov     a,r0            ;acc0-acc1
 5029: 1  116A	9C		                subb    a,r4
 5030: 1  116B	F8		                mov     r0,a
 5031: 1  116C	E9		                mov     a,r1
 5032: 1  116D	9D		                subb    a,r5
 5033: 1  116E	F9		                mov     r1,a
 5034: 1  116F	EA		                mov     a,r2
 5035: 1  1170	9E		                subb    a,r6
 5036: 1  1171	FA		                mov     r2,a
 5037: 1  1172	EB		                mov     a,r3
 5038: 1  1173	9F		                subb    a,r7
 5039: 1  1174	FB		                mov     r3,a
 5040: 1  1175	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5041: 1  1178	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5042: 1  1179	49		                orl     a,r1
 5043: 1  117A	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5044: 1  117B	60 02		                jz      s_cmp323        ;acc0=acc1
 5045: 1  117D	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5046: 1			;acc0=acc1
 5047: 1  117F	D0 E0		s_cmp323:       pop     acc
 5048: 1  1181	FB		                mov     r3,a
 5049: 1  1182	D0 E0		                pop     acc
 5050: 1  1184	FA		                mov     r2,a
 5051: 1  1185	D0 E0		                pop     acc
 5052: 1  1187	F9		                mov     r1,a
 5053: 1  1188	D0 E0		                pop     acc
 5054: 1  118A	F8		                mov     r0,a
 5055: 1  118B	D0 D0		                pop     psw             ;acc0=acc1
 5056: 1  118D	C3		                clr     c               ;geef dit aan in de outputstatus
 5057: 1  118E	D2 D5		                setb    f0
 5058: 1  1190	D0 E0		                pop     acc
 5059: 1  1192	22		                ret
 5060: 1
 5061: 1			;*******************************************************************************
 5062: 1			; cmp32        (27,14us @16.777216MHz)
 5063: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5064: 1			;
 5065: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5066: 1			;
 5067: 1			; input:     r3,r2,r1,r0 = acc0
 5068: 1			;            r7,r6,r5,r4 = acc1
 5069: 1			;
 5070: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5071: 1			;            f0=0,cy=0  als acc0 > acc1
 5072: 1			;            f0=1 cy=0    als acc1 = acc0
 5073: 1			;
 5074: 1			; vernietigt:  niets
 5075: 1			;*******************************************************************************
 5076: 1  1193	C0 E0		cmp32:          push    acc             ;bewaar registers
 5077: 1  1195	C0 F0		                push    b
 5078: 1  1197	C0 D0		                push    psw
 5079: 1
 5080: 1  1199	C3		                clr     c               ;vergelijk acc0 met acc1
 5081: 1  119A	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5082: 1  119B	8F F0		                mov     b,r7            ;test r3-r7
 5083: 1  119D	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5084: 1
 5085: 1  11A0	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5086: 1  11A1	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5087: 1  11A3	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5088: 1
 5089: 1  11A6	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5090: 1  11A7	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5091: 1  11A9	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5092: 1
 5093: 1  11AC	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5094: 1  11AD	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5095: 1  11AF	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5096: 1			;acc0=acc1
 5097: 1  11B2	D0 D0		                pop     psw
 5098: 1  11B4	D2 D5		                setb    f0
 5099: 1  11B6	C3		                clr     c
 5100: 1  11B7	D0 F0		                pop     b
 5101: 1  11B9	D0 E0		                pop     acc
 5102: 1  11BB	22		                ret
 5103: 1  11BC	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5104: 1			;acc0>acc1, indien cy=0
 5105: 1  11BE	D0 D0		                pop     psw
 5106: 1  11C0	C2 D5		                clr     f0
 5107: 1  11C2	C3		                clr     c
 5108: 1  11C3	D0 F0		                pop     b
 5109: 1  11C5	D0 E0		                pop     acc
 5110: 1  11C7	22		                ret
 5111: 1			;acc0<acc1
 5112: 1  11C8	D0 D0		cmp322:         pop     psw
 5113: 1  11CA	D3		                setb    c
 5114: 1  11CB	C2 D5		                clr     f0
 5115: 1  11CD	D0 F0		                pop     b
 5116: 1  11CF	D0 E0		                pop     acc
 5117: 1  11D1	22		                ret
 5118: 1
 5119: 1
 5120: 1			;*******************************************************************************
 5121: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5122: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5123: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5124: 1			; adres zitten.
 5125: 1			;
 5126: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5127: 1			;
 5128: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5129: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5130: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5131: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5132: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5133: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5134: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5135: 1			;                cy = 0  lookup is ok
 5136: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5137: 1			; vernietigt:  niets
 5138: 1			;*******************************************************************************
 5139: 1  11D2	C0 E0		table_lu:       push    acc             ;bewaren registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5140: 1  11D4	C0 D0		                push    psw
 5141: 1  11D6	C0 82		                push    dpl
 5142: 1  11D8	C0 83		                push    dph
 5143: 1
 5144: 1  11DA	A2 D5		                mov     c,f0            ;byte of word items?
 5145: 1  11DC	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5146: 1			;tabel met byte items
 5147: 1  11DE	E5 82		                mov     a,dpl           ;datapointer plus index
 5148: 1  11E0	28		                add     a,r0
 5149: 1  11E1	F5 82		                mov     dpl,a
 5150: 1  11E3	E5 83		                mov     a,dph
 5151: 1  11E5	39		                addc    a,r1
 5152: 1  11E6	F5 83		                mov     dph,a
 5153: 1  11E8	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5154: 1  11EA	A2 D1		                mov     c,f1            ;code of datageheugen?
 5155: 1  11EC	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5156: 1
 5157: 1			;bytetabel in codegeheugen
 5158: 1  11EE	74 00		                mov     a,#0
 5159: 1  11F0	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5160: 1  11F1	F8		                mov     r0,a            ;en stop in acc0
 5161: 1  11F2	79 00		                mov     r1,#0
 5162: 1  11F4	02 12 53	                ljmp    table_lu4       ;en klaar
 5163: 1
 5164: 1			;bytetabel in datageheugen
 5165: 1  11F7	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5166: 1  11F8	F8		                mov     r0,a            ;en stop in acc0
 5167: 1  11F9	79 00		                mov     r1,#0
 5168: 1  11FB	02 12 53	                ljmp    table_lu4       ;en klaar
 5169: 1
 5170: 1  11FE	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5171: 1  1200	D0 82		                pop     dpl
 5172: 1  1202	D0 D0		                pop     psw
 5173: 1  1204	D3		                setb    c              ;foutstatus teruggeven!
 5174: 1  1205	D0 E0		                pop     acc
 5175: 1  1207	22		                ret
 5176: 1
 5177: 1			;tabel met word items
 5178: 1  1208	E8		table_lu2:      mov     a,r0            ;index op stack
 5179: 1  1209	C0 E0		                push    acc
 5180: 1  120B	E9		                mov     a,r1
 5181: 1  120C	C0 E0		                push    acc
 5182: 1
 5183: 1  120E	C3		                clr      c              ;index maal 2 (word items)
 5184: 1  120F	E8		                mov     a,r0
 5185: 1  1210	33		                rlc     a
 5186: 1  1211	F8		                mov     r0,a
 5187: 1  1212	E9		                mov     a,r1
 5188: 1  1213	33		                rlc     a
 5189: 1  1214	F9		                mov     r1,a
 5190: 1
 5191: 1  1215	E5 82		                mov     a,dpl           ;datapointer plus index
 5192: 1  1217	28		                add     a,r0
 5193: 1  1218	F5 82		                mov     dpl,a
 5194: 1  121A	E5 83		                mov     a,dph
 5195: 1  121C	39		                addc    a,r1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5196: 1  121D	F5 83		                mov     dph,a
 5197: 1
 5198: 1  121F	D0 E0		                pop     acc             ;index weer van stack
 5199: 1  1221	F9		                mov     r1,a
 5200: 1  1222	D0 E0		                pop     acc
 5201: 1  1224	F8		                mov     r0,a
 5202: 1
 5203: 1  1225	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5204: 1  1227	A2 D1		                mov     c,f1            ;code of datageheugen?
 5205: 1  1229	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5206: 1			;wordtabel in codegeheugen
 5207: 1  122B	74 00		                mov     a,#0
 5208: 1  122D	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5209: 1  122E	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5210: 1  122F	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5211: 1  1231	24 01		                add     a,#1
 5212: 1  1233	F5 82		                mov     dpl,a
 5213: 1  1235	E5 83		                mov     a,dph
 5214: 1  1237	34 00		                addc    a,#0
 5215: 1  1239	F5 83		                mov     dph,a
 5216: 1  123B	74 00		                mov     a,#0
 5217: 1  123D	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5218: 1  123E	F9		                mov     r1,a            ;msb in acc0 stoppen
 5219: 1  123F	80 12		                sjmp    table_lu4        ;en klaar
 5220: 1			;wordtabel    in datageheugen
 5221: 1  1241	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5222: 1  1242	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5223: 1  1243	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5224: 1  1245	24 01		                add     a,#1
 5225: 1  1247	F5 82		                mov     dpl,a
 5226: 1  1249	E5 83		                mov     a,dph
 5227: 1  124B	34 00		                addc    a,#0
 5228: 1  124D	F5 83		                mov     dph,a
 5229: 1  124F	74 00		                mov     a,#0
 5230: 1  1251	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5231: 1  1252	F9		                mov     r1,a            ;msb in acc0 stoppen
 5232: 1			                                        ;en klaar
 5233: 1
 5234: 1  1253	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5235: 1  1255	D0 82		                pop     dpl
 5236: 1  1257	D0 D0		                pop     psw
 5237: 1  1259	D0 E0		                pop     acc
 5238: 1  125B	22		                ret
 5239: 1
 5240: 1
 5241: 1
 5242: 1			;*******************************************************************************
 5243: 1			; Cordic        (2,11ms @16.777216MHz)
 5244: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5245: 1			; waarde (2's complement) opgegeven hoek.
 5246: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5247: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5248: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5249: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5250: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5251: 1			; als geschaalde getallen ter beschikking komen.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5252: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5253: 1			;
 5254: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5255: 1			;
 5256: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5257: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5258: 1			;            cy = 0 : hoek binnen bereik
 5259: 1			;            cy = 1 : error, hoek buiten bereik
 5260: 1			;            nauwkeurigheid: 12 msbits
 5261: 1			; vernietigt:  niets
 5262: 1			;*******************************************************************************
 5263: 1  125C	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5264: 1  125E	C0 D0		                push    psw
 5265: 1  1260	C0 83		                push    dph
 5266: 1  1262	C0 82		                push    dpl
 5267: 1  1264	C0 F0		                push    b
 5268: 1
 5269: 1  1266	EF		                mov     a,r7
 5270: 1  1267	C0 E0		                push    acc
 5271: 1  1269	EE		                mov     a,r6
 5272: 1  126A	C0 E0		                push    acc
 5273: 1  126C	ED		                mov     a,r5
 5274: 1  126D	C0 E0		                push    acc
 5275: 1  126F	EC		                mov     a,r4
 5276: 1  1270	C0 E0		                push    acc
 5277: 1
 5278: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5279: 1			;en niet groter dan pi/2 radialen (6478h)
 5280: 1  1272	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5281: 1  1274	7D 64		                mov     r5,#64h
 5282: 1  1276	12 10 F2	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5283: 1  1279	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5284: 1  127C	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5285: 1  127E	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5286: 1
 5287: 1  1280	C2 A0		cordic000:      clr     p2.0
 5288: 1  1282	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5289: 1  1284	7D 9B		                mov     r5,#9bh
 5290: 1  1286	12 10 F2	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5291: 1  1289	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5292: 1  128C	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5293: 1  128E	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5294: 1
 5295: 1  1290	C2 A1		cordic_error:   clr     p2.1
 5296: 1  1292	02 13 44	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5297: 1
 5298: 1			;Hoek is -pi/2 resultaat gekend
 5299: 1  1295	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5300: 1  1297	7A 00		                mov     r2,#000h
 5301: 1  1299	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5302: 1  129B	78 00		                mov     r0,#000h
 5303: 1  129D	C3		                clr     c
 5304: 1  129E	02 13 44	                ljmp    cordic40        ;en klaar
 5305: 1			;hoek is +pi/2 resultaat gekend
 5306: 1  12A1	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5307: 1  12A3	7A FF		                mov     r2,#0ffh

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5308: 1  12A5	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5309: 1  12A7	78 00		                mov     r0,#000h
 5310: 1  12A9	C3		                clr     c
 5311: 1  12AA	02 13 44	                ljmp    cordic40        ;en klaar
 5312: 1
 5313: 1  12AD	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5314: 1  12AF	7D 00		                mov     r5,#00h
 5315: 1  12B1	12 10 F2	                lcall   cmp16            ;vergelijk de hoeken
 5316: 1  12B4	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5317: 1  12B7	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5318: 1			;hoek is 0, resultaat gekend
 5319: 1  12B9	C2 A7		cordic_nul:     clr     p2.7
 5320: 1  12BB	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5321: 1  12BD	7A 00		                mov     r2,#000h
 5322: 1  12BF	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5323: 1  12C1	78 FF		                mov     r0,#0ffh
 5324: 1  12C3	C3		                clr     c
 5325: 1  12C4	02 13 44	                ljmp    cordic40        ;en klaar
 5326: 1
 5327: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5328: 1  12C7	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5329: 1  12C8	C0 E0		                push    acc
 5330: 1  12CA	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5331: 1  12CB	C0 E0		                push    acc
 5332: 1
 5333: 1  12CD	7B 00		                mov     r3,#00h         ;y=0
 5334: 1  12CF	7A 00		                mov     r2,#00h
 5335: 1  12D1	79 26		                mov     r1,#026h        ;x = K * 2^14
 5336: 1  12D3	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5337: 1
 5338: 1  12D5	75 F0 00	                mov     b,#00h          ;loopteller=0
 5339: 1
 5340: 1  12D8	90 13 9C	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5341: 1
 5342: 1  12DB	EB		cordic1:        mov     a,r3            ;sry=y
 5343: 1  12DC	FF		                mov     r7,a
 5344: 1  12DD	EA		                mov     a,r2
 5345: 1  12DE	FE		                mov     r6,a
 5346: 1  12DF	E9		                mov     a,r1            ;srx=x
 5347: 1  12E0	FD		                mov     r5,a
 5348: 1  12E1	E8		                mov     a,r0
 5349: 1  12E2	FC		                mov     r4,a
 5350: 1
 5351: 1  12E3	12 13 63	                lcall   cordic5          ;srx en sry >> loopteller
 5352: 1
 5353: 1  12E6	D0 E0		                pop     acc
 5354: 1  12E8	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5355: 1
 5356: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5357: 1  12EB	C3		                clr     c
 5358: 1  12EC	E8		                mov     a,r0            ;bereken x=x-sry
 5359: 1  12ED	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5360: 1  12EE	F8		                mov     r0,a
 5361: 1  12EF	E9		                mov     a,r1
 5362: 1  12F0	9F		                subb    a,r7
 5363: 1  12F1	F9		                mov     r1,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5364: 1
 5365: 1  12F2	EA		                mov     a,r2            ;bereken y=y+srx
 5366: 1  12F3	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5367: 1  12F4	FA		                mov     r2,a
 5368: 1  12F5	EB		                mov     a,r3
 5369: 1  12F6	3D		                addc    a,r5
 5370: 1  12F7	FB		                mov     r3,a
 5371: 1
 5372: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5373: 1  12F8	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5374: 1  12FA	93		                movc    a,@a+dptr
 5375: 1  12FB	A3		                inc     dptr
 5376: 1  12FC	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5377: 1  12FD	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5378: 1  12FF	C3		                clr     c               ;verklein de hoek
 5379: 1  1300	9C		                subb    a,r4
 5380: 1  1301	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5381: 1  1303	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5382: 1
 5383: 1  1305	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5384: 1  1307	93		                movc    a,@a+dptr
 5385: 1  1308	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5386: 1  1309	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5387: 1  130A	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5388: 1  130C	9D		                subb    a,r5            ;verklein de hoek
 5389: 1  130D	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5390: 1
 5391: 1			;loopteller incrementeren en testen op einde van de iteratie
 5392: 1  130F	05 F0		cordic2:        inc     b               ;loopteller++
 5393: 1  1311	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5394: 1  1313	65 F0		                xrl     a,b             ;test op gelijkheid
 5395: 1  1315	60 28		                jz      cordic4         ;ja klaar!
 5396: 1  1317	02 12 DB	                ljmp    cordic1         ;nee, nog even verder...
 5397: 1
 5398: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5399: 1  131A	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5400: 1  131B	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5401: 1  131C	F8		                mov     r0,a
 5402: 1  131D	E9		                mov     a,r1
 5403: 1  131E	3F		                addc    a,r7
 5404: 1  131F	F9		                mov     r1,a
 5405: 1
 5406: 1  1320	C3		                clr     c
 5407: 1  1321	EA		                mov     a,r2            ;bereken y=y-srx
 5408: 1  1322	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5409: 1  1323	FA		                mov     r2,a
 5410: 1  1324	EB		                mov     a,r3
 5411: 1  1325	9D		                subb    a,r5
 5412: 1  1326	FB		                mov     r3,a
 5413: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5414: 1  1327	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5415: 1  1329	93		                movc    a,@a+dptr
 5416: 1  132A	A3		                inc     dptr
 5417: 1  132B	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5418: 1  132C	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5419: 1  132E	2C		                add     a,r4            ;vergroot de hoek

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5420: 1  132F	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5421: 1  1331	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5422: 1
 5423: 1  1333	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5424: 1  1335	93		                movc    a,@a+dptr
 5425: 1  1336	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5426: 1  1337	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5427: 1  1338	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5428: 1  133A	3D		                addc    a,r5            ;vergroot de hoek
 5429: 1  133B	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5430: 1
 5431: 1  133D	80 D0		                sjmp    cordic2
 5432: 1
 5433: 1  133F	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5434: 1  1341	D0 E0		                pop     acc             ;dummy hoek van stack
 5435: 1  1343	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5436: 1
 5437: 1  1344	D0 E0		cordic40:       pop     acc
 5438: 1  1346	FC		                mov     r4,a
 5439: 1  1347	D0 E0		                pop     acc
 5440: 1  1349	FD		                mov     r5,a
 5441: 1  134A	D0 E0		                pop     acc
 5442: 1  134C	FE		                mov     r6,a
 5443: 1  134D	D0 E0		                pop     acc
 5444: 1  134F	FF		                mov     r7,a
 5445: 1  1350	D0 F0		                pop     b
 5446: 1  1352	D0 82		                pop     dpl
 5447: 1  1354	D0 83		                pop     dph
 5448: 1  1356	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5449: 1  1358	D0 D0		                pop     psw
 5450: 1  135A	D0 E0		                pop     acc
 5451: 1  135C	22		                ret
 5452: 1
 5453: 1  135D	D0 D0		cordic41:       pop     psw
 5454: 1  135F	D3		                setb    c
 5455: 1  1360	D0 E0		                pop     acc
 5456: 1  1362	22		                ret
 5457: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5458: 1			;over het aantal posities aangegeven in het B register.
 5459: 1  1363	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5460: 1  1365	74 00		                mov     a,#0            ;test of loopteller=0
 5461: 1  1367	65 F0		                xrl     a,b
 5462: 1  1369	60 2E		                jz      cordic52        ;klaar
 5463: 1
 5464: 1  136B	ED		                mov     a,r5            ;test teken van srx
 5465: 1  136C	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5466: 1  136F	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5467: 1  1371	80 02		                sjmp    cordic50
 5468: 1  1373	D2 D5		cordic5a:       setb    f0
 5469: 1  1375	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5470: 1  1377	ED		                mov     a,r5            ;eerst de msb
 5471: 1  1378	13		                rrc     a
 5472: 1  1379	FD		                mov     r5,a
 5473: 1  137A	EC		                mov     a,r4            ;dan de lsb
 5474: 1  137B	13		                rrc     a
 5475: 1  137C	FC		                mov     r4,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5476: 1  137D	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5477: 1  1380	D0 F0		                pop     b               ;haal de loopteller van stack
 5478: 1  1382	C0 F0		                push    b               ;en bewaar hem weer
 5479: 1  1384	EF		                mov     a,r7            ;test teken van sry
 5480: 1  1385	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5481: 1  1388	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5482: 1  138A	80 02		                sjmp    cordic51
 5483: 1  138C	D2 D5		cordic5b:       setb    f0
 5484: 1  138E	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5485: 1  1390	EF		                mov     a,r7            ;eerst de msb
 5486: 1  1391	13		                rrc     a
 5487: 1  1392	FF		                mov     r7,a
 5488: 1  1393	EE		                mov     a,r6            ;dan de lsb
 5489: 1  1394	13		                rrc     a
 5490: 1  1395	FE		                mov     r6,a
 5491: 1  1396	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5492: 1
 5493: 1  1399	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5494: 1  139B	22		                ret
 5495: 1
 5496: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5497: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5498: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5499: 1  139C	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5500: 1  139E	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5501: 1  13A0	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5502: 1  13A2	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5503: 1  13A4	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5504: 1  13A6	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5505: 1  13A8	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5506: 1  13AA	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5507: 1  13AC	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5508: 1  13AE	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5509: 1  13B0	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5510: 1  13B2	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5511: 1  13B4	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5512: 1  13B6	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5513: 1  13B8	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5514: 1
 5515: 1			endif        ;einde van aduc_math
 5516: 1			;******************************************************************************
 5517: 1
 5518: 1			ifdef        aduc_adc    ;A/D conversie routines
 5519: 1			;*******************************************************************************
 5520: 1			; ADuCADC_mide
 5521: 1			; Geschreven door [dp] op 5/1/2014
 5522: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5523: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5524: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5525: 1			; bron instellen.
 5526: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5527: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5528: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5529: 1			;
 5530: 1			;*******************************************************************************
 5531: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5532: 1			;*******************************************************************************
 5533: 1			; adc_init
 5534: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5535: 1			; -  4 track&hold clockperiodes
 5536: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5537: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5538: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5539: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5540: 1			;
 5541: 1			; input: R0 =  0  : Interne referentiebron
 5542: 1			;        R0 <> 0  : Externe referentiebron
 5543: 1			;
 5544: 1			; Deze routine vernietigt niets
 5545: 1			;*******************************************************************************
 5546: 1  13BA	C0 E0		adc_init:       push    acc                 ;registers op stack
 5547: 1  13BC	C0 D0		                push    psw
 5548: 1  13BE	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5549: 1  13C1	E8		                mov     a,r0                ;welke referentiebron?
 5550: 1  13C2	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5551: 1  13C4	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5552: 1  13C7	D0 D0		adc_init1:      pop     psw
 5553: 1  13C9	D0 E0		                pop     acc
 5554: 1  13CB	22		                ret
 5555: 1
 5556: 1			;*******************************************************************************
 5557: 1			; adc_single
 5558: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5559: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5560: 1			; (2's complement) formaat van de meetwaarde.
 5561: 1			; _____________________________________________________________
 5562: 1			; resolutie  |     unsigned      |           signed            |
 5563: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5564: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5565: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5566: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5567: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5568: 1			; _____________________________________________________________
 5569: 1			;
 5570: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5571: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5572: 1			; De ingangsparameter wordt doorgegeven via R0.
 5573: 1			;
 5574: 1			; input:
 5575: 1			;             7    6    5    4    3    2    1    0
 5576: 1			;           _______________________________________
 5577: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5578: 1			;           ---------------------------------------
 5579: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5580: 1			;                                         1000b = temp.sensor
 5581: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5582: 1			;                                   10b = 12 bits, 11b = 12 bits
 5583: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5584: 1			;
 5585: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5586: 1			;         cy=0  bij conversie ok
 5587: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5588: 1			;
 5589: 1			; Deze routine vernietigt niets
 5590: 1			;*******************************************************************************
 5591: 1  13CC	C0 E0		adc_single:     push    acc                 ;registers op stack
 5592: 1  13CE	C0 D0		                push    psw
 5593: 1  13D0	C0 F0		                push    b
 5594: 1  13D2	E8		                mov     a,r0                ;neem inputparameter
 5595: 1  13D3	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5596: 1  13D5	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5597: 1  13D8	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5598: 1  13DA	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5599: 1  13DC	D2 DC		                setb    sconv               ;start een meting
 5600: 1  13DE	E8		                mov     a,r0                ;neem parameter terug
 5601: 1  13DF	A2 E6		                mov     c,acc.6
 5602: 1  13E1	92 D5		                mov     f0,c                ;bewaar format bit
 5603: 1  13E3	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5604: 1  13E6	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5605: 1  13E9	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5606: 1  13EC	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5607: 1			;*******************************************************************************
 5608: 1			;8 bit resultaat gevraagd
 5609: 1			;*******************************************************************************
 5610: 1  13EF	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5611: 1  13F1	C4		                swap    a                    ;swap nibbles
 5612: 1  13F2	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5613: 1  13F4	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5614: 1  13F6	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5615: 1  13F8	C4		                swap    a
 5616: 1  13F9	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5617: 1  13FB	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5618: 1			;8 bit unsigned formaat
 5619: 1  13FE	79 00		                mov     r1,#00h              ;unsigned
 5620: 1  1400	F8		                mov     r0,a
 5621: 1  1401	80 63		                sjmp    adc_single42
 5622: 1			;8 bit signed formaat
 5623: 1  1403	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5624: 1  1406	24 80		                add     a,#80h                ;negatief getal van maken
 5625: 1  1408	F8		                mov     r0,a
 5626: 1  1409	79 FF		                mov     r1,#0ffh
 5627: 1  140B	80 59		                sjmp    adc_single42
 5628: 1  140D	C3		adc_single20:   clr     c
 5629: 1  140E	94 80		                subb    a,#80h                ;positief deel verkleinen
 5630: 1  1410	F8		                mov     r0,a
 5631: 1  1411	79 00		                mov     r1,#00h
 5632: 1  1413	80 51		                sjmp    adc_single42
 5633: 1
 5634: 1  1415	02 14 6E	adc_single21:   ljmp    adc_single43
 5635: 1			;*******************************************************************************
 5636: 1			;10 bit resultaat gevraagd
 5637: 1			;*******************************************************************************
 5638: 1  1418	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5639: 1  141A	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5640: 1  141C	03		                rr     a              ;naar msbits roteren
 5641: 1  141D	03		                rr     a
 5642: 1  141E	F5 F0		                mov    b,a            ;even bewaren
 5643: 1  1420	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5644: 1  1422	03		                rr     a              ;twee plaatsen opschuiven
 5645: 1  1423	03		                rr     a
 5646: 1  1424	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5647: 1  1426	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5648: 1  1428	F5 F0		                mov    b,a            ;low byte even bewaren
 5649: 1  142A	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5650: 1  142C	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5651: 1  142E	03		                rr     a               ;en op hun plaats schuiven
 5652: 1  142F	03		                rr     a
 5653: 1  1430	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5654: 1			;10 bit unsigned formaat
 5655: 1  1433	F9		                mov    r1,a            ;unsigned
 5656: 1  1434	A8 F0		                mov    r0,b
 5657: 1  1436	80 2E		                sjmp   adc_single42
 5658: 1			;10 bit signed formaat
 5659: 1  1438	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5660: 1  143B	24 FE		                add    a,#0feh             ;negatief getal van maken
 5661: 1  143D	F9		                mov    r1,a
 5662: 1  143E	A8 F0		                mov    r0,b
 5663: 1  1440	80 24		                sjmp   adc_single42
 5664: 1  1442	C3		adc_single31:   clr    c
 5665: 1  1443	94 02		                subb   a,#02h              ;positief deel verkleinen
 5666: 1  1445	F9		                mov    r1,a
 5667: 1  1446	A8 F0		                mov    r0,b
 5668: 1  1448	80 1C		                sjmp   adc_single42
 5669: 1
 5670: 1			;*******************************************************************************
 5671: 1			;12 bit resultaat gevraagd
 5672: 1			;*******************************************************************************
 5673: 1  144A	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5674: 1  144C	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5675: 1  144E	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5676: 1			;12 bit unsigned formaat
 5677: 1  1451	A8 D9		                mov    r0,adcdatal           ;unsigned
 5678: 1  1453	F9		                mov    r1,a
 5679: 1  1454	80 10		                sjmp   adc_single42
 5680: 1			;12 bit signed formaat
 5681: 1  1456	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5682: 1  1459	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5683: 1  145B	F9		                mov    r1,a
 5684: 1  145C	A8 D9		                mov    r0,adcdatal
 5685: 1  145E	80 06		                sjmp   adc_single42
 5686: 1  1460	C3		adc_single41:   clr    c
 5687: 1  1461	94 08		                subb   a,#08h                ;positief deel verkleinen
 5688: 1  1463	F9		                mov    r1,a
 5689: 1  1464	A8 D9		                mov    r0,adcdatal
 5690: 1  1466	D0 F0		adc_single42:   pop    b
 5691: 1  1468	D0 D0		                pop    psw
 5692: 1  146A	C3		                clr    c
 5693: 1  146B	D0 E0		                pop    acc
 5694: 1  146D	22		                ret
 5695: 1
 5696: 1  146E	D0 F0		adc_single43:   pop    b
 5697: 1  1470	D0 D0		                pop    psw
 5698: 1  1472	D3		                setb   c
 5699: 1  1473	D0 E0		                pop    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5700: 1  1475	22		                ret
 5701: 1
 5702: 1			endif        ;einde van aduc_adc
 5703: 1			;*******************************************************************************
 5704: 1
 5705: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5706: 1			;******************************************************************************
 5707: 1			; ADuCKEY_mide.inc
 5708: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5709: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5710: 1			;
 5711: 1			;     V2.0      V1.1
 5712: 1			;                           |   |   |   |
 5713: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5714: 1			;                   |       |   |   |   |
 5715: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5716: 1			;                   |       |   |   |   |
 5717: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5718: 1			;                   |       |   |   |   |
 5719: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5720: 1			;                   |       |   |   |   |
 5721: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5722: 1			;                   |           |   |   |
 5723: 1			;     P0.5      P3.5|-K2--------|   |   |
 5724: 1			;                   |               |   |
 5725: 1			;     P0.6      P3.6|-K3------------|   |
 5726: 1			;                   |                   |
 5727: 1			;     P0.7      P3.7|-K4----------------|
 5728: 1			;
 5729: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5730: 1			; gebruikt.
 5731: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5732: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5733: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5734: 1			; en als ingang wordt aangeboden.
 5735: 1			;
 5736: 1			;                                  ___                 ___
 5737: 1			;                     ____________|   |  |------------|   |
 5738: 1			;              ____  |   ____     |   |  |   ____     |   |
 5739: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5740: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5741: 1			; '1'= toets  | cl |    | cl |              | cl |
 5742: 1			;  ingedrukt  |____|    |____|              |____|
 5743: 1			;                |         |                   |
 5744: 1			;      CLOCK     |         |                   |
 5745: 1			;         _______|_________|___________________|
 5746: 1			;
 5747: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 5748: 1			;
 5749: 1			;              MAP0      MAP1                 MAP2         MAP3
 5750: 1			;
 5751: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5752: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5753: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5754: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5755: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5756: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5757: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 5758: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5759: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5760: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5761: 1			;
 5762: 1			;          MAP0    MAP1          MAP2    MAP3
 5763: 1			;         _______________       _______________
 5764: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 5765: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5766: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5767: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5768: 1			;
 5769: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5770: 1			;         | | | | | | | |       | | | | | | | |
 5771: 1			;        K K K K K K K K       K K K K K K K K
 5772: 1			;         O O O O O O O O       O O O O O O O O
 5773: 1			;         L L L L L L L L       L L L L L L L L
 5774: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5775: 1			;
 5776: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 5777: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 5778: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5779: 1			; van bitmaps van voor naar achter.
 5780: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5781: 1			;
 5782: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5783: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5784: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5785: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 5786: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5787: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5788: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5789: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5790: 1			; deze toetswaarde weer.
 5791: 1			;
 5792: 1			;
 5793: 1			;
 5794: 1			;******************************************************************************
 5795: 1
 5796: 1
 5797: 1			;******************************************************************************
 5798: 1			; key_init
 5799: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 5800: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5801: 1			; input: niets
 5802: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 5803: 1			;         (map0,map1,map2,map3 =0)
 5804: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5805: 1			; Deze routine vernietigt niets
 5806: 1			;******************************************************************************
 5807: 1
 5808: 1  1476	C0 E0		Key_init:       push    acc          ;bewaar registers
 5809: 1  1478	C0 D0		                push    psw
 5810: 1  147A	E8		                mov     a,r0
 5811: 1  147B	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5812: 1  147D	E9		                mov     a,r1
 5813: 1  147E	C0 E0		                push    acc
 5814: 1  1480	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5815: 1  1482	79 09		                mov     r1,#9        ;9 bytes in de maps
 5816: 1  1484	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5817: 1  1486	08		                inc     r0           ;volgende byte nemen
 5818: 1  1487	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5819: 1  1489	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5820: 1  148B	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 5821: 1  148D	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5822: 1  1490	D0 E0		                pop     acc          ;herstel registers
 5823: 1  1492	F9		                mov     r1,a
 5824: 1  1493	D0 E0		                pop     acc
 5825: 1  1495	F8		                mov     r0,a
 5826: 1  1496	D0 D0		                pop     psw
 5827: 1  1498	D0 E0		                pop     acc
 5828: 1  149A	22		                ret                    ;terug naar caller
 5829: 1			;******************************************************************************
 5830: 1
 5831: 1
 5832: 1			;******************************************************************************
 5833: 1			; toets_flank
 5834: 1			; Deze routine detecteert de indrukflank van een toets.
 5835: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5836: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5837: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5838: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5839: 1			; minder dan 20ms duurt.
 5840: 1			; input : niets
 5841: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5842: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5843: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5844: 1			;
 5845: 1			; Deze routine vernietigt geen registers.
 5846: 1			;******************************************************************************
 5847: 1  149B	C0 E0		Toets_flank:    push    acc
 5848: 1  149D	C0 D0		                push    psw
 5849: 1  149F	12 14 B9	                lcall   Keyscan
 5850: 1  14A2	12 15 35	                lcall   Keyedge
 5851: 1  14A5	D0 D0		                pop     psw
 5852: 1  14A7	D0 E0		                pop     acc
 5853: 1  14A9	22		                ret
 5854: 1
 5855: 1			;******************************************************************************
 5856: 1			; toets_ingedrukt
 5857: 1			; Deze routine detecteert een ingedrukte toets.
 5858: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5859: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5860: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5861: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5862: 1			; minder dan 20ms duurt.
 5863: 1			; input : niets
 5864: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5865: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5866: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5867: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5868: 1			; Deze routine vernietigt geen registers.
 5869: 1			;******************************************************************************
 5870: 1  14AA	C0 E0		Toets_ingedrukt:push    acc
 5871: 1  14AC	C0 D0		                push    psw
 5872: 1  14AE	12 14 B9	                lcall   Keyscan
 5873: 1  14B1	12 15 1C	                lcall   Keydown
 5874: 1  14B4	D0 D0		                pop     psw
 5875: 1  14B6	D0 E0		                pop     acc
 5876: 1  14B8	22		                ret
 5877: 1
 5878: 1
 5879: 1			;******************************************************************************
 5880: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5881: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5882: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5883: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5884: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5885: 1			; zoals aangegeven in het blokschema van het algorithme.
 5886: 1			; input : niets
 5887: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5888: 1			;         ervan weergeven
 5889: 1			;
 5890: 1			; Deze routine vernietigt geen registers
 5891: 1			;******************************************************************************
 5892: 1
 5893: 1  14B9	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 5894: 1  14BB	C0 D0		                push    psw
 5895: 1  14BD	C0 F0		                push    b
 5896: 1  14BF	E8		                mov     a,r0
 5897: 1  14C0	C0 E0		                push    acc
 5898: 1  14C2	E9		                mov     a,r1
 5899: 1  14C3	C0 E0		                push    acc
 5900: 1  14C5	EA		                mov     a,r2
 5901: 1  14C6	C0 E0		                push    acc
 5902: 1  14C8	EE		                mov     a,r6
 5903: 1  14C9	C0 E0		                push    acc
 5904: 1
 5905: 1  14CB	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 5906: 1  14CD	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 5907: 1  14D0	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 5908: 1  14D2	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 5909: 1
 5910: 1  14D4			Scanloop:
 5911: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 5912: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 5913: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 5914: 1			                mov     p0.0,c
 5915: 1			                mov     c,acc.1
 5916: 1			                mov     p0.1,c
 5917: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 5918: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 5919: 1			endif
 5920: 1
 5921: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 5922: 1  14D4	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 5923: 1			                                      ;een rij-lijn

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5924: 1			endif
 5925: 1
 5926: 1			; Eerst de flipflops implementeren.
 5927: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 5928: 1			; te lezen van de kolomlijnen
 5929: 1  14D6	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 5930: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5931: 1  14D7	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 5932: 1  14D8	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 5933: 1  14D9	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 5934: 1  14DA	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 5935: 1  14DC	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 5936: 1  14DD	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 5937: 1  14DE	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 5938: 1  14E0	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 5939: 1  14E1	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 5940: 1  14E2	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 5941: 1  14E3	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 5942: 1  14E4	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 5943: 1  14E6	FA		                mov     r2,a          ;even bewaren in register
 5944: 1
 5945: 1
 5946: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 5947: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 5948: 1			                                      ;poort3 kolomlijnen
 5949: 1			endif
 5950: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 5951: 1  14E7	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 5952: 1			                                     ;poort0 kolomlijnen
 5953: 1			endif
 5954: 1  14E9	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 5955: 1  14EA	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 5956: 1  14EC	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 5957: 1  14ED	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 5958: 1
 5959: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 5960: 1			; Nu volgen de logische functies uit het blokschema
 5961: 1
 5962: 1  14EE	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 5963: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5964: 1  14EF	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 5965: 1  14F0	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 5966: 1  14F1	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 5967: 1  14F2	54 0F		                anl     a,#00001111b ;low nibble houden
 5968: 1  14F4	FA		                mov     r2,a         ;resultaat bewaren
 5969: 1  14F5	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 5970: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 5971: 1  14F6	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 5972: 1  14F7	C4		                swap    a            ;map2 naar low nibble schuiven
 5973: 1  14F8	5A		                anl     a,r2         ;combineren met output vorige and poort
 5974: 1  14F9	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 5975: 1  14FB	FA		                mov     r2,a         ;even bewaren
 5976: 1  14FC	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 5977: 1  14FD	54 F0		                anl     a,#11110000b ;map2 overhouden
 5978: 1  14FF	4A		                orl     a,r2         ;en combineren met nieuwe map3
 5979: 1  1500	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5980: 1
 5981: 1			; We gaan nu de volgende lijn scannen
 5982: 1
 5983: 1  1501	EE		                mov     a,r6         ;scanpatroon nemen
 5984: 1  1502	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 5985: 1  1503	FE		                mov     r6,a         ;scanpatroon bewaren
 5986: 1
 5987: 1  1504	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 5988: 1  1505	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 5989: 1  1506	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 5990: 1  1509	D0 E0		                pop     acc          ;herstel registers
 5991: 1  150B	FE		                mov     r6,a
 5992: 1  150C	D0 E0		                pop     acc
 5993: 1  150E	FA		                mov     r2,a
 5994: 1  150F	D0 E0		                pop     acc
 5995: 1  1511	F9		                mov     r1,a
 5996: 1  1512	D0 E0		                pop     acc
 5997: 1  1514	F8		                mov     r0,a
 5998: 1  1515	D0 F0		                pop     b
 5999: 1  1517	D0 D0		                pop     psw
 6000: 1  1519	D0 E0		                pop     acc
 6001: 1  151B	22		                ret                    ;terug naar caller
 6002: 1			;******************************************************************************
 6003: 1
 6004: 1
 6005: 1			;******************************************************************************
 6006: 1			; Keydown, Keyedge (twee entry's)
 6007: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6008: 1			;
 6009: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6010: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6011: 1			; Er zijn twee detectie-modes:
 6012: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6013: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6014: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6015: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6016: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6017: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6018: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6019: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6020: 1			;
 6021: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6022: 1			; (flankdetectie mode).
 6023: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6024: 1			; (toets ingedrukt mode).
 6025: 1			;
 6026: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6027: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6028: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6029: 1			; geldt voor een standaard 4x4 keypad.
 6030: 1			;
 6031: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6032: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6033: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6034: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6035: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6036: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6037: 1			; output: key = gedetecteerde toets
 6038: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6039: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6040: 1			;
 6041: 1			; Deze routine vernietigt geen registers
 6042: 1			;******************************************************************************
 6043: 1
 6044: 1			;'Toets ingedrukt mode' enty van de routine
 6045: 1  151C	C0 E0		Keydown:        push    acc            ;registers bewaren
 6046: 1  151E	C0 D0		                push    psw
 6047: 1  1520	C0 F0		                push    b
 6048: 1  1522	C0 82		                push    dpl
 6049: 1  1524	C0 83		                push    dph
 6050: 1  1526	E8		                mov     a,r0
 6051: 1  1527	C0 E0		                push    acc
 6052: 1  1529	E9		                mov     a,r1
 6053: 1  152A	C0 E0		                push    acc
 6054: 1  152C	EA		                mov     a,r2
 6055: 1  152D	C0 E0		                push    acc
 6056: 1  152F	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6057: 1  1531	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6058: 1  1533	80 15		                sjmp    Key1           ;continue
 6059: 1
 6060: 1			;'Flankdetectiemode' entry van de routine
 6061: 1  1535	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6062: 1  1537	C0 D0		                push    psw
 6063: 1  1539	C0 F0		                push    b
 6064: 1  153B	C0 82		                push    dpl
 6065: 1  153D	C0 83		                push    dph
 6066: 1  153F	E8		                mov     a,r0
 6067: 1  1540	C0 E0		                push    acc
 6068: 1  1542	E9		                mov     a,r1
 6069: 1  1543	C0 E0		                push    acc
 6070: 1  1545	EA		                mov     a,r2
 6071: 1  1546	C0 E0		                push    acc
 6072: 1  1548	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6073: 1  154A	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6074: 1  154C	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6075: 1  154E	E6		                mov     a,@r0         ;map entry ophalen
 6076: 1  154F	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6077: 1  1552	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6078: 1  1554	C4		                swap    a             ;map1 en map0 omwisselen
 6079: 1  1555	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6080: 1  1557	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6081: 1  1558	33		                rlc     a             ;kolombit testen
 6082: 1  1559	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6083: 1  155B	33		                rlc    a              ;nee, dan verder roteren
 6084: 1  155C	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6085: 1  155E	08		                inc     r0            ;rijpointer in maps verder zetten
 6086: 1  155F	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6087: 1  1561	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6088: 1
 6089: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6090: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6091: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6092: 1
 6093: 1  1563	1A		toetsin:        dec     r2            ;rij-1
 6094: 1  1564	19		                dec     r1            ;kolom-1
 6095: 1  1565	EA		                mov     a,r2          ;neem rij-1
 6096: 1  1566	23		                rl      a             ;(rij-1)x2
 6097: 1  1567	23		                rl      a              ;(rij-1)x4
 6098: 1  1568	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6099: 1  1569	90 15 87	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6100: 1  156C	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6101: 1  156D	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6102: 1  156F	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6103: 1  1571	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6104: 1  1573	D0 E0		                pop     acc            ;herstellen registers
 6105: 1  1575	FA		                mov     r2,a
 6106: 1  1576	D0 E0		                pop     acc
 6107: 1  1578	F9		                mov     r1,a
 6108: 1  1579	D0 E0		                pop     acc
 6109: 1  157B	F8		                mov     r0,a
 6110: 1  157C	D0 83		                pop     dph
 6111: 1  157E	D0 82		                pop     dpl
 6112: 1  1580	D0 F0		                pop     b
 6113: 1  1582	D0 D0		                pop     psw
 6114: 1  1584	D0 E0		                pop     acc
 6115: 1  1586	22		                ret                    ;terug naar caller
 6116: 1			;******************************************************************************
 6117: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6118: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6119: 1
 6120: 1  1587	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6121: 1  1588	30		                db    '0'    ;kolom2@rij4 toets
 6122: 1  1589	23		                db    '#'    ;kolom3@rij4 toets
 6123: 1  158A	44		                db    'D'    ;kolom4@rij4 toets
 6124: 1
 6125: 1  158B	37		                db    '7'    ;kolom1@rij3 toets
 6126: 1  158C	38		                db    '8'    ;kolom2@rij3 toets
 6127: 1  158D	39		                db    '9'    ;kolom3@rij3 toets
 6128: 1  158E	43		                db    'C'    ;kolom4@rij3 toets
 6129: 1
 6130: 1  158F	34		                db    '4'    ;kolom1@rij2 toets
 6131: 1  1590	35		                db    '5'    ;kolom2@rij2 toets
 6132: 1  1591	36		                db    '6'    ;kolom3@rij2 toets
 6133: 1  1592	42		                db    'B'    ;kolom4@rij2 toets
 6134: 1
 6135: 1  1593	31		                db    '1'    ;kolom1@rij1 toets
 6136: 1  1594	32		                db    '2'    ;kolom2@rij1 toets
 6137: 1  1595	33		                db    '3'    ;kolom3@rij1 toets
 6138: 1  1596	41		                db    'A'    ;kolom4@rij1 toets
 6139: 1
 6140: 1			;******************************************************************************
 6141: 1			; switch_init
 6142: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6143: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6144: 1			; input : niets
 6145: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6146: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6147: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6148: 1			; Deze routine vernietigt niets
 6149: 1			;******************************************************************************
 6150: 1
 6151: 1  1597	C0 E0		switch_init:    push    acc
 6152: 1  1599	C0 D0		                push    psw
 6153: 1  159B	C0 F0		                push    b
 6154: 1  159D	E8		                mov     a,r0         ;bewaar registers
 6155: 1  159E	C0 E0		                push    acc
 6156: 1
 6157: 1  15A0	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6158: 1  15A2	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6159: 1  15A5	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6160: 1  15A7	08		                inc     r0           ;volgende byte nemen
 6161: 1  15A8	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6162: 1  15AB	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6163: 1  15AD	C2 03		                clr     negvalid
 6164: 1  15AF	C2 04		                clr     posvalid
 6165: 1
 6166: 1  15B1	D0 E0		                pop     acc
 6167: 1  15B3	F8		                mov     r0,a
 6168: 1  15B4	D0 F0		                pop     b
 6169: 1  15B6	D0 D0		                pop     psw
 6170: 1  15B8	D0 E0		                pop     acc
 6171: 1  15BA	22		                ret                   ;terug naar caller
 6172: 1
 6173: 1			;******************************************************************************
 6174: 1			; read_switch
 6175: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6176: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6177: 1			; Deze routine werkt volgens onderstaand blokschema.
 6178: 1			;
 6179: 1			;                                  ___                    ___
 6180: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6181: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6182: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6183: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6184: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6185: 1			;             |____|    |____|              |____|  ----o| 3 |
 6186: 1			;                |         |                   |      |  |   |
 6187: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6188: 1			;         _______*_________*___________________|       --|___|---- posedge
 6189: 1			;
 6190: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6191: 1			;                              (swvalid-flag)
 6192: 1			;            switch1   switch2    debounce      closed
 6193: 1			;
 6194: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6195: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6196: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6197: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6198: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6199: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6200: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6201: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6202: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6203: 1			; een detector voor positieve flanken (posedge).

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6204: 1			;
 6205: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6206: 1			;         bij aduc832v1.1 :
 6207: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6208: 1			;         bij aduc832v2.0 :
 6209: 1			;         als f0=0 dan: schakelaars op p0
 6210: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6211: 1			;
 6212: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6213: 1			;         geactualiseerd.
 6214: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6215: 1			;                  schakelaars weergeeft
 6216: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6217: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6218: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6219: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6220: 1			;                  werd gedetecteerd op een schakelaar.
 6221: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6222: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6223: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6224: 1			;                  werd gedetecteerd op een schakelaar.
 6225: 1			;
 6226: 1			;
 6227: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6228: 1			; en flags te initialiseren.
 6229: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6230: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6231: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6232: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6233: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6234: 1			; bijhorende flag resetten.
 6235: 1			;
 6236: 1			; Deze routine vernietigt niets
 6237: 1			;******************************************************************************
 6238: 1  15BB	C0 E0		read_switch:    push    acc            ;registers bewaren
 6239: 1  15BD	C0 D0		                push    psw
 6240: 1  15BF	C0 F0		                push    b
 6241: 1			;Flipflops uitvoeren is bytes doorschuiven
 6242: 1  15C1	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6243: 1  15C4	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6244: 1
 6245: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6246: 1			                clr      a
 6247: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6248: 1			                mov     acc.0,c
 6249: 1			                mov     c,p0.1
 6250: 1			                mov     acc.1,c
 6251: 1			                mov     b,a            ;even bewaren
 6252: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6253: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6254: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6255: 1			endif        ;einde aduc832_v1_1
 6256: 1
 6257: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6258: 1  15C7	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6259: 1  15CA	E5 80		                mov     a,p0           ;lees de schakelaars

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6260: 1  15CC	80 04		                sjmp    lowlogic
 6261: 1  15CE	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6262: 1  15D0	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6263: 1			endif        ;einde aduc832_2_0
 6264: 1
 6265: 1  15D2	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6266: 1  15D3	F5 40		                mov     switch1,a      ;en sample opslaan
 6267: 1
 6268: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6269: 1
 6270: 1  15D5	E5 40		                mov     a,switch1      ;neem laatste sample
 6271: 1  15D7	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6272: 1  15D9	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6273: 1  15DB	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6274: 1			;negatieve flankdetectie
 6275: 1  15DD	E5 43		                mov     a,closed      ;neem 3de FF
 6276: 1  15DF	F4		                cpl     a             ;complementeer
 6277: 1  15E0	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6278: 1  15E2	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6279: 1  15E4	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6280: 1  15E6	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6281: 1  15E8	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6282: 1			;positieve flankdetectie
 6283: 1  15EA	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6284: 1  15EC	F4		                cpl     a             ;complementeer
 6285: 1  15ED	55 43		                anl     a,closed      ;combineer met 3de FF
 6286: 1  15EF	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6287: 1  15F1	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6288: 1  15F3	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6289: 1  15F5	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6290: 1  15F7	D0 D0		                pop     psw
 6291: 1  15F9	D0 E0		                pop     acc
 6292: 1  15FB	22		                ret
 6293: 1
 6294: 1			endif    ;einde van aduc_key
 6295: 1
 6296: 1
 6297:				end





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 148
ACC				  DATA	      E0	  67
ADCCON1				  DATA	      EF	  70
ADCCON2				  DATA	      D8	  63
ADCCON3				  DATA	      F5	  76
ADCDATAH			  DATA	      DA	  65
ADCDATAL			  DATA	      D9	  64
ADCGAINH			  DATA	      F4	  75
ADCGAINL			  DATA	      F3	  74
ADCI				  BIT	      DF	 157
ADCOFSH				  DATA	      F2	  73
ADCOFSL				  DATA	      F1	  72
ADC_INIT			  CODE	    13BA	5546
ADC_INIT1			  CODE	    13C7	5552
ADC_SINGLE			  CODE	    13CC	5591
ADC_SINGLE1			  CODE	    13D8	5597
ADC_SINGLE2			  CODE	    1403	5623
ADC_SINGLE20			  CODE	    140D	5628
ADC_SINGLE21			  CODE	    1415	5634
ADC_SINGLE3			  CODE	    1418	5638
ADC_SINGLE30			  CODE	    1438	5659
ADC_SINGLE31			  CODE	    1442	5664
ADC_SINGLE4			  CODE	    144A	5673
ADC_SINGLE40			  CODE	    1456	5681
ADC_SINGLE41			  CODE	    1460	5686
ADC_SINGLE42			  CODE	    1466	5690
ADC_SINGLE43			  CODE	    146E	5696
ADD16				  CODE	    0911	2898
ADD161				  CODE	    0925	2914
ADD32				  CODE	    0963	2995
ADD321				  CODE	    097D	3019
ADUC832_V2_0			  NUMBER    0001	 204
ADUC_ADC			  NUMBER    0001	 225
ADUC_I2C			  NUMBER    0001	 222
ADUC_KEY			  NUMBER    0001	 226
ADUC_LCD			  NUMBER    0001	 219
ADUC_MATH			  NUMBER    0001	 224
ADUC_SIO			  NUMBER    0001	 223
ASCBINTRANS			  CODE	    05C1	1951
ASCBINTRANS1			  CODE	    05D6	1962
ASCBINTRANS2			  CODE	    05D5	1961
ASCBINTRANS3			  CODE	    05C9	1955
ASCBINTRANS4			  CODE	    05D2	1959
ASCCTR				  CODE	    0598	1897
ASCCTR1				  CODE	    059B	1898
ASCCTR2				  CODE	    05A0	1900
ASCCTR3				  CODE	    05A4	1903
ASCII1				  CODE	    05D7	1973

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII2				  CODE	    05DC	1987
ASCII21				  CODE	    05EE	1996
ASCII4				  CODE	    05F1	2010
ASCII41				  CODE	    0600	2017
B				  DATA	      F0	  71
BACKLIGHT			  BIT	      F6	 371
BACKSP				  NUMBER    0008	1596
BARCHARS			  CODE	    0281	 997
BAREINDE			  CODE	    02A8	1040
BARLCD				  CODE	    021C	 918
BARLCD1				  CODE	    0257	 952
BARLCD2				  CODE	    025E	 957
BARLCD3				  CODE	    0267	 965
BARLCD4				  CODE	    026C	 969
BARLCDE				  CODE	    0274	 974
BARLCD_1			  CODE	    0237	 934
BATRANS				  CODE	    05B3	1933
BATRANS1			  CODE	    05B8	1935
BATRANS2			  CODE	    05BC	1937
BCDHEX16			  CODE	    0676	2212
BCDHEX161			  CODE	    0684	2220
BCDHEX1611			  CODE	    068D	2224
BCDHEX1612			  CODE	    0697	2229
BCDHEX1613			  CODE	    06A0	2233
BCDHEX162			  CODE	    06EB	2287
BCDHEX8				  CODE	    0601	2103
BCDHEX81			  CODE	    060F	2111
BCDHEX811			  CODE	    0618	2115
BCDHEX82			  CODE	    063A	2139
BDELETE				  CODE	    0573	1863
BDELETE1			  CODE	    0581	1871
BDELETE2			  CODE	    0594	1882
BDELETE3			  CODE	    0585	1873
BEEP				  NUMBER    0007	1597
BLANK				  NUMBER    0020	1591
BUILD				  CODE	    02A9	1072
BUILD1				  CODE	    02C1	1114
BUILD2				  CODE	    02D0	1121
BUILD3				  CODE	    02C4	1115
BUILD_ADR			  CODE	    02B7	1109
BUZZER				  BIT	      F7	 372
CAP2				  BIT	      C8	 134
CCONV				  BIT	      DD	 155
CFG832				  DATA	      AF	  36
CGRAM				  NUMBER    0040	 387
CHIPID				  DATA	      C2	  50
CLEARDISP			  NUMBER    0001	 377
CLOSED				  NUMBER    0043	 291
CMP16				  CODE	    10F2	4929
CMP161				  CODE	    110F	4948
CMP162				  CODE	    111B	4957
CMP32				  CODE	    1193	5076
CMP321				  CODE	    11BC	5103
CMP322				  CODE	    11C8	5112
CNT2				  BIT	      C9	 135
CORDIC				  CODE	    125C	5263

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CORDIC0				  CODE	    12C7	5328
CORDIC00			  CODE	    12AD	5313
CORDIC000			  CODE	    1280	5287
CORDIC1				  CODE	    12DB	5342
CORDIC2				  CODE	    130F	5392
CORDIC3				  CODE	    131A	5399
CORDIC4				  CODE	    133F	5433
CORDIC40			  CODE	    1344	5437
CORDIC41			  CODE	    135D	5453
CORDIC5				  CODE	    1363	5459
CORDIC50			  CODE	    1375	5469
CORDIC51			  CODE	    138E	5484
CORDIC52			  CODE	    1399	5493
CORDIC5A			  CODE	    1373	5468
CORDIC5B			  CODE	    138C	5483
CORDIC_ATAN			  CODE	    139C	5499
CORDIC_ERROR			  CODE	    1290	5295
CORDIC_MIN90			  CODE	    1295	5299
CORDIC_NUL			  CODE	    12B9	5319
CORDIC_PLUS90			  CODE	    12A1	5306
CPHA				  BIT	      FA	 172
CPOL				  BIT	      FB	 173
CR				  NUMBER    000D	1594
CS0				  BIT	      D8	 150
CS1				  BIT	      D9	 151
CS2				  BIT	      DA	 152
CS3				  BIT	      DB	 153
CURSATHOM			  NUMBER    0002	 378
CURSOROFF			  NUMBER    000C	 383
CURSORONB			  NUMBER    000F	 384
CURSORONN			  NUMBER    000E	 385
CY				  BIT	      D7	 149
D0				  BIT	      ED	 159
D0EN				  BIT	      EB	 158
D1				  BIT	      EF	 161
D1EN				  BIT	      EE	 160
DAC0H				  DATA	      FA	  80
DAC0L				  DATA	      F9	  79
DAC1H				  DATA	      FC	  82
DAC1L				  DATA	      FB	  81
DACCON				  DATA	      FD	  83
DCON				  DATA	      E8	  68
DDRAM				  NUMBER    0080	 388
DEBOUNCE			  NUMBER    0042	 290
DELAY2MS			  CODE	    02DE	1138
DELAY2MS1			  CODE	    02E4	1141
DELAY60US			  CODE	    02EF	1158
DELAY60US1			  CODE	    0301	1172
DELAY60US2			  CODE	    02FF	1171
DIPSWITCH			  NUMBER    0001	 244
DISPDPTR			  CODE	    04C9	1705
DISPDPTRLCD			  CODE	    00E3	 593
DISPLAYOF			  NUMBER    0008	 382
DISPLAYON			  NUMBER    0001	 381
DIV16				  CODE	    0BD8	3681
DIV160				  CODE	    0BE6	3692

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DIV161				  CODE	    0C04	3715
DIV162				  CODE	    0C17	3731
DIV163				  CODE	    0C33	3756
DIV164				  CODE	    0C45	3774
DIV32				  CODE	    0C82	3845
DIV320				  CODE	    0C92	3858
DIV320A				  CODE	    0C9C	3869
DIV320B				  CODE	    0CBA	3897
DIV320C				  CODE	    0CDF	3925
DIV322				  CODE	    0D04	3959
DIV323				  CODE	    0D4E	4035
DIV324				  CODE	    0D80	4085
DIV8				  CODE	    0B95	3608
DIV81				  CODE	    0BAD	3624
DMA				  BIT	      DE	 156
DMAH				  DATA	      D3	  60
DMAL				  DATA	      D2	  59
DMAP				  DATA	      D4	  61
DPCON				  DATA	      A7	  32
DPH				  DATA	      83	   9
DPL				  DATA	      82	   8
DPP				  DATA	      84	  10
E				  BIT	      F1	 369
EA				  BIT	      AF	 109
EADC				  BIT	      AE	 108
EADRH				  DATA	      C7	  52
EADRL				  DATA	      C6	  51
ECON				  DATA	      B9	  44
EDATA1				  DATA	      BC	  45
EDATA2				  DATA	      BD	  46
EDATA3				  DATA	      BE	  47
EDATA4				  DATA	      BF	  48
ENDBUF				  NUMBER    007F	1603
ENTRYMODE			  NUMBER    0006	 380
ES				  BIT	      AC	 106
ET0				  BIT	      A9	 103
ET1				  BIT	      AB	 105
ET2				  BIT	      AD	 107
EX0				  BIT	      A8	 102
EX1				  BIT	      AA	 104
EXEN2				  BIT	      CB	 137
EXF2				  BIT	      CE	 140
F0				  BIT	      D5	 147
F1				  BIT	      D1	 143
FF				  NUMBER    000C	1593
FUNCTIONS			  NUMBER    0028	 386
HEXBCD16			  CODE	    06F4	2323
HEXBCD161			  CODE	    0702	2330
HEXBCD16_U			  CODE	    06F7	2324
HEXBCD8				  CODE	    0643	2164
HEXBCD81			  CODE	    064D	2169
HEXBCD82			  CODE	    0652	2171
HEXBCD83			  CODE	    065C	2177
HEXBUF2LCD			  CODE	    01BF	 859
HEXBUF2LCD1			  CODE	    01E3	 875
HEXBUF2LCDE			  CODE	    01FA	 886

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBUFTXT			  CODE	    0208	 895
HOUR				  DATA	      A5	  30
HTHSEC				  DATA	      A2	  27
I2CADD				  DATA	      9B	  22
I2CCON				  DATA	      E8	  69
I2CDAT				  DATA	      9A	  21
I2CI				  BIT	      E8	 162
I2CINBYTEA1			  CODE	    034B	1280
I2CINBYTEACK			  CODE	    0344	1277
I2CINBYTEN1			  CODE	    036C	1304
I2CINBYTENACK			  CODE	    0365	1301
I2CINIT				  CODE	    0309	1222
I2CM				  BIT	      EB	 165
I2COUTBYTE			  CODE	    0324	1254
I2COUTBYTE1			  CODE	    032B	1257
I2CPCF8574			  NUMBER    0040	1213
I2CPCF8574A			  NUMBER    0070	1214
I2CRCVDATA			  CODE	    03C6	1406
I2CRCVDATA1			  CODE	    03E5	1424
I2CRCVDATA2			  CODE	    03EE	1428
I2CRCVDATA3			  CODE	    03F5	1433
I2CRCVERROR			  CODE	    0401	1441
I2CRS				  BIT	      EA	 164
I2CSENDDATA			  CODE	    0386	1344
I2CSENDDATA1			  CODE	    03A5	1361
I2CSENDERROR			  CODE	    03BB	1374
I2CSTART			  CODE	    0312	1231
I2CSTOP				  CODE	    031B	1240
I2CTX				  BIT	      E9	 163
IE				  DATA	      A8	  33
IE0				  BIT	      89	  85
IE1				  BIT	      8B	  87
IEIP2				  DATA	      A9	  34
INBUFA				  CODE	    0538	1820
INBUFA1				  CODE	    054F	1837
INBUFA2				  CODE	    053E	1823
INBUFA3				  CODE	    055C	1843
INBUFA4				  CODE	    0555	1839
INBUFA5				  CODE	    056F	1851
INBUFA6				  CODE	    0565	1847
INBUFA7				  CODE	    0557	1840
INBYTE				  CODE	    0518	1788
INBYTE1				  CODE	    0535	1800
INCHAR				  CODE	    0510	1772
INITLCD				  CODE	    0013	 403
INITLCD1			  CODE	    0024	 420
INITSIO				  CODE	    0476	1617
INITSIO1			  CODE	    047F	1621
INITSIOE			  CODE	    0495	1638
INT0				  BIT	      B2	 112
INT0_ROUT			  CODE	    000E	 191
INT1				  BIT	      B3	 113
INTVAL				  DATA	      A6	  31
IP				  DATA	      B8	  43
ISPI				  BIT	      FF	 177
IT0				  BIT	      88	  84

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
IT1				  BIT	      8A	  86
KEY				  NUMBER    0038	 277
KEY1				  CODE	    154A	6073
KEY2				  CODE	    1557	6080
KEYDOWN				  CODE	    151C	6045
KEYEDGE				  CODE	    1535	6061
KEYFLAGS			  NUMBER    0020	 252
KEYINIT1			  CODE	    1484	5816
KEYMAP				  NUMBER    0030	 271
KEYMODE				  BIT	      01	 256
KEYSCAN				  CODE	    14B9	5893
KEYVALID			  BIT	      00	 254
KEY_INIT			  CODE	    1476	5808
KOLOMLOOP			  CODE	    1559	6082
LCDBUZOFF			  CODE	    0465	1562
LCDBUZON			  CODE	    0458	1546
LCDLIGHTOFF			  CODE	    044B	1530
LCDLIGHTON			  CODE	    043E	1513
LCDPORT				  NUMBER    00F0	 368
LCDTOPORT			  CODE	    0425	1487
LF				  NUMBER    000A	1595
LOWLOGIC			  CODE	    15D2	6265
LOWUPTR				  CODE	    05A6	1917
LOWUPTR1			  CODE	    05A9	1918
LOWUPTR2			  CODE	    05B2	1922
LOWUPTR3			  CODE	    05AE	1920
MAGSIG16			  CODE	    0763	2435
MAGSIG16A			  CODE	    0774	2444
MAGSIG16ACC1			  CODE	    0783	2468
MAGSIG16ACC1A			  CODE	    0794	2477
MAGSIG16ACC1B			  CODE	    078F	2474
MAGSIG16ACC1C			  CODE	    079E	2485
MAGSIG16B			  CODE	    076F	2441
MAGSIG16C			  CODE	    077E	2452
MAGSIG32			  CODE	    07A3	2502
MAGSIG32A			  CODE	    07B4	2511
MAGSIG32ACC1			  CODE	    07CD	2547
MAGSIG32ACC1A			  CODE	    07DE	2556
MAGSIG32ACC1B			  CODE	    07D9	2553
MAGSIG32ACC1C			  CODE	    07F2	2573
MAGSIG32B			  CODE	    07AF	2508
MAGSIG32C			  CODE	    07C8	2528
MAGSIG8				  CODE	    072F	2376
MAGSIG8A			  CODE	    0740	2385
MAGSIG8ACC1			  CODE	    0749	2406
MAGSIG8ACC1A			  CODE	    075A	2415
MAGSIG8ACC1B			  CODE	    0755	2412
MAGSIG8ACC1C			  CODE	    075E	2419
MAGSIG8B			  CODE	    073B	2382
MAGSIG8C			  CODE	    0744	2389
MAP01PTR			  NUMBER    0030	 273
MAP23PTR			  NUMBER    0034	 276
MATRIX				  NUMBER    0001	 242
MCO				  BIT	      ED	 167
MDE				  BIT	      EE	 168
MDI				  BIT	      EC	 166

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MDO				  BIT	      EF	 169
MIN				  DATA	      A4	  29
MUL16				  CODE	    0A4D	3267
MUL16ACC1			  CODE	    0AB2	3356
MUL16_10			  CODE	    0E71	4343
MUL16_100			  CODE	    0EA6	4391
MUL16_I_PI			  CODE	    0E0E	4247
MUL16_I_SQRT2			  CODE	    0E50	4312
MUL16_PI			  CODE	    0DED	4216
MUL16_SQRT2			  CODE	    0E2F	4279
MUL816				  CODE	    0B3A	3503
MULDIV				  CODE	    0DB1	4158
MULDIV1				  CODE	    0DC1	4170
NEGEDGE				  NUMBER    0044	 292
NEGVALID			  BIT	      03	 261
NOKEY				  CODE	    1571	6103
OUTBYTE				  CODE	    04B5	1685
OUTBYTELCD			  CODE	    00D2	 574
OUTC				  CODE	    017F	 780
OUTCHAR				  CODE	    0499	1652
OUTCHAR1			  CODE	    049B	1653
OUTCHARLCD			  CODE	    0071	 489
OUTCHARLCD1			  CODE	    0078	 492
OUTCHARLCD2			  CODE	    0082	 496
OUTCHARLCD2_0			  CODE	    007D	 494
OUTCHARLCD3			  CODE	    008B	 506
OUTCHARLCD4			  CODE	    0092	 510
OUTCHARLCD5			  CODE	    0099	 514
OUTCHARLCD6			  CODE	    00A0	 518
OUTCHARLCD7			  CODE	    00A7	 522
OUTCHARLCD8			  CODE	    00AE	 530
OUTCHARLCD9			  CODE	    00B3	 538
OUTCHARLCDE			  CODE	    00B6	 539
OUTD				  CODE	    0145	 702
OUTHNIBC			  CODE	    0195	 822
OUTHNIBD			  CODE	    0155	 750
OUTMSGA				  CODE	    04DC	1724
OUTMSGA1			  CODE	    04F1	1735
OUTMSGA2			  CODE	    04E4	1728
OUTMSGALCD			  CODE	    00F6	 617
OUTMSGALCD1			  CODE	    00FE	 624
OUTMSGALCDE			  CODE	    0109	 634
OUTNIB				  CODE	    04A1	1666
OUTNIBLCD			  CODE	    00BB	 553
OUTNIBLCD1			  CODE	    00C6	 558
OUTNIBLCDE			  CODE	    00CA	 560
OV				  BIT	      D2	 144
P				  BIT	      D0	 142
P0				  DATA	      80	   6
P1				  DATA	      90	  18
P2				  DATA	      A0	  25
P3				  DATA	      B0	  37
PADC				  BIT	      BE	 124
PCF8574A			  NUMBER    0001	1216
PCON				  DATA	      87	  11
PLLCON				  DATA	      D7	  62

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
PORTTOLCD			  CODE	    040C	1459
POSEDGE				  NUMBER    0045	 293
POSVALID			  BIT	      04	 263
PRE0				  BIT	      C4	 130
PRE1				  BIT	      C5	 131
PRE2				  BIT	      C6	 132
PRE3				  BIT	      C7	 133
PS				  BIT	      BC	 122
PSI				  BIT	      BF	 125
PSMCON				  DATA	      DF	  66
PSW				  DATA	      D0	  58
PT0				  BIT	      B9	 119
PT1				  BIT	      BB	 121
PT2				  BIT	      BD	 123
PWM0H				  DATA	      B2	  39
PWM0L				  DATA	      B1	  38
PWM1H				  DATA	      B4	  41
PWM1L				  DATA	      B3	  40
PWMCON				  DATA	      AE	  35
PX0				  BIT	      B8	 118
PX1				  BIT	      BA	 120
RB8				  BIT	      9A	  96
RCAP2H				  DATA	      CB	  55
RCAP2L				  DATA	      CA	  54
RCLK				  BIT	      CD	 139
RD				  BIT	      B7	 117
READ_PORT3			  CODE	    15CE	6261
READ_SWITCH			  CODE	    15BB	6238
READ_SWITCH1			  CODE	    15EA	6283
READ_SWITCH2			  CODE	    15F5	6289
REGTOLCD			  CODE	    0112	 654
REGTOLCD1			  CODE	    0123	 664
REGTOLCD2			  CODE	    0131	 674
REN				  BIT	      9C	  98
RI				  BIT	      98	  94
RIJLOOP				  CODE	    154C	6074
RS				  BIT	      F0	 370
RS0				  BIT	      D3	 145
RS1				  BIT	      D4	 146
RXD				  BIT	      B0	 110
SBUF				  DATA	      99	  20
SCANLOOP			  CODE	    14D4	5910
SCON				  DATA	      98	  19
SCONV				  BIT	      DC	 154
SEC				  DATA	      A3	  28
SHIFTLEFT1			  CODE	    101D	4706
SHIFTLEFT2			  CODE	    1025	4712
SHIFTLEFT3			  CODE	    1029	4714
SHIFTLEFT32			  CODE	    1015	4702
SHIFTRIGHT1			  CODE	    0FF1	4661
SHIFTRIGHT2			  CODE	    0FF9	4667
SHIFTRIGHT3			  CODE	    0FFD	4669
SHIFTRIGHT32			  CODE	    0FE9	4657
SIGMAG16ACC0			  CODE	    0829	2646
SIGMAG16ACC0A			  CODE	    0838	2655
SIGMAG16ACC1			  CODE	    0849	2681

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SIGMAG16ACC1A			  CODE	    0858	2690
SIGMAG16ACC1H			  CODE	    0869	2716
SIGMAG16ACC1HA			  CODE	    0878	2725
SIGMAG32ACC0			  CODE	    0889	2753
SIGMAG32ACC0A			  CODE	    0898	2762
SIGMAG32ACC1			  CODE	    08B3	2797
SIGMAG32ACC1A			  CODE	    08C2	2806
SIGMAG8ACC0			  CODE	    07F7	2590
SIGMAG8ACC0A			  CODE	    0806	2598
SIGMAG8ACC1			  CODE	    0810	2618
SIGMAG8ACC1A			  CODE	    081F	2626
SM0				  BIT	      9F	 101
SM1				  BIT	      9E	 100
SM2				  BIT	      9D	  99
SP				  DATA	      81	   7
SPE				  BIT	      FD	 175
SPH				  DATA	      B7	  42
SPICON				  DATA	      F8	  78
SPIDAT				  DATA	      F7	  77
SPIM				  BIT	      FC	 174
SPR0				  BIT	      F8	 170
SPR1				  BIT	      F9	 171
SQRT32				  CODE	    0EFC	4463
SQRT320				  CODE	    0F23	4485
SQRT321				  CODE	    0F28	4487
SQRT322				  CODE	    0F8B	4569
SQRT323				  CODE	    0F91	4573
SQRT324				  CODE	    0FB4	4597
SQRT3240			  CODE	    0FAF	4595
SQRT325				  CODE	    0FB7	4599
STACK_INIT			  NUMBER    007F	 180
START				  CODE	    0003	 185
STRTBUF				  NUMBER    0054	1602
SUB16				  CODE	    09C3	3105
SUB161				  CODE	    09D8	3122
SUB32				  CODE	    0A2A	3222
SUB321				  CODE	    0A45	3247
SWINIT				  CODE	    15A5	6159
SWITCH1				  NUMBER    0040	 288
SWITCH2				  NUMBER    0041	 289
SWITCHMAP			  NUMBER    0040	 287
SWITCH_INIT			  CODE	    1597	6151
SWVALID				  BIT	      02	 259
S_ADD16				  CODE	    08DD	2843
S_ADD161			  CODE	    0901	2869
S_ADD162			  CODE	    0905	2871
S_ADD163			  CODE	    090B	2876
S_ADD32				  CODE	    092D	2936
S_ADD321			  CODE	    0955	2967
S_ADD322			  CODE	    0957	2968
S_ADD323			  CODE	    095D	2973
S_CMP16				  CODE	    10A6	4855
S_CMP160			  CODE	    10B9	4872
S_CMP161			  CODE	    10C7	4882
S_CMP162			  CODE	    10D5	4892
S_CMP163			  CODE	    10E4	4904

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_CMP32				  CODE	    1125	4979
S_CMP320			  CODE	    1140	4999
S_CMP321			  CODE	    1154	5013
S_CMP322			  CODE	    1168	5027
S_CMP323			  CODE	    117F	5047
S_DIV16				  CODE	    0BB5	3646
S_DIV161			  CODE	    0BC3	3656
S_DIV32				  CODE	    0C5D	3808
S_DIV321			  CODE	    0C6D	3820
S_DIV8				  CODE	    0B83	3585
S_DIV81				  CODE	    0B94	3591
S_MAC16				  CODE	    0B61	3545
S_MAC161			  CODE	    0B7D	3565
S_MUL16				  CODE	    0B13	3447
S_MUL16ACC1			  CODE	    0B20	3465
S_MUL816			  CODE	    0B2D	3484
S_MULDIV			  CODE	    0D8C	4114
S_MULDIV1			  CODE	    0D9C	4126
S_SHIFTLEFT1			  CODE	    1080	4808
S_SHIFTLEFT2			  CODE	    1088	4814
S_SHIFTLEFT3			  CODE	    108C	4819
S_SHIFTLEFT32			  CODE	    1078	4804
S_SHIFTRIGHT1			  CODE	    1049	4754
S_SHIFTRIGHT2			  CODE	    1051	4760
S_SHIFTRIGHT20			  CODE	    105D	4766
S_SHIFTRIGHT3			  CODE	    105F	4768
S_SHIFTRIGHT32			  CODE	    1041	4750
S_SQRT32			  CODE	    0FD2	4630
S_SQRT321			  CODE	    0FE0	4638
S_SUB16				  CODE	    0985	3041
S_SUB161			  CODE	    09B3	3076
S_SUB162			  CODE	    09B7	3078
S_SUB163			  CODE	    09BD	3083
S_SUB32				  CODE	    09E0	3144
S_SUB321			  CODE	    0A1C	3194
S_SUB322			  CODE	    0A1E	3195
S_SUB323			  CODE	    0A24	3200
T0				  BIT	      B4	 114
T1				  BIT	      B5	 115
T2				  BIT	      90	  92
T2CON				  DATA	      C8	  53
T2EX				  BIT	      91	  93
T3CON				  DATA	      9E	  23
T3FD				  DATA	      9D	  24
TABLE_LU			  CODE	    11D2	5139
TABLE_LU1			  CODE	    11F7	5165
TABLE_LU2			  CODE	    1208	5178
TABLE_LU3			  CODE	    1241	5221
TABLE_LU4			  CODE	    1253	5234
TABLE_LU_10			  CODE	    11FE	5170
TB8				  BIT	      9B	  97
TCLK				  BIT	      CC	 138
TCON				  DATA	      88	  12
TF0				  BIT	      8D	  89
TF1				  BIT	      8F	  91
TF2				  BIT	      CF	 141

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TH0				  DATA	      8C	  16
TH1				  DATA	      8D	  17
TH2				  DATA	      CD	  57
TI				  BIT	      99	  95
TIMECON				  DATA	      A1	  26
TL0				  DATA	      8A	  14
TL1				  DATA	      8B	  15
TL2				  DATA	      CC	  56
TMOD				  DATA	      89	  13
TOETSIN				  CODE	    1563	6093
TOETSTABEL			  CODE	    1587	6120
TOETS_FLANK			  CODE	    149B	5847
TOETS_INGEDRUKT			  CODE	    14AA	5870
TR0				  BIT	      8C	  88
TR1				  BIT	      8E	  90
TR2				  BIT	      CA	 136
TXD				  BIT	      B1	 111
WCOL				  BIT	      FE	 176
WDCON				  DATA	      C0	  49
WDE				  BIT	      C1	 127
WDIR				  BIT	      C3	 129
WDS				  BIT	      C2	 128
WDWR				  BIT	      C0	 126
WISSEN				  CODE	    0472	1599
WR				  BIT	      B6	 116
XOFF				  NUMBER    0013	1592
XONXOFF				  CODE	    04FA	1752
XONXOFF1			  CODE	    0506	1758
XONXOFF2			  CODE	    0501	1755
XONXOFF3			  CODE	    050B	1760
