
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 12.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 12.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 12.lst



 Line  I  Addr  Code            Source

    1:				$nolist
  179:
  180:		N      007F	stack_init	equ	07fh
  181:		N      0000			org	0000h
  182:	  0000	02 00 03			ljmp	start
  183:
  184:	  0003	75 81 7F	start:		mov	sp,#stack_init
  185:	  0006	74 00				mov	a,#0
  186:	  0008	12 00 33			lcall	initlcd
  187:	  000B	90 00 15			mov	dptr,#text
  188:	  000E	12 01 16			lcall	outmsgalcd
  189:	  0011	80 FE				sjmp	$
  190:	  0013	80 FE		einde:		sjmp	einde
  191:
  192:	  0015	13 80		text:		db	013h,80h
  193:	  0017	5C 28 6F 2E			db	'\(o.o)/ Anton',0C0h
	  001B	6F 29 2F 20
	  001F	41 6E 74 6F
	  0023	6E C0
  194:	  0025	50 69 65 74			db	'Pieter-Jan D:',0
	  0029	65 72 2D 4A
	  002D	61 6E 20 44
	  0031	3A 00
  195:
  196:				$include (c:/aduc800_mideA.inc)
  197: 1			;******************************************************************************
  198: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  199: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  200: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  201: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  202: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  203: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  204: 1			;******************************************************************************
  205: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  206: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  207: 1			;******************************************************************************
  208: 1
  209: 1
  210: 1			;******************************************************************************
  211: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  212: 1			; hebben voor onze toepassing. Door een module te definieren via het
  213: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  214: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  215: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  216: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  217: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  218: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  219: 1			; definities.
  220: 1			;******************************************************************************
  221: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  222: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  223: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  224: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  225: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  226: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  227: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  228: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  229: 1
  230: 1			ifdef    aduc_key
  231: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  232: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  233: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  234: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  235: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  236: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  237: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  238: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  239: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  240: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  241: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  242: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  243: 1			;definities wel gemaakt worden.
  244: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  245: 1			                            ;anders commentaar van maken!
  246: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  247: 1			                            ;gelezen, anders commentaar van maken!
  248: 1			;******************************************************************************
  249: 1			;Declaraties van de flags voor de aduc_key driver.
  250: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  251: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  252: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  253: 1			;switch_init en read_switch.
  254: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  255: 1			                                ;bereik = 20h-2fh!
  256: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  257: 1			                                   ;een geldige waarde bevat
  258: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  259: 1			                                   ;die de detectie mode aangeeft
  260: 1			;declaratie van de read_switch flags
  261: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  262: 1			                                   ;ontdenderde schakelaars zijn
  263: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  264: 1			                                   ;flanken zijn
  265: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  266: 1			                                   ;flanken zijn
  267: 1			ifdef    matrix        ;matrix keyboard
  268: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  269: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  270: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  271: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  272: 1			;toepassing.
  273: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  274: 1			                                ;geheugenbuffer
  275: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  276: 1			                                ;debounce en de flankdetectie samples stockeren
  277: 1			                                ;de eerste 4 bytes dienen voor debouncing
  278: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  279: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  280: 1			                                ;toetswaarde aangeeft
  281: 1			                                ;bij een geldige keyvalid flag ('1')
  282: 1			endif    ;einde matrix keyboard
  283: 1
  284: 1			ifdef    dipswitch
  285: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  286: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  287: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  288: 1			;toepassing
  289: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  290: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  291: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  292: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  293: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  294: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  295: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  296: 1			endif    ;einde dipswitch
  297: 1			;******************************************************************************
  298: 1			endif    ;einde aduc_key
  299: 1
  300: 1
  301: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  302: 1
  303: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  304: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  305: 1			endif                               ;dus doen we dit hier nog eens!
  306: 1			;******************************************************************************
  307: 1
  308: 1			;******************************************************************************
  309: 1			;
  310: 1			; ADuc_lcd.inc
  311: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  312: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  313: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  314: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  315: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  316: 1			; het plaatsen van de cursor op een correcte plaats).
  317: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  318: 1			; display gebruiken.
  319: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  320: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  321: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  322: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  323: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  324: 1			;
  325: 1			; Versie ADuC832v1.1:
  326: 1			; Hier is het LCD verbonden met pinnen van poort0

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  327: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  328: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  329: 1			;
  330: 1			; Versie ADuC832v2.2:
  331: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  332: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  333: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  334: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  335: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  336: 1			;
  337: 1			;
  338: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  339: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  340: 1			;  aduclcd0.inc
  341: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  342: 1			;  aduclcd1.inc
  343: 1			;    -00dh en 00ah worden door outchar verwerkt
  344: 1			;    -bij de init wordt het display anders opgestart
  345: 1			;
  346: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  347: 1			;  van gebruik en uitgebreid  met :
  348: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  349: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  350: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  351: 1			;    debug doeleinden
  352: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  353: 1			;    user codes aan te maken
  354: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  355: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  356: 1			;
  357: 1			; Beschikbare routines:
  358: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  359: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  360: 1			; build_adr, delay2ms, delay60us
  361: 1			;******************************************************************************
  362: 1
  363: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  364: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  365: 1			e             bit    lcdport.2            ;enable
  366: 1			rs            bit    lcdport.3            ;register select
  367: 1			endif    ;einde aduc832_v1_1
  368: 1
  369: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  370: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  371: 1	B	 F1	e             bit    lcdport.1            ;enable
  372: 1	B	 F0	rs            bit    lcdport.0            ;register select
  373: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  374: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  375: 1			endif    ;einde aduc832_v2_0
  376: 1
  377: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  378: 1			;het uitvoeren van de overeenkomstige commando's.
  379: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  380: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  381: 1
  382: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  383: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  384: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  385: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  386: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  387: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  388: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  389: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  390: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  391: 1
  392: 1			;******************************************************************************
  393: 1			;
  394: 1			; initlcd
  395: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  396: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  397: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  398: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  399: 1			; Na initialisering wordt het scherm leeg gemaakt.
  400: 1			;
  401: 1			; registergebruik: geen
  402: 1			;
  403: 1			;******************************************************************************
  404: 1
  405: 1  0033	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  406: 1  0035	C0 D0		              push   psw
  407: 1  0037	C0 F0		              push   b
  408: 1			ifdef  aduc832_v1_1
  409: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  410: 1			                                   ;let op:twee laagste bits worden
  411: 1			                                   ;niet gebruikt
  412: 1			endif
  413: 1
  414: 1			ifdef    aduc832_v2_0
  415: 1  0039	12 03 29	              lcall  i2cinit              ;LCD via een I2C bus
  416: 1  003C	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  417: 1			                                          ;buzzer en backlight  op 1 gezet
  418: 1  003F	12 04 2C	              lcall  porttolcd            ;data uit b naar het scherm
  419: 1			endif
  420: 1
  421: 1  0042	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  422: 1  0044	12 02 FE	initlcd1:     lcall  delay2ms
  423: 1  0047	D5 E0 FA	              djnz   acc,initlcd1
  424: 1  004A	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  425: 1  004C	12 01 B5	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  426: 1  004F	12 02 FE	              lcall  delay2ms      ;om het display altijd opgestart
  427: 1  0052	74 30		              mov    a,#00110000b  ;te krijgen.
  428: 1  0054	12 01 B5	              lcall  outhnibc
  429: 1  0057	12 02 FE	              lcall  delay2ms
  430: 1  005A	74 30		              mov    a,#00110000b
  431: 1  005C	12 01 B5	              lcall  outhnibc
  432: 1  005F	12 02 FE	              lcall  delay2ms
  433: 1  0062	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  434: 1  0064	12 01 B5	              lcall  outhnibc      ;hoge nibble naar het controleregister
  435: 1  0067	12 02 FE	              lcall  delay2ms      ;niet nodig volgens datasheet
  436: 1  006A	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  437: 1  006C	12 01 9F	              lcall  outc          ;naar display
  438: 1  006F	12 02 FE	              lcall  delay2ms      ;is iets te lang volgens datasheet

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  439: 1  0072	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  440: 1  0074	12 01 9F	              lcall  outc
  441: 1  0077	12 02 FE	              lcall  delay2ms      ;ook deze delay is iets te lang
  442: 1  007A	74 01		              mov    a,#displayon  ;clear display and home cursor
  443: 1  007C	12 01 9F	              lcall  outc
  444: 1  007F	12 02 FE	              lcall  delay2ms      ;deze wachttijd is bijna juist
  445: 1  0082	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  446: 1  0084	12 01 9F	              lcall  outc
  447: 1  0087	12 02 FE	              lcall  delay2ms      ;wachten weer veel te lang
  448: 1  008A	D0 F0		              pop    b
  449: 1  008C	D0 D0		              pop    psw           ;registers terug in orde zetten
  450: 1  008E	D0 E0		              pop    acc
  451: 1  0090	22		              ret                  ;einde van de initialisatie
  452: 1
  453: 1			;******************************************************************************
  454: 1			;
  455: 1			; outcharlcd
  456: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  457: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  458: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  459: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  460: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  461: 1			; De controlekarakters komen overeen met volgende acties:
  462: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  463: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  464: 1			;              (line feed+ carriage return!)
  465: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  466: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  467: 1			;      011h   =cursor on, blink mode
  468: 1			;      012h   =cursor on, no blink mode
  469: 1			;      013h   =cursor off
  470: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  471: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  472: 1			;              van het LCD
  473: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  474: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  475: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  476: 1			; positie 6 (C5H-80H=45H)
  477: 1			;
  478: 1			; Deze routine vernietigt geen registers
  479: 1			;
  480: 1			;******************************************************************************
  481: 1
  482: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  483: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  484: 1			; dataregister van het scherm.
  485: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  486: 1			; controlebyte doorsturen naar het LCD.
  487: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  488: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  489: 1			; naar de LCD sturen.
  490: 1
  491: 1  0091	C0 E0		outcharlcd:   push   acc           ;registers op stack
  492: 1  0093	C0 D0		              push   psw
  493: 1  0095	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  494: 1  0098	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  495: 1  009A	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  496: 1  009D	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  497: 1  009F	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  498: 1  00A2	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  499: 1
  500: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  501: 1			; Als het een commando is, moeten we het uitvoeren.
  502: 1			; Indien niet, gewoon terug zonder actie!
  503: 1
  504: 1  00A4	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  505: 1  00A7	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  506: 1  00A9	80 28		              sjmp   outcharlcd9          ;afsluiten
  507: 1
  508: 1  00AB	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  509: 1  00AE	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  510: 1  00B0	80 21		              sjmp   outcharlcd9
  511: 1
  512: 1  00B2	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  513: 1  00B5	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  514: 1  00B7	80 1A		              sjmp   outcharlcd9
  515: 1
  516: 1  00B9	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  517: 1  00BC	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  518: 1  00BE	80 13		              sjmp   outcharlcd9
  519: 1
  520: 1  00C0	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  521: 1  00C3	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  522: 1  00C5	80 0C		              sjmp   outcharlcd9
  523: 1
  524: 1  00C7	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  525: 1  00CA	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  526: 1  00CC	80 05		              sjmp   outcharlcd9
  527: 1
  528: 1
  529: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  530: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  531: 1
  532: 1  00CE	12 01 65	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  533: 1  00D1	80 03		              sjmp   outcharlcde   ;einde routine
  534: 1
  535: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  536: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  537: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  538: 1			; op dat adres te zetten.
  539: 1
  540: 1  00D3	12 01 9F	outcharlcd9:  lcall  outc          ;klaar
  541: 1  00D6	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  542: 1  00D8	D0 E0		              pop    acc
  543: 1  00DA	22		              ret
  544: 1
  545: 1			;******************************************************************************
  546: 1			;
  547: 1			; outniblcd
  548: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  549: 1			; op het lcd scherm.
  550: 1			;

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  551: 1			; de routine vernietigt geen registers
  552: 1			;
  553: 1			;******************************************************************************
  554: 1
  555: 1  00DB	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  556: 1  00DD	C0 D0		              push   psw
  557: 1  00DF	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  558: 1  00E1	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  559: 1  00E3	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  560: 1  00E6	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  561: 1  00E8	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  562: 1  00EA	12 01 65	outniblcde:   lcall  outd          ;naar het scherm
  563: 1  00ED	D0 D0		              pop    psw
  564: 1  00EF	D0 E0		              pop    acc
  565: 1  00F1	22		              ret
  566: 1
  567: 1			;******************************************************************************
  568: 1			;
  569: 1			; outbytelcd
  570: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  571: 1			;
  572: 1			; de routine vernietigt geen registers
  573: 1			;
  574: 1			;******************************************************************************
  575: 1
  576: 1  00F2	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  577: 1  00F4	C0 D0		              push   psw
  578: 1  00F6	C4		              swap   a             ;bitjes omruilen
  579: 1  00F7	12 00 DB	              lcall  outniblcd
  580: 1  00FA	C4		              swap   a             ;nog eens
  581: 1  00FB	12 00 DB	              lcall  outniblcd
  582: 1  00FE	D0 D0		              pop    psw
  583: 1  0100	D0 E0		              pop    acc
  584: 1  0102	22		              ret
  585: 1
  586: 1			;******************************************************************************
  587: 1			;
  588: 1			; dispdptrlcd
  589: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  590: 1			;
  591: 1			; de routine vernietigt geen registers
  592: 1			;
  593: 1			;******************************************************************************
  594: 1
  595: 1  0103	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  596: 1  0105	C0 D0		              push   psw
  597: 1  0107	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  598: 1  0109	12 00 F2	              lcall  outbytelcd
  599: 1  010C	E5 82		              mov    a,dpl         ;dan het lage deel
  600: 1  010E	12 00 F2	              lcall  outbytelcd
  601: 1  0111	D0 D0		              pop    psw
  602: 1  0113	D0 E0		              pop    acc
  603: 1  0115	22		              ret
  604: 1
  605: 1			;******************************************************************************
  606: 1			;

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  607: 1			; outmsgalcd
  608: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  609: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  610: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  611: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  612: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  613: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  614: 1			;
  615: 1			; de routine vernietigt geen registers
  616: 1			;
  617: 1			;******************************************************************************
  618: 1
  619: 1  0116	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  620: 1  0118	C0 D0		              push   psw
  621: 1  011A	C0 83		              push   dph           ;ook de data pointer
  622: 1  011C	C0 82		              push   dpl
  623: 1
  624: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  625: 1
  626: 1  011E	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  627: 1  011F	93		              movc   a,@a+dptr     ;waarde lezen
  628: 1  0120	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  629: 1
  630: 1			; de code is niet 0 dus versturen met outchar
  631: 1
  632: 1  0122	12 00 91	              lcall  outcharlcd    ;weg er mee
  633: 1  0125	A3		              inc    dptr          ;naar volgende ascii code wijzen
  634: 1  0126	02 01 1E	              ljmp   outmsgalcd1   ;lus sluiten
  635: 1
  636: 1  0129	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  637: 1  012B	D0 83		              pop    dph
  638: 1  012D	D0 D0		              pop    psw
  639: 1  012F	D0 E0		              pop    acc
  640: 1  0131	22		              ret
  641: 1
  642: 1			;******************************************************************************
  643: 1			;
  644: 1			; regtolcd
  645: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  646: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  647: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  648: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  649: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  650: 1			;
  651: 1			; de routine vernietigt geen registers
  652: 1			;
  653: 1			;******************************************************************************
  654: 1
  655: 1
  656: 1  0132	C0 E0		regtolcd:     push   acc           ;registers op de stack
  657: 1  0134	C0 D0		              push   psw
  658: 1  0136	E8		              mov    a,r0
  659: 1  0137	C0 E0		              push   acc
  660: 1  0139	E9		              mov    a,r1
  661: 1  013A	C0 E0		              push   acc
  662: 1  013C	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  663: 1  013E	12 00 91	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  664: 1			                                   ;plaats
  665: 1  0141	79 00		              mov    r1,#000h      ;werkt als loopcounter
  666: 1  0143	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  667: 1  0144	12 00 91	              lcall  outcharlcd    ;weg er mee
  668: 1  0147	08		              inc    r0
  669: 1  0148	09		              inc    r1
  670: 1  0149	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  671: 1			                                          ;nieuwe lijn genomen worden
  672: 1  014C	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  673: 1  014E	12 00 91	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  674: 1			                                   ;plaats
  675: 1
  676: 1  0151	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  677: 1  0152	12 00 91	              lcall  outcharlcd    ;weg er mee
  678: 1  0155	08		              inc    r0
  679: 1  0156	09		              inc    r1
  680: 1  0157	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  681: 1  015A	D0 E0		              pop    acc
  682: 1  015C	F9		              mov    r1,a
  683: 1  015D	D0 E0		              pop    acc
  684: 1  015F	F8		              mov    r0,a
  685: 1  0160	D0 D0		              pop    psw           ;registers herstellen
  686: 1  0162	D0 E0		              pop    acc
  687: 1  0164	22		              ret
  688: 1
  689: 1			;******************************************************************************
  690: 1			;
  691: 1			; outd
  692: 1			; Is een routine die naar het data register van het display een
  693: 1			; volledige byte stuurt.
  694: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  695: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  696: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  697: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  698: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  699: 1			;
  700: 1			; De routine vernietigt geen registers.
  701: 1			;
  702: 1			;******************************************************************************
  703: 1
  704: 1  0165	C0 E0		outd:         push   acc           ;registers op stack zetten
  705: 1  0167	C0 D0		              push   psw
  706: 1  0169	12 01 75	              lcall  outhnibd      ;hoogste vier bits verzenden
  707: 1			ifdef     aduc832_v1_1
  708: 1			              lcall  delay60us     ;niet echt nodig
  709: 1			endif
  710: 1  016C	C4		              swap   a             ;bitjes omruilen
  711: 1  016D	12 01 75	              lcall  outhnibd      ;naar het scherm sturen
  712: 1
  713: 1			ifdef    aduc832_v1_1
  714: 1			              lcall  delay60us     ;altijd goed
  715: 1			endif
  716: 1
  717: 1  0170	D0 D0		              pop    psw           ;registers terug herstellen
  718: 1  0172	D0 E0		              pop    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  719: 1  0174	22		              ret
  720: 1
  721: 1			;******************************************************************************
  722: 1			;
  723: 1			; outhnibd
  724: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  725: 1			; lcd scherm.
  726: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  727: 1			; de routine vernietigt geen registers.
  728: 1			;
  729: 1			;******************************************************************************
  730: 1			ifdef     aduc832_v1_1
  731: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  732: 1			              push   psw
  733: 1			              setb   rs            ;controle lijn in orde
  734: 1			              clr    e             ;deselectie display
  735: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  736: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  737: 1			              mov     c,acc.6      ;afblijven!
  738: 1			              mov     lcdport.6,c
  739: 1			              mov     c,acc.5
  740: 1			              mov     lcdport.5,c
  741: 1			              mov     c,acc.4
  742: 1			              mov     lcdport.4,c
  743: 1			              setb   e             ;display enabelen
  744: 1			              nop                  ;450ns is normaal gezien voldoende
  745: 1			              clr    e             ;display deselecteren
  746: 1			              pop    psw           ;registers herstellen
  747: 1			              pop    acc
  748: 1			              ret
  749: 1			endif
  750: 1
  751: 1			ifdef    aduc832_v2_0
  752: 1  0175	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  753: 1  0177	C0 D0		              push   psw
  754: 1  0179	C0 F0		              push   b             ;werkregister
  755: 1  017B	12 04 45	              lcall  lcdtoport     ;lees de expander naar b register
  756: 1  017E	D2 F0		              setb   rs            ;controle lijn in orde
  757: 1  0180	C2 F1		              clr    e             ;deselectie display
  758: 1  0182	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  759: 1  0184	03		              rr     a             ;bits op juiste plaats zetten
  760: 1  0185	03		              rr     a             ;voor b reg
  761: 1  0186	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  762: 1  0189	42 F0		              orl    b,a           ;bij elkaar voegen
  763: 1  018B	12 04 2C	              lcall  porttolcd     ;naar expander
  764: 1  018E	D2 F1		              setb   e             ;display enabelen
  765: 1  0190	12 04 2C	              lcall  porttolcd
  766: 1  0193	C2 F1		              clr    e             ;display deselecteren
  767: 1  0195	12 04 2C	              lcall  porttolcd
  768: 1  0198	D0 F0		              pop    b
  769: 1  019A	D0 D0		              pop    psw           ;registers herstellen
  770: 1  019C	D0 E0		              pop    acc
  771: 1  019E	22		              ret
  772: 1			endif
  773: 1			;******************************************************************************
  774: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  775: 1			; outc
  776: 1			; Is een routine die naar het controleregister van het display een
  777: 1			; volledige byte (commando) stuurt.
  778: 1			; De routine vernietigt geen registers.
  779: 1			;
  780: 1			;******************************************************************************
  781: 1
  782: 1  019F	C0 E0		outc:         push   acc           ;registers op stack zetten
  783: 1  01A1	C0 D0		              push   psw
  784: 1  01A3	12 01 B5	              lcall  outhnibc      ;hoogste vier bits verzenden
  785: 1  01A6	12 02 FE	              lcall  delay2ms      ;niet echt nodig
  786: 1  01A9	C4		              swap   a             ;bitjes omruilen
  787: 1  01AA	12 01 B5	              lcall  outhnibc      ;naar het scherm sturen
  788: 1  01AD	12 02 FE	              lcall  delay2ms      ;altijd goed voor traagste commando
  789: 1  01B0	D0 D0		              pop    psw           ;registers terug herstellen
  790: 1  01B2	D0 E0		              pop    acc
  791: 1  01B4	22		              ret
  792: 1
  793: 1			;******************************************************************************
  794: 1			;
  795: 1			; outhnibc
  796: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  797: 1			; het lcd scherm.
  798: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  799: 1			; de routine vernietigt geen registers.
  800: 1			;
  801: 1			;******************************************************************************
  802: 1			ifdef     aduc832_v1_1
  803: 1			outhnibc:     push   acc           ;registers op stack plaatsen
  804: 1			              push   psw
  805: 1			              clr    rs            ;controle lijn in orde
  806: 1			              clr    e             ;deselectie display
  807: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  808: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  809: 1			              mov     c,acc.6      ;afblijven!
  810: 1			              mov     lcdport.6,c
  811: 1			              mov     c,acc.5
  812: 1			              mov     lcdport.5,c
  813: 1			              mov     c,acc.4
  814: 1			              mov     lcdport.4,c
  815: 1			              setb   e             ;display enabelen
  816: 1			              nop                  ;450ns is normaal gezien voldoende
  817: 1			              clr    e             ;display deselecteren
  818: 1			              pop    psw           ;registers herstellen
  819: 1			              pop    acc
  820: 1			              ret
  821: 1			endif
  822: 1
  823: 1			ifdef    aduc832_v2_0
  824: 1  01B5	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
  825: 1  01B7	C0 D0		              push   psw
  826: 1  01B9	C0 F0		              push   b             ;werkregister
  827: 1  01BB	12 04 45	              lcall  lcdtoport     ;lees de expander naar b register
  828: 1  01BE	C2 F0		              clr    rs            ;controle lijn in orde
  829: 1  01C0	C2 F1		              clr    e             ;deselectie display
  830: 1  01C2	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  831: 1  01C4	03		              rr     a             ;bits op juiste plaats zetten
  832: 1  01C5	03		              rr     a             ;voor b reg
  833: 1  01C6	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  834: 1  01C9	42 F0		              orl    b,a           ;bij elkaar voegen
  835: 1  01CB	12 04 2C	              lcall  porttolcd     ;naar expnder
  836: 1  01CE	D2 F1		              setb   e             ;display enabelen
  837: 1  01D0	12 04 2C	              lcall  porttolcd
  838: 1  01D3	C2 F1		              clr    e             ;display deselecteren
  839: 1  01D5	12 04 2C	              lcall  porttolcd
  840: 1  01D8	D0 F0		              pop    b
  841: 1  01DA	D0 D0		              pop    psw           ;registers herstellen
  842: 1  01DC	D0 E0		              pop    acc
  843: 1  01DE	22		              ret
  844: 1			endif
  845: 1
  846: 1			;******************************************************************************
  847: 1			; hexbuf2lcd
  848: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  849: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  850: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  851: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  852: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  853: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  854: 1			;
  855: 1			; ADR| HEX DATA  |
  856: 1			; 42 |AF 2D 23 5A|
  857: 1			;
  858: 1			; Deze routine vernietigt geen registers
  859: 1			;******************************************************************************
  860: 1
  861: 1  01DF	C0 E0		hexbuf2lcd:   push   acc
  862: 1  01E1	C0 F0		              push   b
  863: 1  01E3	C0 D0		              push   psw
  864: 1  01E5	C0 82		              push   dpl
  865: 1  01E7	C0 83		              push   dph
  866: 1  01E9	E8		              mov     a,r0
  867: 1  01EA	C0 E0		              push   acc
  868: 1  01EC	90 02 28	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
  869: 1  01EF	12 01 16	              lcall   outmsgalcd
  870: 1  01F2	E8		              mov    a,r0            ;neem pointerwaarde
  871: 1  01F3	12 00 F2	              lcall  outbytelcd      ;byte afdrukken als startadres
  872: 1  01F6	74 20		              mov    a,#' '          ;spatie afdrukken
  873: 1  01F8	12 00 91	              lcall  outcharlcd
  874: 1  01FB	74 7C		              mov    a,#'|'          ;pipe afdrukken
  875: 1  01FD	12 00 91	              lcall  outcharlcd
  876: 1  0200	75 F0 04	              mov    b,#4            ;bytecounter=4
  877: 1  0203	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  878: 1  0204	12 00 F2	              lcall  outbytelcd      ;byte naar buiten
  879: 1  0207	74 20		              mov    a,#' '          ;neem whitespace char
  880: 1  0209	12 00 91	              lcall  outcharlcd       ;druk af
  881: 1  020C	08		              inc    r0              ;volgende byte
  882: 1  020D	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
  883: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  884: 1  0210	74 CF		              mov    a,#0cfh         ;adres laatste char
  885: 1  0212	12 00 91	              lcall   outcharlcd
  886: 1  0215	74 7C		              mov    a,#'|'          ;neem pipe

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  887: 1  0217	12 00 91	              lcall  outcharlcd      ;ascii code afdrukken
  888: 1  021A	D0 E0		hexbuf2lcde:  pop    acc
  889: 1  021C	F8		              mov   r0,a
  890: 1  021D	D0 83		              pop   dph
  891: 1  021F	D0 82		              pop   dpl
  892: 1  0221	D0 D0		              pop   psw
  893: 1  0223	D0 F0		              pop   b
  894: 1  0225	D0 E0		              pop   acc
  895: 1  0227	22		              ret
  896: 1			                        ;'0123456789abcdef'
  897: 1  0228	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  022C	52 7C 20 48
       1  0230	45 58 20 44
       1  0234	41 54 41 20
       1  0238	20 7C C0 00
  898: 1
  899: 1
  900: 1			;******************************************************************************
  901: 1			; barlcd
  902: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
  903: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
  904: 1			; de inhoud van A
  905: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
  906: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
  907: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
  908: 1			; aangemaakt in de LCD CGRAM.
  909: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
  910: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
  911: 1			;       lcall build
  912: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
  913: 1			;       mov     a, #42h     ;de startlocatie is 42h
  914: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
  915: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
  916: 1			;
  917: 1			; Deze routine vernietigt geen registers.
  918: 1			;******************************************************************************
  919: 1
  920: 1  023C	C0 82		barlcd:       push   dpl
  921: 1  023E	88 82		              mov     dpl,r0
  922: 1  0240	C0 82		              push   dpl
  923: 1  0242	C0 E0		              push   acc            ;bewaar startlocatie
  924: 1  0244	C0 D0		              push   psw            ;bewaar status
  925: 1  0246	C0 F0		              push   b              ;bewaar aantal bar's
  926: 1  0248	F5 F0		              mov    b,a            ;bewaar startlocatie
  927: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
  928: 1  024A	E8		              mov    a,r0           ;neem maximum aantal bar's
  929: 1  024B	C0 F0		              push   b              ;bewaar startadres
  930: 1  024D	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
  931: 1  0250	84		              div    ab             ;bereken dus het aantal nodige blokjes
  932: 1  0251	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
  933: 1  0252	E5 F0		              mov    a,b            ;neem restbars
  934: 1  0254	60 01		              jz     barlcd_1       ;als nul dan verder
  935: 1  0256	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
  936: 1  0257	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
  937: 1  0259	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
  938: 1  025B	12 00 91	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  939: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
  940: 1  025E	74 13		              mov    a,#13h         ;cursor off
  941: 1  0260	12 00 91	              lcall  outcharlcd     ;stuur naar LCD
  942: 1  0263	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
  943: 1  0265	C0 F0		              push   b              ;en weer bewaren
  944: 1  0267	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
  945: 1  0269	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
  946: 1  026B	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
  947: 1  026E	84		              div    ab             ;A=aantal volle blokjes, B=rest
  948: 1  026F	C0 F0		              push   b              ;bewaar rest
  949: 1  0271	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
  950: 1  0273	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
  951: 1
  952: 1			;Druk de volle 5x8 blokjes af van de bargraph
  953: 1  0275	74 04		              mov    a,#4           ;neem code voor vol blokje
  954: 1  0277	12 01 65	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
  955: 1  027A	18		              dec    r0             ;verminder karaktersteller
  956: 1  027B	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
  957: 1
  958: 1			;Druk het onvolledige blokje (rest) af
  959: 1  027E	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
  960: 1  0280	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
  961: 1  0282	14		              dec    a              ;converteer rest naar code voor de
  962: 1			                                    ;overeenkomende bar's
  963: 1  0283	12 01 65	              lcall  outd           ;druk resterende bar's af
  964: 1  0286	18		              dec    r0             ;verminder karakterteller
  965: 1
  966: 1			;Test of we aan het einde van de bargraph zitten..
  967: 1  0287	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
  968: 1  028A	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
  969: 1
  970: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
  971: 1  028C	74 20		barlcd4:      mov    a,#' '         ;neem spatie
  972: 1  028E	12 01 65	              lcall  outd           ;en druk af
  973: 1  0291	18		              dec    r0             ;karakterteller verminderen
  974: 1  0292	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
  975: 1
  976: 1  0294	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
  977: 1  0296	D0 D0		              pop    psw            ;haal status weer
  978: 1  0298	D0 E0		              pop    acc            ;haal startlocatie weer
  979: 1  029A	D0 82		              pop    dpl
  980: 1  029C	A8 82		              mov    r0,dpl
  981: 1  029E	D0 82		              pop    dpl
  982: 1  02A0	22		              ret
  983: 1
  984: 1
  985: 1
  986: 1			;******************************************************************************
  987: 1			; barchars
  988: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
  989: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
  990: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
  991: 1			; kunnen pas daarna worden gebruikt.
  992: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
  993: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
  994: 1			; (max. 3 extra char's).

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

  995: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
  996: 1			; opgeslagen met MSB=1.
  997: 1			;******************************************************************************
  998: 1
  999: 1  02A1	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1000: 1  02A2	10		              db 00010000b
 1001: 1  02A3	10		              db 00010000b
 1002: 1  02A4	10		              db 00010000b
 1003: 1  02A5	10		              db 00010000b
 1004: 1  02A6	10		              db 00010000b
 1005: 1  02A7	10		              db 00010000b
 1006: 1  02A8	10		              db 00010000b
 1007: 1
 1008: 1  02A9	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1009: 1  02AA	18		              db 00011000b
 1010: 1  02AB	18		              db 00011000b
 1011: 1  02AC	18		              db 00011000b
 1012: 1  02AD	18		              db 00011000b
 1013: 1  02AE	18		              db 00011000b
 1014: 1  02AF	18		              db 00011000b
 1015: 1  02B0	18		              db 00011000b
 1016: 1
 1017: 1  02B1	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1018: 1  02B2	1C		              db 00011100b
 1019: 1  02B3	1C		              db 00011100b
 1020: 1  02B4	1C		              db 00011100b
 1021: 1  02B5	1C		              db 00011100b
 1022: 1  02B6	1C		              db 00011100b
 1023: 1  02B7	1C		              db 00011100b
 1024: 1  02B8	1C		              db 00011100b
 1025: 1
 1026: 1  02B9	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1027: 1  02BA	1E		              db 00011110b
 1028: 1  02BB	1E		              db 00011110b
 1029: 1  02BC	1E		              db 00011110b
 1030: 1  02BD	1E		              db 00011110b
 1031: 1  02BE	1E		              db 00011110b
 1032: 1  02BF	1E		              db 00011110b
 1033: 1  02C0	1E		              db 00011110b
 1034: 1
 1035: 1  02C1	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1036: 1  02C2	1F		              db 00011111b
 1037: 1  02C3	1F		              db 00011111b
 1038: 1  02C4	1F		              db 00011111b
 1039: 1  02C5	1F		              db 00011111b
 1040: 1  02C6	1F		              db 00011111b
 1041: 1  02C7	1F		              db 00011111b
 1042: 1  02C8	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1043: 1
 1044: 1			;******************************************************************************
 1045: 1			;
 1046: 1			; build
 1047: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1048: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1049: 1			; overeen komen met de ASCII codes 00h-07h.
 1050: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1051: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1052: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1053: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1054: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1055: 1			;
 1056: 1			; De routine vernietigt geen registers.
 1057: 1			;
 1058: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1059: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1060: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1061: 1			;      lcall  outcharlcd         ; druk de karakter af
 1062: 1			;
 1063: 1			;eigenkarakter:
 1064: 1			;      db 00001110b
 1065: 1			;      db 00001010b
 1066: 1			;      db 00001110b
 1067: 1			;      db 00000100b
 1068: 1			;      db 00011111b
 1069: 1			;      db 00000100b
 1070: 1			;      db 00001010b
 1071: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1072: 1			;******************************************************************************
 1073: 1
 1074: 1  02C9	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1075: 1  02CB	C0 D0		              push   psw
 1076: 1  02CD	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1077: 1  02CF	12 02 D7	              lcall  build_adr
 1078: 1  02D2	D0 D0		              pop    psw
 1079: 1  02D4	D0 E0		              pop    acc
 1080: 1  02D6	22		              ret                  ;terug
 1081: 1
 1082: 1			;******************************************************************************
 1083: 1			; build_adr
 1084: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1085: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1086: 1			; die overeen komen met de ASCII codes 00h-07h.
 1087: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1088: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1089: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1090: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1091: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1092: 1			;
 1093: 1			; De routine vernietigt geen registers.
 1094: 1			;
 1095: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1096: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1097: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1098: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1099: 1			;      lcall  outcharlcd        ; druk de karakter af
 1100: 1			;
 1101: 1			;eigenkarakters:
 1102: 1			;      db 00001110b
 1103: 1			;      db 00001010b
 1104: 1			;      db 00001110b
 1105: 1			;       db 00000100b
 1106: 1			;      db 00011111b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1107: 1			;      db 00000100b
 1108: 1			;      db 00001010b
 1109: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1110: 1			;******************************************************************************
 1111: 1  02D7	C0 E0		build_adr:      push   acc
 1112: 1  02D9	C0 D0		              push   psw
 1113: 1  02DB	C0 83		              push   dph
 1114: 1  02DD	C0 82		              push   dpl
 1115: 1  02DF	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1116: 1  02E1	12 01 9F	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1117: 1  02E4	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1118: 1  02E6	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1119: 1  02E7	12 01 65	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1120: 1  02EA	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1121: 1  02ED	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1122: 1  02EE	80 F4		              sjmp   build3
 1123: 1  02F0	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1124: 1  02F2	12 01 9F	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1125: 1  02F5	D0 82		              pop    dpl
 1126: 1  02F7	D0 83		              pop    dph
 1127: 1  02F9	D0 D0		              pop    psw
 1128: 1  02FB	D0 E0		              pop    acc
 1129: 1  02FD	22		              ret
 1130: 1
 1131: 1			;******************************************************************************
 1132: 1			;
 1133: 1			; delay2ms
 1134: 1			; Is een vertragingsroutine van 2ms.
 1135: 1			;
 1136: 1			; De routine vernietigt geen registers.
 1137: 1			;
 1138: 1			;******************************************************************************
 1139: 1
 1140: 1  02FE	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1141: 1  0300	C0 D0		              push   psw
 1142: 1  0302	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1143: 1  0304	12 03 0F	delay2ms1:    lcall  delay60us
 1144: 1  0307	D5 E0 FA	              djnz   acc,delay2ms1
 1145: 1  030A	D0 D0		              pop    psw           ;registers herstellen
 1146: 1  030C	D0 E0		              pop    acc
 1147: 1  030E	22		              ret
 1148: 1
 1149: 1			;******************************************************************************
 1150: 1			;
 1151: 1			; delay60us.
 1152: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1153: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1154: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1155: 1			;
 1156: 1			; de routine vernietigt geen registers.
 1157: 1			;
 1158: 1			;******************************************************************************
 1159: 1
 1160: 1  030F	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1161: 1  0311	C0 D0		              push   psw
 1162: 1  0313	E5 D7		              mov    a,pllcon      ;pllcon inlezen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1163: 1  0315	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1164: 1
 1165: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1166: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1167: 1
 1168: 1  0317	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1169: 1  031A	D0 E0		              pop    acc           ;registers herstellen
 1170: 1  031C	D0 D0		              pop    psw
 1171: 1  031E	22		              ret
 1172: 1
 1173: 1  031F	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1174: 1  0321	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1175: 1  0324	D0 D0		              pop    psw
 1176: 1  0326	D0 E0		              pop    acc
 1177: 1  0328	22		              ret
 1178: 1
 1179: 1			endif        ;einde van aduc_lcd
 1180: 1
 1181: 1
 1182: 1
 1183: 1
 1184: 1			ifdef aduc_i2c
 1185: 1			;******************************************************************************
 1186: 1			;
 1187: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1188: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1189: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1190: 1			;
 1191: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1192: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1193: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1194: 1			;
 1195: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1196: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1197: 1			;
 1198: 1			; Beschikbare routines:
 1199: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1200: 1			; i2cstart     :verzenden van een start conditie
 1201: 1			; i2cstop      :verzenden van een stop conditie
 1202: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1203: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1204: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1205: 1			;               negende klokpuls
 1206: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1207: 1			;               negende klokpuls
 1208: 1			;
 1209: 1			; Toevoeging [dp]
 1210: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1211: 1			;               een slavedevice
 1212: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1213: 1			;               en plaatst deze in een geheugenbuffer
 1214: 1			;******************************************************************************
 1215: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1216: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1217: 1			;pcf8574		set		1				;bij gewone portexpander met

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

       1			 adres 40h
 1218: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1219: 1
 1220: 1			;******************************************************************************
 1221: 1			; i2cinit
 1222: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1223: 1			;******************************************************************************
 1224: 1  0329	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1225: 1  032B	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1226: 1  032D	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1227: 1  032F	D2 EB		                setb    i2cm            ;master mode inschakelen
 1228: 1  0331	22		                ret
 1229: 1			;******************************************************************************
 1230: 1			; i2cstart
 1231: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1232: 1			;******************************************************************************
 1233: 1  0332	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1234: 1  0334	C2 EF		                clr     mdo             ;data moet laag worden
 1235: 1  0336	D2 EE		                setb    mde             ;data pin enable
 1236: 1  0338	C2 ED		                clr     mco             ;klok laag maken
 1237: 1  033A	22		                ret
 1238: 1			;******************************************************************************
 1239: 1			; i2cstop
 1240: 1			; Dit is een subroutine die de stop conditie opwekt.
 1241: 1			;******************************************************************************
 1242: 1  033B	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1243: 1  033D	D2 EE		                setb    mde             ;data mag naar buiten
 1244: 1  033F	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1245: 1  0341	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1246: 1  0343	22		                ret
 1247: 1
 1248: 1			;******************************************************************************
 1249: 1			; i2coutbyte
 1250: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1251: 1			; De routine vernietigt geen registers.
 1252: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1253: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1254: 1			;         uitvoeren van de routine.
 1255: 1			;******************************************************************************
 1256: 1  0344	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1257: 1  0346	C0 F0		                push    b
 1258: 1  0348	75 F0 08	                mov     b,#008h         ;loopcounter
 1259: 1  034B	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1260: 1  034C	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1261: 1  034E	D2 EE		                setb    mde             ;pin als output activeren
 1262: 1  0350	D2 ED		                setb    mco             ;klokpukls hoog
 1263: 1  0352	C2 ED		                clr     mco             ;klokpuls laag
 1264: 1  0354	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1265: 1  0357	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1266: 1  0359	D2 ED		                setb    mco             ;klokpuls hoog
 1267: 1  035B	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1268: 1  035D	C2 ED		                clr     mco             ;klokpuls terug laag
 1269: 1  035F	D0 F0		                pop     b
 1270: 1  0361	D0 E0		                pop     acc             ;registers herstellen
 1271: 1  0363	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1272: 1
 1273: 1			;******************************************************************************
 1274: 1			; i2cinbyteack
 1275: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1276: 1			; De routine vernietigt geen registers. De routine zal als
 1277: 1			; negende bit een ack verzenden.
 1278: 1			;******************************************************************************
 1279: 1  0364	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1280: 1  0366	C0 D0		                push    psw
 1281: 1  0368	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1282: 1  036B	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1283: 1  036D	D2 ED		                setb    mco             ;klokpuls hoog
 1284: 1  036F	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1285: 1  0371	C2 ED		                clr     mco             ;klokpuls terug laag
 1286: 1  0373	33		                rlc     a               ;in accu shiften
 1287: 1  0374	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1288: 1  0377	C3		                clr     c               ;ack verzenden
 1289: 1  0378	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1290: 1  037A	D2 EE		                setb    mde             ;pin als output activeren
 1291: 1  037C	D2 ED		                setb    mco             ;klokpukls hoog
 1292: 1  037E	C2 ED		                clr     mco             ;klokpuls laag
 1293: 1  0380	D0 D0		                pop     psw             ;registers herstellen
 1294: 1  0382	D0 F0		                pop     b
 1295: 1  0384	22		                ret
 1296: 1
 1297: 1			;******************************************************************************
 1298: 1			; i2cinbytenack
 1299: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1300: 1			; De routine vernietigt geen registers. De routine zal als
 1301: 1			; negende bit een nack verzenden.
 1302: 1			;******************************************************************************
 1303: 1  0385	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1304: 1  0387	C0 D0		                push    psw
 1305: 1  0389	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1306: 1  038C	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1307: 1  038E	D2 ED		                setb    mco             ;klokpuls hoog
 1308: 1  0390	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1309: 1  0392	C2 ED		                clr     mco             ;klokpuls terug laag
 1310: 1  0394	33		                rlc     a               ;in accu shiften
 1311: 1  0395	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1312: 1  0398	D3		                setb    c               ;nack verzenden
 1313: 1  0399	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1314: 1  039B	D2 EE		                setb    mde             ;pin als output activeren
 1315: 1  039D	D2 ED		                setb    mco             ;klokpukls hoog
 1316: 1  039F	C2 ED		                clr     mco             ;klokpuls laag
 1317: 1  03A1	D0 D0		                pop     psw             ;registers herstellen
 1318: 1  03A3	D0 F0		                pop     b
 1319: 1  03A5	22		                ret
 1320: 1
 1321: 1			;******************************************************************************
 1322: 1			; i2csenddata
 1323: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1324: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1325: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1326: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1327: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1328: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1329: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1330: 1			;
 1331: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1332: 1			; pointer naar deze data.  .
 1333: 1
 1334: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1335: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1336: 1			;         B       = aantal te versturen bytes (minimum 1)
 1337: 1			;         R0      = startadres van te versturen datablok
 1338: 1			;
 1339: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1340: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1341: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1342: 1			;               verzonden byte waarvoor er geen ack kwam.
 1343: 1			;
 1344: 1			; Deze routine vernietigt niets...
 1345: 1			;******************************************************************************
 1346: 1  03A6	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1347: 1  03A8	C0 D0		                    push   psw
 1348: 1  03AA	E8		                    mov    a,r0
 1349: 1  03AB	C0 E0		                    push   acc           ;r0 op stack
 1350: 1
 1351: 1  03AD	12 03 32	                    lcall  i2cstart      ;genereer startconditie
 1352: 1  03B0	E5 83		                    mov    a,dph         ;neem adresbyte
 1353: 1  03B2	12 03 44	                    lcall  i2coutbyte    ;en verstuur naar slave
 1354: 1  03B5	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1355: 1  03B7	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1356: 1  03B9	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1357: 1  03BB	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1358: 1			;10 bit adressering!
 1359: 1  03BE	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1360: 1  03C0	12 03 44	                    lcall  i2coutbyte    ;en verstuur naar slave
 1361: 1  03C3	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1362: 1			;7 bit adressering!
 1363: 1  03C5	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1364: 1  03C6	12 03 44	                    lcall  i2coutbyte    ;en verstuur naar slave
 1365: 1  03C9	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1366: 1  03CB	08		                    inc    r0            ;volgende byte
 1367: 1  03CC	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1368: 1  03CF	12 03 3B	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1369: 1  03D2	D0 E0		                    pop    acc
 1370: 1  03D4	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1371: 1  03D5	D0 D0		                    pop    psw
 1372: 1  03D7	C3		                    clr    c             ;alles is ok!
 1373: 1  03D8	D0 E0		                    pop    acc
 1374: 1  03DA	22		                    ret
 1375: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1376: 1  03DB	12 03 3B	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1377: 1  03DE	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1378: 1  03E0	D0 D0		                    pop    psw
 1379: 1  03E2	D3		                    setb   c            ;terug met foutmelding
 1380: 1  03E3	D0 E0		                    pop    acc
 1381: 1  03E5	22		                    ret
 1382: 1
 1383: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1384: 1			; i2crcvdata
 1385: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1386: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1387: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1388: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1389: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1390: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1391: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1392: 1			;
 1393: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1394: 1			; is een pointer naar de start van dit ontvangen datablok.
 1395: 1			;
 1396: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1397: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1398: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1399: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1400: 1			;
 1401: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1402: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1403: 1			;               het adres, wordt de CY bit geset bij return.
 1404: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1405: 1			;
 1406: 1			; Deze routine vernietigt verder niets...
 1407: 1			;******************************************************************************
 1408: 1  03E6	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1409: 1  03E8	C0 D0		                    push    psw
 1410: 1  03EA	E8		                    mov     a,r0            ;r0 op stack
 1411: 1  03EB	C0 E0		                    push    acc
 1412: 1
 1413: 1  03ED	12 03 32	                    lcall   i2cstart        ;genereer startconditie
 1414: 1  03F0	E5 83		                    mov     a,dph           ;neem adresbyte
 1415: 1  03F2	12 03 44	                    lcall   i2coutbyte      ;en verstuur naar slave
 1416: 1  03F5	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1417: 1  03F7	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1418: 1  03F9	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1419: 1  03FB	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1420: 1			;10 bit adressering!
 1421: 1  03FE	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1422: 1  0400	12 03 44	                    lcall   i2coutbyte      ;en verstuur naar slave
 1423: 1  0403	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1424: 1			;7 bit adressering!
 1425: 1
 1426: 1  0405	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1427: 1  0408	12 03 85	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1428: 1  040B	F6		                    mov     @r0,a           ;en deze ook bewaren
 1429: 1  040C	80 07		                    sjmp    i2crcvdata3
 1430: 1  040E	12 03 64	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1431: 1  0411	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1432: 1  0412	08		                    inc     r0              ;pointer verhogen
 1433: 1  0413	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1434: 1
 1435: 1  0415	12 03 3B	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1436: 1  0418	D0 E0		                    pop     acc
 1437: 1  041A	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1438: 1  041B	D0 D0		                    pop     psw
 1439: 1  041D	C3		                    clr     c               ;alles is ok!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1440: 1  041E	D0 E0		                    pop     acc
 1441: 1  0420	22		                    ret
 1442: 1			;fout: geen ack gekregen bij het versturen van het adres
 1443: 1  0421	12 03 3B	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1444: 1  0424	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1445: 1  0426	D0 D0		                    pop        psw
 1446: 1  0428	D3		                    setb    c               ;terug met foutmelding
 1447: 1  0429	D0 E0		                    pop        acc
 1448: 1  042B	22		                    ret
 1449: 1
 1450: 1
 1451: 1			;******************************************************************************
 1452: 1			;
 1453: 1			; porttolcd
 1454: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1455: 1			; scherm stuurt via de port expander.
 1456: 1			;
 1457: 1			; Gebruikt geen registers
 1458: 1			;
 1459: 1			;******************************************************************************
 1460: 1
 1461: 1  042C	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1462: 1  042E	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1463: 1  0430	12 03 32	              lcall  i2cstart      ;vertrokken
 1464: 1			ifdef    pcf8574
 1465: 1			              mov    a,#01000000b  ;schrijven naar expander
 1466: 1			endif
 1467: 1			ifdef    pcf8574A
 1468: 1  0433	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1469: 1			endif
 1470: 1  0435	12 03 44	              lcall  i2coutbyte    ;weg er mee
 1471: 1  0438	E5 F0		              mov    a,b           ;data verzenden
 1472: 1  043A	12 03 44	              lcall  i2coutbyte
 1473: 1  043D	12 03 3B	              lcall  i2cstop       ;transactie sluiten
 1474: 1  0440	D0 D0		              pop    psw
 1475: 1  0442	D0 E0		              pop    acc
 1476: 1  0444	22		              ret
 1477: 1
 1478: 1			;******************************************************************************
 1479: 1			;
 1480: 1			; lcdtoport
 1481: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1482: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1483: 1			; aansturen van de buzzer en backlight.
 1484: 1			;
 1485: 1			; output: b register
 1486: 1			;
 1487: 1			;******************************************************************************
 1488: 1
 1489: 1  0445	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1490: 1  0447	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1491: 1  0449	12 03 32	              lcall  i2cstart      ;vertrokken
 1492: 1			ifdef    pcf8574
 1493: 1			              mov    a,#01000000b  ;schrijven naar expander
 1494: 1			endif
 1495: 1			ifdef    pcf8574A

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1496: 1  044C	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1497: 1			endif
 1498: 1  044E	12 03 44	              lcall  i2coutbyte    ;weg er mee
 1499: 1  0451	12 03 85	              lcall  i2cinbytenack ;data inlezen
 1500: 1  0454	12 03 3B	              lcall  i2cstop
 1501: 1  0457	F5 F0		              mov    b,a
 1502: 1  0459	D0 D0		              pop    psw
 1503: 1  045B	D0 E0		              pop    acc
 1504: 1  045D	22		              ret
 1505: 1
 1506: 1			;******************************************************************************
 1507: 1			;
 1508: 1			; lcdlighton
 1509: 1			; Dit is een subroutine die de backlight inschakeld
 1510: 1			;
 1511: 1			; Gebruikt geen registers
 1512: 1			;
 1513: 1			;******************************************************************************
 1514: 1
 1515: 1  045E	C0 F0		lcdlighton:   push   b
 1516: 1  0460	12 04 45	              lcall  lcdtoport     ;expander lezen
 1517: 1  0463	C2 F6		              clr    b.6           ;licht aan doen
 1518: 1  0465	12 04 2C	              lcall  porttolcd     ;expander schrijven
 1519: 1  0468	D0 F0		              pop    b
 1520: 1  046A	22		              ret
 1521: 1
 1522: 1
 1523: 1			;******************************************************************************
 1524: 1			;
 1525: 1			; lcdlightoff
 1526: 1			; Dit is een subroutine die de backlight uitschakeld
 1527: 1			;
 1528: 1			; Gebruikt geen registers
 1529: 1			;
 1530: 1			;******************************************************************************
 1531: 1
 1532: 1  046B	C0 F0		lcdlightoff:  push   b
 1533: 1  046D	12 04 45	              lcall  lcdtoport     ;expander lezen
 1534: 1  0470	D2 F6		              setb   b.6           ;licht uit doen
 1535: 1  0472	12 04 2C	              lcall  porttolcd     ;expander schrijven
 1536: 1  0475	D0 F0		              pop    b
 1537: 1  0477	22		              ret
 1538: 1
 1539: 1			;******************************************************************************
 1540: 1			;
 1541: 1			; lcdbuzon
 1542: 1			; Dit is een subroutine die de buzzer inschakeld
 1543: 1			;
 1544: 1			; Gebruikt geen registers
 1545: 1			;
 1546: 1			;******************************************************************************
 1547: 1
 1548: 1  0478	C0 F0		lcdbuzon:     push   b
 1549: 1  047A	12 04 45	              lcall  lcdtoport     ;expander lezen
 1550: 1  047D	C2 F7		              clr    b.7           ;buzzer aan doen
 1551: 1  047F	12 04 2C	              lcall  porttolcd     ;expander schrijven

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1552: 1  0482	D0 F0		              pop    b
 1553: 1  0484	22		              ret
 1554: 1
 1555: 1			;******************************************************************************
 1556: 1			;
 1557: 1			; lcdbuzoff
 1558: 1			; Dit is een subroutine die de buzzer uitschakeld
 1559: 1			;
 1560: 1			; Gebruikt geen registers
 1561: 1			;
 1562: 1			;******************************************************************************
 1563: 1
 1564: 1  0485	C0 F0		lcdbuzoff:    push   b
 1565: 1  0487	12 04 45	              lcall  lcdtoport     ;expander lezen
 1566: 1  048A	D2 F7		              setb   b.7           ;buzzer aan doen
 1567: 1  048C	12 04 2C	              lcall  porttolcd     ;expander schrijven
 1568: 1  048F	D0 F0		              pop    b
 1569: 1  0491	22		              ret
 1570: 1
 1571: 1			endif    ;einde aduc_i2c
 1572: 1			;******************************************************************************
 1573: 1
 1574: 1
 1575: 1
 1576: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1577: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1578: 1			;
 1579: 1			; ADuCsio.inc
 1580: 1			; Is een include file voor de ADuC832 microcontroller.
 1581: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1582: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1583: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1584: 1			; afwijking van de standaard routines is de initsio subroutine.
 1585: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1586: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1587: 1			; zijn.
 1588: 1			;
 1589: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1590: 1			;
 1591: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1592: 1
 1593: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1594: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1595: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1596: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1597: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1598: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1599: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1600: 1
 1601: 1  0492	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1602: 1			                                                        ;van het scherm
 1603: 1
 1604: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1605: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1606: 1
 1607: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1608: 1			;
 1609: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1610: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1611: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1612: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1613: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1614: 1			;
 1615: 1			; de routine gebruikt de psw
 1616: 1			;
 1617: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1618: 1
 1619: 1  0496	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1620: 1  0498	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1621: 1  049A	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1622: 1  049C	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1623: 1  049F	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1624: 1
 1625: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1626: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1627: 1
 1628: 1  04A1	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1629: 1  04A4	F4		              cpl    a             ;bitbangen om laten uit te komen
 1630: 1  04A5	C3		              clr    c             ;verder doen
 1631: 1  04A6	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1632: 1  04A8	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1633: 1  04AA	24 80		              add    a,#080h       ;nu alles in orde
 1634: 1  04AC	F5 9E		              mov    t3con,a       ;baud rate klaar
 1635: 1  04AE	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1636: 1  04B1	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1637: 1  04B2	D0 E0		              pop    acc
 1638: 1  04B4	22		              ret
 1639: 1
 1640: 1  04B5	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1641: 1  04B6	D0 E0		              pop    acc
 1642: 1  04B8	22		              ret
 1643: 1
 1644: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1645: 1			;
 1646: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1647: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1648: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1649: 1			;
 1650: 1			; de routine gebruikt geen registers.
 1651: 1			;
 1652: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1653: 1
 1654: 1  04B9	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1655: 1  04BB	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1656: 1  04BE	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1657: 1  04C0	22		              RET
 1658: 1
 1659: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1660: 1			;
 1661: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1662: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1663: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1664: 1			; de routine gebruikt geen registers.
 1665: 1			;
 1666: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1667: 1
 1668: 1  04C1	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1669: 1  04C3	C0 D0		              push   psw
 1670: 1  04C5	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1671: 1  04C7	12 05 D3	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1672: 1  04CA	12 04 B9	              LCALL  OUTCHAR       ;VERSTUREN
 1673: 1  04CD	12 05 1A	              LCALL  XONXOFF       ;FLOW CONTROL
 1674: 1  04D0	D0 D0		              pop    psw           ;registers herstellen
 1675: 1  04D2	D0 E0		              pop    acc
 1676: 1  04D4	22		              RET
 1677: 1
 1678: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1679: 1			;
 1680: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1681: 1			; WORDT XONXOFF GEBRUIKT.
 1682: 1			;
 1683: 1			; de routine gebruikt geen registers.
 1684: 1			;
 1685: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1686: 1
 1687: 1  04D5	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1688: 1  04D7	C0 D0		              push   psw
 1689: 1  04D9	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1690: 1  04DB	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1691: 1  04DC	12 04 C1	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1692: 1  04DF	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1693: 1  04E1	12 04 C1	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1694: 1  04E4	D0 D0		              pop    psw           ;registers herstellen
 1695: 1  04E6	D0 E0		              pop    acc
 1696: 1  04E8	22		              RET
 1697: 1
 1698: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1699: 1			;
 1700: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1701: 1			; VAN DE CURSOR.
 1702: 1			;
 1703: 1			; de routine gebruikt geen registers.
 1704: 1			;
 1705: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1706: 1
 1707: 1  04E9	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1708: 1  04EB	C0 D0		              push   psw
 1709: 1  04ED	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1710: 1  04EF	12 04 D5	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1711: 1  04F2	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1712: 1  04F4	12 04 D5	              LCALL  OUTBYTE       ;WEG ER MEE
 1713: 1  04F7	D0 D0		              pop    psw           ;registers herstellen
 1714: 1  04F9	D0 E0		              pop    acc
 1715: 1  04FB	22		              RET                  ;EINDE
 1716: 1
 1717: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1718: 1			;
 1719: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1720: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1721: 1			;
 1722: 1			; de routine gebruikt geen registers.
 1723: 1			;
 1724: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1725: 1
 1726: 1  04FC	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1727: 1  04FE	C0 D0		              push   psw
 1728: 1  0500	C0 82		              push   dpl
 1729: 1  0502	C0 83		              push   dph
 1730: 1  0504	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1731: 1  0505	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1732: 1  0506	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1733: 1  0508	12 04 B9	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1734: 1  050B	12 05 1A	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1735: 1  050E	A3		              INC    DPTR          ;DPTR AANPASSEN
 1736: 1  050F	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1737: 1  0511	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1738: 1  0513	D0 82		              pop    dpl
 1739: 1  0515	D0 D0		              pop    psw
 1740: 1  0517	D0 E0		              pop    acc
 1741: 1  0519	22		              RET                  ;EINDE ROUTINE
 1742: 1
 1743: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1744: 1			;
 1745: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1746: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1747: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1748: 1			; VERDER DOORGEGEVEN.
 1749: 1			;
 1750: 1			; de routine gebruikt geen registers.
 1751: 1			;
 1752: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1753: 1
 1754: 1  051A	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1755: 1  051C	C0 D0		              push   psw
 1756: 1  051E	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1757: 1  0521	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 1758: 1  0523	D0 E0		              pop    acc
 1759: 1  0525	22		              RET                  ;ANDERS EINDE
 1760: 1  0526	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1761: 1  0528	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1762: 1  052B	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1763: 1  052E	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1764: 1
 1765: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1766: 1			;
 1767: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1768: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1769: 1			;
 1770: 1			; de routine gebruikt de accu.
 1771: 1			;
 1772: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1773: 1
 1774: 1  0530	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 1775: 1  0533	C2 98		              CLR    RI            ;BIT LAAG MAKEN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1776: 1  0535	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1777: 1  0537	22		              RET
 1778: 1
 1779: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1780: 1			;
 1781: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1782: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1783: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 1784: 1			; DE CARRY OP 1 GEZET WORDEN.
 1785: 1			;
 1786: 1			; De routine gebruikt de accu EN PSW.
 1787: 1			;
 1788: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1789: 1
 1790: 1  0538	C0 F0		INBYTE:       PUSH     B
 1791: 1  053A	12 05 30	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1792: 1  053D	12 05 C6	              LCALL  LOWUPTR
 1793: 1  0540	12 05 E1	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1794: 1  0543	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1795: 1  0545	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1796: 1  0546	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1797: 1  0548	12 05 30	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1798: 1  054B	12 05 C6	              LCALL  LOWUPTR
 1799: 1  054E	12 05 E1	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1800: 1  0551	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1801: 1  0553	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1802: 1  0555	D0 F0		INBYTE1:      POP     B
 1803: 1  0557	22		              RET
 1804: 1
 1805: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1806: 1			;
 1807: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1808: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1809: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1810: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1811: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1812: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1813: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 1814: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1815: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1816: 1			; bepalen.
 1817: 1			;
 1818: 1			; De routine gebruikt  r0 .
 1819: 1			;
 1820: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1821: 1
 1822: 1  0558	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1823: 1  055A	C0 D0		              push   psw
 1824: 1  055C	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1825: 1  055E	12 05 30	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 1826: 1  0561	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1827: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 1828: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1829: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1830: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 1831: 1			; GEVOERD.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1832: 1  0563	12 05 C6	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1833: 1  0566	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1834: 1  0569	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1835: 1  056A	D0 D0		              pop    psw                  ;registers herstellen
 1836: 1  056C	D0 E0		              pop    acc
 1837: 1  056E	22		              RET                         ;EINDE VAN DE ROUTINE
 1838: 1
 1839: 1  056F	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 1840: 1  0572	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1841: 1  0575	74 07		INBUFA4:      MOV    A,#BEEP
 1842: 1  0577	12 04 B9	INBUFA7:      LCALL  OUTCHAR
 1843: 1  057A	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1844: 1
 1845: 1  057C	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1846: 1  057D	90 04 92	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1847: 1  0580	12 04 FC	              LCALL  OUTMSGA
 1848: 1  0583	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 1849: 1  0585	12 05 B8	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1850: 1  0588	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1851: 1  058A	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1852: 1  058D	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1853: 1  058F	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1854: 1  0590	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1855: 1  0591	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1856: 1
 1857: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1858: 1			;
 1859: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1860: 1			;
 1861: 1			; De routine gebruikt niets.
 1862: 1			;
 1863: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1864: 1
 1865: 1  0593	C0 E0		BDELETE:      PUSH     ACC
 1866: 1  0595	C0 D0		              PUSH     PSW
 1867: 1  0597	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1868: 1  0598	C0 E0		              PUSH     ACC
 1869: 1  059A	E9		              MOV     A,R1
 1870: 1  059B	C0 E0		              PUSH     ACC
 1871: 1  059D	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1872: 1  059F	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1873: 1  05A1	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1874: 1  05A2	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1875: 1  05A5	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1876: 1  05A6	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1877: 1  05A9	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1878: 1  05AB	F9		              MOV     R1,A
 1879: 1  05AC	D0 E0		              POP     ACC
 1880: 1  05AE	F8		              MOV     R0,A
 1881: 1  05AF	D0 D0		              POP     PSW
 1882: 1  05B1	D0 E0		              POP     ACC
 1883: 1  05B3	22		              RET                         ;EINDE VAN DE ROUTINE
 1884: 1  05B4	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1885: 1  05B5	09		              INC    R1
 1886: 1  05B6	80 ED		              SJMP   BDELETE3
 1887: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1888: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1889: 1			;
 1890: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1891: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1892: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1893: 1			; AANZIEN.
 1894: 1			;
 1895: 1			; De routine gebruikt de accu en de psw.
 1896: 1			;
 1897: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1898: 1
 1899: 1  05B8	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 1900: 1  05BB	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 1901: 1  05BD	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 1902: 1  05C0	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 1903: 1  05C2	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 1904: 1  05C3	22		              RET
 1905: 1  05C4	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 1906: 1  05C5	22		              RET
 1907: 1
 1908: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1909: 1			;
 1910: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 1911: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 1912: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 1913: 1			; AANGEPAST WORDEN.
 1914: 1			;
 1915: 1			; De routine gebruikt de accu en psw .
 1916: 1			;
 1917: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1918: 1
 1919: 1  05C6	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 1920: 1  05C9	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 1921: 1  05CB	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 1922: 1  05CE	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 1923: 1  05D0	94 20		              SUBB   A,#020H              ;OMZETTING
 1924: 1  05D2	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 1925: 1
 1926: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1927: 1			;
 1928: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 1929: 1			; ASCII CODE.
 1930: 1			;
 1931: 1			; De routine gebruikt de accu .
 1932: 1			;
 1933: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1934: 1
 1935: 1  05D3	C0 D0		BATRANS:      PUSH   PSW
 1936: 1  05D5	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 1937: 1  05D8	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 1938: 1  05DA	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 1939: 1  05DC	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 1940: 1  05DE	D0 D0		              POP     PSW
 1941: 1  05E0	22		              RET
 1942: 1
 1943: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1944: 1			;
 1945: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 1946: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 1947: 1			; GEVAL WORDT DE CARRY GEZET.
 1948: 1			;
 1949: 1			; De routine gebruikt de accu en de psw.
 1950: 1			;
 1951: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1952: 1
 1953: 1  05E1	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 1954: 1  05E2	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 1955: 1  05E4	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 1956: 1  05E6	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 1957: 1  05E9	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 1958: 1  05EB	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 1959: 1  05ED	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 1960: 1  05EF	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 1961: 1  05F2	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 1962: 1  05F3	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 1963: 1  05F5	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 1964: 1  05F6	22		ASCBINTRANS1: RET
 1965: 1
 1966: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1967: 1			;
 1968: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 1969: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 1970: 1			;
 1971: 1			; De routine gebruikt de accu en de psw.
 1972: 1			;
 1973: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1974: 1
 1975: 1  05F7	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 1976: 1  05F8	12 05 E1	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 1977: 1  05FB	22		              RET                         ;EINDE OMZETTING
 1978: 1
 1979: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1980: 1			;
 1981: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 1982: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 1983: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 1984: 1			;
 1985: 1			; De routine gebruikt de accu, r0.
 1986: 1			;
 1987: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1988: 1
 1989: 1  05FC	C0 F0		ASCII2:       PUSH   B
 1990: 1  05FE	12 05 F7	              LCALL  ASCII1               ;OMZETTEN
 1991: 1  0601	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 1992: 1  0603	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 1993: 1  0604	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 1994: 1  0606	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 1995: 1  0607	12 05 F7	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 1996: 1  060A	40 02		              JC     ASCII21               ;WEG ALS C=1
 1997: 1  060C	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 1998: 1  060E	D0 F0		ASCII21:      POP     B
 1999: 1  0610	22		              RET

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2000: 1
 2001: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2002: 1			;
 2003: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2004: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2005: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2006: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2007: 1			;
 2008: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2009: 1			;
 2010: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2011: 1
 2012: 1  0611	12 05 FC	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2013: 1  0614	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2014: 1  0616	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2015: 1  0618	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2016: 1  0619	12 05 FC	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2017: 1  061C	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2018: 1  061E	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2019: 1  0620	22		ASCII41:      RET
 2020: 1
 2021: 1			endif        ;einde van aduc_sio
 2022: 1			;*******************************************************************************
 2023: 1
 2024: 1
 2025: 1			ifdef        aduc_math    ;rekenkundige routines
 2026: 1			;*******************************************************************************
 2027: 1			; aduc_math
 2028: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2029: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2030: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2031: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2032: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2033: 1			; zoals aangegeven:
 2034: 1			;
 2035: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2036: 1			;        ---------------------------
 2037: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2038: 1			;        ---------------------------                             statusbit = f0
 2039: 1			;        ---------------------------
 2040: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2041: 1			;        ---------------------------
 2042: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2043: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2044: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2045: 1			; return en moeten hiervoor worden gereserveerd.
 2046: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2047: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2048: 1			; en unsigned getallen.
 2049: 1			;
 2050: 1			; Beschikbare routines:
 2051: 1			;
 2052: 1			; Conversie routines:
 2053: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2054: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2055: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2056: 1			;
 2057: 1			; Som:
 2058: 1			; s_add16, add16, s_add32, add32
 2059: 1			;
 2060: 1			; Verschil:
 2061: 1			; s_sub16, sub16, s_sub32, sub32
 2062: 1			;
 2063: 1			; Vermenigvuldigen:
 2064: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2065: 1			;
 2066: 1			; Delen:
 2067: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2068: 1			;
 2069: 1			; Vemenigvuldig met factor:
 2070: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2071: 1			;
 2072: 1			; Vierkantswortel:
 2073: 1			; sqrt32, s_sqrt32
 2074: 1			;
 2075: 1			; Schuiven:
 2076: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2077: 1			;
 2078: 1			; Vergelijken:
 2079: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2080: 1			;
 2081: 1			; Tabel lookup:
 2082: 1			; table_lu
 2083: 1			;
 2084: 1			; Gonemetrische functies:
 2085: 1			; Cordic = sinus,cosinus
 2086: 1			;
 2087: 1			;*******************************************************************************
 2088: 1
 2089: 1			;*******************************************************************************
 2090: 1			;
 2091: 1			; bcdhex8     (45,77us @16.777216MHz)
 2092: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2093: 1			; naar een 2's complement hex getal.
 2094: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2095: 1			; een waarde 00h tot 63h.
 2096: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2097: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2098: 1			; input:      R0 = waarde tussen 00h en 99h.
 2099: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2100: 1			; output:     R0 = 2's complement waarde
 2101: 1			;             cy=1 bij out of range van r0
 2102: 1			;             cy=0 bij conversie ok
 2103: 1			; vernietigt: niets
 2104: 1			;*******************************************************************************
 2105: 1  0621	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2106: 1  0623	C0 D0		              push   psw
 2107: 1  0625	C0 F0		              push   b
 2108: 1
 2109: 1  0627	E8		              mov    a,r0                 ;neem te converteren waarde
 2110: 1  0628	F5 F0		              mov    b,a
 2111: 1  062A	54 0F		              anl    a,#0fh

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2112: 1  062C	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2113: 1  062F	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2114: 1  0631	E5 F0		              mov    a,b
 2115: 1  0633	54 F0		              anl    a,#0f0h
 2116: 1  0635	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2117: 1  0638	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2118: 1
 2119: 1  063A	E8		              mov    a,r0
 2120: 1  063B	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2121: 1  063D	C4		              swap   a
 2122: 1  063E	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2123: 1  0641	A4		              mul    ab
 2124: 1  0642	F5 F0		              mov    b,a                  ;bewaar dit product even
 2125: 1  0644	E8		              mov    a,r0
 2126: 1  0645	54 0F		              anl    a,#00fh
 2127: 1  0647	F8		              mov    r0,a
 2128: 1  0648	E5 F0		              mov    a,b
 2129: 1  064A	28		              add    a,r0                 ;eenheden er bijtellen
 2130: 1  064B	F8		              mov    r0,a
 2131: 1
 2132: 1  064C	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2133: 1  064E	12 07 4F	              lcall  magsig8              ;omzetten naar 2's complement
 2134: 1
 2135: 1  0651	D0 F0		              pop    b
 2136: 1  0653	D0 D0		              pop    psw
 2137: 1  0655	C2 D7		              clr    cy                   ;geen fout
 2138: 1  0657	D0 E0		              pop    acc
 2139: 1  0659	22		              ret
 2140: 1
 2141: 1  065A	D0 F0		bcdhex82:     pop    b
 2142: 1  065C	D0 D0		              pop    psw
 2143: 1  065E	D2 D7		              setb   cy                   ;fout! r0 out of range
 2144: 1  0660	D0 E0		              pop    acc
 2145: 1  0662	22		              ret
 2146: 1
 2147: 1			;*******************************************************************************
 2148: 1			;
 2149: 1			; hexbcd8     (38,4us @16.777216MHz)
 2150: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2151: 1			; naar een 8bit bcd getal.
 2152: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2153: 1			; bcdgetal van 00h tot +99h.
 2154: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2155: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2156: 1			; bcdgetal 00h tot -99h
 2157: 1			;
 2158: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2159: 1			;
 2160: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2161: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2162: 1			;             cy=1 bij out of range van r0
 2163: 1			;             cy=0 bij conversie ok
 2164: 1			; vernietigt: niets
 2165: 1			;*******************************************************************************
 2166: 1  0663	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2167: 1  0665	C0 D0		                push    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2168: 1  0667	C0 F0		                push    b
 2169: 1  0669	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2170: 1  066A	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2171: 1  066D	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2172: 1  066F	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2173: 1  0672	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2174: 1  0674	D0 F0		                pop     b
 2175: 1  0676	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2176: 1  0678	D3		                setb    c
 2177: 1  0679	D0 E0		                pop     acc
 2178: 1  067B	22		                ret
 2179: 1  067C	12 08 17	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2180: 1  067F	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2181: 1  0680	75 F0 0A	                mov     b,#10
 2182: 1  0683	84		                div     ab
 2183: 1  0684	C4		                swap    a
 2184: 1  0685	25 F0		                add     a,b
 2185: 1  0687	F8		                mov     r0,a
 2186: 1  0688	D0 F0		                pop     b               ;registers herstellen
 2187: 1  068A	D0 E0		                pop     acc             ;psw van stack halen
 2188: 1  068C	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2189: 1  068E	92 E5		                mov     acc.5,c
 2190: 1  0690	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2191: 1  0692	C3		                clr     c               ;status: conversie ok
 2192: 1  0693	D0 E0		                pop     acc
 2193: 1  0695	22		                ret
 2194: 1
 2195: 1
 2196: 1
 2197: 1			;*******************************************************************************
 2198: 1			;
 2199: 1			; bcdhex16    (86,6us @16.777216MHz)
 2200: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2201: 1			; omzetten naar een 2's complement hex getal.
 2202: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2203: 1			; naareen waarde 0000h tot 270fh.
 2204: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2205: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2206: 1			; van -270fh).
 2207: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2208: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2209: 1			; output:     R1,R0 = 2's complement waarde
 2210: 1			;             cy=1 bij out of range van r1,r0
 2211: 1			;             cy=0 bij conversie ok
 2212: 1			; vernietigt: niets
 2213: 1			;*******************************************************************************
 2214: 1  0696	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2215: 1  0698	C0 D0		              push   psw
 2216: 1  069A	C0 F0		              push   b
 2217: 1
 2218: 1  069C	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2219: 1  069D	F5 F0		              mov    b,a
 2220: 1  069F	54 0F		              anl    a,#0fh
 2221: 1  06A1	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2222: 1  06A4	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2223: 1  06A6	E5 F0		              mov    a,b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2224: 1  06A8	54 F0		              anl    a,#0f0h
 2225: 1  06AA	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2226: 1  06AD	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2227: 1  06AF	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2228: 1  06B0	F5 F0		              mov    b,a
 2229: 1  06B2	54 0F		              anl    a,#0fh
 2230: 1  06B4	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2231: 1  06B7	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2232: 1  06B9	E5 F0		              mov    a,b
 2233: 1  06BB	54 F0		              anl    a,#0f0h
 2234: 1  06BD	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2235: 1  06C0	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2236: 1
 2237: 1  06C2	E8		              mov    a,r0                  ;neem low byte voor conversie
 2238: 1  06C3	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2239: 1  06C5	C0 E0		              push   acc                   ;en even bewaren
 2240: 1
 2241: 1  06C7	E8		              mov    a,r0
 2242: 1  06C8	C4		              swap   a
 2243: 1  06C9	54 0F		              anl    a,#00fh              ;tientallen
 2244: 1  06CB	75 F0 0A	              mov    b,#00ah              ;maal tien
 2245: 1  06CE	A4		              mul    ab                   ;
 2246: 1  06CF	D0 F0		              pop    b                    ;neem eenheden
 2247: 1  06D1	25 F0		              add    a,b                  ;tel bij tientallen
 2248: 1  06D3	C0 E0		              push   acc                  ;weer bewaren
 2249: 1
 2250: 1  06D5	E9		              mov    a,r1                 ;neem high byte voor conversie
 2251: 1  06D6	54 F0		              anl    a,#0f0h
 2252: 1  06D8	C4		              swap   a
 2253: 1  06D9	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2254: 1
 2255: 1  06DB	E9		              mov    a,r1                  ;neem high byte voor conversie
 2256: 1  06DC	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2257: 1  06DE	75 F0 64	              mov    b,#100d              ;en maal honderd
 2258: 1  06E1	A4		              mul    ab
 2259: 1  06E2	A9 F0		              mov    r1,b
 2260: 1  06E4	F8		              mov    r0,a
 2261: 1
 2262: 1  06E5	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2263: 1  06E7	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2264: 1  06EA	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2265: 1  06EB	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2266: 1  06EE	A4		              mul    ab
 2267: 1  06EF	28		              add    a,r0                 ;tel honderdtallen bij de
 2268: 1  06F0	F8		              mov    r0,a                 ;duizendtallen
 2269: 1  06F1	E9		              mov    a,r1
 2270: 1  06F2	35 F0		              addc   a,b
 2271: 1  06F4	F9		              mov    r1,a
 2272: 1
 2273: 1  06F5	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2274: 1  06F7	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2275: 1  06F8	F8		              mov    r0,a                 ;duizendtallen
 2276: 1  06F9	74 00		              mov    a,#000h
 2277: 1  06FB	39		              addc   a,r1
 2278: 1  06FC	F9		              mov    r1,a                 ;omzetting klaar
 2279: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2280: 1  06FD	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2281: 1  06FF	12 07 83	              lcall  magsig16             ;omzetten naar 2's complement
 2282: 1
 2283: 1  0702	D0 F0		              pop    b
 2284: 1  0704	D0 D0		              pop    psw
 2285: 1  0706	C2 D7		              clr    cy                   ;geen fout
 2286: 1  0708	D0 E0		              pop    acc
 2287: 1  070A	22		              ret
 2288: 1
 2289: 1  070B	D0 F0		bcdhex162:    pop    b
 2290: 1  070D	D0 D0		              pop    psw
 2291: 1  070F	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2292: 1  0711	D0 E0		              pop    acc
 2293: 1  0713	22		              ret
 2294: 1
 2295: 1			;*******************************************************************************
 2296: 1			;
 2297: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2298: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2299: 1			; naar een 24bit bcd getal.
 2300: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2301: 1			; bcdgetal van 000000h tot +032767h.
 2302: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2303: 1			; naar een bcdgetal 000000h tot -032768h
 2304: 1			;
 2305: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2306: 1			;
 2307: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2308: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2309: 1			;
 2310: 1			; vernietigt: niets
 2311: 1			;*******************************************************************************
 2312: 1			;
 2313: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2314: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2315: 1			; naar een 24bit bcd getal.
 2316: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2317: 1			; bcdgetal van 000000h tot 065535h.
 2318: 1			;
 2319: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2320: 1			;
 2321: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2322: 1			;
 2323: 1			; vernietigt: niets
 2324: 1			;*******************************************************************************
 2325: 1  0714	12 08 49	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2326: 1  0717	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2327: 1  0719	C0 D0		                push   psw
 2328: 1  071B	C0 F0		                push   b
 2329: 1  071D	C0 82		                push   dpl
 2330: 1
 2331: 1  071F	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2332: 1  0722	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2333: 1  0724	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2334: 1  0726	12 0B F8	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2335: 1  0729	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2336: 1  072A	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2337: 1			                                        ;dus eerst eenheden, dan tientallen
 2338: 1			                                        ;honderdtallen, duizendtallen en
 2339: 1			                                        ;tienduizendtallen
 2340: 1  072C	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2341: 1
 2342: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2343: 1
 2344: 1  072F	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2345: 1  0731	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2346: 1  0732	D0 E0		                pop    acc              ;duizendtallen ophalen
 2347: 1  0734	C4		                swap   a                ;en combineren met de
 2348: 1  0735	F5 82		                mov    dpl,a
 2349: 1  0737	D0 E0		                pop    acc              ;honderdtallen van de stack
 2350: 1  0739	25 82		                add    a,dpl
 2351: 1  073B	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2352: 1  073C	D0 E0		                pop    acc              ;tientallen van de stack halen
 2353: 1  073E	C4		                swap   a
 2354: 1  073F	F5 82		                mov    dpl,a
 2355: 1  0741	D0 E0		                pop    acc              ;en combineren met de eenheden
 2356: 1  0743	25 82		                add    a,dpl
 2357: 1  0745	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2358: 1
 2359: 1  0746	D0 82		                pop    dpl              ;registers herstellen
 2360: 1  0748	D0 F0		                pop    b
 2361: 1  074A	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2362: 1  074C	D0 E0		                pop    acc
 2363: 1  074E	22		                ret
 2364: 1
 2365: 1			;*******************************************************************************
 2366: 1			; magsig8        (13,6us @16.777216MHz)
 2367: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2368: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2369: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2370: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2371: 1			;           (f0 en f1 zijn 1 als negatief)
 2372: 1			;
 2373: 1			; output:   r0 = 2's complement
 2374: 1			;
 2375: 1			; vernietigt: niets
 2376: 1			;*******************************************************************************
 2377: 1
 2378: 1  074F	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2379: 1  0751	C0 D0		               push   psw
 2380: 1  0753	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2381: 1  0756	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2382: 1  0759	80 09		               sjmp   magsig8c
 2383: 1
 2384: 1  075B	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2385: 1  075E	80 04		               sjmp   magsig8c
 2386: 1
 2387: 1  0760	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2388: 1  0761	F4		               cpl    a                  ;complementeer abs waarde
 2389: 1  0762	04		               inc    a                  ;r0 = complement(r0)+1
 2390: 1  0763	F8		               mov    r0,a               ;bewaar in 2's complement
 2391: 1  0764	D0 D0		magsig8c:      pop    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2392: 1  0766	D0 E0		               pop    acc
 2393: 1  0768	22		               ret                        ;klaar
 2394: 1
 2395: 1			;*******************************************************************************
 2396: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2397: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2398: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2399: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2400: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2401: 1			;           (f0 en f1 zijn 1 als negatief)
 2402: 1			;
 2403: 1			; output:   r4 = 2's complement
 2404: 1			;
 2405: 1			; vernietigt: niets
 2406: 1			;*******************************************************************************
 2407: 1
 2408: 1  0769	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2409: 1  076B	C0 D0		               push    psw
 2410: 1  076D	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2411: 1  0770	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2412: 1  0773	80 EF		               sjmp    magsig8c
 2413: 1
 2414: 1  0775	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2415: 1  0778	80 04		               sjmp    magsig8acc1c
 2416: 1
 2417: 1  077A	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2418: 1  077B	F4		               cpl     a                 ;complementeer abs waarde
 2419: 1  077C	04		               inc     a                 ;r4 = complement(r0)+1
 2420: 1  077D	FC		               mov     r4,a              ;bewaar in 2's complement
 2421: 1  077E	D0 D0		magsig8acc1c:  pop     psw
 2422: 1  0780	D0 E0		               pop     acc
 2423: 1  0782	22		               ret                       ;klaar
 2424: 1
 2425: 1			;*******************************************************************************
 2426: 1			; magsig16        (16,6us @16.777216MHz)
 2427: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2428: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2429: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2430: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2431: 1			;           (f0 en f1 zijn 1 als negatief)
 2432: 1			;
 2433: 1			; output:   r1,r0 = 2's complement
 2434: 1			;
 2435: 1			; vernietigt: niets
 2436: 1			;*******************************************************************************
 2437: 1  0783	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2438: 1  0785	C0 D0		               push    psw
 2439: 1  0787	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2440: 1  078A	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2441: 1  078D	80 0F		               sjmp    magsig16c
 2442: 1
 2443: 1  078F	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2444: 1  0792	80 0A		               sjmp    magsig16c
 2445: 1
 2446: 1  0794	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2447: 1  0795	F4		               cpl     a                ;complementeer het dan

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2448: 1  0796	24 01		               add     a, #1            ;en tel er 1 bij
 2449: 1  0798	F8		               mov     r0,a
 2450: 1  0799	E9		               mov     a,r1             ;neem volgende byte
 2451: 1  079A	F4		               cpl     a                ;complementeer en tel carry erbij
 2452: 1  079B	34 00		               addc    a,#0
 2453: 1  079D	F9		               mov     r1,a
 2454: 1  079E	D0 D0		magsig16c:     pop     psw
 2455: 1  07A0	D0 E0		               pop     acc
 2456: 1  07A2	22		               ret
 2457: 1
 2458: 1			;*******************************************************************************
 2459: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2460: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2461: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2462: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2463: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2464: 1			;           (f0 en f1 zijn 1 als negatief)
 2465: 1			;
 2466: 1			; output:   r5,r4 = 2's complement
 2467: 1			;
 2468: 1			; vernietigt: niets
 2469: 1			;*******************************************************************************
 2470: 1  07A3	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2471: 1  07A5	C0 D0		                push    psw
 2472: 1  07A7	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2473: 1  07AA	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2474: 1  07AD	80 0F		                sjmp    magsig16acc1c
 2475: 1
 2476: 1  07AF	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2477: 1  07B2	80 0A		                sjmp    magsig16acc1c
 2478: 1
 2479: 1  07B4	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2480: 1  07B5	F4		                cpl     a                   ;complementeer het dan
 2481: 1  07B6	24 01		                add     a,#1                ;en tel er 1 bij
 2482: 1  07B8	FC		                mov     r4,a
 2483: 1  07B9	ED		                mov     a,r5                ;neem volgende byte
 2484: 1  07BA	F4		                cpl     a                   ;complementeer en tel carry erbij
 2485: 1  07BB	34 00		                addc    a,#0
 2486: 1  07BD	FD		                mov     r5,a
 2487: 1  07BE	D0 D0		magsig16acc1c:  pop     psw
 2488: 1  07C0	D0 E0		                pop     acc
 2489: 1  07C2	22		                ret
 2490: 1
 2491: 1			;*******************************************************************************
 2492: 1			; magsig32        (22,2us @16.777216MHz)
 2493: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2494: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2495: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2496: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2497: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2498: 1			;           (f0 en f1 zijn 1 als negatief)
 2499: 1			;
 2500: 1			; output:   r3,r2,r1,r0 = 2's complement
 2501: 1			;
 2502: 1			; vernietigt: niets
 2503: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2504: 1  07C3	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2505: 1  07C5	C0 D0		               push    psw
 2506: 1  07C7	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2507: 1  07CA	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2508: 1  07CD	80 19		               sjmp    magsig32c
 2509: 1
 2510: 1  07CF	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2511: 1  07D2	80 14		               sjmp    magsig32c
 2512: 1
 2513: 1  07D4	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2514: 1  07D5	F4		               cpl     a                 ;complementeer het dan
 2515: 1  07D6	24 01		               add     a,#1             ;en tel er 1 bij
 2516: 1  07D8	F8		               mov     r0,a
 2517: 1  07D9	E9		               mov     a,r1             ;neem volgende byte
 2518: 1  07DA	F4		               cpl     a                 ;complementeer en tel carry erbij
 2519: 1  07DB	34 00		               addc    a,#0
 2520: 1  07DD	F9		               mov     r1,a
 2521: 1  07DE	EA		               mov     a,r2            ;neem volgende byte
 2522: 1  07DF	F4		               cpl     a                ;complementeer en tel carry erbij
 2523: 1  07E0	34 00		               addc    a,#0
 2524: 1  07E2	FA		               mov     r2,a
 2525: 1  07E3	EB		               mov     a,r3            ;neem volgende byte
 2526: 1  07E4	F4		               cpl     a                ;complementeer en tel carry erbij
 2527: 1  07E5	34 00		               addc    a,#0
 2528: 1  07E7	FB		               mov     r3,a
 2529: 1
 2530: 1  07E8	D0 D0		magsig32c:     pop     psw
 2531: 1  07EA	D0 E0		               pop     acc
 2532: 1  07EC	22		               ret
 2533: 1
 2534: 1
 2535: 1
 2536: 1			;*******************************************************************************
 2537: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2538: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2539: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2540: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2541: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2542: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2543: 1			;           (f0 en f1 zijn 1 als negatief)
 2544: 1			;
 2545: 1			; output:   r7,r6,r5,r4 = 2's complement
 2546: 1			;
 2547: 1			; vernietigt: niets
 2548: 1			;*******************************************************************************
 2549: 1  07ED	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2550: 1  07EF	C0 D0		               push    psw
 2551: 1  07F1	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2552: 1  07F4	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2553: 1  07F7	80 19		               sjmp    magsig32acc1c
 2554: 1
 2555: 1  07F9	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2556: 1  07FC	80 14		               sjmp    magsig32acc1c
 2557: 1
 2558: 1  07FE	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2559: 1  07FF	F4		               cpl     a                 ;complementeer het dan

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2560: 1  0800	24 01		               add     a,#1             ;en tel er 1 bij
 2561: 1  0802	FC		               mov     r4,a
 2562: 1  0803	ED		               mov     a,r5             ;neem volgende byte
 2563: 1  0804	F4		               cpl     a                 ;complementeer en tel carry erbij
 2564: 1  0805	34 00		               addc    a,#0
 2565: 1  0807	FD		               mov     r5,a
 2566: 1  0808	EE		               mov     a,r6             ;neem volgende byte
 2567: 1  0809	F4		               cpl     a                 ;complementeer en tel carry erbij
 2568: 1  080A	34 00		               addc    a,#0
 2569: 1  080C	FE		               mov     r6,a
 2570: 1  080D	EF		               mov     a,r7             ;neem volgende byte
 2571: 1  080E	F4		               cpl     a                ;complementeer en tel carry erbij
 2572: 1  080F	34 00		               addc    a,#0
 2573: 1  0811	FF		               mov     r7,a
 2574: 1
 2575: 1  0812	D0 D0		magsig32acc1c: pop     psw
 2576: 1  0814	D0 E0		               pop     acc
 2577: 1  0816	22		               ret
 2578: 1
 2579: 1
 2580: 1			;*******************************************************************************
 2581: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2582: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2583: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2584: 1			; input:     r0 = 2's complement byte in acc0
 2585: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2586: 1			; output:    r0 = absolute waarde
 2587: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2588: 1			;
 2589: 1			; vernietigt: niets
 2590: 1			;*******************************************************************************
 2591: 1
 2592: 1  0817	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2593: 1  0819	C0 D0		                push    psw
 2594: 1  081B	E8		                mov     a,r0               ;neem lsb van acc0
 2595: 1  081C	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2596: 1  081F	D0 D0		                pop     psw
 2597: 1  0821	C2 D5		                clr     f0                 ;nee, positief...klaar
 2598: 1  0823	D0 E0		                pop     acc
 2599: 1  0825	22		                ret
 2600: 1  0826	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2601: 1  0827	04		                inc     a                   ;een erbij
 2602: 1  0828	F8		                mov     r0,a               ;bewaar
 2603: 1  0829	D0 D0		                pop     psw
 2604: 1  082B	D2 D5		                setb    f0                 ;f0=1 als negatief
 2605: 1  082D	D0 E0		                pop     acc
 2606: 1  082F	22		                ret
 2607: 1
 2608: 1			;*******************************************************************************
 2609: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2610: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2611: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2612: 1			; input:     r4 = 2's complement byte in acc1
 2613: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2614: 1			; output:    r4 = absolute waarde
 2615: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2616: 1			;
 2617: 1			; vernietigt: niets
 2618: 1			;*******************************************************************************
 2619: 1
 2620: 1  0830	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2621: 1  0832	C0 D0		                push    psw
 2622: 1  0834	EC		                mov     a,r4               ;neem lsb van acc0
 2623: 1  0835	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2624: 1  0838	D0 D0		                pop     psw
 2625: 1  083A	C2 D1		                clr     f1                 ;nee, positief...klaar
 2626: 1  083C	D0 E0		                pop     acc
 2627: 1  083E	22		                ret
 2628: 1  083F	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2629: 1  0840	04		                inc     a                   ;een erbij
 2630: 1  0841	FC		                mov     r4,a               ;bewaar
 2631: 1  0842	D0 D0		                pop     psw
 2632: 1  0844	D2 D1		                setb    f1                 ;f0=1 als negatief
 2633: 1  0846	D0 E0		                pop     acc
 2634: 1  0848	22		                ret
 2635: 1
 2636: 1			;*******************************************************************************
 2637: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2638: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2639: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2640: 1			; input:     r1,r0 = 2's complement word in acc0
 2641: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2642: 1			; output:    r1,r0 = absolute waarde
 2643: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2644: 1			;
 2645: 1			; vernietigt: niets
 2646: 1			;*******************************************************************************
 2647: 1
 2648: 1  0849	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2649: 1  084B	C0 D0		                push    psw
 2650: 1  084D	E9		                mov     a,r1               ; neem msb van acc0
 2651: 1  084E	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2652: 1  0851	D0 D0		                pop     psw
 2653: 1  0853	C2 D5		                clr     f0                 ;f0=0 als positief
 2654: 1  0855	D0 E0		                pop     acc
 2655: 1  0857	22		                ret                        ;klaar
 2656: 1
 2657: 1  0858	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2658: 1  0859	F4		                cpl     a                  ;complementeren
 2659: 1  085A	24 01		                add     a,#1               ;en een bijtellen
 2660: 1  085C	F8		                mov     r0,a
 2661: 1  085D	E9		                mov     a,r1
 2662: 1  085E	F4		                cpl     a                  ;complement eer volgende byte
 2663: 1  085F	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2664: 1  0861	F9		                mov     r1,a
 2665: 1  0862	D0 D0		                pop     psw
 2666: 1  0864	D2 D5		                setb    f0                 ;f0=1 als negatief
 2667: 1  0866	D0 E0		                pop     acc
 2668: 1  0868	22		                ret
 2669: 1
 2670: 1
 2671: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2672: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2673: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2674: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2675: 1			; input:     r5,r4 = 2's complement word in acc1
 2676: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2677: 1			; output:    r5,r4 = absolute waarde
 2678: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2679: 1			;
 2680: 1			; vernietigt: niets
 2681: 1			;*******************************************************************************
 2682: 1
 2683: 1  0869	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2684: 1  086B	C0 D0		                push    psw
 2685: 1  086D	ED		                mov     a,r5               ;neem msb van acc1
 2686: 1  086E	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2687: 1  0871	D0 D0		                pop     psw
 2688: 1  0873	C2 D1		                clr     f1                 ;f1=0 als positief
 2689: 1  0875	D0 E0		                pop    acc
 2690: 1  0877	22		                ret                        ;klaar
 2691: 1
 2692: 1  0878	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2693: 1  0879	F4		                cpl     a                   ;complementeren
 2694: 1  087A	24 01		                add     a,#1               ;en een bijtellen
 2695: 1  087C	FC		                mov     r4,a
 2696: 1  087D	ED		                mov     a,r5
 2697: 1  087E	F4		                cpl     a                  ;complementeer volgende byte
 2698: 1  087F	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2699: 1  0881	FD		                mov     r5,a
 2700: 1  0882	D0 D0		                pop     psw
 2701: 1  0884	D2 D1		                setb    f1                ;f1=1 als negatief
 2702: 1  0886	D0 E0		                pop     acc
 2703: 1  0888	22		                ret
 2704: 1
 2705: 1
 2706: 1			;*******************************************************************************
 2707: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2708: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2709: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2710: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2711: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2712: 1			; output:    r7,r6 = absolute waarde
 2713: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2714: 1			;
 2715: 1			; vernietigt: niets
 2716: 1			;*******************************************************************************
 2717: 1
 2718: 1  0889	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2719: 1  088B	C0 D0		                push    psw
 2720: 1  088D	EF		                mov     a,r7                ; neem msb van acc1 high
 2721: 1  088E	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2722: 1  0891	D0 D0		                pop     psw
 2723: 1  0893	C2 D5		                clr     f0                  ;f0=0 als positief
 2724: 1  0895	D0 E0		                pop     acc
 2725: 1  0897	22		                ret                         ;klaar
 2726: 1
 2727: 1  0898	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2728: 1  0899	F4		                cpl     a                   ;complementeren
 2729: 1  089A	24 01		                add     a,#1               ;en een bijtellen
 2730: 1  089C	FE		                mov     r6,a
 2731: 1  089D	EF		                mov     a,r7
 2732: 1  089E	F4		                cpl     a                  ;complementeer volgende byte
 2733: 1  089F	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2734: 1  08A1	FF		                mov     r7,a
 2735: 1  08A2	D0 D0		                pop     psw
 2736: 1  08A4	D2 D5		                setb    f0                ;f0=1 als negatief
 2737: 1  08A6	D0 E0		                pop     acc
 2738: 1  08A8	22		                ret
 2739: 1
 2740: 1
 2741: 1			;*******************************************************************************
 2742: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2743: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2744: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 2745: 1			;
 2746: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2747: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2748: 1			;            (-2147483648 tot +2147483647)
 2749: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2750: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2751: 1			;
 2752: 1			; vernietigt: niets
 2753: 1			;*******************************************************************************
 2754: 1
 2755: 1  08A9	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2756: 1  08AB	C0 D0		                push    psw
 2757: 1  08AD	EB		                mov     a,r3               ;neem msb van acc0
 2758: 1  08AE	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2759: 1  08B1	D0 D0		                pop     psw                ;nee, positief
 2760: 1  08B3	C2 D5		                clr     f0
 2761: 1  08B5	D0 E0		                pop     acc
 2762: 1  08B7	22		                ret                        ;klaar
 2763: 1
 2764: 1  08B8	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2765: 1  08B9	F4		                cpl     a                  ;complementeren
 2766: 1  08BA	24 01		                add     a,#1               ;en een bijtellen
 2767: 1  08BC	F8		                mov     r0,a
 2768: 1  08BD	E9		                mov     a,r1               ;neem volgende byte
 2769: 1  08BE	F4		                cpl     a                  ;complementeer volgende byte
 2770: 1  08BF	34 00		                addc    a,#0
 2771: 1  08C1	F9		                mov     r1,a
 2772: 1  08C2	EA		                mov     a,r2               ;neem volgende byte
 2773: 1  08C3	F4		                cpl     a                  ;complementeer volgende byte
 2774: 1  08C4	34 00		                addc    a,#0
 2775: 1  08C6	FA		                mov     r2,a
 2776: 1  08C7	EB		                mov     a,r3               ;neem volgende byte
 2777: 1  08C8	F4		                cpl     a                  ;complementeer volgende byte
 2778: 1  08C9	34 00		                addc    a,#0
 2779: 1  08CB	FB		                mov     r3,a
 2780: 1  08CC	D0 D0		                pop     psw
 2781: 1  08CE	D2 D5		                setb    f0                 ;negatief: f0=1
 2782: 1  08D0	D0 E0		                pop     acc
 2783: 1  08D2	22		                ret                        ;klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2784: 1
 2785: 1			;*******************************************************************************
 2786: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2787: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2788: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2789: 1			;
 2790: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2791: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2792: 1			;            (-2147483648 tot +2147483647)
 2793: 1			; output:    r7,r6,r5,r4 = absolute waarde
 2794: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2795: 1			;
 2796: 1			; vernietigt: niets
 2797: 1			;*******************************************************************************
 2798: 1
 2799: 1  08D3	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2800: 1  08D5	C0 D0		                push    psw
 2801: 1  08D7	EF		                mov     a,r7               ;neem msb van acc0
 2802: 1  08D8	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2803: 1  08DB	D0 D0		                pop     psw                ;nee, positief
 2804: 1  08DD	C2 D1		                clr     f1
 2805: 1  08DF	D0 E0		                pop     acc
 2806: 1  08E1	22		                ret                        ;klaar
 2807: 1
 2808: 1  08E2	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2809: 1  08E3	F4		                cpl     a                   ;complementeren
 2810: 1  08E4	24 01		                add     a,#1               ;en een bijtellen
 2811: 1  08E6	FC		                mov     r4,a
 2812: 1  08E7	ED		                mov     a,r5               ;neem volgende byte
 2813: 1  08E8	F4		                cpl     a                  ;complementeer volgende byte
 2814: 1  08E9	34 00		                addc    a,#0
 2815: 1  08EB	FD		                mov     r5,a
 2816: 1  08EC	EE		                mov     a,r6               ;neem volgende byte
 2817: 1  08ED	F4		                cpl     a                  ;complementeer volgende byte
 2818: 1  08EE	34 00		                addc    a,#0
 2819: 1  08F0	FE		                mov     r6,a
 2820: 1  08F1	EF		                mov     a,r7               ;neem volgende byte
 2821: 1  08F2	F4		                cpl     a                  ;complementeer volgende byte
 2822: 1  08F3	34 00		                addc    a,#0
 2823: 1  08F5	FF		                mov     r7,a
 2824: 1  08F6	D0 D0		                pop     psw
 2825: 1  08F8	D2 D1		                setb    f1                 ;negatief: f0=1
 2826: 1  08FA	D0 E0		                pop     acc
 2827: 1  08FC	22		                ret                        ;klaar
 2828: 1
 2829: 1
 2830: 1			;*******************************************************************************
 2831: 1			; s_add16        (19,35us @16.777216MHz)
 2832: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2833: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2834: 1			; input:     r1,r0 = acc0
 2835: 1			;            r5,r4 = acc1
 2836: 1			;
 2837: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2838: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2839: 1			;                  gebruik van r3,r2 is niet nodig

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2840: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2841: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2842: 1			;
 2843: 1			; vernietigt:  niets
 2844: 1			;*******************************************************************************
 2845: 1  08FD	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2846: 1  08FF	C0 D0		               push    psw
 2847: 1
 2848: 1  0901	E8		               mov     a,r0           ;tel de soft accumulators op
 2849: 1  0902	2C		               add     a,r4           ;low byte eerst
 2850: 1  0903	F8		               mov     r0,a           ;resultaat bewaren
 2851: 1  0904	E9		               mov     a,r1           ;nu de high bytes
 2852: 1  0905	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2853: 1  0906	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2854: 1
 2855: 1  0907	92 D5		               mov     f0,c
 2856: 1  0909	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 2857: 1  090B	92 D1		               mov     f1,c
 2858: 1  090D	A2 D5		               mov     c,f0           ;herstel carrybit
 2859: 1
 2860: 1  090F	74 00		               mov     a,#00h
 2861: 1  0911	34 00		               addc    a,#00h
 2862: 1  0913	FA		               mov     r2,a            ;24bit resultaat klaar
 2863: 1
 2864: 1  0914	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2865: 1
 2866: 1  0917	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2867: 1  0918	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2868: 1  091B	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 2869: 1  091D	7B FF		               mov     r3,#0ffh
 2870: 1  091F	80 04		               sjmp    s_add162
 2871: 1  0921	7A 00		s_add161:      mov     r2,#00h
 2872: 1  0923	7B 00		               mov     r3,#00h
 2873: 1  0925	D0 D0		s_add162:      pop     psw
 2874: 1  0927	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2875: 1  0928	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2876: 1  092A	22		               ret
 2877: 1
 2878: 1  092B	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2879: 1  092D	C3		               clr     c
 2880: 1  092E	D0 E0		               pop     acc
 2881: 1  0930	22		               ret
 2882: 1
 2883: 1			;*******************************************************************************
 2884: 1			; add16        (13,6us @16.777216MHz)
 2885: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2886: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2887: 1			; input:     r1,r0 = acc0
 2888: 1			;            r5,r4 = acc1
 2889: 1			;
 2890: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2891: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 2892: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2893: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 2894: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 2895: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2896: 1			;
 2897: 1			; vernietigt:  niets
 2898: 1			;*******************************************************************************
 2899: 1
 2900: 1  0931	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 2901: 1  0933	C0 D0		               push    psw
 2902: 1  0935	E8		               mov     a,r0           ;tel de soft accumulators op
 2903: 1  0936	2C		               add     a,r4           ;low byte eerst
 2904: 1  0937	F8		               mov     r0,a           ;resultaat bewaren
 2905: 1  0938	E9		               mov     a,r1           ;nu de high bytes
 2906: 1  0939	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2907: 1  093A	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2908: 1  093B	50 08		               jnc     add161          ;geen 24 bit resultaat
 2909: 1
 2910: 1  093D	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 2911: 1  093F	D0 D0		               pop     psw
 2912: 1  0941	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2913: 1  0942	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 2914: 1  0944	22		               ret
 2915: 1
 2916: 1  0945	7A 00		add161:        mov     r2,#00h
 2917: 1  0947	D0 D0		               pop     psw
 2918: 1  0949	C3		               clr     c               ;aangeven aan de gebruiker dat het
 2919: 1  094A	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 2920: 1  094C	22		               ret
 2921: 1
 2922: 1			;*******************************************************************************
 2923: 1			; s_add32        (28,0us @16.777216MHz)
 2924: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2925: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 2926: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2927: 1			; input:     r3,r2,r1,r0 = acc0
 2928: 1			;            r7,r6,r5,r4 = acc1
 2929: 1			;
 2930: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2931: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2932: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 2933: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 2934: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 2935: 1			;
 2936: 1			; vernietigt:  niets
 2937: 1			;*******************************************************************************
 2938: 1  094D	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 2939: 1  094F	C0 D0		               push    psw
 2940: 1
 2941: 1  0951	E8		               mov     a,r0           ;tel de soft accumulators op
 2942: 1  0952	2C		               add     a,r4           ;low byte eerst
 2943: 1  0953	F8		               mov     r0,a           ;resultaat bewaren
 2944: 1  0954	E9		               mov     a,r1           ;nu de hogere bytes
 2945: 1  0955	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2946: 1  0956	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2947: 1
 2948: 1  0957	EA		               mov     a,r2           ;derde bytes optellen
 2949: 1  0958	3E		               addc    a,r6           ;optellen met eventuele overdracht
 2950: 1  0959	FA		               mov     r2,a           ;24bit resultaat is klaar
 2951: 1  095A	EB		               mov     a,r3           ;nu de ms bytes

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2952: 1  095B	3F		               addc    a,r7           ;optellen met eventuele overdracht
 2953: 1  095C	FB		               mov     r3,a           ;32 bit resultaat is klaar
 2954: 1
 2955: 1  095D	92 D5		               mov     f0,c
 2956: 1  095F	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 2957: 1  0961	92 D1		               mov     f1,c
 2958: 1  0963	A2 D5		               mov     c,f0           ;herstel carrybit
 2959: 1
 2960: 1  0965	74 00		               mov     a,#00h
 2961: 1  0967	34 00		               addc    a,#00h
 2962: 1  0969	FC		               mov     r4,a            ;40bit resultaat klaar
 2963: 1
 2964: 1  096A	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 2965: 1  096D	EC		               mov     a,r4            ;ja, sign extention toepassen!
 2966: 1  096E	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 2967: 1  0971	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 2968: 1  0973	80 02		               sjmp    s_add322
 2969: 1  0975	7C 00		s_add321:      mov     r4,#00h
 2970: 1  0977	D0 D0		s_add322:      pop     psw
 2971: 1  0979	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2972: 1  097A	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 2973: 1  097C	22		               ret
 2974: 1
 2975: 1  097D	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 2976: 1  097F	C3		               clr     c
 2977: 1  0980	D0 E0		               pop     acc
 2978: 1  0982	22		               ret
 2979: 1
 2980: 1
 2981: 1			;*******************************************************************************
 2982: 1			; add32        (18,0us @16.777216MHz)
 2983: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 2984: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 2985: 1			; input:     r3,r2,r1,r0 = acc0
 2986: 1			;            r7,r6,r5,r4 = acc1
 2987: 1			;
 2988: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 2989: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 2990: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2991: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 2992: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 2993: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 2994: 1			;
 2995: 1			; vernietigt:  niets
 2996: 1			;*******************************************************************************
 2997: 1  0983	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 2998: 1  0985	C0 D0		               push    psw
 2999: 1  0987	E8		               mov     a,r0           ;tel de soft accumulators op
 3000: 1  0988	2C		               add     a,r4           ;low byte eerst
 3001: 1  0989	F8		               mov     r0,a           ;resultaat bewaren
 3002: 1  098A	E9		               mov     a,r1           ;nu de hogere bytes
 3003: 1  098B	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3004: 1  098C	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3005: 1
 3006: 1  098D	EA		               mov     a,r2           ;derde bytes optellen
 3007: 1  098E	3E		               addc    a,r6           ;optellen met eventuele overdracht

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3008: 1  098F	FA		               mov     r2,a           ;24bit resultaat is klaar
 3009: 1  0990	EB		               mov     a,r3           ;nu de ms bytes
 3010: 1  0991	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3011: 1  0992	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3012: 1
 3013: 1  0993	50 08		               jnc     add321          ;geen 40 bit resultaat
 3014: 1
 3015: 1  0995	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3016: 1  0997	D0 D0		               pop     psw
 3017: 1  0999	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3018: 1  099A	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3019: 1  099C	22		               ret
 3020: 1
 3021: 1  099D	7C 00		add321:        mov     r4,#00h
 3022: 1  099F	D0 D0		               pop     psw
 3023: 1  09A1	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3024: 1  09A2	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3025: 1  09A4	22		               ret
 3026: 1
 3027: 1
 3028: 1			;*******************************************************************************
 3029: 1			; s_sub16        (24,4us @16.777216MHz)
 3030: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3031: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3032: 1			; input:     r1,r0 = acc0
 3033: 1			;            r5,r4 = acc1
 3034: 1			;
 3035: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3036: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3037: 1			;                  gebruik van r3,r2 is niet nodig
 3038: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3039: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3040: 1			;
 3041: 1			; vernietigt:  niets
 3042: 1			;*******************************************************************************
 3043: 1  09A5	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3044: 1  09A7	C0 D0		                push    psw
 3045: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3046: 1
 3047: 1  09A9	EC		                mov   	a,r4            ;verander het teken van acc1
 3048: 1  09AA	F4		                cpl    	a               ;door het 2's complement te nemen
 3049: 1  09AB	24 01		                add   	a,#1
 3050: 1  09AD	FC		                mov    	r4,a
 3051: 1  09AE	ED		                mov    	a,r5
 3052: 1  09AF	F4		                cpl    	a
 3053: 1  09B0	34 00		                addc	a,#0
 3054: 1  09B2	FD		                mov    	r5,a
 3055: 1			;acc0+acc1
 3056: 1  09B3	E8						mov		a,r0
 3057: 1  09B4	2C						add		a,r4
 3058: 1  09B5	F8						mov		r0,a
 3059: 1  09B6	E9						mov		a,r1
 3060: 1  09B7	3D						addc	a,r5
 3061: 1  09B8	F9						mov		r1,a
 3062: 1
 3063: 1  09B9	92 D5		                mov    f0,c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3064: 1  09BB	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3065: 1  09BD	92 D1		                mov    f1,c
 3066: 1  09BF	A2 D5		                mov    c,f0            ;herstel carrybit
 3067: 1
 3068: 1  09C1	74 00		                mov    a,#00h
 3069: 1  09C3	34 00		                addc   a,#00h
 3070: 1  09C5	FA		                mov    r2,a            ;24bit resultaat klaar
 3071: 1
 3072: 1  09C6	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3073: 1  09C9	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3074: 1  09CA	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3075: 1  09CD	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3076: 1  09CF	7B FF		                mov    r3,#0ffh
 3077: 1  09D1	80 04		                sjmp   s_sub162
 3078: 1  09D3	7A 00		s_sub161:       mov    r2,#00h
 3079: 1  09D5	7B 00		                mov    r3,#00h
 3080: 1  09D7	D0 D0		s_sub162:       pop    psw
 3081: 1  09D9	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3082: 1  09DA	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3083: 1  09DC	22		                ret
 3084: 1
 3085: 1  09DD	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3086: 1  09DF	C3		                clr    c
 3087: 1  09E0	D0 E0		                pop    acc
 3088: 1  09E2	22		                ret
 3089: 1
 3090: 1			;*******************************************************************************
 3091: 1			; sub16            (14,4us @16.777216MHz)
 3092: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3093: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3094: 1			; input:     r1,r0 = acc0
 3095: 1			;            r5,r4 = acc1
 3096: 1			;
 3097: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3098: 1			;            bij een underflow r2 op ffh zetten
 3099: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3100: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3101: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3102: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3103: 1			;
 3104: 1			; vernietigt:  niets
 3105: 1			;*******************************************************************************
 3106: 1
 3107: 1  09E3	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3108: 1  09E5	C0 D0		                push    psw
 3109: 1  09E7	C3		                clr     c
 3110: 1  09E8	E8		                mov     a,r0            ;tel de soft accumulators op
 3111: 1  09E9	9C		                subb    a,r4            ;low byte eerst
 3112: 1  09EA	F8		                mov     r0,a            ;resultaat bewaren
 3113: 1  09EB	E9		                mov     a,r1            ;nu de high bytes
 3114: 1  09EC	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3115: 1  09ED	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3116: 1  09EE	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3117: 1
 3118: 1  09F0	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3119: 1  09F2	D0 D0		                pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3120: 1  09F4	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3121: 1  09F5	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3122: 1  09F7	22		                ret
 3123: 1
 3124: 1  09F8	7A 00		sub161:         mov     r2,#00h
 3125: 1  09FA	D0 D0		                pop     psw
 3126: 1  09FC	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3127: 1  09FD	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3128: 1  09FF	22		                ret
 3129: 1
 3130: 1			;*******************************************************************************
 3131: 1			; s_sub32        (27,2us @16.777216MHz)
 3132: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3133: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3134: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3135: 1			; input:     r3,r2,r1,r0 = acc0
 3136: 1			;            r7,r6,r5,r4 = acc1
 3137: 1			;
 3138: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3139: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3140: 1			;                  gebruik van r4 is niet nodig
 3141: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3142: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3143: 1			;
 3144: 1			; vernietigt:  niets
 3145: 1			;*******************************************************************************
 3146: 1  0A00	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3147: 1  0A02	C0 D0		                push   psw
 3148: 1
 3149: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3150: 1
 3151: 1  0A04	EC		                mov    	a,r4            ;verander het teken van acc1
 3152: 1  0A05	F4		                cpl    	a               ;door het 2's complement te nemen
 3153: 1  0A06	24 01		                add    	a,#1
 3154: 1  0A08	FC		                mov    	r4,a
 3155: 1  0A09	ED		                mov    	a,r5
 3156: 1  0A0A	F4		                cpl    	a
 3157: 1  0A0B	34 00		                addc	a,#0
 3158: 1  0A0D	FD		                mov    	r5,a
 3159: 1  0A0E	EE		                mov    	a,r6
 3160: 1  0A0F	F4		                cpl    	a
 3161: 1  0A10	34 00		                addc   	a,#0
 3162: 1  0A12	FE		                mov    	r6,a
 3163: 1  0A13	EF		                mov    	a,r7
 3164: 1  0A14	F4		                cpl    	a
 3165: 1  0A15	34 00		                addc   	a,#0
 3166: 1  0A17	FF		                mov    	r7,a
 3167: 1			;acc0+acc1
 3168: 1  0A18	E8						mov		a,r0
 3169: 1  0A19	2C						add		a,r4
 3170: 1  0A1A	F8						mov		r0,a
 3171: 1  0A1B	E9						mov		a,r1
 3172: 1  0A1C	3D						addc	a,r5
 3173: 1  0A1D	F9						mov		r1,a
 3174: 1  0A1E	EA						mov		a,r2
 3175: 1  0A1F	3E						addc	a,r6

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3176: 1  0A20	FA						mov		r2,a
 3177: 1  0A21	EB						mov		a,r3
 3178: 1  0A22	3F						addc	a,r7
 3179: 1  0A23	FB						mov		r3,a
 3180: 1
 3181: 1  0A24	92 D5		                mov   f0,c
 3182: 1  0A26	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3183: 1  0A28	92 D1		                mov   f1,c
 3184: 1  0A2A	A2 D5		                mov   c,f0            ;herstel carrybit
 3185: 1
 3186: 1  0A2C	74 00		                mov   a,#00h
 3187: 1  0A2E	34 00		                addc  a,#00h
 3188: 1  0A30	FC		                mov   r4,a            ;40bit resultaat klaar
 3189: 1
 3190: 1  0A31	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3191: 1
 3192: 1  0A34	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3193: 1  0A35	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3194: 1  0A38	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3195: 1  0A3A	80 02		                sjmp   s_sub322
 3196: 1  0A3C	7C 00		s_sub321:       mov   r4,#00h
 3197: 1  0A3E	D0 D0		s_sub322:       pop   psw
 3198: 1  0A40	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3199: 1  0A41	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3200: 1  0A43	22		                ret
 3201: 1
 3202: 1  0A44	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3203: 1  0A46	C3		                clr   c
 3204: 1  0A47	D0 E0		                pop   acc
 3205: 1  0A49	22		                ret
 3206: 1
 3207: 1
 3208: 1			;*******************************************************************************
 3209: 1			; sub32        (18,7us @16.777216MHz)
 3210: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3211: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3212: 1			; input:     r3,r2,r1,r0 = acc0
 3213: 1			;            r7,r6,r5,r4 = acc1
 3214: 1			;
 3215: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3216: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3217: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3218: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3219: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3220: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3221: 1			;
 3222: 1			; vernietigt:  niets
 3223: 1			;*******************************************************************************
 3224: 1  0A4A	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3225: 1  0A4C	C0 D0		               push    psw
 3226: 1  0A4E	C3		               clr       c
 3227: 1  0A4F	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3228: 1  0A50	9C		               subb    a,r4           ;low byte eerst
 3229: 1  0A51	F8		               mov     r0,a           ;resultaat bewaren
 3230: 1  0A52	E9		               mov     a,r1           ;nu de hogere bytes
 3231: 1  0A53	9D		               subb    a,r5           ;verschil met eventuele overdracht

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3232: 1  0A54	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3233: 1
 3234: 1  0A55	EA		               mov     a,r2           ;derde bytes optellen
 3235: 1  0A56	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3236: 1  0A57	FA		               mov     r2,a           ;24bit resultaat is klaar
 3237: 1  0A58	EB		               mov     a,r3           ;nu de ms bytes
 3238: 1  0A59	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3239: 1  0A5A	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3240: 1
 3241: 1  0A5B	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3242: 1
 3243: 1  0A5D	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3244: 1  0A5F	D0 D0		               pop     psw
 3245: 1  0A61	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3246: 1  0A62	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3247: 1  0A64	22		               ret
 3248: 1
 3249: 1  0A65	7C 00		sub321:        mov     r4,#00h
 3250: 1  0A67	D0 D0		               pop     psw
 3251: 1  0A69	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3252: 1  0A6A	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3253: 1  0A6C	22		               ret
 3254: 1
 3255: 1
 3256: 1
 3257: 1			;*******************************************************************************
 3258: 1			; mul16        (71,2us @16.777216MHz)
 3259: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3260: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3261: 1			; input:     r1,r0 = acc0
 3262: 1			;            r5,r4 = acc1
 3263: 1			;
 3264: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3265: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3266: 1			;
 3267: 1			; vernietigt:  niets
 3268: 1			;*******************************************************************************
 3269: 1  0A6D	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3270: 1  0A6F	C0 D0		                push    psw
 3271: 1  0A71	C0 F0		                push    b
 3272: 1  0A73	C0 82		                push    dpl
 3273: 1  0A75	C0 83		                push    dph
 3274: 1
 3275: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3276: 1
 3277: 1  0A77	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3278: 1  0A79	89 83		                mov     dph,r1
 3279: 1  0A7B	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3280: 1  0A7D	08		                inc     r0              ;pointer naar eerste vrije plaats
 3281: 1  0A7E	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3282: 1  0A80	E5 81		                mov     a,sp            ;plaats alloceren
 3283: 1  0A82	24 03		                add     a,#3            ;3 bytes nodig
 3284: 1  0A84	F5 81		                mov     sp,a            ;stackpointer verzetten
 3285: 1
 3286: 1  0A86	E5 82		                mov     a,dpl            ;acc0 lsb
 3287: 1  0A88	8C F0		                mov     b,r4            ;acc1 lsb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3288: 1  0A8A	A4		                mul     ab
 3289: 1  0A8B	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3290: 1  0A8C	08		                inc     r0
 3291: 1  0A8D	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3292: 1
 3293: 1  0A8F	E5 83		                mov     a,dph            ;acc0 msb
 3294: 1  0A91	8C F0		                mov     b,r4            ;acc1 lsb
 3295: 1  0A93	A4		                mul     ab
 3296: 1
 3297: 1  0A94	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3298: 1  0A95	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3299: 1  0A96	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3300: 1  0A98	34 00		                addc    a,#0
 3301: 1  0A9A	08		                inc     r0               ;bewaar als tussenresultaat
 3302: 1  0A9B	F6		                mov     @r0,a
 3303: 1
 3304: 1  0A9C	E5 82		                mov     a,dpl            ;acc0 lsb
 3305: 1  0A9E	8D F0		                mov     b,r5             ;acc1 msb
 3306: 1  0AA0	A4		                mul     ab
 3307: 1  0AA1	18		                dec     r0
 3308: 1  0AA2	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3309: 1  0AA3	F6		                mov     @r0,a            ;en bewaar weer
 3310: 1  0AA4	08		                inc     r0
 3311: 1  0AA5	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3312: 1  0AA7	36		                addc    a,@r0
 3313: 1  0AA8	F6		                mov     @r0,a            ;en bewaar weer
 3314: 1  0AA9	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3315: 1
 3316: 1  0AAB	E5 83		                mov     a,dph            ;acc0 msb
 3317: 1  0AAD	8D F0		                mov     b,r5             ;acc1 msb
 3318: 1  0AAF	A4		                mul     AB
 3319: 1  0AB0	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3320: 1  0AB1	FA		                mov     r2,a
 3321: 1  0AB2	E5 F0		                mov     a,b
 3322: 1  0AB4	34 00		                addc    a,#0
 3323: 1
 3324: 1  0AB6	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3325: 1  0AB8	34 00		                addc    a,#0
 3326: 1
 3327: 1  0ABA	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3328: 1  0ABB	18		                dec     r0
 3329: 1  0ABC	86 83		                mov     dph,@r0
 3330: 1  0ABE	18		                dec     r0
 3331: 1  0ABF	86 82		                mov     dpl,@r0
 3332: 1
 3333: 1  0AC1	89 81		                mov     sp,r1            ;zet stackpointer terug
 3334: 1  0AC3	A9 83		                mov     r1,dph
 3335: 1  0AC5	A8 82		                mov     r0,dpl
 3336: 1
 3337: 1  0AC7	D0 83		                pop     dph              ;herstel de bewaarde registers
 3338: 1  0AC9	D0 82		                pop     dpl
 3339: 1  0ACB	D0 F0		                pop     b
 3340: 1  0ACD	D0 D0		                pop     psw
 3341: 1  0ACF	D0 E0		                pop     acc
 3342: 1  0AD1	22		                ret
 3343: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3344: 1
 3345: 1
 3346: 1			;*******************************************************************************
 3347: 1			; mul16acc1        (71,2us @16.777216MHz)
 3348: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3349: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3350: 1			; input:     r5,r4 = acc1 low
 3351: 1			;            r7,r6 = acc1 high
 3352: 1			;
 3353: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3354: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3355: 1			;
 3356: 1			; vernietigt:  niets
 3357: 1			;*******************************************************************************
 3358: 1  0AD2	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3359: 1  0AD4	C0 D0		                push    psw
 3360: 1  0AD6	C0 F0		                push    b
 3361: 1  0AD8	C0 82		                push    dpl
 3362: 1  0ADA	C0 83		                push    dph
 3363: 1
 3364: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3365: 1
 3366: 1  0ADC	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3367: 1  0ADE	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3368: 1
 3369: 1  0AE0	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3370: 1  0AE2	08		                inc     r0               ;pointer naar eerste vrije plaats
 3371: 1  0AE3	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3372: 1  0AE5	E5 81		                mov     a,sp             ;plaats alloceren
 3373: 1  0AE7	24 03		                add     a,#3             ;3 bytes nodig
 3374: 1  0AE9	F5 81		                mov     sp,a             ;stackpointer verzetten
 3375: 1
 3376: 1  0AEB	EC		                mov     a,r4             ;acc1 low lsb
 3377: 1  0AEC	8E F0		                mov     b,r6             ;acc1 high lsb
 3378: 1  0AEE	A4		                mul     ab
 3379: 1  0AEF	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3380: 1  0AF0	08		                inc     r0
 3381: 1  0AF1	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3382: 1
 3383: 1  0AF3	ED		                mov     a,r5             ;acc1 low msb
 3384: 1  0AF4	8E F0		                mov     b,r6             ;acc1 high lsb
 3385: 1  0AF6	A4		                mul     ab
 3386: 1
 3387: 1  0AF7	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3388: 1  0AF8	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3389: 1  0AF9	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3390: 1  0AFB	34 00		                addc    a,#0
 3391: 1  0AFD	08		                inc     r0               ;bewaar als tussenresultaat
 3392: 1  0AFE	F6		                mov     @r0,a
 3393: 1
 3394: 1  0AFF	EC		                mov     a,r4             ;acc1 low lsb
 3395: 1  0B00	8F F0		                mov     b,r7             ;acc1 high msb
 3396: 1  0B02	A4		                mul     ab
 3397: 1  0B03	18		                dec     r0
 3398: 1  0B04	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3399: 1  0B05	F6		                mov     @r0,a            ;en bewaar weer

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3400: 1  0B06	08		                inc     r0
 3401: 1  0B07	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3402: 1  0B09	36		                addc    a,@r0
 3403: 1  0B0A	F6		                mov     @r0,a            ;en bewaar weer
 3404: 1  0B0B	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3405: 1
 3406: 1  0B0D	ED		                mov     a,r5             ;acc1 low msb
 3407: 1  0B0E	8F F0		                mov     b,r7             ;acc1 high msb
 3408: 1  0B10	A4		                mul     AB
 3409: 1
 3410: 1  0B11	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3411: 1  0B12	FE		                mov     r6,a             ;deze byte van product is al klaar
 3412: 1  0B13	E5 F0		                mov     a,b
 3413: 1  0B15	34 00		                addc    a,#0
 3414: 1  0B17	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3415: 1  0B19	34 00		                addc    a,#0
 3416: 1
 3417: 1  0B1B	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3418: 1  0B1C	18		                dec     r0
 3419: 1  0B1D	E6		                mov     a,@r0
 3420: 1  0B1E	FD		                mov     r5,a
 3421: 1  0B1F	18		                dec     r0
 3422: 1  0B20	E6		                mov     a,@r0
 3423: 1  0B21	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3424: 1
 3425: 1  0B22	89 81		                mov     sp,r1            ;zet stackpointer terug
 3426: 1  0B24	A9 83		                mov     r1,dph
 3427: 1  0B26	A8 82		                mov     r0,dpl
 3428: 1
 3429: 1  0B28	D0 83		                pop     dph              ;herstel de bewaarde registers
 3430: 1  0B2A	D0 82		                pop     dpl
 3431: 1  0B2C	D0 F0		                pop     b
 3432: 1  0B2E	D0 D0		                pop     psw
 3433: 1  0B30	D0 E0		                pop     acc
 3434: 1  0B32	22		                ret
 3435: 1
 3436: 1			;*******************************************************************************
 3437: 1			; s_mul16        (121,1us @16.777216MHz)
 3438: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3439: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3440: 1			; input:     r1,r0 = acc0
 3441: 1			;            r5,r4 = acc1
 3442: 1			;
 3443: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3444: 1			;                                  -1073709056 tot +1073741824
 3445: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3446: 1			;
 3447: 1			; vernietigt:  niets
 3448: 1			;*******************************************************************************
 3449: 1  0B33	12 08 49	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3450: 1  0B36	12 08 69	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3451: 1  0B39	12 0A 6D	                lcall    mul16           ;maak product
 3452: 1  0B3C	12 07 C3	                lcall    magsig32        ;maak 2's complement formaat
 3453: 1  0B3F	22		                ret                      ;klaar
 3454: 1
 3455: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3456: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3457: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3458: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3459: 1			; input:     r5,r4 = acc1 low
 3460: 1			;            r7,r6 = acc1 high
 3461: 1			;
 3462: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3463: 1			;                                  -1073709056 tot +1073741824
 3464: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3465: 1			; vernietigt:  niets
 3466: 1			;*******************************************************************************
 3467: 1  0B40	12 08 69	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3468: 1  0B43	12 08 89	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3469: 1  0B46	12 0A D2	                lcall    mul16acc1       ;maak product
 3470: 1  0B49	12 07 ED	                lcall    magsig32acc1    ;maak 2's complement formaat
 3471: 1  0B4C	22		                ret                      ;klaar
 3472: 1
 3473: 1			;*******************************************************************************
 3474: 1			; s_mul816        (83,5us @16.777216MHz)
 3475: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3476: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3477: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3478: 1			; input:     r1,r0 = acc0
 3479: 1			;               r4 = acc1
 3480: 1			;
 3481: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3482: 1			;                                  -4194176 tot +4194304
 3483: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3484: 1			; vernietigt:  niets
 3485: 1			;*******************************************************************************
 3486: 1  0B4D	12 08 49	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3487: 1  0B50	12 08 30	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3488: 1  0B53	12 0B 5A	                lcall    mul816          ;8bit x 16 bit product
 3489: 1  0B56	12 07 C3	                lcall    magsig32        ;abs. waarde naar 2's complement
 3490: 1  0B59	22		                ret
 3491: 1
 3492: 1			;*******************************************************************************
 3493: 1			; mul816        (29,4us @16.777216MHz)
 3494: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3495: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3496: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3497: 1			; input:     r1,r0 = acc0
 3498: 1			;               r4 = acc1
 3499: 1			;
 3500: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3501: 1			;                           0..16711425 (000000h..feff01h)
 3502: 1			;
 3503: 1			; vernietigt:  niets
 3504: 1			;*******************************************************************************
 3505: 1  0B5A	C0 E0		mul816:         push    acc             ;bewaar registers
 3506: 1  0B5C	C0 F0		                push    b
 3507: 1  0B5E	C0 D0		                push    psw
 3508: 1  0B60	EC		                mov     a,r4            ;neem acc1
 3509: 1  0B61	88 F0		                mov     b,r0            ;neem lsb van acc0
 3510: 1  0B63	A4		                mul     ab              ;maak product

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3511: 1  0B64	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3512: 1  0B65	C0 F0		                push    b               ;bewaar lsb van het product
 3513: 1  0B67	EC		                mov     a,r4            ;neem acc1
 3514: 1  0B68	89 F0		                mov     b,r1            ;neem msb can acc0
 3515: 1  0B6A	A4		                mul     ab              ;maak product
 3516: 1  0B6B	AA F0		                mov     r2,b            ;bewaar msb van product even
 3517: 1  0B6D	F5 F0		                mov     b,a             ;verplaats lsb van product
 3518: 1  0B6F	D0 E0		                pop     acc             ;neem msb van vorig product
 3519: 1  0B71	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3520: 1  0B73	F9		                mov     r1,a            ;de middenste byte is klaar
 3521: 1  0B74	EA		                mov     a,r2            ;tel nu de eventuele
 3522: 1  0B75	34 00		                addc    a,#0            ;carry bij de msb
 3523: 1  0B77	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3524: 1  0B78	7B 00		                mov     r3,#0
 3525: 1  0B7A	D0 D0		                pop     psw
 3526: 1  0B7C	D0 F0		                pop     b
 3527: 1  0B7E	D0 E0		                pop     acc
 3528: 1  0B80	22		                ret
 3529: 1
 3530: 1			;*******************************************************************************
 3531: 1			; s_mac16        (145,1us @16.777216MHz)
 3532: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3533: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3534: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3535: 1			; input:     r7,r6 = acc1 (high word)
 3536: 1			;            r5,r4 = acc1 (low  word)
 3537: 1			;
 3538: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3539: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3540: 1			;                          -2147483648 tot +2147483647
 3541: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3542: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3543: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3544: 1			;
 3545: 1			; vernietigt:  niets
 3546: 1			;*******************************************************************************
 3547: 1  0B81	12 0B 40	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3548: 1  0B84	C0 E0		                push    acc
 3549: 1  0B86	C0 D0		                push    psw
 3550: 1  0B88	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3551: 1  0B89	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3552: 1  0B8A	F8		                mov     r0,a
 3553: 1  0B8B	ED		                mov     a,r5
 3554: 1  0B8C	39		                addc    a,r1
 3555: 1  0B8D	F9		                mov     r1,a
 3556: 1  0B8E	EE		                mov     a,r6
 3557: 1  0B8F	3A		                addc    a,r2
 3558: 1  0B90	FA		                mov     r2,a
 3559: 1  0B91	EF		                mov     a,r7
 3560: 1  0B92	3B		                addc    a,r3
 3561: 1  0B93	FB		                mov     r3,a
 3562: 1  0B94	20 D2 06	                jb      ov,s_mac161
 3563: 1  0B97	D0 D0		                pop     psw
 3564: 1  0B99	C3		                clr     c                ;ok, 32bit som binnen bereik
 3565: 1  0B9A	D0 E0		                pop     acc
 3566: 1  0B9C	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3567: 1  0B9D	D0 D0		s_mac161:       pop     psw
 3568: 1  0B9F	D3		                setb    c                ;fout! 32bit som buiten bereik
 3569: 1  0BA0	D0 E0		                pop     acc
 3570: 1  0BA2	22		                ret
 3571: 1
 3572: 1
 3573: 1			;*******************************************************************************
 3574: 1			; s_div8        (78us @16.777216MHz)
 3575: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3576: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3577: 1			; input:    r0 = acc0 deeltal (2's compl)
 3578: 1			;           r4 = acc1 deler   (2's compl)
 3579: 1			;
 3580: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3581: 1			;           r4 = rest (2's compl)
 3582: 1			;           cy=1 bij acc1=0 (deling door nul)
 3583: 1			;            cy=0 in andere gevallen
 3584: 1			;
 3585: 1			; vernietigt: niets
 3586: 1			;*******************************************************************************
 3587: 1  0BA3	12 08 17	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3588: 1  0BA6	12 08 30	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3589: 1  0BA9	12 0B B5	                lcall   div8
 3590: 1  0BAC	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3591: 1  0BAE	12 07 4F	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3592: 1  0BB1	12 07 69	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3593: 1  0BB4	22		s_div81:        ret
 3594: 1
 3595: 1			;*******************************************************************************
 3596: 1			; div8        (19,4us @16.777216MHz)
 3597: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3598: 1			; absolute waarde
 3599: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3600: 1			; input:    r0 = acc0 deeltal
 3601: 1			;           r4 = acc1 deler
 3602: 1			;
 3603: 1			; output:   r0 = quotient van deling acc0/acc1
 3604: 1			;           r4 = rest
 3605: 1			;           cy=1 bij acc1=0 (deling door nul)
 3606: 1			;            cy=0 in andere gevallen
 3607: 1			;
 3608: 1			; vernietigt: niets
 3609: 1			;*******************************************************************************
 3610: 1  0BB5	C0 E0		div8:           push    acc             ;bewaar registers
 3611: 1  0BB7	C0 F0		                push    b
 3612: 1  0BB9	C0 D0		                push    psw
 3613: 1  0BBB	EC		                mov     a,r4            ;neem deler
 3614: 1  0BBC	60 0F		                jz      div81           ;deling door nul?
 3615: 1  0BBE	E8		                mov     a,r0            ;nee, neem deeltal
 3616: 1  0BBF	8C F0		                mov     b,r4            ;en deler
 3617: 1  0BC1	84		                div     ab              ;en maak deling
 3618: 1  0BC2	F8		                mov     r0,a            ;bewaar quotient in acc0
 3619: 1  0BC3	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3620: 1  0BC5	D0 D0		                pop     psw             ;herstel registers
 3621: 1  0BC7	D0 F0		                pop     b
 3622: 1  0BC9	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3623: 1  0BCB	C3		                clr     c                ;geen deling door nul
 3624: 1  0BCC	22		                ret
 3625: 1
 3626: 1  0BCD	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3627: 1  0BCF	D0 F0		                pop     b
 3628: 1  0BD1	D0 E0		                pop     acc
 3629: 1  0BD3	D3		                setb    c
 3630: 1  0BD4	22		                ret
 3631: 1
 3632: 1
 3633: 1			;*******************************************************************************
 3634: 1			; s_div16        (469,1us @16.777216MHz)
 3635: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3636: 1			; 2's Complement Format
 3637: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3638: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3639: 1			;           r5, r4 = acc1 deler   (2's compl)
 3640: 1			;
 3641: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3642: 1			;           r5, r4 = rest
 3643: 1			;           cy=1 bij acc1=0 (deling door nul)
 3644: 1			;            cy=0 in andere gevallen
 3645: 1			;
 3646: 1			; vernietigt: niets
 3647: 1			;*******************************************************************************
 3648: 1  0BD5	C0 E0		s_div16:        push    acc
 3649: 1  0BD7	C0 D0		                push    psw
 3650: 1  0BD9	ED		                mov     a,r5            ;neem msb van deler
 3651: 1  0BDA	4C		                orl     a,r4            ;combineer met lsb van deler
 3652: 1  0BDB	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3653: 1  0BDD	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3654: 1  0BDF	D0 E0		                pop     acc
 3655: 1  0BE1	D3		                setb    C               ;fout, deling door nul!
 3656: 1  0BE2	22		                ret
 3657: 1
 3658: 1  0BE3	12 08 49	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3659: 1  0BE6	12 08 69	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3660: 1  0BE9	12 0B F8	                lcall   div16
 3661: 1  0BEC	12 07 83	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3662: 1  0BEF	12 07 A3	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3663: 1  0BF2	D0 D0		                pop     psw
 3664: 1  0BF4	C3		                clr     C               ;delig ok
 3665: 1  0BF5	D0 E0		                pop     acc
 3666: 1  0BF7	22		                ret                     ;klaar
 3667: 1
 3668: 1			;*******************************************************************************
 3669: 1			; div16            (405,1us @16.777216MHz)
 3670: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3671: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3672: 1			; input:    r1, r0 = Deeltal (acc0)
 3673: 1			;           r5, r4 = Deler   (acc1)
 3674: 1			;
 3675: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3676: 1			;           r5, r4 = rest van de deling acc0/acc1
 3677: 1			;            cy=1 bij deling door nul (acc1=0)
 3678: 1			;            cy=0 bij normale deling

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3679: 1			;
 3680: 1			; vernietigt: niets
 3681: 1			;*******************************************************************************
 3682: 1
 3683: 1  0BF8	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3684: 1  0BFA	C0 D0		                push    psw
 3685: 1			;check voor deling door nul
 3686: 1  0BFC	EC		                mov     a,r4           ;neem lsb deler
 3687: 1  0BFD	4D		                orl     a,r5           ;combineer met msb van deler
 3688: 1  0BFE	70 06		                jnz     div160         ;niet nul, dan verder werken
 3689: 1  0C00	D0 D0		                pop     psw            ;als nul, dikke snul
 3690: 1  0C02	D3		                setb    c              ;terug met errorstatus
 3691: 1  0C03	D0 E0		                pop     acc
 3692: 1  0C05	22		                ret
 3693: 1
 3694: 1  0C06	C0 F0		div160:         push    b              ;registers verder bewaren
 3695: 1  0C08	EF		                mov     a,r7
 3696: 1  0C09	C0 E0		                push    acc            ;push r7 op stack
 3697: 1  0C0B	EE		                mov     a,r6
 3698: 1  0C0C	C0 E0		                push    acc            ;push r6 op stack
 3699: 1  0C0E	EB		                mov     a,r3
 3700: 1  0C0F	C0 E0		                push    acc            ;push r3 op stack
 3701: 1  0C11	EA		                mov     a,r2
 3702: 1  0C12	C0 E0		                push    acc            ;push r2 op stack
 3703: 1  0C14	C0 83		                push    dph
 3704: 1  0C16	C0 82		                push    dpl
 3705: 1
 3706: 1  0C18	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3707: 1  0C1A	7B 00		                mov     r3,#0
 3708: 1  0C1C	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3709: 1  0C1E	7E 00		                mov     r6,#0
 3710: 1  0C20	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3711: 1
 3712: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3713: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3714: 1			;het aantal significante bits af in de lusteller b
 3715: 1
 3716: 1  0C23	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3717: 1  0C24	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3718: 1  0C27	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3719: 1  0C28	E8		                mov     a,r0            ;lsb van deeltal nemen
 3720: 1  0C29	33		                rlc     a                ;en opschuiven
 3721: 1  0C2A	F8		                mov     r0,a
 3722: 1  0C2B	E9		                mov     a,r1            ;msb van deeltal nemen
 3723: 1  0C2C	33		                rlc     a
 3724: 1  0C2D	F9		                mov     r1,a
 3725: 1  0C2E	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3726: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3727: 1  0C31	7C 00		                mov     r4,#0
 3728: 1  0C33	7D 00		                mov     r5,#0
 3729: 1  0C35	80 2E		                sjmp    div164          ;klaar!
 3730: 1
 3731: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3732: 1
 3733: 1  0C37	C3		div162:            clr     C            ;start met carry op nul
 3734: 1  0C38	E8		                mov     a,r0            ;schuif deeltal naar links

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3735: 1  0C39	33		                rlc     a
 3736: 1  0C3A	F8		                mov     r0,a
 3737: 1  0C3B	E9		                mov     a,r1
 3738: 1  0C3C	33		                rlc     a
 3739: 1  0C3D	F9		                mov     r1,a
 3740: 1  0C3E	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3741: 1  0C3F	33		                rlc     a               ;gedeeltelijke rest
 3742: 1  0C40	FE		                mov     r6,a
 3743: 1  0C41	EF		                mov     a,r7
 3744: 1  0C42	33		                rlc     a
 3745: 1  0C43	FF		                mov     r7,a
 3746: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3747: 1  0C44	EE		                mov     a,r6
 3748: 1  0C45	C3		                clr     C
 3749: 1  0C46	9C		                subb    a,r4
 3750: 1  0C47	F5 82		                mov     dpl,a
 3751: 1  0C49	EF		                mov     a,r7
 3752: 1  0C4A	9D		                subb    a,r5
 3753: 1  0C4B	F5 83		                mov     dph,a
 3754: 1  0C4D	40 04		                jc      div163
 3755: 1  0C4F	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3756: 1  0C51	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3757: 1
 3758: 1  0C53	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3759: 1  0C54	EA		                mov     a,r2            ;binnenschuiven
 3760: 1  0C55	33		                rlc     a
 3761: 1  0C56	FA		                mov     r2,a
 3762: 1  0C57	EB		                mov     a,r3
 3763: 1  0C58	33		                rlc     a
 3764: 1  0C59	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 3765: 1  0C5A	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3766: 1
 3767: 1  0C5D	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3768: 1  0C5E	F9		                mov     r1,a
 3769: 1  0C5F	EA		                mov     a,r2
 3770: 1  0C60	F8		                mov     r0,a
 3771: 1  0C61	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3772: 1  0C62	FD		                mov     r5,a
 3773: 1  0C63	EE		                mov     a,r6
 3774: 1  0C64	FC		                mov     r4,a
 3775: 1
 3776: 1  0C65	D0 82		div164:         pop     dpl             ;registers herstellen
 3777: 1  0C67	D0 83		                pop     dph
 3778: 1  0C69	D0 E0		                pop     acc
 3779: 1  0C6B	FA		                mov     r2,a            ;r2 van stack halen
 3780: 1  0C6C	D0 E0		                pop     acc
 3781: 1  0C6E	FB		                mov     r3,a            ;r3 van stack halen
 3782: 1  0C6F	D0 E0		                pop     acc
 3783: 1  0C71	FE		                mov     r6,a            ;r6 van stack halen
 3784: 1  0C72	D0 E0		                pop     acc
 3785: 1  0C74	FF		                mov     r7,a            ;r7 van stack halen
 3786: 1  0C75	D0 F0		                pop     b
 3787: 1  0C77	D0 D0		                pop     psw
 3788: 1  0C79	C3		                clr     c               ;deling ok
 3789: 1  0C7A	D0 E0		                pop     acc
 3790: 1  0C7C	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3791: 1
 3792: 1
 3793: 1			;*******************************************************************************
 3794: 1			; s_div32        (2,15ms @16.777216MHz)
 3795: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3796: 1			; 2's Complement Format
 3797: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3798: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3799: 1			;
 3800: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 3801: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3802: 1			;
 3803: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3804: 1			;           r7,r6,r5, r4 = rest
 3805: 1			;           cy=1 bij acc1=0 (deling door nul)
 3806: 1			;            cy=0 in andere gevallen
 3807: 1			;
 3808: 1			; vernietigt: niets
 3809: 1			;*******************************************************************************
 3810: 1  0C7D	C0 E0		s_div32:        push    acc
 3811: 1  0C7F	C0 D0		                push    psw
 3812: 1  0C81	EF		                mov     a,r7            ;neem msb van deler
 3813: 1  0C82	4E		                orl     a,r6            ;combineer met lsb's van deler
 3814: 1  0C83	4D		                orl     a,r5
 3815: 1  0C84	4C		                orl     a,r4
 3816: 1  0C85	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3817: 1  0C87	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3818: 1  0C89	D0 E0		                pop     acc
 3819: 1  0C8B	D3		                setb    C                ;fout, deling door nul!
 3820: 1  0C8C	22		                ret
 3821: 1
 3822: 1  0C8D	12 08 A9	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3823: 1  0C90	12 08 D3	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3824: 1  0C93	12 0C A2	                lcall   div32            ;deel 32bit/32bit
 3825: 1  0C96	12 07 C3	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3826: 1  0C99	12 07 ED	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3827: 1  0C9C	D0 D0		                pop     psw
 3828: 1  0C9E	C3		                clr     C                ;delig ok
 3829: 1  0C9F	D0 E0		                pop     acc
 3830: 1  0CA1	22		                ret                        ;klaar
 3831: 1
 3832: 1
 3833: 1			;*******************************************************************************
 3834: 1			; div32        (2,09ms @16.777216MHz)
 3835: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3836: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3837: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3838: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3839: 1			;
 3840: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 3841: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3842: 1			;            cy=1 bij deling door nul (acc1=0)
 3843: 1			;            cy=0 bij normale deling
 3844: 1			;
 3845: 1			; vernietigt: niets
 3846: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3847: 1  0CA2	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3848: 1  0CA4	C0 D0		                push    psw
 3849: 1			;check voor deling door nul
 3850: 1  0CA6	EF		                mov     a,r7            ;neem msb van deler
 3851: 1  0CA7	4E		                orl     a,r6            ;combineer met lsb's van deler
 3852: 1  0CA8	4D		                orl     a,r5
 3853: 1  0CA9	4C		                orl     a,r4
 3854: 1  0CAA	70 06		                jnz     div320          ;niet nul, dan verder werken
 3855: 1  0CAC	D0 D0		                pop     psw             ;als nul, dikke snul
 3856: 1  0CAE	D3		                setb    c               ;terug met errorstatus
 3857: 1  0CAF	D0 E0		                pop     acc
 3858: 1  0CB1	22		                ret
 3859: 1
 3860: 1  0CB2	C0 F0		div320:         push    b                ;registers verder bewaren
 3861: 1  0CB4	C0 83		                push    dph
 3862: 1  0CB6	C0 82		                push    dpl
 3863: 1
 3864: 1  0CB8	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3865: 1
 3866: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3867: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3868: 1			;het aantal significante bits af in de lusteller b
 3869: 1
 3870: 1  0CBB	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3871: 1  0CBC	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3872: 1  0CBF	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3873: 1  0CC0	E8		                mov     a,r0            ;lsb van deeltal nemen
 3874: 1  0CC1	33		                rlc     a               ;en opschuiven
 3875: 1  0CC2	F8		                mov     r0,a
 3876: 1  0CC3	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 3877: 1  0CC4	33		                rlc     a
 3878: 1  0CC5	F9		                mov     r1,a
 3879: 1  0CC6	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3880: 1  0CC7	33		                rlc     a
 3881: 1  0CC8	FA		                mov     r2,a
 3882: 1  0CC9	EB		                mov     a,r3           ;lsb van deeltal nemen
 3883: 1  0CCA	33		                rlc     a
 3884: 1  0CCB	FB		                mov     r3,a
 3885: 1  0CCC	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3886: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3887: 1  0CCF	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3888: 1  0CD1	7E 00		                mov     r6,#0
 3889: 1  0CD3	7D 00		                mov     r5,#0
 3890: 1  0CD5	7C 00		                mov     r4,#0
 3891: 1  0CD7	02 0D A0	                ljmp    div324           ;klaar!
 3892: 1
 3893: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 3894: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 3895: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 3896: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 3897: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 3898: 1
 3899: 1  0CDA			div320b:
 3900: 1  0CDA	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 3901: 1
 3902: 1  0CDD	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3903: 1  0CDF	24 0C		                add     a,#12           ;met 12 plaatsen
 3904: 1  0CE1	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 3905: 1
 3906: 1  0CE3	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 3907: 1  0CE4	C0 E0		                push    acc
 3908: 1  0CE6	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 3909: 1  0CE7	C0 E0		                push    acc
 3910: 1
 3911: 1  0CE9	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 3912: 1  0CEB	08		                inc     r0              ;de deler
 3913: 1  0CEC	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 3914: 1  0CEE	24 05		                add     a,#5            ;het tijdelijk verschil X
 3915: 1  0CF0	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 3916: 1  0CF1	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 3917: 1  0CF3	24 09		                add     a,#9            ;quotient
 3918: 1  0CF5	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 3919: 1
 3920: 1			;Eenmalig de variabelen op stack initaliseren
 3921: 1			;Tijdelijk quotient op nul zetten
 3922: 1
 3923: 1  0CF7	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 3924: 1  0CF9	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 3925: 1  0CFA	C0 F0		                push    b                ;loopteller deling bewaren
 3926: 1  0CFC	75 F0 04	                mov     b,#4
 3927: 1  0CFF	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 3928: 1  0D01	09		                inc     r1
 3929: 1  0D02	D5 F0 FA	                djnz    b,div320c
 3930: 1  0D05	D0 F0		                pop     b                ;loopteller deling ophalen
 3931: 1  0D07	19		                dec     r1
 3932: 1  0D08	19		                dec     r1
 3933: 1  0D09	19		                dec     r1
 3934: 1  0D0A	19		                dec     r1               ;pointer weer op startadres quotient
 3935: 1  0D0B	C9		                xch     a,r1             ;weer omwisselen
 3936: 1  0D0C	C5 82		                xch     a,dpl
 3937: 1
 3938: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 3939: 1  0D0E	EC		                mov     a,r4
 3940: 1  0D0F	F6		                mov     @r0,a
 3941: 1  0D10	08		                inc     r0
 3942: 1  0D11	ED		                mov     a,r5
 3943: 1  0D12	F6		                mov     @r0,a
 3944: 1  0D13	08		                inc     r0
 3945: 1  0D14	EE		                mov     a,r6
 3946: 1  0D15	F6		                mov     @r0,a
 3947: 1  0D16	08		                inc     r0
 3948: 1  0D17	EF		                mov     a,r7
 3949: 1  0D18	F6		                mov     @r0,a
 3950: 1  0D19	18		                dec     r0             ;pointer herstellen naar lsb van deler
 3951: 1  0D1A	18		                dec     r0
 3952: 1  0D1B	18		                dec     r0
 3953: 1
 3954: 1  0D1C	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 3955: 1  0D1E	7E 00		                mov     r6,#0
 3956: 1  0D20	7D 00		                mov     r5,#0
 3957: 1  0D22	7C 00		                mov     r4,#0
 3958: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3959: 1
 3960: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 3961: 1  0D24	C3		div322:         clr     C               ;start met carry op nul
 3962: 1
 3963: 1  0D25	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 3964: 1  0D27	33		                rlc     a
 3965: 1  0D28	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 3966: 1  0D2A	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 3967: 1  0D2C	D0 E0		                pop     acc             ;r1 van deeltal van stack
 3968: 1  0D2E	33		                rlc     a
 3969: 1  0D2F	C0 E0		                push    acc             ;en weer bewaren
 3970: 1  0D31	05 81		                inc     sp              ;stackpointer weer corrigeren
 3971: 1
 3972: 1  0D33	EA		                mov     a,r2
 3973: 1  0D34	33		                rlc     a
 3974: 1  0D35	FA		                mov     r2,a
 3975: 1  0D36	EB		                mov     a,r3
 3976: 1  0D37	33		                rlc     a
 3977: 1  0D38	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 3978: 1
 3979: 1  0D39	EC		                mov     a,r4            ;schuif carry van deeltal in de
 3980: 1  0D3A	33		                rlc     a               ;gedeeltelijke rest r7..r4
 3981: 1  0D3B	FC		                mov     r4,a
 3982: 1  0D3C	ED		                mov     a,r5
 3983: 1  0D3D	33		                rlc     a
 3984: 1  0D3E	FD		                mov     r5,a
 3985: 1  0D3F	EE		                mov     a,r6
 3986: 1  0D40	33		                rlc     a
 3987: 1  0D41	FE		                mov     r6,a
 3988: 1  0D42	EF		                mov     a,r7
 3989: 1  0D43	33		                rlc     a
 3990: 1  0D44	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 3991: 1
 3992: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 3993: 1
 3994: 1  0D45	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 3995: 1  0D46	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 3996: 1  0D47	96		                subb    a,@r0           ;trek er de lsb deler af
 3997: 1  0D48	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 3998: 1  0D49	08		                inc     r0              ;pointers aanpassen
 3999: 1  0D4A	09		                inc     r1
 4000: 1  0D4B	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4001: 1  0D4C	96		                subb    a,@r0           ;trek er volgende byte deler af
 4002: 1  0D4D	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4003: 1  0D4E	08		                inc     r0              ;pointers aanpassen
 4004: 1  0D4F	09		                inc     r1
 4005: 1  0D50	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4006: 1  0D51	96		                subb    a,@r0           ;trek er volgende byte deler af
 4007: 1  0D52	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4008: 1  0D53	08		                inc     r0              ;pointers aanpassen
 4009: 1  0D54	09		                inc     r1
 4010: 1  0D55	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4011: 1  0D56	96		                subb    a,@r0           ;trek er msb deler af
 4012: 1  0D57	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4013: 1  0D58	18		                dec     r0              ;pointers herstellen naar lsb's
 4014: 1  0D59	18		                dec     r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4015: 1  0D5A	18		                dec     r0
 4016: 1  0D5B	19		                dec     r1
 4017: 1  0D5C	19		                dec     r1
 4018: 1  0D5D	19		                dec     r1
 4019: 1
 4020: 1  0D5E	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4021: 1  0D60	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4022: 1  0D61	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4023: 1  0D62	09		                inc     r1
 4024: 1  0D63	E7		                mov     a,@r1
 4025: 1  0D64	FD		                mov     r5,a
 4026: 1  0D65	09		                inc     r1
 4027: 1  0D66	E7		                mov     a,@r1
 4028: 1  0D67	FE		                mov     r6,a
 4029: 1  0D68	09		                inc     r1
 4030: 1  0D69	E7		                mov     a,@r1
 4031: 1  0D6A	FF		                mov     r7,a
 4032: 1  0D6B	19		                dec     r1              ;met pointer weer naar lsb van
 4033: 1  0D6C	19		                dec     r1              ;het tijdelijk verschil wijzen
 4034: 1  0D6D	19		                dec     r1
 4035: 1
 4036: 1
 4037: 1  0D6E	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4038: 1  0D6F	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4039: 1  0D71	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4040: 1  0D72	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4041: 1  0D74	E7		                mov     a,@r1           ;neem lsb van qoutient
 4042: 1  0D75	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4043: 1  0D76	F7		                mov     @r1,a
 4044: 1  0D77	09		                inc     r1              ;volgende byte
 4045: 1  0D78	E7		                mov     a,@r1
 4046: 1  0D79	33		                rlc     a
 4047: 1  0D7A	F7		                mov     @r1,a
 4048: 1  0D7B	09		                inc     r1              ;volgende byte
 4049: 1  0D7C	E7		                mov     a,@r1
 4050: 1  0D7D	33		                rlc     a
 4051: 1  0D7E	F7		                mov     @r1,a
 4052: 1  0D7F	09		                inc     r1              ;volgende byte
 4053: 1  0D80	E7		                mov     a,@r1
 4054: 1  0D81	33		                rlc     a
 4055: 1  0D82	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4056: 1  0D83	19		                dec     r1
 4057: 1  0D84	19		                dec     r1
 4058: 1  0D85	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4059: 1  0D86	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4060: 1  0D88	C9		                xch     a,r1            ;r1=pointer naar verschil
 4061: 1  0D89	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4062: 1
 4063: 1  0D8B	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4064: 1
 4065: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4066: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4067: 1
 4068: 1  0D8E	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4069: 1  0D90	18		                dec     r0
 4070: 1  0D91	18		                dec     r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4071: 1  0D92	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4072: 1  0D93	FB		                mov     r3,a            ;en verplaatsen
 4073: 1  0D94	18		                dec     r0              ;volgende byte
 4074: 1  0D95	E6		                mov     a,@r0
 4075: 1  0D96	FA		                mov     r2,a
 4076: 1  0D97	18		                dec     r0              ;volgende byte
 4077: 1  0D98	E6		                mov     a,@r0
 4078: 1  0D99	F9		                mov     r1,a
 4079: 1  0D9A	18		                dec     r0              ;volgende byte
 4080: 1  0D9B	E6		                mov     a,@r0
 4081: 1  0D9C	F8		                mov     r0,a            ;laatste byte verplaatst!
 4082: 1
 4083: 1  0D9D	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4084: 1			                                         ;weer vrijgeven
 4085: 1
 4086: 1
 4087: 1  0DA0	D0 82		div324:         pop     dpl             ;registers herstellen
 4088: 1  0DA2	D0 83		                pop     dph
 4089: 1  0DA4	D0 F0		                pop     b
 4090: 1  0DA6	D0 D0		                pop     psw
 4091: 1  0DA8	C3		                clr     c               ;normale deling
 4092: 1  0DA9	D0 E0		                pop     acc
 4093: 1  0DAB	22		                ret
 4094: 1
 4095: 1			;*******************************************************************************
 4096: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4097: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4098: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4099: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4100: 1			;
 4101: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4102: 1			;
 4103: 1			; input:     r5,r4 = acc1 (low word product)
 4104: 1			;            r7,r6 = acc1 (high word product)
 4105: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4106: 1			;
 4107: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4108: 1			;            r7,r6,r5,r4 = acc1 = rest
 4109: 1			;                          -2147483648 tot +2147483647
 4110: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4111: 1			;             cy=1 bij deling door nul (acc0=0)
 4112: 1			;             cy=0 bij normale deling
 4113: 1			;
 4114: 1			; vernietigt:  niets
 4115: 1			;*******************************************************************************
 4116: 1  0DAC	C0 E0		s_muldiv:       push    acc
 4117: 1  0DAE	C0 D0		                push    psw
 4118: 1  0DB0	E8		                mov     a,r0            ;neem msb van deler
 4119: 1  0DB1	49		                orl     a,r1            ;combineer met lsb's van deler
 4120: 1  0DB2	4A		                orl     a,r2
 4121: 1  0DB3	4B		                orl     a,r3
 4122: 1  0DB4	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4123: 1  0DB6	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4124: 1  0DB8	D0 E0		                pop     acc
 4125: 1  0DBA	D3		                setb    C               ;fout, deling door nul!
 4126: 1  0DBB	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4127: 1
 4128: 1  0DBC	12 08 69	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4129: 1  0DBF	12 08 89	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4130: 1  0DC2	12 0D D1	                lcall    muldiv          ;maak product en daarna de deling
 4131: 1  0DC5	12 07 C3	                lcall    magsig32        ;quotient naar 2's complement
 4132: 1  0DC8	12 07 ED	                lcall    magsig32acc1    ;rest naar 2's complement
 4133: 1  0DCB	D0 D0		                pop     psw
 4134: 1  0DCD	C3		                clr     c                ;deling is ok
 4135: 1  0DCE	D0 E0		                pop    acc
 4136: 1  0DD0	22		                ret
 4137: 1
 4138: 1			;*******************************************************************************
 4139: 1			; muldiv        (2,0ms @16.777216MHz)
 4140: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4141: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4142: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4143: 1			; 32bit rest in acc1.
 4144: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4145: 1			;
 4146: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4147: 1			;
 4148: 1			; input:     r5,r4 = acc1 (low word product)
 4149: 1			;            r7,r6 = acc1 (high word product)
 4150: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4151: 1			;
 4152: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4153: 1			;            r7,r6,r5,r4 = acc1 = rest
 4154: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4155: 1			;             cy=1 bij deling door nul (acc0=0)
 4156: 1			;             cy=0 bij normale deling
 4157: 1			;
 4158: 1			; vernietigt:  niets
 4159: 1			;*******************************************************************************
 4160: 1  0DD1	C0 E0		muldiv:         push    acc
 4161: 1  0DD3	C0 D0		                push    psw
 4162: 1  0DD5	E8		                mov     a,r0            ;neem msb van deler
 4163: 1  0DD6	49		                orl     a,r1            ;combineer met lsb's van deler
 4164: 1  0DD7	4A		                orl     a,r2
 4165: 1  0DD8	4B		                orl     a,r3
 4166: 1  0DD9	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4167: 1  0DDB	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4168: 1  0DDD	D0 E0		                pop     acc
 4169: 1  0DDF	D3		                setb    C               ;fout, deling door nul!
 4170: 1  0DE0	22		                ret
 4171: 1
 4172: 1  0DE1	12 0A D2	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4173: 1  0DE4	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4174: 1  0DE5	C0 E0		                push    acc
 4175: 1  0DE7	ED		                mov     a,r5
 4176: 1  0DE8	C0 E0		                push    acc
 4177: 1  0DEA	EE		                mov     a,r6
 4178: 1  0DEB	C0 E0		                push    acc
 4179: 1  0DED	EF		                mov     a,r7
 4180: 1  0DEE	C0 E0		                push    acc             ;product staat nu op stack
 4181: 1
 4182: 1  0DF0	E8		                mov     a,r0            ;deler in acc1 stoppen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4183: 1  0DF1	FC		                mov     r4,a
 4184: 1  0DF2	E9		                mov     a,r1
 4185: 1  0DF3	FD		                mov     r5,a
 4186: 1  0DF4	EA		                mov     a,r2
 4187: 1  0DF5	FE		                mov     r6,a
 4188: 1  0DF6	EB		                mov     a,r3
 4189: 1  0DF7	FF		                mov     r7,a            ;deler zit volledig in acc1
 4190: 1
 4191: 1  0DF8	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4192: 1  0DFA	FB		                mov     r3,a
 4193: 1  0DFB	D0 E0		                pop     acc
 4194: 1  0DFD	FA		                mov     r2,a
 4195: 1  0DFE	D0 E0		                pop     acc
 4196: 1  0E00	F9		                mov     r1,a
 4197: 1  0E01	D0 E0		                pop     acc
 4198: 1  0E03	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4199: 1  0E04	12 0C A2	                lcall   div32           ;maak deling
 4200: 1
 4201: 1  0E07	D0 D0		                pop     psw            ;herstel registers
 4202: 1  0E09	D0 E0		                pop     acc
 4203: 1  0E0B	C3		                clr     C              ;resultaat ok!
 4204: 1  0E0C	22		                ret
 4205: 1
 4206: 1			;*******************************************************************************
 4207: 1			; mul16_pi        (257,1us @16.777216MHz)
 4208: 1			; acc0 = acc0 x pi
 4209: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4210: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4211: 1			;
 4212: 1			; input:     r1,r0 = acc0 (low word)
 4213: 1			;
 4214: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4215: 1			;
 4216: 1			; vernietigt:  niets
 4217: 1			;*******************************************************************************
 4218: 1  0E0D	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4219: 1  0E0F	C0 D0		                push    psw
 4220: 1  0E11	EC		                mov     a,r4
 4221: 1  0E12	C0 E0		                push    acc
 4222: 1  0E14	ED		                mov     a,r5
 4223: 1  0E15	C0 E0		                push    acc
 4224: 1  0E17	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4225: 1  0E19	7C 0F		                mov     r4,#0fH
 4226: 1  0E1B	12 0A 6D	                lcall   mul16           ;acc0 = acc0 x acc1
 4227: 1  0E1E	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4228: 1  0E20	12 10 09	                lcall   shiftright32    ;om te delen door 2^14
 4229: 1  0E23	D0 E0		                pop     acc
 4230: 1  0E25	FD		                mov     r5,a
 4231: 1  0E26	D0 E0		                pop     acc
 4232: 1  0E28	FC		                mov     r4,a
 4233: 1  0E29	D0 D0		                pop     psw
 4234: 1  0E2B	D0 E0		                pop     acc
 4235: 1  0E2D	22		                ret
 4236: 1
 4237: 1			;*******************************************************************************
 4238: 1			; mul16_i_pi        (279,1us @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4239: 1			; acc0 = acc0 x 1/pi
 4240: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4241: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4242: 1			;
 4243: 1			; input:     r1,r0 = acc0 (low word)
 4244: 1			;
 4245: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4246: 1			;
 4247: 1			; vernietigt:  niets
 4248: 1			;*******************************************************************************
 4249: 1  0E2E	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4250: 1  0E30	C0 D0		                push    psw
 4251: 1  0E32	EC		                mov     a,r4
 4252: 1  0E33	C0 E0		                push    acc
 4253: 1  0E35	ED		                mov     a,r5
 4254: 1  0E36	C0 E0		                push    acc
 4255: 1  0E38	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4256: 1  0E3A	7C 7D		                mov     r4,#07dH
 4257: 1  0E3C	12 0A 6D	                lcall    mul16          ;acc0 = acc0 x acc1
 4258: 1  0E3F	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4259: 1  0E41	12 10 09	                lcall   shiftright32    ;om te delen door 2^16
 4260: 1  0E44	D0 E0		                pop     acc
 4261: 1  0E46	FD		                mov     r5,a
 4262: 1  0E47	D0 E0		                pop     acc
 4263: 1  0E49	FC		                mov     r4,a
 4264: 1  0E4A	D0 D0		                pop     psw
 4265: 1  0E4C	D0 E0		                pop     acc
 4266: 1  0E4E	22		                ret
 4267: 1
 4268: 1			;*******************************************************************************
 4269: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4270: 1			; acc0 = acc0 x sqrt2
 4271: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4272: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4273: 1			;
 4274: 1			; input:     r1,r0 = acc0 (low word)
 4275: 1			;
 4276: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4277: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4278: 1			;
 4279: 1			; vernietigt:  niets
 4280: 1			;*******************************************************************************
 4281: 1  0E4F	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4282: 1  0E51	C0 D0		                push    psw
 4283: 1  0E53	EC		                mov     a,r4
 4284: 1  0E54	C0 E0		                push    acc
 4285: 1  0E56	ED		                mov     a,r5
 4286: 1  0E57	C0 E0		                push    acc
 4287: 1  0E59	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4288: 1  0E5B	7C 05		                mov     r4,#005H
 4289: 1  0E5D	12 0A 6D	                lcall   mul16           ;acc0 = acc0 x acc1
 4290: 1  0E60	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4291: 1  0E62	12 10 09	                lcall   shiftright32    ;om te delen door 2^15
 4292: 1  0E65	D0 E0		                pop     acc
 4293: 1  0E67	FD		                mov     r5,a
 4294: 1  0E68	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4295: 1  0E6A	FC		                mov     r4,a
 4296: 1  0E6B	D0 D0		                pop     psw
 4297: 1  0E6D	D0 E0		                pop     acc
 4298: 1  0E6F	22		                ret
 4299: 1
 4300: 1
 4301: 1
 4302: 1			;*******************************************************************************
 4303: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4304: 1			; acc0 = acc0 x 1/sqrt2
 4305: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4306: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4307: 1			;
 4308: 1			; input:     r1,r0 = acc0 (low word)
 4309: 1			;
 4310: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4311: 1			;
 4312: 1			; vernietigt:  niets
 4313: 1			;*******************************************************************************
 4314: 1  0E70	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4315: 1  0E72	C0 D0		                push    psw
 4316: 1  0E74	EC		                mov     a,r4
 4317: 1  0E75	C0 E0		                push    acc
 4318: 1  0E77	ED		                mov     a,r5
 4319: 1  0E78	C0 E0		                push    acc
 4320: 1  0E7A	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4321: 1  0E7C	7C 05		                mov     r4,#005H
 4322: 1  0E7E	12 0A 6D	                lcall   mul16           ;acc0 = acc0 x acc1
 4323: 1  0E81	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4324: 1  0E83	12 10 09	                lcall   shiftright32    ;om te delen door 2^16
 4325: 1  0E86	D0 E0		                pop     acc
 4326: 1  0E88	FD		                mov     r5,a
 4327: 1  0E89	D0 E0		                pop     acc
 4328: 1  0E8B	FC		                mov     r4,a
 4329: 1  0E8C	D0 D0		                pop     psw
 4330: 1  0E8E	D0 E0		                pop     acc
 4331: 1  0E90	22		                ret
 4332: 1
 4333: 1			;*******************************************************************************
 4334: 1			; mul16_10        (98,7us @16.777216MHz)
 4335: 1			; acc0 = acc0 x 10
 4336: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4337: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4338: 1			;
 4339: 1			; input:     r1,r0 = acc0 (low word)
 4340: 1			;
 4341: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4342: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4343: 1			; vernietigt:  niets
 4344: 1			;*******************************************************************************
 4345: 1  0E91	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4346: 1  0E93	C0 D0		                push    psw
 4347: 1  0E95	EC		                mov     a,r4
 4348: 1  0E96	C0 E0		                push    acc
 4349: 1  0E98	7C 01		                mov     r4,#1           ;acc0 x2
 4350: 1  0E9A	12 10 35	                lcall   shiftleft32     ;acc0 = acc0 x 2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4351: 1  0E9D	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4352: 1  0E9E	C0 E0		                push    acc
 4353: 1  0EA0	EA		                mov     a,r2
 4354: 1  0EA1	C0 E0		                push    acc
 4355: 1  0EA3	E9		                mov     a,r1
 4356: 1  0EA4	C0 E0		                push    acc
 4357: 1  0EA6	E8		                mov     a,r0
 4358: 1  0EA7	C0 E0		                push    acc             ;acc0 op stack
 4359: 1  0EA9	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4360: 1  0EAB	12 10 35	                lcall   shiftleft32     ;acc0 =acc0 x4
 4361: 1  0EAE	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4362: 1  0EB0	28		                add     a,r0            ;tel bij huidige acc0
 4363: 1  0EB1	F8		                mov     r0,a
 4364: 1  0EB2	D0 E0		                pop     acc
 4365: 1  0EB4	39		                addc    a,r1
 4366: 1  0EB5	F9		                mov     r1,a
 4367: 1  0EB6	D0 E0		                pop     acc
 4368: 1  0EB8	3A		                addc    a,r2
 4369: 1  0EB9	FA		                mov     r2,a
 4370: 1  0EBA	D0 E0		                pop     acc
 4371: 1  0EBC	3B		                addc    a,r3
 4372: 1  0EBD	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4373: 1
 4374: 1
 4375: 1  0EBE	D0 E0		                pop     acc
 4376: 1  0EC0	FC		                mov     r4,a
 4377: 1  0EC1	D0 D0		                pop     psw
 4378: 1  0EC3	D0 E0		                pop     acc
 4379: 1  0EC5	22		                ret
 4380: 1
 4381: 1			;*******************************************************************************
 4382: 1			; mul16_100        (169,1us @16.777216MHz)
 4383: 1			; acc0 = acc0 x 100
 4384: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4385: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4386: 1			;
 4387: 1			; input:     r1,r0 = acc0 (low word)
 4388: 1			;
 4389: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4390: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4391: 1			; vernietigt:  niets
 4392: 1			;*******************************************************************************
 4393: 1  0EC6	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4394: 1  0EC8	C0 D0		                push    psw
 4395: 1  0ECA	EC		                mov     a,r4
 4396: 1  0ECB	C0 E0		                push    acc
 4397: 1  0ECD	7C 02		                mov     r4,#2           ;acc0 x4
 4398: 1  0ECF	12 10 35	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4399: 1  0ED2	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4400: 1  0ED3	C0 E0		                push    acc
 4401: 1  0ED5	EA		                mov     a,r2
 4402: 1  0ED6	C0 E0		                push    acc
 4403: 1  0ED8	E9		                mov     a,r1
 4404: 1  0ED9	C0 E0		                push    acc
 4405: 1  0EDB	E8		                mov     a,r0
 4406: 1  0EDC	C0 E0		                push    acc             ;acc0 op stack

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4407: 1
 4408: 1  0EDE	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4409: 1  0EE0	12 10 35	                lcall   shiftleft32     ;acc0 =acc0 x8
 4410: 1  0EE3	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4411: 1  0EE4	C0 E0		                push    acc
 4412: 1  0EE6	EA		                mov     a,r2
 4413: 1  0EE7	C0 E0		                push    acc
 4414: 1  0EE9	E9		                mov     a,r1
 4415: 1  0EEA	C0 E0		                push    acc
 4416: 1  0EEC	E8		                mov     a,r0
 4417: 1  0EED	C0 E0		                push    acc             ;acc0 op stack
 4418: 1
 4419: 1  0EEF	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4420: 1  0EF1	12 10 35	                lcall   shiftleft32     ;acc0 =acc0 x2
 4421: 1  0EF4	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4422: 1  0EF6	28		                add     a,r0            ;tel bij huidige acc0
 4423: 1  0EF7	F8		                mov     r0,a
 4424: 1  0EF8	D0 E0		                pop     acc
 4425: 1  0EFA	39		                addc    a,r1
 4426: 1  0EFB	F9		                mov     r1,a
 4427: 1  0EFC	D0 E0		                pop     acc
 4428: 1  0EFE	3A		                addc    a,r2
 4429: 1  0EFF	FA		                mov     r2,a
 4430: 1  0F00	D0 E0		                pop     acc
 4431: 1  0F02	3B		                addc    a,r3
 4432: 1  0F03	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4433: 1
 4434: 1  0F04	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4435: 1  0F06	28		                add     a,r0            ;tel bij huidige acc0
 4436: 1  0F07	F8		                mov     r0,a
 4437: 1  0F08	D0 E0		                pop     acc
 4438: 1  0F0A	39		                addc    a,r1
 4439: 1  0F0B	F9		                mov     r1,a
 4440: 1  0F0C	D0 E0		                pop     acc
 4441: 1  0F0E	3A		                addc    a,r2
 4442: 1  0F0F	FA		                mov     r2,a
 4443: 1  0F10	D0 E0		                pop     acc
 4444: 1  0F12	3B		                addc    a,r3
 4445: 1  0F13	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4446: 1
 4447: 1  0F14	D0 E0		                pop     acc
 4448: 1  0F16	FC		                mov     r4,a
 4449: 1  0F17	D0 D0		                pop     psw
 4450: 1  0F19	D0 E0		                pop     acc
 4451: 1  0F1B	22		                ret
 4452: 1
 4453: 1			;*******************************************************************************
 4454: 1			; sqrt32        (2,99ms @16.777216MHz)
 4455: 1			; acc0 = acc0 ^(1/2)
 4456: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4457: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4458: 1			;
 4459: 1			; input:     r3,r2,r1,r0 = acc0
 4460: 1			;
 4461: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4462: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4463: 1			; vernietigt:  niets
 4464: 1			;*******************************************************************************
 4465: 1  0F1C	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4466: 1  0F1E	C0 F0		                push    b
 4467: 1  0F20	C0 D0		                push    psw
 4468: 1  0F22	C0 82		                push    dpl
 4469: 1  0F24	C0 83		                push    dph
 4470: 1  0F26	EC		                mov     a,r4
 4471: 1  0F27	C0 E0		                push    acc
 4472: 1  0F29	ED		                mov     a,r5
 4473: 1  0F2A	C0 E0		                push    acc
 4474: 1  0F2C	EE		                mov     a,r6
 4475: 1  0F2D	C0 E0		                push    acc
 4476: 1  0F2F	EF		                mov     a,r7
 4477: 1  0F30	C0 E0		                push    acc
 4478: 1
 4479: 1  0F32	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4480: 1  0F34	7D 00		                mov     r5,#0
 4481: 1  0F36	7E 00		                mov     r6,#0
 4482: 1  0F38	7F 00		                mov     r7,#0
 4483: 1  0F3A	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4484: 1  0F3D	75 83 00	                mov     dph,#0
 4485: 1  0F40	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4486: 1			;hier start het algorithme voor het berekenen van de wortel
 4487: 1  0F43	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4488: 1  0F45	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4489: 1  0F48	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4490: 1  0F49	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4491: 1  0F4A	33		                rlc     a                ;getest worden om een wortelbit te
 4492: 1  0F4B	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4493: 1  0F4C	E9		                mov     a,r1            ;met nullen!
 4494: 1  0F4D	33		                rlc     a
 4495: 1  0F4E	F9		                mov     r1,a
 4496: 1  0F4F	EA		                mov     a,r2
 4497: 1  0F50	33		                rlc     a
 4498: 1  0F51	FA		                mov     r2,a
 4499: 1  0F52	EB		                mov     a,r3
 4500: 1  0F53	33		                rlc     a
 4501: 1  0F54	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4502: 1
 4503: 1  0F55	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4504: 1  0F56	33		                rlc     a
 4505: 1  0F57	FC		                mov     r4,a
 4506: 1  0F58	ED		                mov     a,r5
 4507: 1  0F59	33		                rlc     a
 4508: 1  0F5A	FD		                mov     r5,a
 4509: 1  0F5B	EE		                mov     a,r6
 4510: 1  0F5C	33		                rlc     a
 4511: 1  0F5D	FE		                mov     r6,a
 4512: 1  0F5E	EF		                mov     a,r7
 4513: 1  0F5F	33		                rlc     a
 4514: 1  0F60	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4515: 1  0F61	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4516: 1
 4517: 1  0F64	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4518: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4519: 1  0F66	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4520: 1  0F67	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4521: 1  0F69	33		                rlc     a
 4522: 1  0F6A	F5 82		                mov     dpl,a
 4523: 1  0F6C	E5 83		                mov     a,dph
 4524: 1  0F6E	33		                rlc     a
 4525: 1  0F6F	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4526: 1
 4527: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4528: 1  0F71	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4529: 1  0F72	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4530: 1  0F74	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4531: 1  0F75	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4532: 1  0F77	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4533: 1  0F78	C0 E0		                push    acc             ;van acc1
 4534: 1  0F7A	EB		                mov     a,r3
 4535: 1  0F7B	C0 E0		                push    acc
 4536: 1  0F7D	EC		                mov     a,r4
 4537: 1  0F7E	C0 E0		                push    acc
 4538: 1  0F80	ED		                mov     a,r5
 4539: 1  0F81	C0 E0		                push    acc
 4540: 1  0F83	EE		                mov     a,r6
 4541: 1  0F84	C0 E0		                push    acc
 4542: 1  0F86	EF		                mov     a,r7
 4543: 1  0F87	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4544: 1
 4545: 1  0F89	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4546: 1  0F8B	AD 83		                mov     r5,dph
 4547: 1  0F8D	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4548: 1  0F8F	AF 83		                mov     r7,dph
 4549: 1  0F91	12 0A D2	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4550: 1
 4551: 1  0F94	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4552: 1  0F96	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4553: 1  0F97	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4554: 1  0F99	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4555: 1  0F9A	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4556: 1  0F9C	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4557: 1  0F9D	D0 E0		                pop     acc             ;de stack...
 4558: 1  0F9F	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4559: 1
 4560: 1  0FA0	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4561: 1  0FA1	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4562: 1  0FA2	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4563: 1  0FA3	E9		                mov     a,r1            ;in acc1.
 4564: 1  0FA4	9D		                subb    a,r5            ;We doen dit door de carry van het
 4565: 1  0FA5	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4566: 1  0FA6	9E		                subb    a,r6
 4567: 1  0FA7	EB		                mov     a,r3
 4568: 1  0FA8	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4569: 1  0FA9	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4570: 1			                                        ;wortel behouden
 4571: 1  0FAB	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4572: 1  0FAD	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4573: 1  0FAF	F5 82		                mov     dpl,a          ;wortel aanpassen
 4574: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4575: 1  0FB1	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4576: 1  0FB3	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4577: 1  0FB5	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4578: 1
 4579: 1  0FB7	D0 E0		                pop     acc            ;haal acc1 weer op
 4580: 1  0FB9	FF		                mov     r7,a
 4581: 1  0FBA	D0 E0		                pop     acc
 4582: 1  0FBC	FE		                mov     r6,a
 4583: 1  0FBD	D0 E0		                pop     acc
 4584: 1  0FBF	FD		                mov     r5,a
 4585: 1  0FC0	D0 E0		                pop     acc
 4586: 1  0FC2	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4587: 1
 4588: 1  0FC3	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4589: 1  0FC5	FB		                mov     r3,a
 4590: 1  0FC6	D0 E0		                pop     acc
 4591: 1  0FC8	FA		                mov     r2,a
 4592: 1  0FC9	D0 E0		                pop     acc
 4593: 1  0FCB	F9		                mov     r1,a
 4594: 1  0FCC	D0 E0		                pop     acc
 4595: 1  0FCE	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4596: 1
 4597: 1  0FCF	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4598: 1  0FD2	80 03		                sjmp    sqrt325
 4599: 1  0FD4	02 0F 43	sqrt324:        ljmp    sqrt320        ;uit acc0
 4600: 1
 4601: 1  0FD7	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4602: 1  0FD9	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4603: 1
 4604: 1  0FDB	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4605: 1  0FDD	FF		                mov     r7,a
 4606: 1  0FDE	D0 E0		                pop     acc
 4607: 1  0FE0	FE		                mov     r6,a
 4608: 1  0FE1	D0 E0		                pop     acc
 4609: 1  0FE3	FD		                mov     r5,a
 4610: 1  0FE4	D0 E0		                pop     acc
 4611: 1  0FE6	FC		                mov     r4,a           ;acc1 is hersteld
 4612: 1  0FE7	D0 83		                pop     dph
 4613: 1  0FE9	D0 82		                pop     dpl
 4614: 1  0FEB	D0 D0		                pop     psw
 4615: 1  0FED	D0 F0		                pop     b
 4616: 1  0FEF	D0 E0		                pop     acc
 4617: 1
 4618: 1  0FF1	22		                ret                    ;eindelijk klaar...
 4619: 1
 4620: 1			;*******************************************************************************
 4621: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4622: 1			; acc0 = acc0 ^(1/2)
 4623: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4624: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4625: 1			;                           (-2147483648 tot +2147483647)
 4626: 1			; input:     r3,r2,r1,r0 = acc0
 4627: 1			;
 4628: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4629: 1			;            CY = 1 als acc0 negatief is
 4630: 1			; vernietigt:  niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4631: 1			;*******************************************************************************
 4632: 1  0FF2	C0 E0		s_sqrt32:       push    acc
 4633: 1  0FF4	C0 D0		                push    psw
 4634: 1  0FF6	EB		                mov     a,r3
 4635: 1  0FF7	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4636: 1  0FFA	D0 D0		                pop     psw
 4637: 1  0FFC	D3		                setb    c                ;als negatief dan error
 4638: 1  0FFD	D0 E0		                pop     acc
 4639: 1  0FFF	22		                ret
 4640: 1  1000	D0 D0		s_sqrt321:      pop     psw
 4641: 1  1002	D0 E0		                pop     acc
 4642: 1  1004	12 0F 1C	                lcall   sqrt32            ;wortel trekken
 4643: 1  1007	C3		                clr     c                 ;wortel ok
 4644: 1  1008	22		                ret                       ;klaar
 4645: 1
 4646: 1			;*******************************************************************************
 4647: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4648: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4649: 1			; (logical shift)
 4650: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4651: 1			;
 4652: 1			; input:     r3,r2,r1,r0 = acc0
 4653: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4654: 1			;
 4655: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4656: 1			;            CY=1 als N>=32
 4657: 1			; vernietigt:  niets
 4658: 1			;*******************************************************************************
 4659: 1  1009	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4660: 1  100B	C0 D0		                push    psw
 4661: 1  100D	EC		                mov     a,r4            ;neem aantal shifts
 4662: 1  100E	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4663: 1  1011	40 06		shiftright1:    jc      shiftright2
 4664: 1  1013	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4665: 1  1015	D3		                setb    c               ;N buiten bereik
 4666: 1  1016	D0 E0		                pop     acc
 4667: 1  1018	22		                ret
 4668: 1
 4669: 1  1019	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4670: 1  101B	8C F0		                mov     b,r4            ;lusteller initialiseren
 4671: 1  101D	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4672: 1  101E	EB		                mov     a,r3            ;start bij msb
 4673: 1  101F	13		                rrc     a
 4674: 1  1020	FB		                mov     r3,a
 4675: 1  1021	EA		                mov     a,r2
 4676: 1  1022	13		                rrc     a
 4677: 1  1023	FA		                mov     r2,a
 4678: 1  1024	E9		                mov     a,r1
 4679: 1  1025	13		                rrc     a
 4680: 1  1026	F9		                mov     r1,a
 4681: 1  1027	E8		                mov     a,r0
 4682: 1  1028	13		                rrc     a
 4683: 1  1029	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4684: 1  102A	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4685: 1  102D	D0 F0		                pop     b               ;registers herstellen
 4686: 1  102F	D0 D0		                pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4687: 1  1031	C3		                clr     c               ;N is binnen bereik
 4688: 1  1032	D0 E0		                pop     acc
 4689: 1  1034	22		                ret
 4690: 1
 4691: 1			;*******************************************************************************
 4692: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4693: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4694: 1			; (logical shift)
 4695: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4696: 1			;
 4697: 1			; input:     r3,r2,r1,r0 = acc0
 4698: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4699: 1			;
 4700: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4701: 1			;
 4702: 1			; vernietigt:  niets
 4703: 1			;*******************************************************************************
 4704: 1  1035	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4705: 1  1037	C0 D0		                push    psw
 4706: 1  1039	EC		                mov     a,r4            ;neem aantal shifts
 4707: 1  103A	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4708: 1  103D	40 06		shiftleft1:     jc      shiftleft2
 4709: 1  103F	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4710: 1  1041	D3		                setb    c               ;N buiten bereik
 4711: 1  1042	D0 E0		                pop     acc
 4712: 1  1044	22		                ret
 4713: 1
 4714: 1  1045	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4715: 1  1047	8C F0		                mov     b,r4            ;lusteller initialiseren
 4716: 1  1049	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4717: 1  104A	E8		                mov     a,r0            ;start bij lsb
 4718: 1  104B	33		                rlc     a
 4719: 1  104C	F8		                mov     r0,a
 4720: 1  104D	E9		                mov     a,r1
 4721: 1  104E	33		                rlc     a
 4722: 1  104F	F9		                mov     r1,a
 4723: 1  1050	EA		                mov     a,r2
 4724: 1  1051	33		                rlc     a
 4725: 1  1052	FA		                mov     r2,a
 4726: 1  1053	EB		                mov     a,r3
 4727: 1  1054	33		                rlc     a
 4728: 1  1055	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4729: 1  1056	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4730: 1  1059	D0 F0		                pop     b               ;registers herstellen
 4731: 1  105B	D0 D0		                pop     psw
 4732: 1  105D	C3		                clr     c               ;N is binnen bereik
 4733: 1  105E	D0 E0		                pop     acc
 4734: 1  1060	22		                ret
 4735: 1
 4736: 1			;*******************************************************************************
 4737: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4738: 1			; (arithmetic shift)
 4739: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4740: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4741: 1			; niet van teken!
 4742: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4743: 1			;                       (-2147483648 tot +2147483647)
 4744: 1			;
 4745: 1			; input:     r3,r2,r1,r0 = acc0
 4746: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4747: 1			;
 4748: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4749: 1			;            CY=1 als N>=31
 4750: 1			; vernietigt:  niets
 4751: 1			;*******************************************************************************
 4752: 1  1061	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 4753: 1  1063	C0 D0		                push    psw
 4754: 1  1065	EC		                mov     a,r4            ;neem aantal shifts
 4755: 1  1066	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4756: 1  1069	40 06		s_shiftright1:  jc      s_shiftright2
 4757: 1  106B	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4758: 1  106D	D3		                setb    c               ;N buiten bereik
 4759: 1  106E	D0 E0		                pop     acc
 4760: 1  1070	22		                ret
 4761: 1
 4762: 1  1071	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4763: 1  1073	8C F0		                mov     b,r4            ;lusteller initialiseren
 4764: 1  1075	EB		                mov     a,r3
 4765: 1  1076	20 E7 04	                jb      acc.7,s_shiftright20
 4766: 1  1079	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4767: 1  107B	80 02		                sjmp    s_shiftright3
 4768: 1  107D	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4769: 1
 4770: 1  107F	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4771: 1  1081	EB		                mov     a,r3            ;start bij msb
 4772: 1  1082	13		                rrc     a
 4773: 1  1083	FB		                mov     r3,a
 4774: 1  1084	EA		                mov     a,r2
 4775: 1  1085	13		                rrc     a
 4776: 1  1086	FA		                mov     r2,a
 4777: 1  1087	E9		                mov     a,r1
 4778: 1  1088	13		                rrc     a
 4779: 1  1089	F9		                mov     r1,a
 4780: 1  108A	E8		                mov     a,r0
 4781: 1  108B	13		                rrc     a
 4782: 1  108C	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4783: 1  108D	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4784: 1  1090	D0 F0		                pop     b               ;registers herstellen
 4785: 1  1092	D0 D0		                pop     psw
 4786: 1  1094	C3		                clr     c               ;N is binnen bereik
 4787: 1  1095	D0 E0		                pop     acc
 4788: 1  1097	22		                ret
 4789: 1
 4790: 1			;*******************************************************************************
 4791: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4792: 1			; (arithmetic shift)
 4793: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4794: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 4795: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4796: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4797: 1			;                       (-2147483648 tot +2147483647)
 4798: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4799: 1			; input:     r3,r2,r1,r0 = acc0
 4800: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4801: 1			;
 4802: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4803: 1			;            CY=1 als N>=31
 4804: 1			; vernietigt:  niets
 4805: 1			;*******************************************************************************
 4806: 1  1098	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 4807: 1  109A	C0 D0		                push    psw
 4808: 1  109C	EC		                mov     a,r4            ;neem aantal shifts
 4809: 1  109D	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4810: 1  10A0	40 06		s_shiftleft1:   jc      s_shiftleft2
 4811: 1  10A2	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4812: 1  10A4	D3		                setb    c               ;N buiten bereik
 4813: 1  10A5	D0 E0		                pop     acc
 4814: 1  10A7	22		                ret
 4815: 1
 4816: 1  10A8	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4817: 1  10AA	8C F0		                mov     b,r4            ;lusteller initialiseren
 4818: 1
 4819: 1
 4820: 1
 4821: 1  10AC	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4822: 1  10AD	E8		                mov     a,r0             ;start bij lsb
 4823: 1  10AE	33		                rlc     a
 4824: 1  10AF	F8		                mov     r0,a
 4825: 1  10B0	E9		                mov     a,r1
 4826: 1  10B1	33		                rlc     a
 4827: 1  10B2	F9		                mov     r1,a
 4828: 1  10B3	EA		                mov     a,r2
 4829: 1  10B4	33		                rlc     a
 4830: 1  10B5	FA		                mov     r2,a
 4831: 1  10B6	EB		                mov     a,r3
 4832: 1  10B7	33		                rlc     a
 4833: 1  10B8	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4834: 1  10BA	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4835: 1  10BB	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4836: 1  10BE	D0 F0		                pop     b                ;registers herstellen
 4837: 1  10C0	D0 D0		                pop     psw
 4838: 1  10C2	C3		                clr     c                ;N is binnen bereik
 4839: 1  10C3	D0 E0		                pop     acc
 4840: 1  10C5	22		                ret
 4841: 1
 4842: 1			;*******************************************************************************
 4843: 1			; s_cmp16    (29,5us @16.777216MHz)
 4844: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4845: 1			;
 4846: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4847: 1			;
 4848: 1			; input:     r1,r0 = acc0
 4849: 1			;            r5,r4 = acc1
 4850: 1			;
 4851: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4852: 1			;             f0=0,cy=0  als acc0 > acc1
 4853: 1			;             f0=1 cy=0    als acc1 = acc0
 4854: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4855: 1			; vernietigt:  niets
 4856: 1			;*******************************************************************************
 4857: 1  10C6	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4858: 1  10C8	C0 D0		                push    psw
 4859: 1  10CA	E8		                mov     a,r0
 4860: 1  10CB	C0 E0		                push    acc
 4861: 1  10CD	E9		                mov     a,r1
 4862: 1  10CE	C0 E0		                push    acc
 4863: 1
 4864: 1  10D0	E9		                mov     a,r1            ;neem msb van acc0
 4865: 1  10D1	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4866: 1  10D2	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4867: 1  10D5	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4868: 1			                                        ;negatief is
 4869: 1  10D6	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4870: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4871: 1
 4872: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4873: 1			;acc0>acc1
 4874: 1  10D9	D0 E0		s_cmp160:       pop     acc
 4875: 1  10DB	F9		                mov     r1,a
 4876: 1  10DC	D0 E0		                pop     acc
 4877: 1  10DE	F8		                mov     r0,a
 4878: 1  10DF	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4879: 1  10E1	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4880: 1  10E3	C3		                clr     c               ;geef dit aan in de outputstatus
 4881: 1  10E4	D0 E0		                pop     acc
 4882: 1  10E6	22		                ret
 4883: 1			;acc0<acc1
 4884: 1  10E7	D0 E0		s_cmp161:       pop     acc
 4885: 1  10E9	F9		                mov     r1,a
 4886: 1  10EA	D0 E0		                pop     acc
 4887: 1  10EC	F8		                mov     r0,a
 4888: 1  10ED	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4889: 1  10EF	D3		                setb    c               ;groter dan acc0
 4890: 1  10F0	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4891: 1  10F2	D0 E0		                pop     acc
 4892: 1  10F4	22		                ret
 4893: 1			;gelijk teken, maak verschil
 4894: 1  10F5	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 4895: 1  10F6	E8		                mov     a,r0            ;acc0-acc1
 4896: 1  10F7	9C		                subb    a,r4
 4897: 1  10F8	F8		                mov     r0,a
 4898: 1  10F9	E9		                mov     a,r1
 4899: 1  10FA	9D		                subb    a,r5
 4900: 1  10FB	F9		                mov     r1,a
 4901: 1  10FC	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 4902: 1  10FF	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 4903: 1  1100	60 02		                jz      s_cmp163        ;acc0=acc1
 4904: 1  1102	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 4905: 1			;acc0=acc1
 4906: 1  1104	D0 E0		s_cmp163:       pop     acc
 4907: 1  1106	F9		                mov     r1,a
 4908: 1  1107	D0 E0		                pop     acc
 4909: 1  1109	F8		                mov     r0,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4910: 1  110A	D0 D0		                pop     psw             ;acc0=acc1
 4911: 1  110C	C3		                clr     c               ;geef dit aan in de outputstatus
 4912: 1  110D	D2 D5		                setb    f0
 4913: 1  110F	D0 E0		                pop     acc
 4914: 1  1111	22		                ret
 4915: 1
 4916: 1			;*******************************************************************************
 4917: 1			; cmp16            (19,9us @16.777216MHz)
 4918: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 4919: 1			;
 4920: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 4921: 1			;
 4922: 1			; input:     r1,r0 = acc0
 4923: 1			;            r5,r4 = acc1
 4924: 1			;
 4925: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4926: 1			;             f0=0,cy=0  als acc0 > acc1
 4927: 1			;             f0=1 cy=0    als acc1 = acc0
 4928: 1			;
 4929: 1			; vernietigt:  niets
 4930: 1			;*******************************************************************************
 4931: 1  1112	C0 E0		cmp16:          push    acc             ;bewaar registers
 4932: 1  1114	C0 F0		                push    b
 4933: 1  1116	C0 D0		                push    psw
 4934: 1
 4935: 1  1118	C3		                clr     c               ;vergelijk acc0 met acc1
 4936: 1  1119	E9		                mov     a,r1            ;eerst de msb's
 4937: 1  111A	8D F0		                mov     b,r5            ;test r1-r5
 4938: 1  111C	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4939: 1
 4940: 1  111F	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 4941: 1  1120	8C F0		                mov     b,r4            ;test r0-r4
 4942: 1  1122	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4943: 1			;acc0=acc1
 4944: 1  1125	D0 D0		                pop     psw
 4945: 1  1127	D2 D5		                setb    f0
 4946: 1  1129	C3		                clr     c
 4947: 1  112A	D0 F0		                pop     b
 4948: 1  112C	D0 E0		                pop     acc
 4949: 1  112E	22		                ret
 4950: 1  112F	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 4951: 1			;acc0>acc1
 4952: 1  1131	D0 D0		                pop     psw
 4953: 1  1133	C2 D5		                clr     f0
 4954: 1  1135	C3		                clr     c
 4955: 1  1136	D0 F0		                pop     b
 4956: 1  1138	D0 E0		                pop     acc
 4957: 1  113A	22		                ret
 4958: 1			;acc0<acc1
 4959: 1  113B	D0 D0		cmp162:         pop     psw
 4960: 1  113D	D3		                setb    c
 4961: 1  113E	C2 D5		                clr     f0
 4962: 1  1140	D0 F0		                pop     b
 4963: 1  1142	D0 E0		                pop     acc
 4964: 1  1144	22		                ret
 4965: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4966: 1			;*******************************************************************************
 4967: 1			; s_cmp32        (44,3us @16.777216MHz)
 4968: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 4969: 1			;
 4970: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4971: 1			;                         -2147483648 tot +2147483647
 4972: 1			; input:     r1,r0 = acc0
 4973: 1			;            r5,r4 = acc1
 4974: 1			;
 4975: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4976: 1			;             f0=0,cy=0  als acc0 > acc1
 4977: 1			;             f0=1 cy=0    als acc1 = acc0
 4978: 1			;
 4979: 1			; vernietigt:  niets
 4980: 1			;*******************************************************************************
 4981: 1  1145	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 4982: 1  1147	C0 D0		                push    psw
 4983: 1  1149	E8		                mov     a,r0
 4984: 1  114A	C0 E0		                push    acc
 4985: 1  114C	E9		                mov     a,r1
 4986: 1  114D	C0 E0		                push    acc
 4987: 1  114F	EA		                mov     a,r2
 4988: 1  1150	C0 E0		                push    acc
 4989: 1  1152	EB		                mov     a,r3
 4990: 1  1153	C0 E0		                push    acc
 4991: 1
 4992: 1  1155	EB		                mov     a,r3            ;neem msb van acc0
 4993: 1  1156	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 4994: 1  1157	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 4995: 1  1159	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 4996: 1  115B	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 4997: 1  115C	A2 E7		                mov     c,acc.7         ;negatief is
 4998: 1  115E	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 4999: 1			                                        ;acc1 positief. Dus acc1>acc0
 5000: 1			;acc0>acc1
 5001: 1  1160	D0 E0		s_cmp320:       pop     acc
 5002: 1  1162	FB		                mov     r3,a
 5003: 1  1163	D0 E0		                pop     acc
 5004: 1  1165	FA		                mov     r2,a
 5005: 1  1166	D0 E0		                pop     acc
 5006: 1  1168	F9		                mov     r1,a
 5007: 1  1169	D0 E0		                pop     acc
 5008: 1  116B	F8		                mov     r0,a
 5009: 1  116C	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5010: 1  116E	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5011: 1  1170	C3		                clr     c               ;geef dit aan in de outputstatus
 5012: 1  1171	D0 E0		                pop     acc
 5013: 1  1173	22		                ret
 5014: 1			;acc0<acc1
 5015: 1  1174	D0 E0		s_cmp321:       pop     acc
 5016: 1  1176	FB		                mov     r3,a
 5017: 1  1177	D0 E0		                pop     acc
 5018: 1  1179	FA		                mov     r2,a
 5019: 1  117A	D0 E0		                pop     acc
 5020: 1  117C	F9		                mov     r1,a
 5021: 1  117D	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5022: 1  117F	F8		                mov     r0,a
 5023: 1  1180	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5024: 1  1182	D3		                setb    c               ;groter dan acc0
 5025: 1  1183	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5026: 1  1185	D0 E0		                pop     acc
 5027: 1  1187	22		                ret
 5028: 1			;gelijk teken, maak verschil
 5029: 1  1188	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5030: 1  1189	E8		                mov     a,r0            ;acc0-acc1
 5031: 1  118A	9C		                subb    a,r4
 5032: 1  118B	F8		                mov     r0,a
 5033: 1  118C	E9		                mov     a,r1
 5034: 1  118D	9D		                subb    a,r5
 5035: 1  118E	F9		                mov     r1,a
 5036: 1  118F	EA		                mov     a,r2
 5037: 1  1190	9E		                subb    a,r6
 5038: 1  1191	FA		                mov     r2,a
 5039: 1  1192	EB		                mov     a,r3
 5040: 1  1193	9F		                subb    a,r7
 5041: 1  1194	FB		                mov     r3,a
 5042: 1  1195	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5043: 1  1198	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5044: 1  1199	49		                orl     a,r1
 5045: 1  119A	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5046: 1  119B	60 02		                jz      s_cmp323        ;acc0=acc1
 5047: 1  119D	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5048: 1			;acc0=acc1
 5049: 1  119F	D0 E0		s_cmp323:       pop     acc
 5050: 1  11A1	FB		                mov     r3,a
 5051: 1  11A2	D0 E0		                pop     acc
 5052: 1  11A4	FA		                mov     r2,a
 5053: 1  11A5	D0 E0		                pop     acc
 5054: 1  11A7	F9		                mov     r1,a
 5055: 1  11A8	D0 E0		                pop     acc
 5056: 1  11AA	F8		                mov     r0,a
 5057: 1  11AB	D0 D0		                pop     psw             ;acc0=acc1
 5058: 1  11AD	C3		                clr     c               ;geef dit aan in de outputstatus
 5059: 1  11AE	D2 D5		                setb    f0
 5060: 1  11B0	D0 E0		                pop     acc
 5061: 1  11B2	22		                ret
 5062: 1
 5063: 1			;*******************************************************************************
 5064: 1			; cmp32        (27,14us @16.777216MHz)
 5065: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5066: 1			;
 5067: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5068: 1			;
 5069: 1			; input:     r3,r2,r1,r0 = acc0
 5070: 1			;            r7,r6,r5,r4 = acc1
 5071: 1			;
 5072: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5073: 1			;            f0=0,cy=0  als acc0 > acc1
 5074: 1			;            f0=1 cy=0    als acc1 = acc0
 5075: 1			;
 5076: 1			; vernietigt:  niets
 5077: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5078: 1  11B3	C0 E0		cmp32:          push    acc             ;bewaar registers
 5079: 1  11B5	C0 F0		                push    b
 5080: 1  11B7	C0 D0		                push    psw
 5081: 1
 5082: 1  11B9	C3		                clr     c               ;vergelijk acc0 met acc1
 5083: 1  11BA	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5084: 1  11BB	8F F0		                mov     b,r7            ;test r3-r7
 5085: 1  11BD	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5086: 1
 5087: 1  11C0	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5088: 1  11C1	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5089: 1  11C3	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5090: 1
 5091: 1  11C6	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5092: 1  11C7	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5093: 1  11C9	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5094: 1
 5095: 1  11CC	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5096: 1  11CD	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5097: 1  11CF	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5098: 1			;acc0=acc1
 5099: 1  11D2	D0 D0		                pop     psw
 5100: 1  11D4	D2 D5		                setb    f0
 5101: 1  11D6	C3		                clr     c
 5102: 1  11D7	D0 F0		                pop     b
 5103: 1  11D9	D0 E0		                pop     acc
 5104: 1  11DB	22		                ret
 5105: 1  11DC	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5106: 1			;acc0>acc1, indien cy=0
 5107: 1  11DE	D0 D0		                pop     psw
 5108: 1  11E0	C2 D5		                clr     f0
 5109: 1  11E2	C3		                clr     c
 5110: 1  11E3	D0 F0		                pop     b
 5111: 1  11E5	D0 E0		                pop     acc
 5112: 1  11E7	22		                ret
 5113: 1			;acc0<acc1
 5114: 1  11E8	D0 D0		cmp322:         pop     psw
 5115: 1  11EA	D3		                setb    c
 5116: 1  11EB	C2 D5		                clr     f0
 5117: 1  11ED	D0 F0		                pop     b
 5118: 1  11EF	D0 E0		                pop     acc
 5119: 1  11F1	22		                ret
 5120: 1
 5121: 1
 5122: 1			;*******************************************************************************
 5123: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5124: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5125: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5126: 1			; adres zitten.
 5127: 1			;
 5128: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5129: 1			;
 5130: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5131: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5132: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5133: 1			;                    01 = tabel in codegeheugen, items op 16bit basis

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5134: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5135: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5136: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5137: 1			;                cy = 0  lookup is ok
 5138: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5139: 1			; vernietigt:  niets
 5140: 1			;*******************************************************************************
 5141: 1  11F2	C0 E0		table_lu:       push    acc             ;bewaren registers
 5142: 1  11F4	C0 D0		                push    psw
 5143: 1  11F6	C0 82		                push    dpl
 5144: 1  11F8	C0 83		                push    dph
 5145: 1
 5146: 1  11FA	A2 D5		                mov     c,f0            ;byte of word items?
 5147: 1  11FC	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5148: 1			;tabel met byte items
 5149: 1  11FE	E5 82		                mov     a,dpl           ;datapointer plus index
 5150: 1  1200	28		                add     a,r0
 5151: 1  1201	F5 82		                mov     dpl,a
 5152: 1  1203	E5 83		                mov     a,dph
 5153: 1  1205	39		                addc    a,r1
 5154: 1  1206	F5 83		                mov     dph,a
 5155: 1  1208	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5156: 1  120A	A2 D1		                mov     c,f1            ;code of datageheugen?
 5157: 1  120C	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5158: 1
 5159: 1			;bytetabel in codegeheugen
 5160: 1  120E	74 00		                mov     a,#0
 5161: 1  1210	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5162: 1  1211	F8		                mov     r0,a            ;en stop in acc0
 5163: 1  1212	79 00		                mov     r1,#0
 5164: 1  1214	02 12 73	                ljmp    table_lu4       ;en klaar
 5165: 1
 5166: 1			;bytetabel in datageheugen
 5167: 1  1217	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5168: 1  1218	F8		                mov     r0,a            ;en stop in acc0
 5169: 1  1219	79 00		                mov     r1,#0
 5170: 1  121B	02 12 73	                ljmp    table_lu4       ;en klaar
 5171: 1
 5172: 1  121E	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5173: 1  1220	D0 82		                pop     dpl
 5174: 1  1222	D0 D0		                pop     psw
 5175: 1  1224	D3		                setb    c              ;foutstatus teruggeven!
 5176: 1  1225	D0 E0		                pop     acc
 5177: 1  1227	22		                ret
 5178: 1
 5179: 1			;tabel met word items
 5180: 1  1228	E8		table_lu2:      mov     a,r0            ;index op stack
 5181: 1  1229	C0 E0		                push    acc
 5182: 1  122B	E9		                mov     a,r1
 5183: 1  122C	C0 E0		                push    acc
 5184: 1
 5185: 1  122E	C3		                clr      c              ;index maal 2 (word items)
 5186: 1  122F	E8		                mov     a,r0
 5187: 1  1230	33		                rlc     a
 5188: 1  1231	F8		                mov     r0,a
 5189: 1  1232	E9		                mov     a,r1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5190: 1  1233	33		                rlc     a
 5191: 1  1234	F9		                mov     r1,a
 5192: 1
 5193: 1  1235	E5 82		                mov     a,dpl           ;datapointer plus index
 5194: 1  1237	28		                add     a,r0
 5195: 1  1238	F5 82		                mov     dpl,a
 5196: 1  123A	E5 83		                mov     a,dph
 5197: 1  123C	39		                addc    a,r1
 5198: 1  123D	F5 83		                mov     dph,a
 5199: 1
 5200: 1  123F	D0 E0		                pop     acc             ;index weer van stack
 5201: 1  1241	F9		                mov     r1,a
 5202: 1  1242	D0 E0		                pop     acc
 5203: 1  1244	F8		                mov     r0,a
 5204: 1
 5205: 1  1245	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5206: 1  1247	A2 D1		                mov     c,f1            ;code of datageheugen?
 5207: 1  1249	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5208: 1			;wordtabel in codegeheugen
 5209: 1  124B	74 00		                mov     a,#0
 5210: 1  124D	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5211: 1  124E	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5212: 1  124F	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5213: 1  1251	24 01		                add     a,#1
 5214: 1  1253	F5 82		                mov     dpl,a
 5215: 1  1255	E5 83		                mov     a,dph
 5216: 1  1257	34 00		                addc    a,#0
 5217: 1  1259	F5 83		                mov     dph,a
 5218: 1  125B	74 00		                mov     a,#0
 5219: 1  125D	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5220: 1  125E	F9		                mov     r1,a            ;msb in acc0 stoppen
 5221: 1  125F	80 12		                sjmp    table_lu4        ;en klaar
 5222: 1			;wordtabel    in datageheugen
 5223: 1  1261	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5224: 1  1262	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5225: 1  1263	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5226: 1  1265	24 01		                add     a,#1
 5227: 1  1267	F5 82		                mov     dpl,a
 5228: 1  1269	E5 83		                mov     a,dph
 5229: 1  126B	34 00		                addc    a,#0
 5230: 1  126D	F5 83		                mov     dph,a
 5231: 1  126F	74 00		                mov     a,#0
 5232: 1  1271	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5233: 1  1272	F9		                mov     r1,a            ;msb in acc0 stoppen
 5234: 1			                                        ;en klaar
 5235: 1
 5236: 1  1273	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5237: 1  1275	D0 82		                pop     dpl
 5238: 1  1277	D0 D0		                pop     psw
 5239: 1  1279	D0 E0		                pop     acc
 5240: 1  127B	22		                ret
 5241: 1
 5242: 1
 5243: 1
 5244: 1			;*******************************************************************************
 5245: 1			; Cordic        (2,11ms @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5246: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5247: 1			; waarde (2's complement) opgegeven hoek.
 5248: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5249: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5250: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5251: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5252: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5253: 1			; als geschaalde getallen ter beschikking komen.
 5254: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5255: 1			;
 5256: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5257: 1			;
 5258: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5259: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5260: 1			;            cy = 0 : hoek binnen bereik
 5261: 1			;            cy = 1 : error, hoek buiten bereik
 5262: 1			;            nauwkeurigheid: 12 msbits
 5263: 1			; vernietigt:  niets
 5264: 1			;*******************************************************************************
 5265: 1  127C	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5266: 1  127E	C0 D0		                push    psw
 5267: 1  1280	C0 83		                push    dph
 5268: 1  1282	C0 82		                push    dpl
 5269: 1  1284	C0 F0		                push    b
 5270: 1
 5271: 1  1286	EF		                mov     a,r7
 5272: 1  1287	C0 E0		                push    acc
 5273: 1  1289	EE		                mov     a,r6
 5274: 1  128A	C0 E0		                push    acc
 5275: 1  128C	ED		                mov     a,r5
 5276: 1  128D	C0 E0		                push    acc
 5277: 1  128F	EC		                mov     a,r4
 5278: 1  1290	C0 E0		                push    acc
 5279: 1
 5280: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5281: 1			;en niet groter dan pi/2 radialen (6478h)
 5282: 1  1292	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5283: 1  1294	7D 64		                mov     r5,#64h
 5284: 1  1296	12 11 12	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5285: 1  1299	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5286: 1  129C	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5287: 1  129E	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5288: 1
 5289: 1  12A0	C2 A0		cordic000:      clr     p2.0
 5290: 1  12A2	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5291: 1  12A4	7D 9B		                mov     r5,#9bh
 5292: 1  12A6	12 11 12	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5293: 1  12A9	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5294: 1  12AC	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5295: 1  12AE	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5296: 1
 5297: 1  12B0	C2 A1		cordic_error:   clr     p2.1
 5298: 1  12B2	02 13 64	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5299: 1
 5300: 1			;Hoek is -pi/2 resultaat gekend
 5301: 1  12B5	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5302: 1  12B7	7A 00		                mov     r2,#000h
 5303: 1  12B9	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5304: 1  12BB	78 00		                mov     r0,#000h
 5305: 1  12BD	C3		                clr     c
 5306: 1  12BE	02 13 64	                ljmp    cordic40        ;en klaar
 5307: 1			;hoek is +pi/2 resultaat gekend
 5308: 1  12C1	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5309: 1  12C3	7A FF		                mov     r2,#0ffh
 5310: 1  12C5	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5311: 1  12C7	78 00		                mov     r0,#000h
 5312: 1  12C9	C3		                clr     c
 5313: 1  12CA	02 13 64	                ljmp    cordic40        ;en klaar
 5314: 1
 5315: 1  12CD	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5316: 1  12CF	7D 00		                mov     r5,#00h
 5317: 1  12D1	12 11 12	                lcall   cmp16            ;vergelijk de hoeken
 5318: 1  12D4	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5319: 1  12D7	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5320: 1			;hoek is 0, resultaat gekend
 5321: 1  12D9	C2 A7		cordic_nul:     clr     p2.7
 5322: 1  12DB	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5323: 1  12DD	7A 00		                mov     r2,#000h
 5324: 1  12DF	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5325: 1  12E1	78 FF		                mov     r0,#0ffh
 5326: 1  12E3	C3		                clr     c
 5327: 1  12E4	02 13 64	                ljmp    cordic40        ;en klaar
 5328: 1
 5329: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5330: 1  12E7	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5331: 1  12E8	C0 E0		                push    acc
 5332: 1  12EA	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5333: 1  12EB	C0 E0		                push    acc
 5334: 1
 5335: 1  12ED	7B 00		                mov     r3,#00h         ;y=0
 5336: 1  12EF	7A 00		                mov     r2,#00h
 5337: 1  12F1	79 26		                mov     r1,#026h        ;x = K * 2^14
 5338: 1  12F3	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5339: 1
 5340: 1  12F5	75 F0 00	                mov     b,#00h          ;loopteller=0
 5341: 1
 5342: 1  12F8	90 13 BC	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5343: 1
 5344: 1  12FB	EB		cordic1:        mov     a,r3            ;sry=y
 5345: 1  12FC	FF		                mov     r7,a
 5346: 1  12FD	EA		                mov     a,r2
 5347: 1  12FE	FE		                mov     r6,a
 5348: 1  12FF	E9		                mov     a,r1            ;srx=x
 5349: 1  1300	FD		                mov     r5,a
 5350: 1  1301	E8		                mov     a,r0
 5351: 1  1302	FC		                mov     r4,a
 5352: 1
 5353: 1  1303	12 13 83	                lcall   cordic5          ;srx en sry >> loopteller
 5354: 1
 5355: 1  1306	D0 E0		                pop     acc
 5356: 1  1308	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5357: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5358: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5359: 1  130B	C3		                clr     c
 5360: 1  130C	E8		                mov     a,r0            ;bereken x=x-sry
 5361: 1  130D	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5362: 1  130E	F8		                mov     r0,a
 5363: 1  130F	E9		                mov     a,r1
 5364: 1  1310	9F		                subb    a,r7
 5365: 1  1311	F9		                mov     r1,a
 5366: 1
 5367: 1  1312	EA		                mov     a,r2            ;bereken y=y+srx
 5368: 1  1313	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5369: 1  1314	FA		                mov     r2,a
 5370: 1  1315	EB		                mov     a,r3
 5371: 1  1316	3D		                addc    a,r5
 5372: 1  1317	FB		                mov     r3,a
 5373: 1
 5374: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5375: 1  1318	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5376: 1  131A	93		                movc    a,@a+dptr
 5377: 1  131B	A3		                inc     dptr
 5378: 1  131C	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5379: 1  131D	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5380: 1  131F	C3		                clr     c               ;verklein de hoek
 5381: 1  1320	9C		                subb    a,r4
 5382: 1  1321	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5383: 1  1323	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5384: 1
 5385: 1  1325	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5386: 1  1327	93		                movc    a,@a+dptr
 5387: 1  1328	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5388: 1  1329	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5389: 1  132A	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5390: 1  132C	9D		                subb    a,r5            ;verklein de hoek
 5391: 1  132D	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5392: 1
 5393: 1			;loopteller incrementeren en testen op einde van de iteratie
 5394: 1  132F	05 F0		cordic2:        inc     b               ;loopteller++
 5395: 1  1331	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5396: 1  1333	65 F0		                xrl     a,b             ;test op gelijkheid
 5397: 1  1335	60 28		                jz      cordic4         ;ja klaar!
 5398: 1  1337	02 12 FB	                ljmp    cordic1         ;nee, nog even verder...
 5399: 1
 5400: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5401: 1  133A	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5402: 1  133B	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5403: 1  133C	F8		                mov     r0,a
 5404: 1  133D	E9		                mov     a,r1
 5405: 1  133E	3F		                addc    a,r7
 5406: 1  133F	F9		                mov     r1,a
 5407: 1
 5408: 1  1340	C3		                clr     c
 5409: 1  1341	EA		                mov     a,r2            ;bereken y=y-srx
 5410: 1  1342	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5411: 1  1343	FA		                mov     r2,a
 5412: 1  1344	EB		                mov     a,r3
 5413: 1  1345	9D		                subb    a,r5

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5414: 1  1346	FB		                mov     r3,a
 5415: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5416: 1  1347	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5417: 1  1349	93		                movc    a,@a+dptr
 5418: 1  134A	A3		                inc     dptr
 5419: 1  134B	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5420: 1  134C	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5421: 1  134E	2C		                add     a,r4            ;vergroot de hoek
 5422: 1  134F	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5423: 1  1351	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5424: 1
 5425: 1  1353	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5426: 1  1355	93		                movc    a,@a+dptr
 5427: 1  1356	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5428: 1  1357	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5429: 1  1358	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5430: 1  135A	3D		                addc    a,r5            ;vergroot de hoek
 5431: 1  135B	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5432: 1
 5433: 1  135D	80 D0		                sjmp    cordic2
 5434: 1
 5435: 1  135F	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5436: 1  1361	D0 E0		                pop     acc             ;dummy hoek van stack
 5437: 1  1363	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5438: 1
 5439: 1  1364	D0 E0		cordic40:       pop     acc
 5440: 1  1366	FC		                mov     r4,a
 5441: 1  1367	D0 E0		                pop     acc
 5442: 1  1369	FD		                mov     r5,a
 5443: 1  136A	D0 E0		                pop     acc
 5444: 1  136C	FE		                mov     r6,a
 5445: 1  136D	D0 E0		                pop     acc
 5446: 1  136F	FF		                mov     r7,a
 5447: 1  1370	D0 F0		                pop     b
 5448: 1  1372	D0 82		                pop     dpl
 5449: 1  1374	D0 83		                pop     dph
 5450: 1  1376	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5451: 1  1378	D0 D0		                pop     psw
 5452: 1  137A	D0 E0		                pop     acc
 5453: 1  137C	22		                ret
 5454: 1
 5455: 1  137D	D0 D0		cordic41:       pop     psw
 5456: 1  137F	D3		                setb    c
 5457: 1  1380	D0 E0		                pop     acc
 5458: 1  1382	22		                ret
 5459: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5460: 1			;over het aantal posities aangegeven in het B register.
 5461: 1  1383	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5462: 1  1385	74 00		                mov     a,#0            ;test of loopteller=0
 5463: 1  1387	65 F0		                xrl     a,b
 5464: 1  1389	60 2E		                jz      cordic52        ;klaar
 5465: 1
 5466: 1  138B	ED		                mov     a,r5            ;test teken van srx
 5467: 1  138C	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5468: 1  138F	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5469: 1  1391	80 02		                sjmp    cordic50

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5470: 1  1393	D2 D5		cordic5a:       setb    f0
 5471: 1  1395	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5472: 1  1397	ED		                mov     a,r5            ;eerst de msb
 5473: 1  1398	13		                rrc     a
 5474: 1  1399	FD		                mov     r5,a
 5475: 1  139A	EC		                mov     a,r4            ;dan de lsb
 5476: 1  139B	13		                rrc     a
 5477: 1  139C	FC		                mov     r4,a
 5478: 1  139D	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5479: 1  13A0	D0 F0		                pop     b               ;haal de loopteller van stack
 5480: 1  13A2	C0 F0		                push    b               ;en bewaar hem weer
 5481: 1  13A4	EF		                mov     a,r7            ;test teken van sry
 5482: 1  13A5	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5483: 1  13A8	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5484: 1  13AA	80 02		                sjmp    cordic51
 5485: 1  13AC	D2 D5		cordic5b:       setb    f0
 5486: 1  13AE	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5487: 1  13B0	EF		                mov     a,r7            ;eerst de msb
 5488: 1  13B1	13		                rrc     a
 5489: 1  13B2	FF		                mov     r7,a
 5490: 1  13B3	EE		                mov     a,r6            ;dan de lsb
 5491: 1  13B4	13		                rrc     a
 5492: 1  13B5	FE		                mov     r6,a
 5493: 1  13B6	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5494: 1
 5495: 1  13B9	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5496: 1  13BB	22		                ret
 5497: 1
 5498: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5499: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5500: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5501: 1  13BC	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5502: 1  13BE	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5503: 1  13C0	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5504: 1  13C2	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5505: 1  13C4	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5506: 1  13C6	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5507: 1  13C8	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5508: 1  13CA	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5509: 1  13CC	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5510: 1  13CE	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5511: 1  13D0	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5512: 1  13D2	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5513: 1  13D4	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5514: 1  13D6	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5515: 1  13D8	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5516: 1
 5517: 1			endif        ;einde van aduc_math
 5518: 1			;******************************************************************************
 5519: 1
 5520: 1			ifdef        aduc_adc    ;A/D conversie routines
 5521: 1			;*******************************************************************************
 5522: 1			; ADuCADC_mide
 5523: 1			; Geschreven door [dp] op 5/1/2014
 5524: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5525: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5526: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5527: 1			; bron instellen.
 5528: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5529: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5530: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5531: 1			;
 5532: 1			;*******************************************************************************
 5533: 1
 5534: 1			;*******************************************************************************
 5535: 1			; adc_init
 5536: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5537: 1			; -  4 track&hold clockperiodes
 5538: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5539: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5540: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5541: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5542: 1			;
 5543: 1			; input: R0 =  0  : Interne referentiebron
 5544: 1			;        R0 <> 0  : Externe referentiebron
 5545: 1			;
 5546: 1			; Deze routine vernietigt niets
 5547: 1			;*******************************************************************************
 5548: 1  13DA	C0 E0		adc_init:       push    acc                 ;registers op stack
 5549: 1  13DC	C0 D0		                push    psw
 5550: 1  13DE	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5551: 1  13E1	E8		                mov     a,r0                ;welke referentiebron?
 5552: 1  13E2	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5553: 1  13E4	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5554: 1  13E7	D0 D0		adc_init1:      pop     psw
 5555: 1  13E9	D0 E0		                pop     acc
 5556: 1  13EB	22		                ret
 5557: 1
 5558: 1			;*******************************************************************************
 5559: 1			; adc_single
 5560: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5561: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5562: 1			; (2's complement) formaat van de meetwaarde.
 5563: 1			; _____________________________________________________________
 5564: 1			; resolutie  |     unsigned      |           signed            |
 5565: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5566: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5567: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5568: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5569: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5570: 1			; _____________________________________________________________
 5571: 1			;
 5572: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5573: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5574: 1			; De ingangsparameter wordt doorgegeven via R0.
 5575: 1			;
 5576: 1			; input:
 5577: 1			;             7    6    5    4    3    2    1    0
 5578: 1			;           _______________________________________
 5579: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5580: 1			;           ---------------------------------------
 5581: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5582: 1			;                                         1000b = temp.sensor
 5583: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5584: 1			;                                   10b = 12 bits, 11b = 12 bits
 5585: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5586: 1			;
 5587: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5588: 1			;         cy=0  bij conversie ok
 5589: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5590: 1			;
 5591: 1			; Deze routine vernietigt niets
 5592: 1			;*******************************************************************************
 5593: 1  13EC	C0 E0		adc_single:     push    acc                 ;registers op stack
 5594: 1  13EE	C0 D0		                push    psw
 5595: 1  13F0	C0 F0		                push    b
 5596: 1  13F2	E8		                mov     a,r0                ;neem inputparameter
 5597: 1  13F3	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5598: 1  13F5	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5599: 1  13F8	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5600: 1  13FA	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5601: 1  13FC	D2 DC		                setb    sconv               ;start een meting
 5602: 1  13FE	E8		                mov     a,r0                ;neem parameter terug
 5603: 1  13FF	A2 E6		                mov     c,acc.6
 5604: 1  1401	92 D5		                mov     f0,c                ;bewaar format bit
 5605: 1  1403	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5606: 1  1406	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5607: 1  1409	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5608: 1  140C	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5609: 1			;*******************************************************************************
 5610: 1			;8 bit resultaat gevraagd
 5611: 1			;*******************************************************************************
 5612: 1  140F	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5613: 1  1411	C4		                swap    a                    ;swap nibbles
 5614: 1  1412	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5615: 1  1414	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5616: 1  1416	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5617: 1  1418	C4		                swap    a
 5618: 1  1419	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5619: 1  141B	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5620: 1			;8 bit unsigned formaat
 5621: 1  141E	79 00		                mov     r1,#00h              ;unsigned
 5622: 1  1420	F8		                mov     r0,a
 5623: 1  1421	80 63		                sjmp    adc_single42
 5624: 1			;8 bit signed formaat
 5625: 1  1423	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5626: 1  1426	24 80		                add     a,#80h                ;negatief getal van maken
 5627: 1  1428	F8		                mov     r0,a
 5628: 1  1429	79 FF		                mov     r1,#0ffh
 5629: 1  142B	80 59		                sjmp    adc_single42
 5630: 1  142D	C3		adc_single20:   clr     c
 5631: 1  142E	94 80		                subb    a,#80h                ;positief deel verkleinen
 5632: 1  1430	F8		                mov     r0,a
 5633: 1  1431	79 00		                mov     r1,#00h
 5634: 1  1433	80 51		                sjmp    adc_single42
 5635: 1
 5636: 1  1435	02 14 8E	adc_single21:   ljmp    adc_single43
 5637: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5638: 1			;10 bit resultaat gevraagd
 5639: 1			;*******************************************************************************
 5640: 1  1438	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5641: 1  143A	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5642: 1  143C	03		                rr     a              ;naar msbits roteren
 5643: 1  143D	03		                rr     a
 5644: 1  143E	F5 F0		                mov    b,a            ;even bewaren
 5645: 1  1440	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5646: 1  1442	03		                rr     a              ;twee plaatsen opschuiven
 5647: 1  1443	03		                rr     a
 5648: 1  1444	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5649: 1  1446	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5650: 1  1448	F5 F0		                mov    b,a            ;low byte even bewaren
 5651: 1  144A	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5652: 1  144C	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5653: 1  144E	03		                rr     a               ;en op hun plaats schuiven
 5654: 1  144F	03		                rr     a
 5655: 1  1450	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5656: 1			;10 bit unsigned formaat
 5657: 1  1453	F9		                mov    r1,a            ;unsigned
 5658: 1  1454	A8 F0		                mov    r0,b
 5659: 1  1456	80 2E		                sjmp   adc_single42
 5660: 1			;10 bit signed formaat
 5661: 1  1458	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5662: 1  145B	24 FE		                add    a,#0feh             ;negatief getal van maken
 5663: 1  145D	F9		                mov    r1,a
 5664: 1  145E	A8 F0		                mov    r0,b
 5665: 1  1460	80 24		                sjmp   adc_single42
 5666: 1  1462	C3		adc_single31:   clr    c
 5667: 1  1463	94 02		                subb   a,#02h              ;positief deel verkleinen
 5668: 1  1465	F9		                mov    r1,a
 5669: 1  1466	A8 F0		                mov    r0,b
 5670: 1  1468	80 1C		                sjmp   adc_single42
 5671: 1
 5672: 1			;*******************************************************************************
 5673: 1			;12 bit resultaat gevraagd
 5674: 1			;*******************************************************************************
 5675: 1  146A	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5676: 1  146C	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5677: 1  146E	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5678: 1			;12 bit unsigned formaat
 5679: 1  1471	A8 D9		                mov    r0,adcdatal           ;unsigned
 5680: 1  1473	F9		                mov    r1,a
 5681: 1  1474	80 10		                sjmp   adc_single42
 5682: 1			;12 bit signed formaat
 5683: 1  1476	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5684: 1  1479	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5685: 1  147B	F9		                mov    r1,a
 5686: 1  147C	A8 D9		                mov    r0,adcdatal
 5687: 1  147E	80 06		                sjmp   adc_single42
 5688: 1  1480	C3		adc_single41:   clr    c
 5689: 1  1481	94 08		                subb   a,#08h                ;positief deel verkleinen
 5690: 1  1483	F9		                mov    r1,a
 5691: 1  1484	A8 D9		                mov    r0,adcdatal
 5692: 1  1486	D0 F0		adc_single42:   pop    b
 5693: 1  1488	D0 D0		                pop    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5694: 1  148A	C3		                clr    c
 5695: 1  148B	D0 E0		                pop    acc
 5696: 1  148D	22		                ret
 5697: 1
 5698: 1  148E	D0 F0		adc_single43:   pop    b
 5699: 1  1490	D0 D0		                pop    psw
 5700: 1  1492	D3		                setb   c
 5701: 1  1493	D0 E0		                pop    acc
 5702: 1  1495	22		                ret
 5703: 1
 5704: 1			endif        ;einde van aduc_adc
 5705: 1			;*******************************************************************************
 5706: 1
 5707: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5708: 1			;******************************************************************************
 5709: 1			; ADuCKEY_mide.inc
 5710: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5711: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5712: 1			;
 5713: 1			;     V2.0      V1.1
 5714: 1			;                           |   |   |   |
 5715: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5716: 1			;                   |       |   |   |   |
 5717: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5718: 1			;                   |       |   |   |   |
 5719: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5720: 1			;                   |       |   |   |   |
 5721: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5722: 1			;                   |       |   |   |   |
 5723: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5724: 1			;                   |           |   |   |
 5725: 1			;     P0.5      P3.5|-K2--------|   |   |
 5726: 1			;                   |               |   |
 5727: 1			;     P0.6      P3.6|-K3------------|   |
 5728: 1			;                   |                   |
 5729: 1			;     P0.7      P3.7|-K4----------------|
 5730: 1			;
 5731: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5732: 1			; gebruikt.
 5733: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5734: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5735: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5736: 1			; en als ingang wordt aangeboden.
 5737: 1			;
 5738: 1			;                                  ___                 ___
 5739: 1			;                     ____________|   |  |------------|   |
 5740: 1			;              ____  |   ____     |   |  |   ____     |   |
 5741: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5742: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5743: 1			; '1'= toets  | cl |    | cl |              | cl |
 5744: 1			;  ingedrukt  |____|    |____|              |____|
 5745: 1			;                |         |                   |
 5746: 1			;      CLOCK     |         |                   |
 5747: 1			;         _______|_________|___________________|
 5748: 1			;
 5749: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5750: 1			;
 5751: 1			;              MAP0      MAP1                 MAP2         MAP3
 5752: 1			;
 5753: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5754: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5755: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5756: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5757: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 5758: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5759: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 5760: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5761: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5762: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5763: 1			;
 5764: 1			;          MAP0    MAP1          MAP2    MAP3
 5765: 1			;         _______________       _______________
 5766: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 5767: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5768: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5769: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5770: 1			;
 5771: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5772: 1			;         | | | | | | | |       | | | | | | | |
 5773: 1			;        K K K K K K K K       K K K K K K K K
 5774: 1			;         O O O O O O O O       O O O O O O O O
 5775: 1			;         L L L L L L L L       L L L L L L L L
 5776: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5777: 1			;
 5778: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 5779: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 5780: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5781: 1			; van bitmaps van voor naar achter.
 5782: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5783: 1			;
 5784: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5785: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5786: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5787: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 5788: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5789: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5790: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5791: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5792: 1			; deze toetswaarde weer.
 5793: 1			;
 5794: 1			;
 5795: 1			;
 5796: 1			;******************************************************************************
 5797: 1
 5798: 1
 5799: 1			;******************************************************************************
 5800: 1			; key_init
 5801: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 5802: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5803: 1			; input: niets
 5804: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 5805: 1			;         (map0,map1,map2,map3 =0)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5806: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5807: 1			; Deze routine vernietigt niets
 5808: 1			;******************************************************************************
 5809: 1
 5810: 1  1496	C0 E0		Key_init:       push    acc          ;bewaar registers
 5811: 1  1498	C0 D0		                push    psw
 5812: 1  149A	E8		                mov     a,r0
 5813: 1  149B	C0 E0		                push    acc
 5814: 1  149D	E9		                mov     a,r1
 5815: 1  149E	C0 E0		                push    acc
 5816: 1  14A0	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5817: 1  14A2	79 09		                mov     r1,#9        ;9 bytes in de maps
 5818: 1  14A4	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5819: 1  14A6	08		                inc     r0           ;volgende byte nemen
 5820: 1  14A7	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5821: 1  14A9	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5822: 1  14AB	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 5823: 1  14AD	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5824: 1  14B0	D0 E0		                pop     acc          ;herstel registers
 5825: 1  14B2	F9		                mov     r1,a
 5826: 1  14B3	D0 E0		                pop     acc
 5827: 1  14B5	F8		                mov     r0,a
 5828: 1  14B6	D0 D0		                pop     psw
 5829: 1  14B8	D0 E0		                pop     acc
 5830: 1  14BA	22		                ret                    ;terug naar caller
 5831: 1			;******************************************************************************
 5832: 1
 5833: 1
 5834: 1			;******************************************************************************
 5835: 1			; toets_flank
 5836: 1			; Deze routine detecteert de indrukflank van een toets.
 5837: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5838: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5839: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5840: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5841: 1			; minder dan 20ms duurt.
 5842: 1			; input : niets
 5843: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5844: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5845: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5846: 1			;
 5847: 1			; Deze routine vernietigt geen registers.
 5848: 1			;******************************************************************************
 5849: 1  14BB	C0 E0		Toets_flank:    push    acc
 5850: 1  14BD	C0 D0		                push    psw
 5851: 1  14BF	12 14 D9	                lcall   Keyscan
 5852: 1  14C2	12 15 55	                lcall   Keyedge
 5853: 1  14C5	D0 D0		                pop     psw
 5854: 1  14C7	D0 E0		                pop     acc
 5855: 1  14C9	22		                ret
 5856: 1
 5857: 1			;******************************************************************************
 5858: 1			; toets_ingedrukt
 5859: 1			; Deze routine detecteert een ingedrukte toets.
 5860: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5861: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5862: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5863: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5864: 1			; minder dan 20ms duurt.
 5865: 1			; input : niets
 5866: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5867: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5868: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5869: 1			;
 5870: 1			; Deze routine vernietigt geen registers.
 5871: 1			;******************************************************************************
 5872: 1  14CA	C0 E0		Toets_ingedrukt:push    acc
 5873: 1  14CC	C0 D0		                push    psw
 5874: 1  14CE	12 14 D9	                lcall   Keyscan
 5875: 1  14D1	12 15 3C	                lcall   Keydown
 5876: 1  14D4	D0 D0		                pop     psw
 5877: 1  14D6	D0 E0		                pop     acc
 5878: 1  14D8	22		                ret
 5879: 1
 5880: 1
 5881: 1			;******************************************************************************
 5882: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5883: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5884: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5885: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5886: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5887: 1			; zoals aangegeven in het blokschema van het algorithme.
 5888: 1			; input : niets
 5889: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5890: 1			;         ervan weergeven
 5891: 1			;
 5892: 1			; Deze routine vernietigt geen registers
 5893: 1			;******************************************************************************
 5894: 1
 5895: 1  14D9	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 5896: 1  14DB	C0 D0		                push    psw
 5897: 1  14DD	C0 F0		                push    b
 5898: 1  14DF	E8		                mov     a,r0
 5899: 1  14E0	C0 E0		                push    acc
 5900: 1  14E2	E9		                mov     a,r1
 5901: 1  14E3	C0 E0		                push    acc
 5902: 1  14E5	EA		                mov     a,r2
 5903: 1  14E6	C0 E0		                push    acc
 5904: 1  14E8	EE		                mov     a,r6
 5905: 1  14E9	C0 E0		                push    acc
 5906: 1
 5907: 1  14EB	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 5908: 1  14ED	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 5909: 1  14F0	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 5910: 1  14F2	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 5911: 1
 5912: 1  14F4			Scanloop:
 5913: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 5914: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 5915: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 5916: 1			                mov     p0.0,c
 5917: 1			                mov     c,acc.1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5918: 1			                mov     p0.1,c
 5919: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 5920: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 5921: 1			endif
 5922: 1
 5923: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 5924: 1  14F4	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 5925: 1			                                      ;een rij-lijn
 5926: 1			endif
 5927: 1
 5928: 1			; Eerst de flipflops implementeren.
 5929: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 5930: 1			; te lezen van de kolomlijnen
 5931: 1  14F6	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 5932: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5933: 1  14F7	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 5934: 1  14F8	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 5935: 1  14F9	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 5936: 1  14FA	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 5937: 1  14FC	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 5938: 1  14FD	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 5939: 1  14FE	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 5940: 1  1500	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 5941: 1  1501	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 5942: 1  1502	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 5943: 1  1503	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 5944: 1  1504	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 5945: 1  1506	FA		                mov     r2,a          ;even bewaren in register
 5946: 1
 5947: 1
 5948: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 5949: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 5950: 1			                                      ;poort3 kolomlijnen
 5951: 1			endif
 5952: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 5953: 1  1507	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 5954: 1			                                     ;poort0 kolomlijnen
 5955: 1			endif
 5956: 1  1509	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 5957: 1  150A	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 5958: 1  150C	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 5959: 1  150D	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 5960: 1
 5961: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 5962: 1			; Nu volgen de logische functies uit het blokschema
 5963: 1
 5964: 1  150E	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 5965: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5966: 1  150F	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 5967: 1  1510	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 5968: 1  1511	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 5969: 1  1512	54 0F		                anl     a,#00001111b ;low nibble houden
 5970: 1  1514	FA		                mov     r2,a         ;resultaat bewaren
 5971: 1  1515	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 5972: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 5973: 1  1516	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5974: 1  1517	C4		                swap    a            ;map2 naar low nibble schuiven
 5975: 1  1518	5A		                anl     a,r2         ;combineren met output vorige and poort
 5976: 1  1519	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 5977: 1  151B	FA		                mov     r2,a         ;even bewaren
 5978: 1  151C	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 5979: 1  151D	54 F0		                anl     a,#11110000b ;map2 overhouden
 5980: 1  151F	4A		                orl     a,r2         ;en combineren met nieuwe map3
 5981: 1  1520	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 5982: 1
 5983: 1			; We gaan nu de volgende lijn scannen
 5984: 1
 5985: 1  1521	EE		                mov     a,r6         ;scanpatroon nemen
 5986: 1  1522	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 5987: 1  1523	FE		                mov     r6,a         ;scanpatroon bewaren
 5988: 1
 5989: 1  1524	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 5990: 1  1525	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 5991: 1  1526	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 5992: 1  1529	D0 E0		                pop     acc          ;herstel registers
 5993: 1  152B	FE		                mov     r6,a
 5994: 1  152C	D0 E0		                pop     acc
 5995: 1  152E	FA		                mov     r2,a
 5996: 1  152F	D0 E0		                pop     acc
 5997: 1  1531	F9		                mov     r1,a
 5998: 1  1532	D0 E0		                pop     acc
 5999: 1  1534	F8		                mov     r0,a
 6000: 1  1535	D0 F0		                pop     b
 6001: 1  1537	D0 D0		                pop     psw
 6002: 1  1539	D0 E0		                pop     acc
 6003: 1  153B	22		                ret                    ;terug naar caller
 6004: 1			;******************************************************************************
 6005: 1
 6006: 1
 6007: 1			;******************************************************************************
 6008: 1			; Keydown, Keyedge (twee entry's)
 6009: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6010: 1			;
 6011: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6012: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6013: 1			; Er zijn twee detectie-modes:
 6014: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6015: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6016: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6017: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6018: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6019: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6020: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6021: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6022: 1			;
 6023: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6024: 1			; (flankdetectie mode).
 6025: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6026: 1			; (toets ingedrukt mode).
 6027: 1			;
 6028: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6029: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6030: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6031: 1			; geldt voor een standaard 4x4 keypad.
 6032: 1			;
 6033: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6034: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6035: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6036: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6037: 1			;
 6038: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6039: 1			; output: key = gedetecteerde toets
 6040: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6041: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6042: 1			;
 6043: 1			; Deze routine vernietigt geen registers
 6044: 1			;******************************************************************************
 6045: 1
 6046: 1			;'Toets ingedrukt mode' enty van de routine
 6047: 1  153C	C0 E0		Keydown:        push    acc            ;registers bewaren
 6048: 1  153E	C0 D0		                push    psw
 6049: 1  1540	C0 F0		                push    b
 6050: 1  1542	C0 82		                push    dpl
 6051: 1  1544	C0 83		                push    dph
 6052: 1  1546	E8		                mov     a,r0
 6053: 1  1547	C0 E0		                push    acc
 6054: 1  1549	E9		                mov     a,r1
 6055: 1  154A	C0 E0		                push    acc
 6056: 1  154C	EA		                mov     a,r2
 6057: 1  154D	C0 E0		                push    acc
 6058: 1  154F	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6059: 1  1551	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6060: 1  1553	80 15		                sjmp    Key1           ;continue
 6061: 1
 6062: 1			;'Flankdetectiemode' entry van de routine
 6063: 1  1555	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6064: 1  1557	C0 D0		                push    psw
 6065: 1  1559	C0 F0		                push    b
 6066: 1  155B	C0 82		                push    dpl
 6067: 1  155D	C0 83		                push    dph
 6068: 1  155F	E8		                mov     a,r0
 6069: 1  1560	C0 E0		                push    acc
 6070: 1  1562	E9		                mov     a,r1
 6071: 1  1563	C0 E0		                push    acc
 6072: 1  1565	EA		                mov     a,r2
 6073: 1  1566	C0 E0		                push    acc
 6074: 1  1568	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6075: 1  156A	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6076: 1  156C	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6077: 1  156E	E6		                mov     a,@r0         ;map entry ophalen
 6078: 1  156F	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6079: 1  1572	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6080: 1  1574	C4		                swap    a             ;map1 en map0 omwisselen
 6081: 1  1575	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6082: 1  1577	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6083: 1  1578	33		                rlc     a             ;kolombit testen
 6084: 1  1579	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6085: 1  157B	33		                rlc    a              ;nee, dan verder roteren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6086: 1  157C	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6087: 1  157E	08		                inc     r0            ;rijpointer in maps verder zetten
 6088: 1  157F	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6089: 1  1581	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6090: 1
 6091: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6092: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6093: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6094: 1
 6095: 1  1583	1A		toetsin:        dec     r2            ;rij-1
 6096: 1  1584	19		                dec     r1            ;kolom-1
 6097: 1  1585	EA		                mov     a,r2          ;neem rij-1
 6098: 1  1586	23		                rl      a             ;(rij-1)x2
 6099: 1  1587	23		                rl      a              ;(rij-1)x4
 6100: 1  1588	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6101: 1  1589	90 15 A7	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6102: 1  158C	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6103: 1  158D	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6104: 1  158F	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6105: 1  1591	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6106: 1  1593	D0 E0		                pop     acc            ;herstellen registers
 6107: 1  1595	FA		                mov     r2,a
 6108: 1  1596	D0 E0		                pop     acc
 6109: 1  1598	F9		                mov     r1,a
 6110: 1  1599	D0 E0		                pop     acc
 6111: 1  159B	F8		                mov     r0,a
 6112: 1  159C	D0 83		                pop     dph
 6113: 1  159E	D0 82		                pop     dpl
 6114: 1  15A0	D0 F0		                pop     b
 6115: 1  15A2	D0 D0		                pop     psw
 6116: 1  15A4	D0 E0		                pop     acc
 6117: 1  15A6	22		                ret                    ;terug naar caller
 6118: 1			;******************************************************************************
 6119: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6120: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6121: 1
 6122: 1  15A7	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6123: 1  15A8	30		                db    '0'    ;kolom2@rij4 toets
 6124: 1  15A9	23		                db    '#'    ;kolom3@rij4 toets
 6125: 1  15AA	44		                db    'D'    ;kolom4@rij4 toets
 6126: 1
 6127: 1  15AB	37		                db    '7'    ;kolom1@rij3 toets
 6128: 1  15AC	38		                db    '8'    ;kolom2@rij3 toets
 6129: 1  15AD	39		                db    '9'    ;kolom3@rij3 toets
 6130: 1  15AE	43		                db    'C'    ;kolom4@rij3 toets
 6131: 1
 6132: 1  15AF	34		                db    '4'    ;kolom1@rij2 toets
 6133: 1  15B0	35		                db    '5'    ;kolom2@rij2 toets
 6134: 1  15B1	36		                db    '6'    ;kolom3@rij2 toets
 6135: 1  15B2	42		                db    'B'    ;kolom4@rij2 toets
 6136: 1
 6137: 1  15B3	31		                db    '1'    ;kolom1@rij1 toets
 6138: 1  15B4	32		                db    '2'    ;kolom2@rij1 toets
 6139: 1  15B5	33		                db    '3'    ;kolom3@rij1 toets
 6140: 1  15B6	41		                db    'A'    ;kolom4@rij1 toets
 6141: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6142: 1			;******************************************************************************
 6143: 1			; switch_init
 6144: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6145: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6146: 1			; input : niets
 6147: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6148: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6149: 1			;
 6150: 1			; Deze routine vernietigt niets
 6151: 1			;******************************************************************************
 6152: 1
 6153: 1  15B7	C0 E0		switch_init:    push    acc
 6154: 1  15B9	C0 D0		                push    psw
 6155: 1  15BB	C0 F0		                push    b
 6156: 1  15BD	E8		                mov     a,r0         ;bewaar registers
 6157: 1  15BE	C0 E0		                push    acc
 6158: 1
 6159: 1  15C0	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6160: 1  15C2	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6161: 1  15C5	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6162: 1  15C7	08		                inc     r0           ;volgende byte nemen
 6163: 1  15C8	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6164: 1  15CB	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6165: 1  15CD	C2 03		                clr     negvalid
 6166: 1  15CF	C2 04		                clr     posvalid
 6167: 1
 6168: 1  15D1	D0 E0		                pop     acc
 6169: 1  15D3	F8		                mov     r0,a
 6170: 1  15D4	D0 F0		                pop     b
 6171: 1  15D6	D0 D0		                pop     psw
 6172: 1  15D8	D0 E0		                pop     acc
 6173: 1  15DA	22		                ret                   ;terug naar caller
 6174: 1
 6175: 1			;******************************************************************************
 6176: 1			; read_switch
 6177: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6178: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6179: 1			; Deze routine werkt volgens onderstaand blokschema.
 6180: 1			;
 6181: 1			;                                  ___                    ___
 6182: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6183: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6184: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6185: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6186: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6187: 1			;             |____|    |____|              |____|  ----o| 3 |
 6188: 1			;                |         |                   |      |  |   |
 6189: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6190: 1			;         _______*_________*___________________|       --|___|---- posedge
 6191: 1			;
 6192: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6193: 1			;                              (swvalid-flag)
 6194: 1			;            switch1   switch2    debounce      closed
 6195: 1			;
 6196: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6197: 1			; die telkens tegelijk worden gelezen (8 schakelaars).

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6198: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6199: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6200: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6201: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6202: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6203: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6204: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6205: 1			; een detector voor positieve flanken (posedge).
 6206: 1			;
 6207: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6208: 1			;         bij aduc832v1.1 :
 6209: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6210: 1			;         bij aduc832v2.0 :
 6211: 1			;         als f0=0 dan: schakelaars op p0
 6212: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6213: 1			;
 6214: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6215: 1			;         geactualiseerd.
 6216: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6217: 1			;                  schakelaars weergeeft
 6218: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6219: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6220: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6221: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6222: 1			;                  werd gedetecteerd op een schakelaar.
 6223: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6224: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6225: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6226: 1			;                  werd gedetecteerd op een schakelaar.
 6227: 1			;
 6228: 1			;
 6229: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6230: 1			; en flags te initialiseren.
 6231: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6232: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6233: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6234: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6235: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6236: 1			; bijhorende flag resetten.
 6237: 1			;
 6238: 1			; Deze routine vernietigt niets
 6239: 1			;******************************************************************************
 6240: 1  15DB	C0 E0		read_switch:    push    acc            ;registers bewaren
 6241: 1  15DD	C0 D0		                push    psw
 6242: 1  15DF	C0 F0		                push    b
 6243: 1			;Flipflops uitvoeren is bytes doorschuiven
 6244: 1  15E1	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6245: 1  15E4	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6246: 1
 6247: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6248: 1			                clr      a
 6249: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6250: 1			                mov     acc.0,c
 6251: 1			                mov     c,p0.1
 6252: 1			                mov     acc.1,c
 6253: 1			                mov     b,a            ;even bewaren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6254: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6255: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6256: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6257: 1			endif        ;einde aduc832_v1_1
 6258: 1
 6259: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6260: 1  15E7	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6261: 1  15EA	E5 80		                mov     a,p0           ;lees de schakelaars
 6262: 1  15EC	80 04		                sjmp    lowlogic
 6263: 1  15EE	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6264: 1  15F0	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6265: 1			endif        ;einde aduc832_2_0
 6266: 1
 6267: 1  15F2	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6268: 1  15F3	F5 40		                mov     switch1,a      ;en sample opslaan
 6269: 1
 6270: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6271: 1
 6272: 1  15F5	E5 40		                mov     a,switch1      ;neem laatste sample
 6273: 1  15F7	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6274: 1  15F9	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6275: 1  15FB	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6276: 1			;negatieve flankdetectie
 6277: 1  15FD	E5 43		                mov     a,closed      ;neem 3de FF
 6278: 1  15FF	F4		                cpl     a             ;complementeer
 6279: 1  1600	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6280: 1  1602	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6281: 1  1604	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6282: 1  1606	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6283: 1  1608	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6284: 1			;positieve flankdetectie
 6285: 1  160A	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6286: 1  160C	F4		                cpl     a             ;complementeer
 6287: 1  160D	55 43		                anl     a,closed      ;combineer met 3de FF
 6288: 1  160F	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6289: 1  1611	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6290: 1  1613	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6291: 1  1615	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6292: 1  1617	D0 D0		                pop     psw
 6293: 1  1619	D0 E0		                pop     acc
 6294: 1  161B	22		                ret
 6295: 1
 6296: 1			endif    ;einde van aduc_key
 6297: 1
 6298: 1
 6299:				end





                     register banks used:  ---

                     no errors



ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111





ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 148
ACC				  DATA	      E0	  67
ADCCON1				  DATA	      EF	  70
ADCCON2				  DATA	      D8	  63
ADCCON3				  DATA	      F5	  76
ADCDATAH			  DATA	      DA	  65
ADCDATAL			  DATA	      D9	  64
ADCGAINH			  DATA	      F4	  75
ADCGAINL			  DATA	      F3	  74
ADCI				  BIT	      DF	 157
ADCOFSH				  DATA	      F2	  73
ADCOFSL				  DATA	      F1	  72
ADC_INIT			  CODE	    13DA	5548
ADC_INIT1			  CODE	    13E7	5554
ADC_SINGLE			  CODE	    13EC	5593
ADC_SINGLE1			  CODE	    13F8	5599
ADC_SINGLE2			  CODE	    1423	5625
ADC_SINGLE20			  CODE	    142D	5630
ADC_SINGLE21			  CODE	    1435	5636
ADC_SINGLE3			  CODE	    1438	5640
ADC_SINGLE30			  CODE	    1458	5661
ADC_SINGLE31			  CODE	    1462	5666
ADC_SINGLE4			  CODE	    146A	5675
ADC_SINGLE40			  CODE	    1476	5683
ADC_SINGLE41			  CODE	    1480	5688
ADC_SINGLE42			  CODE	    1486	5692
ADC_SINGLE43			  CODE	    148E	5698
ADD16				  CODE	    0931	2900
ADD161				  CODE	    0945	2916
ADD32				  CODE	    0983	2997
ADD321				  CODE	    099D	3021
ADUC832_V2_0			  NUMBER    0001	 206
ADUC_ADC			  NUMBER    0001	 227
ADUC_I2C			  NUMBER    0001	 224
ADUC_KEY			  NUMBER    0001	 228
ADUC_LCD			  NUMBER    0001	 221
ADUC_MATH			  NUMBER    0001	 226
ADUC_SIO			  NUMBER    0001	 225
ASCBINTRANS			  CODE	    05E1	1953
ASCBINTRANS1			  CODE	    05F6	1964
ASCBINTRANS2			  CODE	    05F5	1963
ASCBINTRANS3			  CODE	    05E9	1957
ASCBINTRANS4			  CODE	    05F2	1961
ASCCTR				  CODE	    05B8	1899
ASCCTR1				  CODE	    05BB	1900
ASCCTR2				  CODE	    05C0	1902
ASCCTR3				  CODE	    05C4	1905
ASCII1				  CODE	    05F7	1975

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII2				  CODE	    05FC	1989
ASCII21				  CODE	    060E	1998
ASCII4				  CODE	    0611	2012
ASCII41				  CODE	    0620	2019
B				  DATA	      F0	  71
BACKLIGHT			  BIT	      F6	 373
BACKSP				  NUMBER    0008	1598
BARCHARS			  CODE	    02A1	 999
BAREINDE			  CODE	    02C8	1042
BARLCD				  CODE	    023C	 920
BARLCD1				  CODE	    0277	 954
BARLCD2				  CODE	    027E	 959
BARLCD3				  CODE	    0287	 967
BARLCD4				  CODE	    028C	 971
BARLCDE				  CODE	    0294	 976
BARLCD_1			  CODE	    0257	 936
BATRANS				  CODE	    05D3	1935
BATRANS1			  CODE	    05D8	1937
BATRANS2			  CODE	    05DC	1939
BCDHEX16			  CODE	    0696	2214
BCDHEX161			  CODE	    06A4	2222
BCDHEX1611			  CODE	    06AD	2226
BCDHEX1612			  CODE	    06B7	2231
BCDHEX1613			  CODE	    06C0	2235
BCDHEX162			  CODE	    070B	2289
BCDHEX8				  CODE	    0621	2105
BCDHEX81			  CODE	    062F	2113
BCDHEX811			  CODE	    0638	2117
BCDHEX82			  CODE	    065A	2141
BDELETE				  CODE	    0593	1865
BDELETE1			  CODE	    05A1	1873
BDELETE2			  CODE	    05B4	1884
BDELETE3			  CODE	    05A5	1875
BEEP				  NUMBER    0007	1599
BLANK				  NUMBER    0020	1593
BUILD				  CODE	    02C9	1074
BUILD1				  CODE	    02E1	1116
BUILD2				  CODE	    02F0	1123
BUILD3				  CODE	    02E4	1117
BUILD_ADR			  CODE	    02D7	1111
BUZZER				  BIT	      F7	 374
CAP2				  BIT	      C8	 134
CCONV				  BIT	      DD	 155
CFG832				  DATA	      AF	  36
CGRAM				  NUMBER    0040	 389
CHIPID				  DATA	      C2	  50
CLEARDISP			  NUMBER    0001	 379
CLOSED				  NUMBER    0043	 293
CMP16				  CODE	    1112	4931
CMP161				  CODE	    112F	4950
CMP162				  CODE	    113B	4959
CMP32				  CODE	    11B3	5078
CMP321				  CODE	    11DC	5105
CMP322				  CODE	    11E8	5114
CNT2				  BIT	      C9	 135
CORDIC				  CODE	    127C	5265

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CORDIC0				  CODE	    12E7	5330
CORDIC00			  CODE	    12CD	5315
CORDIC000			  CODE	    12A0	5289
CORDIC1				  CODE	    12FB	5344
CORDIC2				  CODE	    132F	5394
CORDIC3				  CODE	    133A	5401
CORDIC4				  CODE	    135F	5435
CORDIC40			  CODE	    1364	5439
CORDIC41			  CODE	    137D	5455
CORDIC5				  CODE	    1383	5461
CORDIC50			  CODE	    1395	5471
CORDIC51			  CODE	    13AE	5486
CORDIC52			  CODE	    13B9	5495
CORDIC5A			  CODE	    1393	5470
CORDIC5B			  CODE	    13AC	5485
CORDIC_ATAN			  CODE	    13BC	5501
CORDIC_ERROR			  CODE	    12B0	5297
CORDIC_MIN90			  CODE	    12B5	5301
CORDIC_NUL			  CODE	    12D9	5321
CORDIC_PLUS90			  CODE	    12C1	5308
CPHA				  BIT	      FA	 172
CPOL				  BIT	      FB	 173
CR				  NUMBER    000D	1596
CS0				  BIT	      D8	 150
CS1				  BIT	      D9	 151
CS2				  BIT	      DA	 152
CS3				  BIT	      DB	 153
CURSATHOM			  NUMBER    0002	 380
CURSOROFF			  NUMBER    000C	 385
CURSORONB			  NUMBER    000F	 386
CURSORONN			  NUMBER    000E	 387
CY				  BIT	      D7	 149
D0				  BIT	      ED	 159
D0EN				  BIT	      EB	 158
D1				  BIT	      EF	 161
D1EN				  BIT	      EE	 160
DAC0H				  DATA	      FA	  80
DAC0L				  DATA	      F9	  79
DAC1H				  DATA	      FC	  82
DAC1L				  DATA	      FB	  81
DACCON				  DATA	      FD	  83
DCON				  DATA	      E8	  68
DDRAM				  NUMBER    0080	 390
DEBOUNCE			  NUMBER    0042	 292
DELAY2MS			  CODE	    02FE	1140
DELAY2MS1			  CODE	    0304	1143
DELAY60US			  CODE	    030F	1160
DELAY60US1			  CODE	    0321	1174
DELAY60US2			  CODE	    031F	1173
DIPSWITCH			  NUMBER    0001	 246
DISPDPTR			  CODE	    04E9	1707
DISPDPTRLCD			  CODE	    0103	 595
DISPLAYOF			  NUMBER    0008	 384
DISPLAYON			  NUMBER    0001	 383
DIV16				  CODE	    0BF8	3683
DIV160				  CODE	    0C06	3694

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DIV161				  CODE	    0C24	3717
DIV162				  CODE	    0C37	3733
DIV163				  CODE	    0C53	3758
DIV164				  CODE	    0C65	3776
DIV32				  CODE	    0CA2	3847
DIV320				  CODE	    0CB2	3860
DIV320A				  CODE	    0CBC	3871
DIV320B				  CODE	    0CDA	3899
DIV320C				  CODE	    0CFF	3927
DIV322				  CODE	    0D24	3961
DIV323				  CODE	    0D6E	4037
DIV324				  CODE	    0DA0	4087
DIV8				  CODE	    0BB5	3610
DIV81				  CODE	    0BCD	3626
DMA				  BIT	      DE	 156
DMAH				  DATA	      D3	  60
DMAL				  DATA	      D2	  59
DMAP				  DATA	      D4	  61
DPCON				  DATA	      A7	  32
DPH				  DATA	      83	   9
DPL				  DATA	      82	   8
DPP				  DATA	      84	  10
E				  BIT	      F1	 371
EA				  BIT	      AF	 109
EADC				  BIT	      AE	 108
EADRH				  DATA	      C7	  52
EADRL				  DATA	      C6	  51
ECON				  DATA	      B9	  44
EDATA1				  DATA	      BC	  45
EDATA2				  DATA	      BD	  46
EDATA3				  DATA	      BE	  47
EDATA4				  DATA	      BF	  48
EINDE				  CODE	    0013	 190
ENDBUF				  NUMBER    007F	1605
ENTRYMODE			  NUMBER    0006	 382
ES				  BIT	      AC	 106
ET0				  BIT	      A9	 103
ET1				  BIT	      AB	 105
ET2				  BIT	      AD	 107
EX0				  BIT	      A8	 102
EX1				  BIT	      AA	 104
EXEN2				  BIT	      CB	 137
EXF2				  BIT	      CE	 140
F0				  BIT	      D5	 147
F1				  BIT	      D1	 143
FF				  NUMBER    000C	1595
FUNCTIONS			  NUMBER    0028	 388
HEXBCD16			  CODE	    0714	2325
HEXBCD161			  CODE	    0722	2332
HEXBCD16_U			  CODE	    0717	2326
HEXBCD8				  CODE	    0663	2166
HEXBCD81			  CODE	    066D	2171
HEXBCD82			  CODE	    0672	2173
HEXBCD83			  CODE	    067C	2179
HEXBUF2LCD			  CODE	    01DF	 861
HEXBUF2LCD1			  CODE	    0203	 877

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBUF2LCDE			  CODE	    021A	 888
HEXBUFTXT			  CODE	    0228	 897
HOUR				  DATA	      A5	  30
HTHSEC				  DATA	      A2	  27
I2CADD				  DATA	      9B	  22
I2CCON				  DATA	      E8	  69
I2CDAT				  DATA	      9A	  21
I2CI				  BIT	      E8	 162
I2CINBYTEA1			  CODE	    036B	1282
I2CINBYTEACK			  CODE	    0364	1279
I2CINBYTEN1			  CODE	    038C	1306
I2CINBYTENACK			  CODE	    0385	1303
I2CINIT				  CODE	    0329	1224
I2CM				  BIT	      EB	 165
I2COUTBYTE			  CODE	    0344	1256
I2COUTBYTE1			  CODE	    034B	1259
I2CPCF8574			  NUMBER    0040	1215
I2CPCF8574A			  NUMBER    0070	1216
I2CRCVDATA			  CODE	    03E6	1408
I2CRCVDATA1			  CODE	    0405	1426
I2CRCVDATA2			  CODE	    040E	1430
I2CRCVDATA3			  CODE	    0415	1435
I2CRCVERROR			  CODE	    0421	1443
I2CRS				  BIT	      EA	 164
I2CSENDDATA			  CODE	    03A6	1346
I2CSENDDATA1			  CODE	    03C5	1363
I2CSENDERROR			  CODE	    03DB	1376
I2CSTART			  CODE	    0332	1233
I2CSTOP				  CODE	    033B	1242
I2CTX				  BIT	      E9	 163
IE				  DATA	      A8	  33
IE0				  BIT	      89	  85
IE1				  BIT	      8B	  87
IEIP2				  DATA	      A9	  34
INBUFA				  CODE	    0558	1822
INBUFA1				  CODE	    056F	1839
INBUFA2				  CODE	    055E	1825
INBUFA3				  CODE	    057C	1845
INBUFA4				  CODE	    0575	1841
INBUFA5				  CODE	    058F	1853
INBUFA6				  CODE	    0585	1849
INBUFA7				  CODE	    0577	1842
INBYTE				  CODE	    0538	1790
INBYTE1				  CODE	    0555	1802
INCHAR				  CODE	    0530	1774
INITLCD				  CODE	    0033	 405
INITLCD1			  CODE	    0044	 422
INITSIO				  CODE	    0496	1619
INITSIO1			  CODE	    049F	1623
INITSIOE			  CODE	    04B5	1640
INT0				  BIT	      B2	 112
INT1				  BIT	      B3	 113
INTVAL				  DATA	      A6	  31
IP				  DATA	      B8	  43
ISPI				  BIT	      FF	 177
IT0				  BIT	      88	  84

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
IT1				  BIT	      8A	  86
KEY				  NUMBER    0038	 279
KEY1				  CODE	    156A	6075
KEY2				  CODE	    1577	6082
KEYDOWN				  CODE	    153C	6047
KEYEDGE				  CODE	    1555	6063
KEYFLAGS			  NUMBER    0020	 254
KEYINIT1			  CODE	    14A4	5818
KEYMAP				  NUMBER    0030	 273
KEYMODE				  BIT	      01	 258
KEYSCAN				  CODE	    14D9	5895
KEYVALID			  BIT	      00	 256
KEY_INIT			  CODE	    1496	5810
KOLOMLOOP			  CODE	    1579	6084
LCDBUZOFF			  CODE	    0485	1564
LCDBUZON			  CODE	    0478	1548
LCDLIGHTOFF			  CODE	    046B	1532
LCDLIGHTON			  CODE	    045E	1515
LCDPORT				  NUMBER    00F0	 370
LCDTOPORT			  CODE	    0445	1489
LF				  NUMBER    000A	1597
LOWLOGIC			  CODE	    15F2	6267
LOWUPTR				  CODE	    05C6	1919
LOWUPTR1			  CODE	    05C9	1920
LOWUPTR2			  CODE	    05D2	1924
LOWUPTR3			  CODE	    05CE	1922
MAGSIG16			  CODE	    0783	2437
MAGSIG16A			  CODE	    0794	2446
MAGSIG16ACC1			  CODE	    07A3	2470
MAGSIG16ACC1A			  CODE	    07B4	2479
MAGSIG16ACC1B			  CODE	    07AF	2476
MAGSIG16ACC1C			  CODE	    07BE	2487
MAGSIG16B			  CODE	    078F	2443
MAGSIG16C			  CODE	    079E	2454
MAGSIG32			  CODE	    07C3	2504
MAGSIG32A			  CODE	    07D4	2513
MAGSIG32ACC1			  CODE	    07ED	2549
MAGSIG32ACC1A			  CODE	    07FE	2558
MAGSIG32ACC1B			  CODE	    07F9	2555
MAGSIG32ACC1C			  CODE	    0812	2575
MAGSIG32B			  CODE	    07CF	2510
MAGSIG32C			  CODE	    07E8	2530
MAGSIG8				  CODE	    074F	2378
MAGSIG8A			  CODE	    0760	2387
MAGSIG8ACC1			  CODE	    0769	2408
MAGSIG8ACC1A			  CODE	    077A	2417
MAGSIG8ACC1B			  CODE	    0775	2414
MAGSIG8ACC1C			  CODE	    077E	2421
MAGSIG8B			  CODE	    075B	2384
MAGSIG8C			  CODE	    0764	2391
MAP01PTR			  NUMBER    0030	 275
MAP23PTR			  NUMBER    0034	 278
MATRIX				  NUMBER    0001	 244
MCO				  BIT	      ED	 167
MDE				  BIT	      EE	 168
MDI				  BIT	      EC	 166

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MDO				  BIT	      EF	 169
MIN				  DATA	      A4	  29
MUL16				  CODE	    0A6D	3269
MUL16ACC1			  CODE	    0AD2	3358
MUL16_10			  CODE	    0E91	4345
MUL16_100			  CODE	    0EC6	4393
MUL16_I_PI			  CODE	    0E2E	4249
MUL16_I_SQRT2			  CODE	    0E70	4314
MUL16_PI			  CODE	    0E0D	4218
MUL16_SQRT2			  CODE	    0E4F	4281
MUL816				  CODE	    0B5A	3505
MULDIV				  CODE	    0DD1	4160
MULDIV1				  CODE	    0DE1	4172
NEGEDGE				  NUMBER    0044	 294
NEGVALID			  BIT	      03	 263
NOKEY				  CODE	    1591	6105
OUTBYTE				  CODE	    04D5	1687
OUTBYTELCD			  CODE	    00F2	 576
OUTC				  CODE	    019F	 782
OUTCHAR				  CODE	    04B9	1654
OUTCHAR1			  CODE	    04BB	1655
OUTCHARLCD			  CODE	    0091	 491
OUTCHARLCD1			  CODE	    0098	 494
OUTCHARLCD2			  CODE	    00A2	 498
OUTCHARLCD2_0			  CODE	    009D	 496
OUTCHARLCD3			  CODE	    00AB	 508
OUTCHARLCD4			  CODE	    00B2	 512
OUTCHARLCD5			  CODE	    00B9	 516
OUTCHARLCD6			  CODE	    00C0	 520
OUTCHARLCD7			  CODE	    00C7	 524
OUTCHARLCD8			  CODE	    00CE	 532
OUTCHARLCD9			  CODE	    00D3	 540
OUTCHARLCDE			  CODE	    00D6	 541
OUTD				  CODE	    0165	 704
OUTHNIBC			  CODE	    01B5	 824
OUTHNIBD			  CODE	    0175	 752
OUTMSGA				  CODE	    04FC	1726
OUTMSGA1			  CODE	    0511	1737
OUTMSGA2			  CODE	    0504	1730
OUTMSGALCD			  CODE	    0116	 619
OUTMSGALCD1			  CODE	    011E	 626
OUTMSGALCDE			  CODE	    0129	 636
OUTNIB				  CODE	    04C1	1668
OUTNIBLCD			  CODE	    00DB	 555
OUTNIBLCD1			  CODE	    00E6	 560
OUTNIBLCDE			  CODE	    00EA	 562
OV				  BIT	      D2	 144
P				  BIT	      D0	 142
P0				  DATA	      80	   6
P1				  DATA	      90	  18
P2				  DATA	      A0	  25
P3				  DATA	      B0	  37
PADC				  BIT	      BE	 124
PCF8574A			  NUMBER    0001	1218
PCON				  DATA	      87	  11
PLLCON				  DATA	      D7	  62

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
PORTTOLCD			  CODE	    042C	1461
POSEDGE				  NUMBER    0045	 295
POSVALID			  BIT	      04	 265
PRE0				  BIT	      C4	 130
PRE1				  BIT	      C5	 131
PRE2				  BIT	      C6	 132
PRE3				  BIT	      C7	 133
PS				  BIT	      BC	 122
PSI				  BIT	      BF	 125
PSMCON				  DATA	      DF	  66
PSW				  DATA	      D0	  58
PT0				  BIT	      B9	 119
PT1				  BIT	      BB	 121
PT2				  BIT	      BD	 123
PWM0H				  DATA	      B2	  39
PWM0L				  DATA	      B1	  38
PWM1H				  DATA	      B4	  41
PWM1L				  DATA	      B3	  40
PWMCON				  DATA	      AE	  35
PX0				  BIT	      B8	 118
PX1				  BIT	      BA	 120
RB8				  BIT	      9A	  96
RCAP2H				  DATA	      CB	  55
RCAP2L				  DATA	      CA	  54
RCLK				  BIT	      CD	 139
RD				  BIT	      B7	 117
READ_PORT3			  CODE	    15EE	6263
READ_SWITCH			  CODE	    15DB	6240
READ_SWITCH1			  CODE	    160A	6285
READ_SWITCH2			  CODE	    1615	6291
REGTOLCD			  CODE	    0132	 656
REGTOLCD1			  CODE	    0143	 666
REGTOLCD2			  CODE	    0151	 676
REN				  BIT	      9C	  98
RI				  BIT	      98	  94
RIJLOOP				  CODE	    156C	6076
RS				  BIT	      F0	 372
RS0				  BIT	      D3	 145
RS1				  BIT	      D4	 146
RXD				  BIT	      B0	 110
SBUF				  DATA	      99	  20
SCANLOOP			  CODE	    14F4	5912
SCON				  DATA	      98	  19
SCONV				  BIT	      DC	 154
SEC				  DATA	      A3	  28
SHIFTLEFT1			  CODE	    103D	4708
SHIFTLEFT2			  CODE	    1045	4714
SHIFTLEFT3			  CODE	    1049	4716
SHIFTLEFT32			  CODE	    1035	4704
SHIFTRIGHT1			  CODE	    1011	4663
SHIFTRIGHT2			  CODE	    1019	4669
SHIFTRIGHT3			  CODE	    101D	4671
SHIFTRIGHT32			  CODE	    1009	4659
SIGMAG16ACC0			  CODE	    0849	2648
SIGMAG16ACC0A			  CODE	    0858	2657
SIGMAG16ACC1			  CODE	    0869	2683

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SIGMAG16ACC1A			  CODE	    0878	2692
SIGMAG16ACC1H			  CODE	    0889	2718
SIGMAG16ACC1HA			  CODE	    0898	2727
SIGMAG32ACC0			  CODE	    08A9	2755
SIGMAG32ACC0A			  CODE	    08B8	2764
SIGMAG32ACC1			  CODE	    08D3	2799
SIGMAG32ACC1A			  CODE	    08E2	2808
SIGMAG8ACC0			  CODE	    0817	2592
SIGMAG8ACC0A			  CODE	    0826	2600
SIGMAG8ACC1			  CODE	    0830	2620
SIGMAG8ACC1A			  CODE	    083F	2628
SM0				  BIT	      9F	 101
SM1				  BIT	      9E	 100
SM2				  BIT	      9D	  99
SP				  DATA	      81	   7
SPE				  BIT	      FD	 175
SPH				  DATA	      B7	  42
SPICON				  DATA	      F8	  78
SPIDAT				  DATA	      F7	  77
SPIM				  BIT	      FC	 174
SPR0				  BIT	      F8	 170
SPR1				  BIT	      F9	 171
SQRT32				  CODE	    0F1C	4465
SQRT320				  CODE	    0F43	4487
SQRT321				  CODE	    0F48	4489
SQRT322				  CODE	    0FAB	4571
SQRT323				  CODE	    0FB1	4575
SQRT324				  CODE	    0FD4	4599
SQRT3240			  CODE	    0FCF	4597
SQRT325				  CODE	    0FD7	4601
STACK_INIT			  NUMBER    007F	 180
START				  CODE	    0003	 184
STRTBUF				  NUMBER    0054	1604
SUB16				  CODE	    09E3	3107
SUB161				  CODE	    09F8	3124
SUB32				  CODE	    0A4A	3224
SUB321				  CODE	    0A65	3249
SWINIT				  CODE	    15C5	6161
SWITCH1				  NUMBER    0040	 290
SWITCH2				  NUMBER    0041	 291
SWITCHMAP			  NUMBER    0040	 289
SWITCH_INIT			  CODE	    15B7	6153
SWVALID				  BIT	      02	 261
S_ADD16				  CODE	    08FD	2845
S_ADD161			  CODE	    0921	2871
S_ADD162			  CODE	    0925	2873
S_ADD163			  CODE	    092B	2878
S_ADD32				  CODE	    094D	2938
S_ADD321			  CODE	    0975	2969
S_ADD322			  CODE	    0977	2970
S_ADD323			  CODE	    097D	2975
S_CMP16				  CODE	    10C6	4857
S_CMP160			  CODE	    10D9	4874
S_CMP161			  CODE	    10E7	4884
S_CMP162			  CODE	    10F5	4894
S_CMP163			  CODE	    1104	4906

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_CMP32				  CODE	    1145	4981
S_CMP320			  CODE	    1160	5001
S_CMP321			  CODE	    1174	5015
S_CMP322			  CODE	    1188	5029
S_CMP323			  CODE	    119F	5049
S_DIV16				  CODE	    0BD5	3648
S_DIV161			  CODE	    0BE3	3658
S_DIV32				  CODE	    0C7D	3810
S_DIV321			  CODE	    0C8D	3822
S_DIV8				  CODE	    0BA3	3587
S_DIV81				  CODE	    0BB4	3593
S_MAC16				  CODE	    0B81	3547
S_MAC161			  CODE	    0B9D	3567
S_MUL16				  CODE	    0B33	3449
S_MUL16ACC1			  CODE	    0B40	3467
S_MUL816			  CODE	    0B4D	3486
S_MULDIV			  CODE	    0DAC	4116
S_MULDIV1			  CODE	    0DBC	4128
S_SHIFTLEFT1			  CODE	    10A0	4810
S_SHIFTLEFT2			  CODE	    10A8	4816
S_SHIFTLEFT3			  CODE	    10AC	4821
S_SHIFTLEFT32			  CODE	    1098	4806
S_SHIFTRIGHT1			  CODE	    1069	4756
S_SHIFTRIGHT2			  CODE	    1071	4762
S_SHIFTRIGHT20			  CODE	    107D	4768
S_SHIFTRIGHT3			  CODE	    107F	4770
S_SHIFTRIGHT32			  CODE	    1061	4752
S_SQRT32			  CODE	    0FF2	4632
S_SQRT321			  CODE	    1000	4640
S_SUB16				  CODE	    09A5	3043
S_SUB161			  CODE	    09D3	3078
S_SUB162			  CODE	    09D7	3080
S_SUB163			  CODE	    09DD	3085
S_SUB32				  CODE	    0A00	3146
S_SUB321			  CODE	    0A3C	3196
S_SUB322			  CODE	    0A3E	3197
S_SUB323			  CODE	    0A44	3202
T0				  BIT	      B4	 114
T1				  BIT	      B5	 115
T2				  BIT	      90	  92
T2CON				  DATA	      C8	  53
T2EX				  BIT	      91	  93
T3CON				  DATA	      9E	  23
T3FD				  DATA	      9D	  24
TABLE_LU			  CODE	    11F2	5141
TABLE_LU1			  CODE	    1217	5167
TABLE_LU2			  CODE	    1228	5180
TABLE_LU3			  CODE	    1261	5223
TABLE_LU4			  CODE	    1273	5236
TABLE_LU_10			  CODE	    121E	5172
TB8				  BIT	      9B	  97
TCLK				  BIT	      CC	 138
TCON				  DATA	      88	  12
TEXT				  CODE	    0015	 192
TF0				  BIT	      8D	  89
TF1				  BIT	      8F	  91

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TF2				  BIT	      CF	 141
TH0				  DATA	      8C	  16
TH1				  DATA	      8D	  17
TH2				  DATA	      CD	  57
TI				  BIT	      99	  95
TIMECON				  DATA	      A1	  26
TL0				  DATA	      8A	  14
TL1				  DATA	      8B	  15
TL2				  DATA	      CC	  56
TMOD				  DATA	      89	  13
TOETSIN				  CODE	    1583	6095
TOETSTABEL			  CODE	    15A7	6122
TOETS_FLANK			  CODE	    14BB	5849
TOETS_INGEDRUKT			  CODE	    14CA	5872
TR0				  BIT	      8C	  88
TR1				  BIT	      8E	  90
TR2				  BIT	      CA	 136
TXD				  BIT	      B1	 111
WCOL				  BIT	      FE	 176
WDCON				  DATA	      C0	  49
WDE				  BIT	      C1	 127
WDIR				  BIT	      C3	 129
WDS				  BIT	      C2	 128
WDWR				  BIT	      C0	 126
WISSEN				  CODE	    0492	1601
WR				  BIT	      B6	 116
XOFF				  NUMBER    0013	1594
XONXOFF				  CODE	    051A	1754
XONXOFF1			  CODE	    0526	1760
XONXOFF2			  CODE	    0521	1757
XONXOFF3			  CODE	    052B	1762
