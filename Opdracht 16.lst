
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 16.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 16.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 16.lst



 Line  I  Addr  Code            Source

    1:				$nolist
  179:
  180:		N      007F	stack_init	equ	07fh
  181:		N      0000			org	0000h
  182:
  183:	  0000	02 00 0E			ljmp	start
  184:		N      000B			org	000bh
  185:	  000B	02 00 23			ljmp	int0_rout
  186:
  187:	  000E	75 81 7F	start:		mov	sp,#stack_init
  188:	  0011	12 00 35			lcall	initlcd
  189:	  0014	12 04 60			lcall	lcdlighton
  190:	  0017	78 00				mov	r0,#0
  191:	  0019	D2 A8				setb	ex0
  192:	  001B	D2 8C				setb	TR0
  193:	  001D	D2 AF				setb	ea
  194:	  001F	D2 A9				setb	et0
  195:	  0021	80 FE		loop:		sjmp	loop
  196:
  197:	  0023	90 00 32	int0_rout:	mov	dptr, #text
  198:	  0026	12 01 18			lcall	outmsgalcd
  199:	  0029	85 8C A0			mov 	p2,th0
  200:	  002C	08				inc	r0
  201:	  002D	E8				mov	a,r0
  202:	  002E	12 00 F4			lcall	outbytelcd
  203:	  0031	32				reti
  204:
  205:
  206:	  0032	80 13 00	text:		db	80h,013h,0
  207:
  208:				$include (c:/aduc800_mideA.inc)
  209: 1			;******************************************************************************
  210: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  211: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  212: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  213: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  214: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  215: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  216: 1			;******************************************************************************
  217: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  218: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  219: 1			;******************************************************************************
  220: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  221: 1
  222: 1			;******************************************************************************
  223: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  224: 1			; hebben voor onze toepassing. Door een module te definieren via het
  225: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  226: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  227: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  228: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  229: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  230: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  231: 1			; definities.
  232: 1			;******************************************************************************
  233: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  234: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  235: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  236: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  237: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  238: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  239: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  240: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  241: 1
  242: 1			ifdef    aduc_key
  243: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  244: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  245: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  246: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  247: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  248: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  249: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  250: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  251: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  252: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  253: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  254: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  255: 1			;definities wel gemaakt worden.
  256: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  257: 1			                            ;anders commentaar van maken!
  258: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  259: 1			                            ;gelezen, anders commentaar van maken!
  260: 1			;******************************************************************************
  261: 1			;Declaraties van de flags voor de aduc_key driver.
  262: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  263: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  264: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  265: 1			;switch_init en read_switch.
  266: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  267: 1			                                ;bereik = 20h-2fh!
  268: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  269: 1			                                   ;een geldige waarde bevat
  270: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  271: 1			                                   ;die de detectie mode aangeeft
  272: 1			;declaratie van de read_switch flags
  273: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  274: 1			                                   ;ontdenderde schakelaars zijn
  275: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  276: 1			                                   ;flanken zijn

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  277: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  278: 1			                                   ;flanken zijn
  279: 1			ifdef    matrix        ;matrix keyboard
  280: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  281: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  282: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  283: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  284: 1			;toepassing.
  285: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  286: 1			                                ;geheugenbuffer
  287: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  288: 1			                                ;debounce en de flankdetectie samples stockeren
  289: 1			                                ;de eerste 4 bytes dienen voor debouncing
  290: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  291: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  292: 1			                                ;toetswaarde aangeeft
  293: 1			                                ;bij een geldige keyvalid flag ('1')
  294: 1			endif    ;einde matrix keyboard
  295: 1
  296: 1			ifdef    dipswitch
  297: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  298: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  299: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  300: 1			;toepassing
  301: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  302: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  303: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  304: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  305: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  306: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  307: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  308: 1			endif    ;einde dipswitch
  309: 1			;******************************************************************************
  310: 1			endif    ;einde aduc_key
  311: 1
  312: 1
  313: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  314: 1
  315: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  316: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  317: 1			endif                               ;dus doen we dit hier nog eens!
  318: 1			;******************************************************************************
  319: 1
  320: 1			;******************************************************************************
  321: 1			;
  322: 1			; ADuc_lcd.inc
  323: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  324: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  325: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  326: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  327: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  328: 1			; het plaatsen van de cursor op een correcte plaats).
  329: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  330: 1			; display gebruiken.
  331: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  332: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  333: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  334: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  335: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  336: 1			;
  337: 1			; Versie ADuC832v1.1:
  338: 1			; Hier is het LCD verbonden met pinnen van poort0
  339: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  340: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  341: 1			;
  342: 1			; Versie ADuC832v2.2:
  343: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  344: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  345: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  346: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  347: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  348: 1			;
  349: 1			;
  350: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  351: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  352: 1			;  aduclcd0.inc
  353: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  354: 1			;  aduclcd1.inc
  355: 1			;    -00dh en 00ah worden door outchar verwerkt
  356: 1			;    -bij de init wordt het display anders opgestart
  357: 1			;
  358: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  359: 1			;  van gebruik en uitgebreid  met :
  360: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  361: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  362: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  363: 1			;    debug doeleinden
  364: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  365: 1			;    user codes aan te maken
  366: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  367: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  368: 1			;
  369: 1			; Beschikbare routines:
  370: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  371: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  372: 1			; build_adr, delay2ms, delay60us
  373: 1			;******************************************************************************
  374: 1
  375: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  376: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  377: 1			e             bit    lcdport.2            ;enable
  378: 1			rs            bit    lcdport.3            ;register select
  379: 1			endif    ;einde aduc832_v1_1
  380: 1
  381: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  382: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  383: 1	B	 F1	e             bit    lcdport.1            ;enable
  384: 1	B	 F0	rs            bit    lcdport.0            ;register select
  385: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  386: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  387: 1			endif    ;einde aduc832_v2_0
  388: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  389: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  390: 1			;het uitvoeren van de overeenkomstige commando's.
  391: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  392: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  393: 1
  394: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  395: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  396: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  397: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  398: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  399: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  400: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  401: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  402: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  403: 1
  404: 1			;******************************************************************************
  405: 1			;
  406: 1			; initlcd
  407: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  408: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  409: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  410: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  411: 1			; Na initialisering wordt het scherm leeg gemaakt.
  412: 1			;
  413: 1			; registergebruik: geen
  414: 1			;
  415: 1			;******************************************************************************
  416: 1
  417: 1  0035	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  418: 1  0037	C0 D0		              push   psw
  419: 1  0039	C0 F0		              push   b
  420: 1			ifdef  aduc832_v1_1
  421: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  422: 1			                                   ;let op:twee laagste bits worden
  423: 1			                                   ;niet gebruikt
  424: 1			endif
  425: 1
  426: 1			ifdef    aduc832_v2_0
  427: 1  003B	12 03 2B	              lcall  i2cinit              ;LCD via een I2C bus
  428: 1  003E	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  429: 1			                                          ;buzzer en backlight  op 1 gezet
  430: 1  0041	12 04 2E	              lcall  porttolcd            ;data uit b naar het scherm
  431: 1			endif
  432: 1
  433: 1  0044	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  434: 1  0046	12 03 00	initlcd1:     lcall  delay2ms
  435: 1  0049	D5 E0 FA	              djnz   acc,initlcd1
  436: 1  004C	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  437: 1  004E	12 01 B7	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  438: 1  0051	12 03 00	              lcall  delay2ms      ;om het display altijd opgestart
  439: 1  0054	74 30		              mov    a,#00110000b  ;te krijgen.
  440: 1  0056	12 01 B7	              lcall  outhnibc
  441: 1  0059	12 03 00	              lcall  delay2ms
  442: 1  005C	74 30		              mov    a,#00110000b
  443: 1  005E	12 01 B7	              lcall  outhnibc
  444: 1  0061	12 03 00	              lcall  delay2ms

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  445: 1  0064	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  446: 1  0066	12 01 B7	              lcall  outhnibc      ;hoge nibble naar het controleregister
  447: 1  0069	12 03 00	              lcall  delay2ms      ;niet nodig volgens datasheet
  448: 1  006C	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  449: 1  006E	12 01 A1	              lcall  outc          ;naar display
  450: 1  0071	12 03 00	              lcall  delay2ms      ;is iets te lang volgens datasheet
  451: 1  0074	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  452: 1  0076	12 01 A1	              lcall  outc
  453: 1  0079	12 03 00	              lcall  delay2ms      ;ook deze delay is iets te lang
  454: 1  007C	74 01		              mov    a,#displayon  ;clear display and home cursor
  455: 1  007E	12 01 A1	              lcall  outc
  456: 1  0081	12 03 00	              lcall  delay2ms      ;deze wachttijd is bijna juist
  457: 1  0084	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  458: 1  0086	12 01 A1	              lcall  outc
  459: 1  0089	12 03 00	              lcall  delay2ms      ;wachten weer veel te lang
  460: 1  008C	D0 F0		              pop    b
  461: 1  008E	D0 D0		              pop    psw           ;registers terug in orde zetten
  462: 1  0090	D0 E0		              pop    acc
  463: 1  0092	22		              ret                  ;einde van de initialisatie
  464: 1
  465: 1			;******************************************************************************
  466: 1			;
  467: 1			; outcharlcd
  468: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  469: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  470: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  471: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  472: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  473: 1			; De controlekarakters komen overeen met volgende acties:
  474: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  475: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  476: 1			;              (line feed+ carriage return!)
  477: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  478: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  479: 1			;      011h   =cursor on, blink mode
  480: 1			;      012h   =cursor on, no blink mode
  481: 1			;      013h   =cursor off
  482: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  483: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  484: 1			;              van het LCD
  485: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  486: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  487: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  488: 1			; positie 6 (C5H-80H=45H)
  489: 1			;
  490: 1			; Deze routine vernietigt geen registers
  491: 1			;
  492: 1			;******************************************************************************
  493: 1
  494: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  495: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  496: 1			; dataregister van het scherm.
  497: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  498: 1			; controlebyte doorsturen naar het LCD.
  499: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  500: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  501: 1			; naar de LCD sturen.
  502: 1
  503: 1  0093	C0 E0		outcharlcd:   push   acc           ;registers op stack
  504: 1  0095	C0 D0		              push   psw
  505: 1  0097	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  506: 1  009A	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  507: 1  009C	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  508: 1  009F	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  509: 1  00A1	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  510: 1  00A4	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  511: 1
  512: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  513: 1			; Als het een commando is, moeten we het uitvoeren.
  514: 1			; Indien niet, gewoon terug zonder actie!
  515: 1
  516: 1  00A6	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  517: 1  00A9	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  518: 1  00AB	80 28		              sjmp   outcharlcd9          ;afsluiten
  519: 1
  520: 1  00AD	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  521: 1  00B0	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  522: 1  00B2	80 21		              sjmp   outcharlcd9
  523: 1
  524: 1  00B4	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  525: 1  00B7	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  526: 1  00B9	80 1A		              sjmp   outcharlcd9
  527: 1
  528: 1  00BB	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  529: 1  00BE	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  530: 1  00C0	80 13		              sjmp   outcharlcd9
  531: 1
  532: 1  00C2	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  533: 1  00C5	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  534: 1  00C7	80 0C		              sjmp   outcharlcd9
  535: 1
  536: 1  00C9	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  537: 1  00CC	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  538: 1  00CE	80 05		              sjmp   outcharlcd9
  539: 1
  540: 1
  541: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  542: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  543: 1
  544: 1  00D0	12 01 67	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  545: 1  00D3	80 03		              sjmp   outcharlcde   ;einde routine
  546: 1
  547: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  548: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  549: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  550: 1			; op dat adres te zetten.
  551: 1
  552: 1  00D5	12 01 A1	outcharlcd9:  lcall  outc          ;klaar
  553: 1  00D8	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  554: 1  00DA	D0 E0		              pop    acc
  555: 1  00DC	22		              ret
  556: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  557: 1			;******************************************************************************
  558: 1			;
  559: 1			; outniblcd
  560: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  561: 1			; op het lcd scherm.
  562: 1			;
  563: 1			; de routine vernietigt geen registers
  564: 1			;
  565: 1			;******************************************************************************
  566: 1
  567: 1  00DD	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  568: 1  00DF	C0 D0		              push   psw
  569: 1  00E1	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  570: 1  00E3	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  571: 1  00E5	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  572: 1  00E8	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  573: 1  00EA	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  574: 1  00EC	12 01 67	outniblcde:   lcall  outd          ;naar het scherm
  575: 1  00EF	D0 D0		              pop    psw
  576: 1  00F1	D0 E0		              pop    acc
  577: 1  00F3	22		              ret
  578: 1
  579: 1			;******************************************************************************
  580: 1			;
  581: 1			; outbytelcd
  582: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  583: 1			;
  584: 1			; de routine vernietigt geen registers
  585: 1			;
  586: 1			;******************************************************************************
  587: 1
  588: 1  00F4	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  589: 1  00F6	C0 D0		              push   psw
  590: 1  00F8	C4		              swap   a             ;bitjes omruilen
  591: 1  00F9	12 00 DD	              lcall  outniblcd
  592: 1  00FC	C4		              swap   a             ;nog eens
  593: 1  00FD	12 00 DD	              lcall  outniblcd
  594: 1  0100	D0 D0		              pop    psw
  595: 1  0102	D0 E0		              pop    acc
  596: 1  0104	22		              ret
  597: 1
  598: 1			;******************************************************************************
  599: 1			;
  600: 1			; dispdptrlcd
  601: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  602: 1			;
  603: 1			; de routine vernietigt geen registers
  604: 1			;
  605: 1			;******************************************************************************
  606: 1
  607: 1  0105	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  608: 1  0107	C0 D0		              push   psw
  609: 1  0109	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  610: 1  010B	12 00 F4	              lcall  outbytelcd
  611: 1  010E	E5 82		              mov    a,dpl         ;dan het lage deel
  612: 1  0110	12 00 F4	              lcall  outbytelcd

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  613: 1  0113	D0 D0		              pop    psw
  614: 1  0115	D0 E0		              pop    acc
  615: 1  0117	22		              ret
  616: 1
  617: 1			;******************************************************************************
  618: 1			;
  619: 1			; outmsgalcd
  620: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  621: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  622: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  623: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  624: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  625: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  626: 1			;
  627: 1			; de routine vernietigt geen registers
  628: 1			;
  629: 1			;******************************************************************************
  630: 1
  631: 1  0118	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  632: 1  011A	C0 D0		              push   psw
  633: 1  011C	C0 83		              push   dph           ;ook de data pointer
  634: 1  011E	C0 82		              push   dpl
  635: 1
  636: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  637: 1
  638: 1  0120	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  639: 1  0121	93		              movc   a,@a+dptr     ;waarde lezen
  640: 1  0122	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  641: 1
  642: 1			; de code is niet 0 dus versturen met outchar
  643: 1
  644: 1  0124	12 00 93	              lcall  outcharlcd    ;weg er mee
  645: 1  0127	A3		              inc    dptr          ;naar volgende ascii code wijzen
  646: 1  0128	02 01 20	              ljmp   outmsgalcd1   ;lus sluiten
  647: 1
  648: 1  012B	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  649: 1  012D	D0 83		              pop    dph
  650: 1  012F	D0 D0		              pop    psw
  651: 1  0131	D0 E0		              pop    acc
  652: 1  0133	22		              ret
  653: 1
  654: 1			;******************************************************************************
  655: 1			;
  656: 1			; regtolcd
  657: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  658: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  659: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  660: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  661: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  662: 1			;
  663: 1			; de routine vernietigt geen registers
  664: 1			;
  665: 1			;******************************************************************************
  666: 1
  667: 1
  668: 1  0134	C0 E0		regtolcd:     push   acc           ;registers op de stack

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  669: 1  0136	C0 D0		              push   psw
  670: 1  0138	E8		              mov    a,r0
  671: 1  0139	C0 E0		              push   acc
  672: 1  013B	E9		              mov    a,r1
  673: 1  013C	C0 E0		              push   acc
  674: 1  013E	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  675: 1  0140	12 00 93	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  676: 1			                                   ;plaats
  677: 1  0143	79 00		              mov    r1,#000h      ;werkt als loopcounter
  678: 1  0145	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  679: 1  0146	12 00 93	              lcall  outcharlcd    ;weg er mee
  680: 1  0149	08		              inc    r0
  681: 1  014A	09		              inc    r1
  682: 1  014B	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  683: 1			                                          ;nieuwe lijn genomen worden
  684: 1  014E	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  685: 1  0150	12 00 93	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  686: 1			                                   ;plaats
  687: 1
  688: 1  0153	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  689: 1  0154	12 00 93	              lcall  outcharlcd    ;weg er mee
  690: 1  0157	08		              inc    r0
  691: 1  0158	09		              inc    r1
  692: 1  0159	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  693: 1  015C	D0 E0		              pop    acc
  694: 1  015E	F9		              mov    r1,a
  695: 1  015F	D0 E0		              pop    acc
  696: 1  0161	F8		              mov    r0,a
  697: 1  0162	D0 D0		              pop    psw           ;registers herstellen
  698: 1  0164	D0 E0		              pop    acc
  699: 1  0166	22		              ret
  700: 1
  701: 1			;******************************************************************************
  702: 1			;
  703: 1			; outd
  704: 1			; Is een routine die naar het data register van het display een
  705: 1			; volledige byte stuurt.
  706: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  707: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  708: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  709: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  710: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  711: 1			;
  712: 1			; De routine vernietigt geen registers.
  713: 1			;
  714: 1			;******************************************************************************
  715: 1
  716: 1  0167	C0 E0		outd:         push   acc           ;registers op stack zetten
  717: 1  0169	C0 D0		              push   psw
  718: 1  016B	12 01 77	              lcall  outhnibd      ;hoogste vier bits verzenden
  719: 1			ifdef     aduc832_v1_1
  720: 1			              lcall  delay60us     ;niet echt nodig
  721: 1			endif
  722: 1  016E	C4		              swap   a             ;bitjes omruilen
  723: 1  016F	12 01 77	              lcall  outhnibd      ;naar het scherm sturen
  724: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  725: 1			ifdef    aduc832_v1_1
  726: 1			              lcall  delay60us     ;altijd goed
  727: 1			endif
  728: 1
  729: 1  0172	D0 D0		              pop    psw           ;registers terug herstellen
  730: 1  0174	D0 E0		              pop    acc
  731: 1  0176	22		              ret
  732: 1
  733: 1			;******************************************************************************
  734: 1			;
  735: 1			; outhnibd
  736: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  737: 1			; lcd scherm.
  738: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  739: 1			; de routine vernietigt geen registers.
  740: 1			;
  741: 1			;******************************************************************************
  742: 1			ifdef     aduc832_v1_1
  743: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  744: 1			              push   psw
  745: 1			              setb   rs            ;controle lijn in orde
  746: 1			              clr    e             ;deselectie display
  747: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  748: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  749: 1			              mov     c,acc.6      ;afblijven!
  750: 1			              mov     lcdport.6,c
  751: 1			              mov     c,acc.5
  752: 1			              mov     lcdport.5,c
  753: 1			              mov     c,acc.4
  754: 1			              mov     lcdport.4,c
  755: 1			              setb   e             ;display enabelen
  756: 1			              nop                  ;450ns is normaal gezien voldoende
  757: 1			              clr    e             ;display deselecteren
  758: 1			              pop    psw           ;registers herstellen
  759: 1			              pop    acc
  760: 1			              ret
  761: 1			endif
  762: 1
  763: 1			ifdef    aduc832_v2_0
  764: 1  0177	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  765: 1  0179	C0 D0		              push   psw
  766: 1  017B	C0 F0		              push   b             ;werkregister
  767: 1  017D	12 04 47	              lcall  lcdtoport     ;lees de expander naar b register
  768: 1  0180	D2 F0		              setb   rs            ;controle lijn in orde
  769: 1  0182	C2 F1		              clr    e             ;deselectie display
  770: 1  0184	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  771: 1  0186	03		              rr     a             ;bits op juiste plaats zetten
  772: 1  0187	03		              rr     a             ;voor b reg
  773: 1  0188	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  774: 1  018B	42 F0		              orl    b,a           ;bij elkaar voegen
  775: 1  018D	12 04 2E	              lcall  porttolcd     ;naar expander
  776: 1  0190	D2 F1		              setb   e             ;display enabelen
  777: 1  0192	12 04 2E	              lcall  porttolcd
  778: 1  0195	C2 F1		              clr    e             ;display deselecteren
  779: 1  0197	12 04 2E	              lcall  porttolcd
  780: 1  019A	D0 F0		              pop    b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  781: 1  019C	D0 D0		              pop    psw           ;registers herstellen
  782: 1  019E	D0 E0		              pop    acc
  783: 1  01A0	22		              ret
  784: 1			endif
  785: 1			;******************************************************************************
  786: 1			;
  787: 1			; outc
  788: 1			; Is een routine die naar het controleregister van het display een
  789: 1			; volledige byte (commando) stuurt.
  790: 1			; De routine vernietigt geen registers.
  791: 1			;
  792: 1			;******************************************************************************
  793: 1
  794: 1  01A1	C0 E0		outc:         push   acc           ;registers op stack zetten
  795: 1  01A3	C0 D0		              push   psw
  796: 1  01A5	12 01 B7	              lcall  outhnibc      ;hoogste vier bits verzenden
  797: 1  01A8	12 03 00	              lcall  delay2ms      ;niet echt nodig
  798: 1  01AB	C4		              swap   a             ;bitjes omruilen
  799: 1  01AC	12 01 B7	              lcall  outhnibc      ;naar het scherm sturen
  800: 1  01AF	12 03 00	              lcall  delay2ms      ;altijd goed voor traagste commando
  801: 1  01B2	D0 D0		              pop    psw           ;registers terug herstellen
  802: 1  01B4	D0 E0		              pop    acc
  803: 1  01B6	22		              ret
  804: 1
  805: 1			;******************************************************************************
  806: 1			;
  807: 1			; outhnibc
  808: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  809: 1			; het lcd scherm.
  810: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  811: 1			; de routine vernietigt geen registers.
  812: 1			;
  813: 1			;******************************************************************************
  814: 1			ifdef     aduc832_v1_1
  815: 1			outhnibc:     push   acc           ;registers op stack plaatsen
  816: 1			              push   psw
  817: 1			              clr    rs            ;controle lijn in orde
  818: 1			              clr    e             ;deselectie display
  819: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  820: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  821: 1			              mov     c,acc.6      ;afblijven!
  822: 1			              mov     lcdport.6,c
  823: 1			              mov     c,acc.5
  824: 1			              mov     lcdport.5,c
  825: 1			              mov     c,acc.4
  826: 1			              mov     lcdport.4,c
  827: 1			              setb   e             ;display enabelen
  828: 1			              nop                  ;450ns is normaal gezien voldoende
  829: 1			              clr    e             ;display deselecteren
  830: 1			              pop    psw           ;registers herstellen
  831: 1			              pop    acc
  832: 1			              ret
  833: 1			endif
  834: 1
  835: 1			ifdef    aduc832_v2_0
  836: 1  01B7	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  837: 1  01B9	C0 D0		              push   psw
  838: 1  01BB	C0 F0		              push   b             ;werkregister
  839: 1  01BD	12 04 47	              lcall  lcdtoport     ;lees de expander naar b register
  840: 1  01C0	C2 F0		              clr    rs            ;controle lijn in orde
  841: 1  01C2	C2 F1		              clr    e             ;deselectie display
  842: 1  01C4	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  843: 1  01C6	03		              rr     a             ;bits op juiste plaats zetten
  844: 1  01C7	03		              rr     a             ;voor b reg
  845: 1  01C8	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  846: 1  01CB	42 F0		              orl    b,a           ;bij elkaar voegen
  847: 1  01CD	12 04 2E	              lcall  porttolcd     ;naar expnder
  848: 1  01D0	D2 F1		              setb   e             ;display enabelen
  849: 1  01D2	12 04 2E	              lcall  porttolcd
  850: 1  01D5	C2 F1		              clr    e             ;display deselecteren
  851: 1  01D7	12 04 2E	              lcall  porttolcd
  852: 1  01DA	D0 F0		              pop    b
  853: 1  01DC	D0 D0		              pop    psw           ;registers herstellen
  854: 1  01DE	D0 E0		              pop    acc
  855: 1  01E0	22		              ret
  856: 1			endif
  857: 1
  858: 1			;******************************************************************************
  859: 1			; hexbuf2lcd
  860: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  861: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  862: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  863: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  864: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  865: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  866: 1			;
  867: 1			; ADR| HEX DATA  |
  868: 1			; 42 |AF 2D 23 5A|
  869: 1			;
  870: 1			; Deze routine vernietigt geen registers
  871: 1			;******************************************************************************
  872: 1
  873: 1  01E1	C0 E0		hexbuf2lcd:   push   acc
  874: 1  01E3	C0 F0		              push   b
  875: 1  01E5	C0 D0		              push   psw
  876: 1  01E7	C0 82		              push   dpl
  877: 1  01E9	C0 83		              push   dph
  878: 1  01EB	E8		              mov     a,r0
  879: 1  01EC	C0 E0		              push   acc
  880: 1  01EE	90 02 2A	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
  881: 1  01F1	12 01 18	              lcall   outmsgalcd
  882: 1  01F4	E8		              mov    a,r0            ;neem pointerwaarde
  883: 1  01F5	12 00 F4	              lcall  outbytelcd      ;byte afdrukken als startadres
  884: 1  01F8	74 20		              mov    a,#' '          ;spatie afdrukken
  885: 1  01FA	12 00 93	              lcall  outcharlcd
  886: 1  01FD	74 7C		              mov    a,#'|'          ;pipe afdrukken
  887: 1  01FF	12 00 93	              lcall  outcharlcd
  888: 1  0202	75 F0 04	              mov    b,#4            ;bytecounter=4
  889: 1  0205	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  890: 1  0206	12 00 F4	              lcall  outbytelcd      ;byte naar buiten
  891: 1  0209	74 20		              mov    a,#' '          ;neem whitespace char
  892: 1  020B	12 00 93	              lcall  outcharlcd       ;druk af

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  893: 1  020E	08		              inc    r0              ;volgende byte
  894: 1  020F	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
  895: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  896: 1  0212	74 CF		              mov    a,#0cfh         ;adres laatste char
  897: 1  0214	12 00 93	              lcall   outcharlcd
  898: 1  0217	74 7C		              mov    a,#'|'          ;neem pipe
  899: 1  0219	12 00 93	              lcall  outcharlcd      ;ascii code afdrukken
  900: 1  021C	D0 E0		hexbuf2lcde:  pop    acc
  901: 1  021E	F8		              mov   r0,a
  902: 1  021F	D0 83		              pop   dph
  903: 1  0221	D0 82		              pop   dpl
  904: 1  0223	D0 D0		              pop   psw
  905: 1  0225	D0 F0		              pop   b
  906: 1  0227	D0 E0		              pop   acc
  907: 1  0229	22		              ret
  908: 1			                        ;'0123456789abcdef'
  909: 1  022A	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  022E	52 7C 20 48
       1  0232	45 58 20 44
       1  0236	41 54 41 20
       1  023A	20 7C C0 00
  910: 1
  911: 1
  912: 1			;******************************************************************************
  913: 1			; barlcd
  914: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
  915: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
  916: 1			; de inhoud van A
  917: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
  918: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
  919: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
  920: 1			; aangemaakt in de LCD CGRAM.
  921: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
  922: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
  923: 1			;       lcall build
  924: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
  925: 1			;       mov     a, #42h     ;de startlocatie is 42h
  926: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
  927: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
  928: 1			;
  929: 1			; Deze routine vernietigt geen registers.
  930: 1			;******************************************************************************
  931: 1
  932: 1  023E	C0 82		barlcd:       push   dpl
  933: 1  0240	88 82		              mov     dpl,r0
  934: 1  0242	C0 82		              push   dpl
  935: 1  0244	C0 E0		              push   acc            ;bewaar startlocatie
  936: 1  0246	C0 D0		              push   psw            ;bewaar status
  937: 1  0248	C0 F0		              push   b              ;bewaar aantal bar's
  938: 1  024A	F5 F0		              mov    b,a            ;bewaar startlocatie
  939: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
  940: 1  024C	E8		              mov    a,r0           ;neem maximum aantal bar's
  941: 1  024D	C0 F0		              push   b              ;bewaar startadres
  942: 1  024F	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
  943: 1  0252	84		              div    ab             ;bereken dus het aantal nodige blokjes
  944: 1  0253	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  945: 1  0254	E5 F0		              mov    a,b            ;neem restbars
  946: 1  0256	60 01		              jz     barlcd_1       ;als nul dan verder
  947: 1  0258	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
  948: 1  0259	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
  949: 1  025B	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
  950: 1  025D	12 00 93	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
  951: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
  952: 1  0260	74 13		              mov    a,#13h         ;cursor off
  953: 1  0262	12 00 93	              lcall  outcharlcd     ;stuur naar LCD
  954: 1  0265	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
  955: 1  0267	C0 F0		              push   b              ;en weer bewaren
  956: 1  0269	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
  957: 1  026B	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
  958: 1  026D	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
  959: 1  0270	84		              div    ab             ;A=aantal volle blokjes, B=rest
  960: 1  0271	C0 F0		              push   b              ;bewaar rest
  961: 1  0273	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
  962: 1  0275	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
  963: 1
  964: 1			;Druk de volle 5x8 blokjes af van de bargraph
  965: 1  0277	74 04		              mov    a,#4           ;neem code voor vol blokje
  966: 1  0279	12 01 67	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
  967: 1  027C	18		              dec    r0             ;verminder karaktersteller
  968: 1  027D	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
  969: 1
  970: 1			;Druk het onvolledige blokje (rest) af
  971: 1  0280	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
  972: 1  0282	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
  973: 1  0284	14		              dec    a              ;converteer rest naar code voor de
  974: 1			                                    ;overeenkomende bar's
  975: 1  0285	12 01 67	              lcall  outd           ;druk resterende bar's af
  976: 1  0288	18		              dec    r0             ;verminder karakterteller
  977: 1
  978: 1			;Test of we aan het einde van de bargraph zitten..
  979: 1  0289	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
  980: 1  028C	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
  981: 1
  982: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
  983: 1  028E	74 20		barlcd4:      mov    a,#' '         ;neem spatie
  984: 1  0290	12 01 67	              lcall  outd           ;en druk af
  985: 1  0293	18		              dec    r0             ;karakterteller verminderen
  986: 1  0294	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
  987: 1
  988: 1  0296	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
  989: 1  0298	D0 D0		              pop    psw            ;haal status weer
  990: 1  029A	D0 E0		              pop    acc            ;haal startlocatie weer
  991: 1  029C	D0 82		              pop    dpl
  992: 1  029E	A8 82		              mov    r0,dpl
  993: 1  02A0	D0 82		              pop    dpl
  994: 1  02A2	22		              ret
  995: 1
  996: 1
  997: 1
  998: 1			;******************************************************************************
  999: 1			; barchars
 1000: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

 1001: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
 1002: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
 1003: 1			; kunnen pas daarna worden gebruikt.
 1004: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
 1005: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
 1006: 1			; (max. 3 extra char's).
 1007: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
 1008: 1			; opgeslagen met MSB=1.
 1009: 1			;******************************************************************************
 1010: 1
 1011: 1  02A3	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1012: 1  02A4	10		              db 00010000b
 1013: 1  02A5	10		              db 00010000b
 1014: 1  02A6	10		              db 00010000b
 1015: 1  02A7	10		              db 00010000b
 1016: 1  02A8	10		              db 00010000b
 1017: 1  02A9	10		              db 00010000b
 1018: 1  02AA	10		              db 00010000b
 1019: 1
 1020: 1  02AB	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1021: 1  02AC	18		              db 00011000b
 1022: 1  02AD	18		              db 00011000b
 1023: 1  02AE	18		              db 00011000b
 1024: 1  02AF	18		              db 00011000b
 1025: 1  02B0	18		              db 00011000b
 1026: 1  02B1	18		              db 00011000b
 1027: 1  02B2	18		              db 00011000b
 1028: 1
 1029: 1  02B3	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1030: 1  02B4	1C		              db 00011100b
 1031: 1  02B5	1C		              db 00011100b
 1032: 1  02B6	1C		              db 00011100b
 1033: 1  02B7	1C		              db 00011100b
 1034: 1  02B8	1C		              db 00011100b
 1035: 1  02B9	1C		              db 00011100b
 1036: 1  02BA	1C		              db 00011100b
 1037: 1
 1038: 1  02BB	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1039: 1  02BC	1E		              db 00011110b
 1040: 1  02BD	1E		              db 00011110b
 1041: 1  02BE	1E		              db 00011110b
 1042: 1  02BF	1E		              db 00011110b
 1043: 1  02C0	1E		              db 00011110b
 1044: 1  02C1	1E		              db 00011110b
 1045: 1  02C2	1E		              db 00011110b
 1046: 1
 1047: 1  02C3	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1048: 1  02C4	1F		              db 00011111b
 1049: 1  02C5	1F		              db 00011111b
 1050: 1  02C6	1F		              db 00011111b
 1051: 1  02C7	1F		              db 00011111b
 1052: 1  02C8	1F		              db 00011111b
 1053: 1  02C9	1F		              db 00011111b
 1054: 1  02CA	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1055: 1
 1056: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1057: 1			;
 1058: 1			; build
 1059: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1060: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1061: 1			; overeen komen met de ASCII codes 00h-07h.
 1062: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1063: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1064: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1065: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1066: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1067: 1			;
 1068: 1			; De routine vernietigt geen registers.
 1069: 1			;
 1070: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1071: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1072: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1073: 1			;      lcall  outcharlcd         ; druk de karakter af
 1074: 1			;
 1075: 1			;eigenkarakter:
 1076: 1			;      db 00001110b
 1077: 1			;      db 00001010b
 1078: 1			;      db 00001110b
 1079: 1			;      db 00000100b
 1080: 1			;      db 00011111b
 1081: 1			;      db 00000100b
 1082: 1			;      db 00001010b
 1083: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1084: 1			;******************************************************************************
 1085: 1
 1086: 1  02CB	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1087: 1  02CD	C0 D0		              push   psw
 1088: 1  02CF	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1089: 1  02D1	12 02 D9	              lcall  build_adr
 1090: 1  02D4	D0 D0		              pop    psw
 1091: 1  02D6	D0 E0		              pop    acc
 1092: 1  02D8	22		              ret                  ;terug
 1093: 1
 1094: 1			;******************************************************************************
 1095: 1			; build_adr
 1096: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1097: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1098: 1			; die overeen komen met de ASCII codes 00h-07h.
 1099: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1100: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1101: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1102: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1103: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1104: 1			;
 1105: 1			; De routine vernietigt geen registers.
 1106: 1			;
 1107: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1108: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1109: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1110: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1111: 1			;      lcall  outcharlcd        ; druk de karakter af
 1112: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1113: 1			;eigenkarakters:
 1114: 1			;      db 00001110b
 1115: 1			;      db 00001010b
 1116: 1			;      db 00001110b
 1117: 1			;       db 00000100b
 1118: 1			;      db 00011111b
 1119: 1			;      db 00000100b
 1120: 1			;      db 00001010b
 1121: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1122: 1			;******************************************************************************
 1123: 1  02D9	C0 E0		build_adr:      push   acc
 1124: 1  02DB	C0 D0		              push   psw
 1125: 1  02DD	C0 83		              push   dph
 1126: 1  02DF	C0 82		              push   dpl
 1127: 1  02E1	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1128: 1  02E3	12 01 A1	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1129: 1  02E6	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1130: 1  02E8	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1131: 1  02E9	12 01 67	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1132: 1  02EC	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1133: 1  02EF	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1134: 1  02F0	80 F4		              sjmp   build3
 1135: 1  02F2	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1136: 1  02F4	12 01 A1	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1137: 1  02F7	D0 82		              pop    dpl
 1138: 1  02F9	D0 83		              pop    dph
 1139: 1  02FB	D0 D0		              pop    psw
 1140: 1  02FD	D0 E0		              pop    acc
 1141: 1  02FF	22		              ret
 1142: 1
 1143: 1			;******************************************************************************
 1144: 1			;
 1145: 1			; delay2ms
 1146: 1			; Is een vertragingsroutine van 2ms.
 1147: 1			;
 1148: 1			; De routine vernietigt geen registers.
 1149: 1			;
 1150: 1			;******************************************************************************
 1151: 1
 1152: 1  0300	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1153: 1  0302	C0 D0		              push   psw
 1154: 1  0304	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1155: 1  0306	12 03 11	delay2ms1:    lcall  delay60us
 1156: 1  0309	D5 E0 FA	              djnz   acc,delay2ms1
 1157: 1  030C	D0 D0		              pop    psw           ;registers herstellen
 1158: 1  030E	D0 E0		              pop    acc
 1159: 1  0310	22		              ret
 1160: 1
 1161: 1			;******************************************************************************
 1162: 1			;
 1163: 1			; delay60us.
 1164: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1165: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1166: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1167: 1			;
 1168: 1			; de routine vernietigt geen registers.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1169: 1			;
 1170: 1			;******************************************************************************
 1171: 1
 1172: 1  0311	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1173: 1  0313	C0 D0		              push   psw
 1174: 1  0315	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1175: 1  0317	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1176: 1
 1177: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1178: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1179: 1
 1180: 1  0319	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1181: 1  031C	D0 E0		              pop    acc           ;registers herstellen
 1182: 1  031E	D0 D0		              pop    psw
 1183: 1  0320	22		              ret
 1184: 1
 1185: 1  0321	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1186: 1  0323	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1187: 1  0326	D0 D0		              pop    psw
 1188: 1  0328	D0 E0		              pop    acc
 1189: 1  032A	22		              ret
 1190: 1
 1191: 1			endif        ;einde van aduc_lcd
 1192: 1
 1193: 1
 1194: 1
 1195: 1
 1196: 1			ifdef aduc_i2c
 1197: 1			;******************************************************************************
 1198: 1			;
 1199: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1200: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1201: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1202: 1			;
 1203: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1204: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1205: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1206: 1			;
 1207: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1208: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1209: 1			;
 1210: 1			; Beschikbare routines:
 1211: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1212: 1			; i2cstart     :verzenden van een start conditie
 1213: 1			; i2cstop      :verzenden van een stop conditie
 1214: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1215: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1216: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1217: 1			;               negende klokpuls
 1218: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1219: 1			;               negende klokpuls
 1220: 1			;
 1221: 1			; Toevoeging [dp]
 1222: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1223: 1			;               een slavedevice
 1224: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1225: 1			;               en plaatst deze in een geheugenbuffer
 1226: 1			;******************************************************************************
 1227: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1228: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1229: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1230: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1231: 1
 1232: 1			;******************************************************************************
 1233: 1			; i2cinit
 1234: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1235: 1			;******************************************************************************
 1236: 1  032B	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1237: 1  032D	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1238: 1  032F	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1239: 1  0331	D2 EB		                setb    i2cm            ;master mode inschakelen
 1240: 1  0333	22		                ret
 1241: 1			;******************************************************************************
 1242: 1			; i2cstart
 1243: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1244: 1			;******************************************************************************
 1245: 1  0334	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1246: 1  0336	C2 EF		                clr     mdo             ;data moet laag worden
 1247: 1  0338	D2 EE		                setb    mde             ;data pin enable
 1248: 1  033A	C2 ED		                clr     mco             ;klok laag maken
 1249: 1  033C	22		                ret
 1250: 1			;******************************************************************************
 1251: 1			; i2cstop
 1252: 1			; Dit is een subroutine die de stop conditie opwekt.
 1253: 1			;******************************************************************************
 1254: 1  033D	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1255: 1  033F	D2 EE		                setb    mde             ;data mag naar buiten
 1256: 1  0341	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1257: 1  0343	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1258: 1  0345	22		                ret
 1259: 1
 1260: 1			;******************************************************************************
 1261: 1			; i2coutbyte
 1262: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1263: 1			; De routine vernietigt geen registers.
 1264: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1265: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1266: 1			;         uitvoeren van de routine.
 1267: 1			;******************************************************************************
 1268: 1  0346	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1269: 1  0348	C0 F0		                push    b
 1270: 1  034A	75 F0 08	                mov     b,#008h         ;loopcounter
 1271: 1  034D	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1272: 1  034E	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1273: 1  0350	D2 EE		                setb    mde             ;pin als output activeren
 1274: 1  0352	D2 ED		                setb    mco             ;klokpukls hoog
 1275: 1  0354	C2 ED		                clr     mco             ;klokpuls laag
 1276: 1  0356	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1277: 1  0359	C2 EE		                clr     mde             ;iic data pin als input schakelen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1278: 1  035B	D2 ED		                setb    mco             ;klokpuls hoog
 1279: 1  035D	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1280: 1  035F	C2 ED		                clr     mco             ;klokpuls terug laag
 1281: 1  0361	D0 F0		                pop     b
 1282: 1  0363	D0 E0		                pop     acc             ;registers herstellen
 1283: 1  0365	22		                ret
 1284: 1
 1285: 1			;******************************************************************************
 1286: 1			; i2cinbyteack
 1287: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1288: 1			; De routine vernietigt geen registers. De routine zal als
 1289: 1			; negende bit een ack verzenden.
 1290: 1			;******************************************************************************
 1291: 1  0366	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1292: 1  0368	C0 D0		                push    psw
 1293: 1  036A	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1294: 1  036D	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1295: 1  036F	D2 ED		                setb    mco             ;klokpuls hoog
 1296: 1  0371	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1297: 1  0373	C2 ED		                clr     mco             ;klokpuls terug laag
 1298: 1  0375	33		                rlc     a               ;in accu shiften
 1299: 1  0376	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1300: 1  0379	C3		                clr     c               ;ack verzenden
 1301: 1  037A	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1302: 1  037C	D2 EE		                setb    mde             ;pin als output activeren
 1303: 1  037E	D2 ED		                setb    mco             ;klokpukls hoog
 1304: 1  0380	C2 ED		                clr     mco             ;klokpuls laag
 1305: 1  0382	D0 D0		                pop     psw             ;registers herstellen
 1306: 1  0384	D0 F0		                pop     b
 1307: 1  0386	22		                ret
 1308: 1
 1309: 1			;******************************************************************************
 1310: 1			; i2cinbytenack
 1311: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1312: 1			; De routine vernietigt geen registers. De routine zal als
 1313: 1			; negende bit een nack verzenden.
 1314: 1			;******************************************************************************
 1315: 1  0387	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1316: 1  0389	C0 D0		                push    psw
 1317: 1  038B	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1318: 1  038E	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1319: 1  0390	D2 ED		                setb    mco             ;klokpuls hoog
 1320: 1  0392	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1321: 1  0394	C2 ED		                clr     mco             ;klokpuls terug laag
 1322: 1  0396	33		                rlc     a               ;in accu shiften
 1323: 1  0397	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1324: 1  039A	D3		                setb    c               ;nack verzenden
 1325: 1  039B	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1326: 1  039D	D2 EE		                setb    mde             ;pin als output activeren
 1327: 1  039F	D2 ED		                setb    mco             ;klokpukls hoog
 1328: 1  03A1	C2 ED		                clr     mco             ;klokpuls laag
 1329: 1  03A3	D0 D0		                pop     psw             ;registers herstellen
 1330: 1  03A5	D0 F0		                pop     b
 1331: 1  03A7	22		                ret
 1332: 1
 1333: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1334: 1			; i2csenddata
 1335: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1336: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1337: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1338: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1339: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1340: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1341: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1342: 1			;
 1343: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1344: 1			; pointer naar deze data.  .
 1345: 1
 1346: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1347: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1348: 1			;         B       = aantal te versturen bytes (minimum 1)
 1349: 1			;         R0      = startadres van te versturen datablok
 1350: 1			;
 1351: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1352: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1353: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1354: 1			;               verzonden byte waarvoor er geen ack kwam.
 1355: 1			;
 1356: 1			; Deze routine vernietigt niets...
 1357: 1			;******************************************************************************
 1358: 1  03A8	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1359: 1  03AA	C0 D0		                    push   psw
 1360: 1  03AC	E8		                    mov    a,r0
 1361: 1  03AD	C0 E0		                    push   acc           ;r0 op stack
 1362: 1
 1363: 1  03AF	12 03 34	                    lcall  i2cstart      ;genereer startconditie
 1364: 1  03B2	E5 83		                    mov    a,dph         ;neem adresbyte
 1365: 1  03B4	12 03 46	                    lcall  i2coutbyte    ;en verstuur naar slave
 1366: 1  03B7	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1367: 1  03B9	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1368: 1  03BB	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1369: 1  03BD	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1370: 1			;10 bit adressering!
 1371: 1  03C0	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1372: 1  03C2	12 03 46	                    lcall  i2coutbyte    ;en verstuur naar slave
 1373: 1  03C5	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1374: 1			;7 bit adressering!
 1375: 1  03C7	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1376: 1  03C8	12 03 46	                    lcall  i2coutbyte    ;en verstuur naar slave
 1377: 1  03CB	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1378: 1  03CD	08		                    inc    r0            ;volgende byte
 1379: 1  03CE	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1380: 1  03D1	12 03 3D	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1381: 1  03D4	D0 E0		                    pop    acc
 1382: 1  03D6	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1383: 1  03D7	D0 D0		                    pop    psw
 1384: 1  03D9	C3		                    clr    c             ;alles is ok!
 1385: 1  03DA	D0 E0		                    pop    acc
 1386: 1  03DC	22		                    ret
 1387: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1388: 1  03DD	12 03 3D	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1389: 1  03E0	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1390: 1  03E2	D0 D0		                    pop    psw
 1391: 1  03E4	D3		                    setb   c            ;terug met foutmelding
 1392: 1  03E5	D0 E0		                    pop    acc
 1393: 1  03E7	22		                    ret
 1394: 1
 1395: 1			;******************************************************************************
 1396: 1			; i2crcvdata
 1397: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1398: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1399: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1400: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1401: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1402: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1403: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1404: 1			;
 1405: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1406: 1			; is een pointer naar de start van dit ontvangen datablok.
 1407: 1			;
 1408: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1409: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1410: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1411: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1412: 1			;
 1413: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1414: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1415: 1			;               het adres, wordt de CY bit geset bij return.
 1416: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1417: 1			;
 1418: 1			; Deze routine vernietigt verder niets...
 1419: 1			;******************************************************************************
 1420: 1  03E8	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1421: 1  03EA	C0 D0		                    push    psw
 1422: 1  03EC	E8		                    mov     a,r0            ;r0 op stack
 1423: 1  03ED	C0 E0		                    push    acc
 1424: 1
 1425: 1  03EF	12 03 34	                    lcall   i2cstart        ;genereer startconditie
 1426: 1  03F2	E5 83		                    mov     a,dph           ;neem adresbyte
 1427: 1  03F4	12 03 46	                    lcall   i2coutbyte      ;en verstuur naar slave
 1428: 1  03F7	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1429: 1  03F9	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1430: 1  03FB	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1431: 1  03FD	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1432: 1			;10 bit adressering!
 1433: 1  0400	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1434: 1  0402	12 03 46	                    lcall   i2coutbyte      ;en verstuur naar slave
 1435: 1  0405	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1436: 1			;7 bit adressering!
 1437: 1
 1438: 1  0407	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1439: 1  040A	12 03 87	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1440: 1  040D	F6		                    mov     @r0,a           ;en deze ook bewaren
 1441: 1  040E	80 07		                    sjmp    i2crcvdata3
 1442: 1  0410	12 03 66	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1443: 1  0413	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1444: 1  0414	08		                    inc     r0              ;pointer verhogen
 1445: 1  0415	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1446: 1
 1447: 1  0417	12 03 3D	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1448: 1  041A	D0 E0		                    pop     acc
 1449: 1  041C	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1450: 1  041D	D0 D0		                    pop     psw
 1451: 1  041F	C3		                    clr     c               ;alles is ok!
 1452: 1  0420	D0 E0		                    pop     acc
 1453: 1  0422	22		                    ret
 1454: 1			;fout: geen ack gekregen bij het versturen van het adres
 1455: 1  0423	12 03 3D	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1456: 1  0426	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1457: 1  0428	D0 D0		                    pop        psw
 1458: 1  042A	D3		                    setb    c               ;terug met foutmelding
 1459: 1  042B	D0 E0		                    pop        acc
 1460: 1  042D	22		                    ret
 1461: 1
 1462: 1
 1463: 1			;******************************************************************************
 1464: 1			;
 1465: 1			; porttolcd
 1466: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1467: 1			; scherm stuurt via de port expander.
 1468: 1			;
 1469: 1			; Gebruikt geen registers
 1470: 1			;
 1471: 1			;******************************************************************************
 1472: 1
 1473: 1  042E	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1474: 1  0430	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1475: 1  0432	12 03 34	              lcall  i2cstart      ;vertrokken
 1476: 1			ifdef    pcf8574
 1477: 1			              mov    a,#01000000b  ;schrijven naar expander
 1478: 1			endif
 1479: 1			ifdef    pcf8574A
 1480: 1  0435	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1481: 1			endif
 1482: 1  0437	12 03 46	              lcall  i2coutbyte    ;weg er mee
 1483: 1  043A	E5 F0		              mov    a,b           ;data verzenden
 1484: 1  043C	12 03 46	              lcall  i2coutbyte
 1485: 1  043F	12 03 3D	              lcall  i2cstop       ;transactie sluiten
 1486: 1  0442	D0 D0		              pop    psw
 1487: 1  0444	D0 E0		              pop    acc
 1488: 1  0446	22		              ret
 1489: 1
 1490: 1			;******************************************************************************
 1491: 1			;
 1492: 1			; lcdtoport
 1493: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1494: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1495: 1			; aansturen van de buzzer en backlight.
 1496: 1			;
 1497: 1			; output: b register
 1498: 1			;
 1499: 1			;******************************************************************************
 1500: 1
 1501: 1  0447	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1502: 1  0449	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1503: 1  044B	12 03 34	              lcall  i2cstart      ;vertrokken
 1504: 1			ifdef    pcf8574
 1505: 1			              mov    a,#01000000b  ;schrijven naar expander
 1506: 1			endif
 1507: 1			ifdef    pcf8574A
 1508: 1  044E	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1509: 1			endif
 1510: 1  0450	12 03 46	              lcall  i2coutbyte    ;weg er mee
 1511: 1  0453	12 03 87	              lcall  i2cinbytenack ;data inlezen
 1512: 1  0456	12 03 3D	              lcall  i2cstop
 1513: 1  0459	F5 F0		              mov    b,a
 1514: 1  045B	D0 D0		              pop    psw
 1515: 1  045D	D0 E0		              pop    acc
 1516: 1  045F	22		              ret
 1517: 1
 1518: 1			;******************************************************************************
 1519: 1			;
 1520: 1			; lcdlighton
 1521: 1			; Dit is een subroutine die de backlight inschakeld
 1522: 1			;
 1523: 1			; Gebruikt geen registers
 1524: 1			;
 1525: 1			;******************************************************************************
 1526: 1
 1527: 1  0460	C0 F0		lcdlighton:   push   b
 1528: 1  0462	12 04 47	              lcall  lcdtoport     ;expander lezen
 1529: 1  0465	C2 F6		              clr    b.6           ;licht aan doen
 1530: 1  0467	12 04 2E	              lcall  porttolcd     ;expander schrijven
 1531: 1  046A	D0 F0		              pop    b
 1532: 1  046C	22		              ret
 1533: 1
 1534: 1
 1535: 1			;******************************************************************************
 1536: 1			;
 1537: 1			; lcdlightoff
 1538: 1			; Dit is een subroutine die de backlight uitschakeld
 1539: 1			;
 1540: 1			; Gebruikt geen registers
 1541: 1			;
 1542: 1			;******************************************************************************
 1543: 1
 1544: 1  046D	C0 F0		lcdlightoff:  push   b
 1545: 1  046F	12 04 47	              lcall  lcdtoport     ;expander lezen
 1546: 1  0472	D2 F6		              setb   b.6           ;licht uit doen
 1547: 1  0474	12 04 2E	              lcall  porttolcd     ;expander schrijven
 1548: 1  0477	D0 F0		              pop    b
 1549: 1  0479	22		              ret
 1550: 1
 1551: 1			;******************************************************************************
 1552: 1			;
 1553: 1			; lcdbuzon
 1554: 1			; Dit is een subroutine die de buzzer inschakeld
 1555: 1			;
 1556: 1			; Gebruikt geen registers
 1557: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1558: 1			;******************************************************************************
 1559: 1
 1560: 1  047A	C0 F0		lcdbuzon:     push   b
 1561: 1  047C	12 04 47	              lcall  lcdtoport     ;expander lezen
 1562: 1  047F	C2 F7		              clr    b.7           ;buzzer aan doen
 1563: 1  0481	12 04 2E	              lcall  porttolcd     ;expander schrijven
 1564: 1  0484	D0 F0		              pop    b
 1565: 1  0486	22		              ret
 1566: 1
 1567: 1			;******************************************************************************
 1568: 1			;
 1569: 1			; lcdbuzoff
 1570: 1			; Dit is een subroutine die de buzzer uitschakeld
 1571: 1			;
 1572: 1			; Gebruikt geen registers
 1573: 1			;
 1574: 1			;******************************************************************************
 1575: 1
 1576: 1  0487	C0 F0		lcdbuzoff:    push   b
 1577: 1  0489	12 04 47	              lcall  lcdtoport     ;expander lezen
 1578: 1  048C	D2 F7		              setb   b.7           ;buzzer aan doen
 1579: 1  048E	12 04 2E	              lcall  porttolcd     ;expander schrijven
 1580: 1  0491	D0 F0		              pop    b
 1581: 1  0493	22		              ret
 1582: 1
 1583: 1			endif    ;einde aduc_i2c
 1584: 1			;******************************************************************************
 1585: 1
 1586: 1
 1587: 1
 1588: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1589: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1590: 1			;
 1591: 1			; ADuCsio.inc
 1592: 1			; Is een include file voor de ADuC832 microcontroller.
 1593: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1594: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1595: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1596: 1			; afwijking van de standaard routines is de initsio subroutine.
 1597: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1598: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1599: 1			; zijn.
 1600: 1			;
 1601: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1602: 1			;
 1603: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1604: 1
 1605: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1606: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1607: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1608: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1609: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1610: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1611: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1612: 1
 1613: 1  0494	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1614: 1			                                                        ;van het scherm
 1615: 1
 1616: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1617: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1618: 1
 1619: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1620: 1			;
 1621: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1622: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1623: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1624: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1625: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1626: 1			;
 1627: 1			; de routine gebruikt de psw
 1628: 1			;
 1629: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1630: 1
 1631: 1  0498	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1632: 1  049A	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1633: 1  049C	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1634: 1  049E	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1635: 1  04A1	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1636: 1
 1637: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1638: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1639: 1
 1640: 1  04A3	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1641: 1  04A6	F4		              cpl    a             ;bitbangen om laten uit te komen
 1642: 1  04A7	C3		              clr    c             ;verder doen
 1643: 1  04A8	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1644: 1  04AA	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1645: 1  04AC	24 80		              add    a,#080h       ;nu alles in orde
 1646: 1  04AE	F5 9E		              mov    t3con,a       ;baud rate klaar
 1647: 1  04B0	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1648: 1  04B3	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1649: 1  04B4	D0 E0		              pop    acc
 1650: 1  04B6	22		              ret
 1651: 1
 1652: 1  04B7	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1653: 1  04B8	D0 E0		              pop    acc
 1654: 1  04BA	22		              ret
 1655: 1
 1656: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1657: 1			;
 1658: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1659: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1660: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1661: 1			;
 1662: 1			; de routine gebruikt geen registers.
 1663: 1			;
 1664: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1665: 1
 1666: 1  04BB	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1667: 1  04BD	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1668: 1  04C0	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1669: 1  04C2	22		              RET

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1670: 1
 1671: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1672: 1			;
 1673: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1674: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1675: 1			;
 1676: 1			; de routine gebruikt geen registers.
 1677: 1			;
 1678: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1679: 1
 1680: 1  04C3	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1681: 1  04C5	C0 D0		              push   psw
 1682: 1  04C7	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1683: 1  04C9	12 05 D5	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1684: 1  04CC	12 04 BB	              LCALL  OUTCHAR       ;VERSTUREN
 1685: 1  04CF	12 05 1C	              LCALL  XONXOFF       ;FLOW CONTROL
 1686: 1  04D2	D0 D0		              pop    psw           ;registers herstellen
 1687: 1  04D4	D0 E0		              pop    acc
 1688: 1  04D6	22		              RET
 1689: 1
 1690: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1691: 1			;
 1692: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1693: 1			; WORDT XONXOFF GEBRUIKT.
 1694: 1			;
 1695: 1			; de routine gebruikt geen registers.
 1696: 1			;
 1697: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1698: 1
 1699: 1  04D7	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1700: 1  04D9	C0 D0		              push   psw
 1701: 1  04DB	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1702: 1  04DD	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1703: 1  04DE	12 04 C3	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1704: 1  04E1	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1705: 1  04E3	12 04 C3	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1706: 1  04E6	D0 D0		              pop    psw           ;registers herstellen
 1707: 1  04E8	D0 E0		              pop    acc
 1708: 1  04EA	22		              RET
 1709: 1
 1710: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1711: 1			;
 1712: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1713: 1			; VAN DE CURSOR.
 1714: 1			;
 1715: 1			; de routine gebruikt geen registers.
 1716: 1			;
 1717: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1718: 1
 1719: 1  04EB	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1720: 1  04ED	C0 D0		              push   psw
 1721: 1  04EF	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1722: 1  04F1	12 04 D7	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1723: 1  04F4	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1724: 1  04F6	12 04 D7	              LCALL  OUTBYTE       ;WEG ER MEE
 1725: 1  04F9	D0 D0		              pop    psw           ;registers herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1726: 1  04FB	D0 E0		              pop    acc
 1727: 1  04FD	22		              RET                  ;EINDE
 1728: 1
 1729: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1730: 1			;
 1731: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1732: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1733: 1			;
 1734: 1			; de routine gebruikt geen registers.
 1735: 1			;
 1736: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1737: 1
 1738: 1  04FE	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1739: 1  0500	C0 D0		              push   psw
 1740: 1  0502	C0 82		              push   dpl
 1741: 1  0504	C0 83		              push   dph
 1742: 1  0506	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1743: 1  0507	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1744: 1  0508	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1745: 1  050A	12 04 BB	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1746: 1  050D	12 05 1C	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1747: 1  0510	A3		              INC    DPTR          ;DPTR AANPASSEN
 1748: 1  0511	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1749: 1  0513	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1750: 1  0515	D0 82		              pop    dpl
 1751: 1  0517	D0 D0		              pop    psw
 1752: 1  0519	D0 E0		              pop    acc
 1753: 1  051B	22		              RET                  ;EINDE ROUTINE
 1754: 1
 1755: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1756: 1			;
 1757: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1758: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1759: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1760: 1			; VERDER DOORGEGEVEN.
 1761: 1			;
 1762: 1			; de routine gebruikt geen registers.
 1763: 1			;
 1764: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1765: 1
 1766: 1  051C	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1767: 1  051E	C0 D0		              push   psw
 1768: 1  0520	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1769: 1  0523	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 1770: 1  0525	D0 E0		              pop    acc
 1771: 1  0527	22		              RET                  ;ANDERS EINDE
 1772: 1  0528	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1773: 1  052A	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1774: 1  052D	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1775: 1  0530	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1776: 1
 1777: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1778: 1			;
 1779: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1780: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1781: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1782: 1			; de routine gebruikt de accu.
 1783: 1			;
 1784: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1785: 1
 1786: 1  0532	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 1787: 1  0535	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 1788: 1  0537	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1789: 1  0539	22		              RET
 1790: 1
 1791: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1792: 1			;
 1793: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1794: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1795: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 1796: 1			; DE CARRY OP 1 GEZET WORDEN.
 1797: 1			;
 1798: 1			; De routine gebruikt de accu EN PSW.
 1799: 1			;
 1800: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1801: 1
 1802: 1  053A	C0 F0		INBYTE:       PUSH     B
 1803: 1  053C	12 05 32	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1804: 1  053F	12 05 C8	              LCALL  LOWUPTR
 1805: 1  0542	12 05 E3	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1806: 1  0545	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1807: 1  0547	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1808: 1  0548	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1809: 1  054A	12 05 32	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1810: 1  054D	12 05 C8	              LCALL  LOWUPTR
 1811: 1  0550	12 05 E3	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1812: 1  0553	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1813: 1  0555	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1814: 1  0557	D0 F0		INBYTE1:      POP     B
 1815: 1  0559	22		              RET
 1816: 1
 1817: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1818: 1			;
 1819: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1820: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1821: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1822: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1823: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1824: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1825: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 1826: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1827: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1828: 1			; bepalen.
 1829: 1			;
 1830: 1			; De routine gebruikt  r0 .
 1831: 1			;
 1832: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1833: 1
 1834: 1  055A	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1835: 1  055C	C0 D0		              push   psw
 1836: 1  055E	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1837: 1  0560	12 05 32	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1838: 1  0563	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1839: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 1840: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1841: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1842: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 1843: 1			; GEVOERD.
 1844: 1  0565	12 05 C8	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1845: 1  0568	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1846: 1  056B	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1847: 1  056C	D0 D0		              pop    psw                  ;registers herstellen
 1848: 1  056E	D0 E0		              pop    acc
 1849: 1  0570	22		              RET                         ;EINDE VAN DE ROUTINE
 1850: 1
 1851: 1  0571	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 1852: 1  0574	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1853: 1  0577	74 07		INBUFA4:      MOV    A,#BEEP
 1854: 1  0579	12 04 BB	INBUFA7:      LCALL  OUTCHAR
 1855: 1  057C	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1856: 1
 1857: 1  057E	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1858: 1  057F	90 04 94	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1859: 1  0582	12 04 FE	              LCALL  OUTMSGA
 1860: 1  0585	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 1861: 1  0587	12 05 BA	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1862: 1  058A	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1863: 1  058C	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1864: 1  058F	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1865: 1  0591	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1866: 1  0592	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1867: 1  0593	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1868: 1
 1869: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1870: 1			;
 1871: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1872: 1			;
 1873: 1			; De routine gebruikt niets.
 1874: 1			;
 1875: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1876: 1
 1877: 1  0595	C0 E0		BDELETE:      PUSH     ACC
 1878: 1  0597	C0 D0		              PUSH     PSW
 1879: 1  0599	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1880: 1  059A	C0 E0		              PUSH     ACC
 1881: 1  059C	E9		              MOV     A,R1
 1882: 1  059D	C0 E0		              PUSH     ACC
 1883: 1  059F	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1884: 1  05A1	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1885: 1  05A3	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1886: 1  05A4	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1887: 1  05A7	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1888: 1  05A8	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1889: 1  05AB	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1890: 1  05AD	F9		              MOV     R1,A
 1891: 1  05AE	D0 E0		              POP     ACC
 1892: 1  05B0	F8		              MOV     R0,A
 1893: 1  05B1	D0 D0		              POP     PSW

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1894: 1  05B3	D0 E0		              POP     ACC
 1895: 1  05B5	22		              RET                         ;EINDE VAN DE ROUTINE
 1896: 1  05B6	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1897: 1  05B7	09		              INC    R1
 1898: 1  05B8	80 ED		              SJMP   BDELETE3
 1899: 1
 1900: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1901: 1			;
 1902: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1903: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1904: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1905: 1			; AANZIEN.
 1906: 1			;
 1907: 1			; De routine gebruikt de accu en de psw.
 1908: 1			;
 1909: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1910: 1
 1911: 1  05BA	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 1912: 1  05BD	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 1913: 1  05BF	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 1914: 1  05C2	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 1915: 1  05C4	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 1916: 1  05C5	22		              RET
 1917: 1  05C6	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 1918: 1  05C7	22		              RET
 1919: 1
 1920: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1921: 1			;
 1922: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 1923: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 1924: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 1925: 1			; AANGEPAST WORDEN.
 1926: 1			;
 1927: 1			; De routine gebruikt de accu en psw .
 1928: 1			;
 1929: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1930: 1
 1931: 1  05C8	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 1932: 1  05CB	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 1933: 1  05CD	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 1934: 1  05D0	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 1935: 1  05D2	94 20		              SUBB   A,#020H              ;OMZETTING
 1936: 1  05D4	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 1937: 1
 1938: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1939: 1			;
 1940: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 1941: 1			; ASCII CODE.
 1942: 1			;
 1943: 1			; De routine gebruikt de accu .
 1944: 1			;
 1945: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1946: 1
 1947: 1  05D5	C0 D0		BATRANS:      PUSH   PSW
 1948: 1  05D7	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 1949: 1  05DA	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1950: 1  05DC	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 1951: 1  05DE	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 1952: 1  05E0	D0 D0		              POP     PSW
 1953: 1  05E2	22		              RET
 1954: 1
 1955: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1956: 1			;
 1957: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 1958: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 1959: 1			; GEVAL WORDT DE CARRY GEZET.
 1960: 1			;
 1961: 1			; De routine gebruikt de accu en de psw.
 1962: 1			;
 1963: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1964: 1
 1965: 1  05E3	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 1966: 1  05E4	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 1967: 1  05E6	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 1968: 1  05E8	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 1969: 1  05EB	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 1970: 1  05ED	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 1971: 1  05EF	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 1972: 1  05F1	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 1973: 1  05F4	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 1974: 1  05F5	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 1975: 1  05F7	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 1976: 1  05F8	22		ASCBINTRANS1: RET
 1977: 1
 1978: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1979: 1			;
 1980: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 1981: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 1982: 1			;
 1983: 1			; De routine gebruikt de accu en de psw.
 1984: 1			;
 1985: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1986: 1
 1987: 1  05F9	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 1988: 1  05FA	12 05 E3	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 1989: 1  05FD	22		              RET                         ;EINDE OMZETTING
 1990: 1
 1991: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1992: 1			;
 1993: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 1994: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 1995: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 1996: 1			;
 1997: 1			; De routine gebruikt de accu, r0.
 1998: 1			;
 1999: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2000: 1
 2001: 1  05FE	C0 F0		ASCII2:       PUSH   B
 2002: 1  0600	12 05 F9	              LCALL  ASCII1               ;OMZETTEN
 2003: 1  0603	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 2004: 1  0605	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 2005: 1  0606	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2006: 1  0608	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 2007: 1  0609	12 05 F9	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 2008: 1  060C	40 02		              JC     ASCII21               ;WEG ALS C=1
 2009: 1  060E	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 2010: 1  0610	D0 F0		ASCII21:      POP     B
 2011: 1  0612	22		              RET
 2012: 1
 2013: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2014: 1			;
 2015: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2016: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2017: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2018: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2019: 1			;
 2020: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2021: 1			;
 2022: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2023: 1
 2024: 1  0613	12 05 FE	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2025: 1  0616	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2026: 1  0618	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2027: 1  061A	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2028: 1  061B	12 05 FE	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2029: 1  061E	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2030: 1  0620	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2031: 1  0622	22		ASCII41:      RET
 2032: 1
 2033: 1			endif        ;einde van aduc_sio
 2034: 1			;*******************************************************************************
 2035: 1
 2036: 1
 2037: 1			ifdef        aduc_math    ;rekenkundige routines
 2038: 1			;*******************************************************************************
 2039: 1			; aduc_math
 2040: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2041: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2042: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2043: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2044: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2045: 1			; zoals aangegeven:
 2046: 1			;
 2047: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2048: 1			;        ---------------------------
 2049: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2050: 1			;        ---------------------------                             statusbit = f0
 2051: 1			;        ---------------------------
 2052: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2053: 1			;        ---------------------------
 2054: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2055: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2056: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2057: 1			; return en moeten hiervoor worden gereserveerd.
 2058: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2059: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2060: 1			; en unsigned getallen.
 2061: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2062: 1			; Beschikbare routines:
 2063: 1			;
 2064: 1			; Conversie routines:
 2065: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2066: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2067: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2068: 1			;
 2069: 1			; Som:
 2070: 1			; s_add16, add16, s_add32, add32
 2071: 1			;
 2072: 1			; Verschil:
 2073: 1			; s_sub16, sub16, s_sub32, sub32
 2074: 1			;
 2075: 1			; Vermenigvuldigen:
 2076: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2077: 1			;
 2078: 1			; Delen:
 2079: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2080: 1			;
 2081: 1			; Vemenigvuldig met factor:
 2082: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2083: 1			;
 2084: 1			; Vierkantswortel:
 2085: 1			; sqrt32, s_sqrt32
 2086: 1			;
 2087: 1			; Schuiven:
 2088: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2089: 1			;
 2090: 1			; Vergelijken:
 2091: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2092: 1			;
 2093: 1			; Tabel lookup:
 2094: 1			; table_lu
 2095: 1			;
 2096: 1			; Gonemetrische functies:
 2097: 1			; Cordic = sinus,cosinus
 2098: 1			;
 2099: 1			;*******************************************************************************
 2100: 1
 2101: 1			;*******************************************************************************
 2102: 1			;
 2103: 1			; bcdhex8     (45,77us @16.777216MHz)
 2104: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2105: 1			; naar een 2's complement hex getal.
 2106: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2107: 1			; een waarde 00h tot 63h.
 2108: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2109: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2110: 1			; input:      R0 = waarde tussen 00h en 99h.
 2111: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2112: 1			; output:     R0 = 2's complement waarde
 2113: 1			;             cy=1 bij out of range van r0
 2114: 1			;             cy=0 bij conversie ok
 2115: 1			; vernietigt: niets
 2116: 1			;*******************************************************************************
 2117: 1  0623	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2118: 1  0625	C0 D0		              push   psw
 2119: 1  0627	C0 F0		              push   b
 2120: 1
 2121: 1  0629	E8		              mov    a,r0                 ;neem te converteren waarde
 2122: 1  062A	F5 F0		              mov    b,a
 2123: 1  062C	54 0F		              anl    a,#0fh
 2124: 1  062E	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2125: 1  0631	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2126: 1  0633	E5 F0		              mov    a,b
 2127: 1  0635	54 F0		              anl    a,#0f0h
 2128: 1  0637	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2129: 1  063A	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2130: 1
 2131: 1  063C	E8		              mov    a,r0
 2132: 1  063D	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2133: 1  063F	C4		              swap   a
 2134: 1  0640	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2135: 1  0643	A4		              mul    ab
 2136: 1  0644	F5 F0		              mov    b,a                  ;bewaar dit product even
 2137: 1  0646	E8		              mov    a,r0
 2138: 1  0647	54 0F		              anl    a,#00fh
 2139: 1  0649	F8		              mov    r0,a
 2140: 1  064A	E5 F0		              mov    a,b
 2141: 1  064C	28		              add    a,r0                 ;eenheden er bijtellen
 2142: 1  064D	F8		              mov    r0,a
 2143: 1
 2144: 1  064E	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2145: 1  0650	12 07 51	              lcall  magsig8              ;omzetten naar 2's complement
 2146: 1
 2147: 1  0653	D0 F0		              pop    b
 2148: 1  0655	D0 D0		              pop    psw
 2149: 1  0657	C2 D7		              clr    cy                   ;geen fout
 2150: 1  0659	D0 E0		              pop    acc
 2151: 1  065B	22		              ret
 2152: 1
 2153: 1  065C	D0 F0		bcdhex82:     pop    b
 2154: 1  065E	D0 D0		              pop    psw
 2155: 1  0660	D2 D7		              setb   cy                   ;fout! r0 out of range
 2156: 1  0662	D0 E0		              pop    acc
 2157: 1  0664	22		              ret
 2158: 1
 2159: 1			;*******************************************************************************
 2160: 1			;
 2161: 1			; hexbcd8     (38,4us @16.777216MHz)
 2162: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2163: 1			; naar een 8bit bcd getal.
 2164: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2165: 1			; bcdgetal van 00h tot +99h.
 2166: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2167: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2168: 1			; bcdgetal 00h tot -99h
 2169: 1			;
 2170: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2171: 1			;
 2172: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2173: 1			;              F0 = tekenbit, 1=negatief, 0=positief.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2174: 1			;             cy=1 bij out of range van r0
 2175: 1			;             cy=0 bij conversie ok
 2176: 1			; vernietigt: niets
 2177: 1			;*******************************************************************************
 2178: 1  0665	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2179: 1  0667	C0 D0		                push    psw
 2180: 1  0669	C0 F0		                push    b
 2181: 1  066B	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2182: 1  066C	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2183: 1  066F	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2184: 1  0671	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2185: 1  0674	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2186: 1  0676	D0 F0		                pop     b
 2187: 1  0678	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2188: 1  067A	D3		                setb    c
 2189: 1  067B	D0 E0		                pop     acc
 2190: 1  067D	22		                ret
 2191: 1  067E	12 08 19	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2192: 1  0681	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2193: 1  0682	75 F0 0A	                mov     b,#10
 2194: 1  0685	84		                div     ab
 2195: 1  0686	C4		                swap    a
 2196: 1  0687	25 F0		                add     a,b
 2197: 1  0689	F8		                mov     r0,a
 2198: 1  068A	D0 F0		                pop     b               ;registers herstellen
 2199: 1  068C	D0 E0		                pop     acc             ;psw van stack halen
 2200: 1  068E	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2201: 1  0690	92 E5		                mov     acc.5,c
 2202: 1  0692	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2203: 1  0694	C3		                clr     c               ;status: conversie ok
 2204: 1  0695	D0 E0		                pop     acc
 2205: 1  0697	22		                ret
 2206: 1
 2207: 1
 2208: 1
 2209: 1			;*******************************************************************************
 2210: 1			;
 2211: 1			; bcdhex16    (86,6us @16.777216MHz)
 2212: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2213: 1			; omzetten naar een 2's complement hex getal.
 2214: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2215: 1			; naareen waarde 0000h tot 270fh.
 2216: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2217: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2218: 1			; van -270fh).
 2219: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2220: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2221: 1			; output:     R1,R0 = 2's complement waarde
 2222: 1			;             cy=1 bij out of range van r1,r0
 2223: 1			;             cy=0 bij conversie ok
 2224: 1			; vernietigt: niets
 2225: 1			;*******************************************************************************
 2226: 1  0698	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2227: 1  069A	C0 D0		              push   psw
 2228: 1  069C	C0 F0		              push   b
 2229: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2230: 1  069E	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2231: 1  069F	F5 F0		              mov    b,a
 2232: 1  06A1	54 0F		              anl    a,#0fh
 2233: 1  06A3	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2234: 1  06A6	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2235: 1  06A8	E5 F0		              mov    a,b
 2236: 1  06AA	54 F0		              anl    a,#0f0h
 2237: 1  06AC	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2238: 1  06AF	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2239: 1  06B1	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2240: 1  06B2	F5 F0		              mov    b,a
 2241: 1  06B4	54 0F		              anl    a,#0fh
 2242: 1  06B6	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2243: 1  06B9	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2244: 1  06BB	E5 F0		              mov    a,b
 2245: 1  06BD	54 F0		              anl    a,#0f0h
 2246: 1  06BF	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2247: 1  06C2	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2248: 1
 2249: 1  06C4	E8		              mov    a,r0                  ;neem low byte voor conversie
 2250: 1  06C5	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2251: 1  06C7	C0 E0		              push   acc                   ;en even bewaren
 2252: 1
 2253: 1  06C9	E8		              mov    a,r0
 2254: 1  06CA	C4		              swap   a
 2255: 1  06CB	54 0F		              anl    a,#00fh              ;tientallen
 2256: 1  06CD	75 F0 0A	              mov    b,#00ah              ;maal tien
 2257: 1  06D0	A4		              mul    ab                   ;
 2258: 1  06D1	D0 F0		              pop    b                    ;neem eenheden
 2259: 1  06D3	25 F0		              add    a,b                  ;tel bij tientallen
 2260: 1  06D5	C0 E0		              push   acc                  ;weer bewaren
 2261: 1
 2262: 1  06D7	E9		              mov    a,r1                 ;neem high byte voor conversie
 2263: 1  06D8	54 F0		              anl    a,#0f0h
 2264: 1  06DA	C4		              swap   a
 2265: 1  06DB	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2266: 1
 2267: 1  06DD	E9		              mov    a,r1                  ;neem high byte voor conversie
 2268: 1  06DE	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2269: 1  06E0	75 F0 64	              mov    b,#100d              ;en maal honderd
 2270: 1  06E3	A4		              mul    ab
 2271: 1  06E4	A9 F0		              mov    r1,b
 2272: 1  06E6	F8		              mov    r0,a
 2273: 1
 2274: 1  06E7	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2275: 1  06E9	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2276: 1  06EC	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2277: 1  06ED	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2278: 1  06F0	A4		              mul    ab
 2279: 1  06F1	28		              add    a,r0                 ;tel honderdtallen bij de
 2280: 1  06F2	F8		              mov    r0,a                 ;duizendtallen
 2281: 1  06F3	E9		              mov    a,r1
 2282: 1  06F4	35 F0		              addc   a,b
 2283: 1  06F6	F9		              mov    r1,a
 2284: 1
 2285: 1  06F7	D0 E0		              pop    acc                  ;neem de tientallen en eenheden

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2286: 1  06F9	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2287: 1  06FA	F8		              mov    r0,a                 ;duizendtallen
 2288: 1  06FB	74 00		              mov    a,#000h
 2289: 1  06FD	39		              addc   a,r1
 2290: 1  06FE	F9		              mov    r1,a                 ;omzetting klaar
 2291: 1
 2292: 1  06FF	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2293: 1  0701	12 07 85	              lcall  magsig16             ;omzetten naar 2's complement
 2294: 1
 2295: 1  0704	D0 F0		              pop    b
 2296: 1  0706	D0 D0		              pop    psw
 2297: 1  0708	C2 D7		              clr    cy                   ;geen fout
 2298: 1  070A	D0 E0		              pop    acc
 2299: 1  070C	22		              ret
 2300: 1
 2301: 1  070D	D0 F0		bcdhex162:    pop    b
 2302: 1  070F	D0 D0		              pop    psw
 2303: 1  0711	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2304: 1  0713	D0 E0		              pop    acc
 2305: 1  0715	22		              ret
 2306: 1
 2307: 1			;*******************************************************************************
 2308: 1			;
 2309: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2310: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2311: 1			; naar een 24bit bcd getal.
 2312: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2313: 1			; bcdgetal van 000000h tot +032767h.
 2314: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2315: 1			; naar een bcdgetal 000000h tot -032768h
 2316: 1			;
 2317: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2318: 1			;
 2319: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2320: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2321: 1			;
 2322: 1			; vernietigt: niets
 2323: 1			;*******************************************************************************
 2324: 1			;
 2325: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2326: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2327: 1			; naar een 24bit bcd getal.
 2328: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2329: 1			; bcdgetal van 000000h tot 065535h.
 2330: 1			;
 2331: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2332: 1			;
 2333: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2334: 1			;
 2335: 1			; vernietigt: niets
 2336: 1			;*******************************************************************************
 2337: 1  0716	12 08 4B	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2338: 1  0719	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2339: 1  071B	C0 D0		                push   psw
 2340: 1  071D	C0 F0		                push   b
 2341: 1  071F	C0 82		                push   dpl

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2342: 1
 2343: 1  0721	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2344: 1  0724	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2345: 1  0726	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2346: 1  0728	12 0B FA	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2347: 1  072B	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2348: 1  072C	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2349: 1			                                        ;dus eerst eenheden, dan tientallen
 2350: 1			                                        ;honderdtallen, duizendtallen en
 2351: 1			                                        ;tienduizendtallen
 2352: 1  072E	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2353: 1
 2354: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2355: 1
 2356: 1  0731	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2357: 1  0733	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2358: 1  0734	D0 E0		                pop    acc              ;duizendtallen ophalen
 2359: 1  0736	C4		                swap   a                ;en combineren met de
 2360: 1  0737	F5 82		                mov    dpl,a
 2361: 1  0739	D0 E0		                pop    acc              ;honderdtallen van de stack
 2362: 1  073B	25 82		                add    a,dpl
 2363: 1  073D	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2364: 1  073E	D0 E0		                pop    acc              ;tientallen van de stack halen
 2365: 1  0740	C4		                swap   a
 2366: 1  0741	F5 82		                mov    dpl,a
 2367: 1  0743	D0 E0		                pop    acc              ;en combineren met de eenheden
 2368: 1  0745	25 82		                add    a,dpl
 2369: 1  0747	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2370: 1
 2371: 1  0748	D0 82		                pop    dpl              ;registers herstellen
 2372: 1  074A	D0 F0		                pop    b
 2373: 1  074C	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2374: 1  074E	D0 E0		                pop    acc
 2375: 1  0750	22		                ret
 2376: 1
 2377: 1			;*******************************************************************************
 2378: 1			; magsig8        (13,6us @16.777216MHz)
 2379: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2380: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2381: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2382: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2383: 1			;           (f0 en f1 zijn 1 als negatief)
 2384: 1			;
 2385: 1			; output:   r0 = 2's complement
 2386: 1			;
 2387: 1			; vernietigt: niets
 2388: 1			;*******************************************************************************
 2389: 1
 2390: 1  0751	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2391: 1  0753	C0 D0		               push   psw
 2392: 1  0755	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2393: 1  0758	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2394: 1  075B	80 09		               sjmp   magsig8c
 2395: 1
 2396: 1  075D	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2397: 1  0760	80 04		               sjmp   magsig8c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2398: 1
 2399: 1  0762	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2400: 1  0763	F4		               cpl    a                  ;complementeer abs waarde
 2401: 1  0764	04		               inc    a                  ;r0 = complement(r0)+1
 2402: 1  0765	F8		               mov    r0,a               ;bewaar in 2's complement
 2403: 1  0766	D0 D0		magsig8c:      pop    psw
 2404: 1  0768	D0 E0		               pop    acc
 2405: 1  076A	22		               ret                        ;klaar
 2406: 1
 2407: 1			;*******************************************************************************
 2408: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2409: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2410: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2411: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2412: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2413: 1			;           (f0 en f1 zijn 1 als negatief)
 2414: 1			;
 2415: 1			; output:   r4 = 2's complement
 2416: 1			;
 2417: 1			; vernietigt: niets
 2418: 1			;*******************************************************************************
 2419: 1
 2420: 1  076B	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2421: 1  076D	C0 D0		               push    psw
 2422: 1  076F	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2423: 1  0772	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2424: 1  0775	80 EF		               sjmp    magsig8c
 2425: 1
 2426: 1  0777	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2427: 1  077A	80 04		               sjmp    magsig8acc1c
 2428: 1
 2429: 1  077C	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2430: 1  077D	F4		               cpl     a                 ;complementeer abs waarde
 2431: 1  077E	04		               inc     a                 ;r4 = complement(r0)+1
 2432: 1  077F	FC		               mov     r4,a              ;bewaar in 2's complement
 2433: 1  0780	D0 D0		magsig8acc1c:  pop     psw
 2434: 1  0782	D0 E0		               pop     acc
 2435: 1  0784	22		               ret                       ;klaar
 2436: 1
 2437: 1			;*******************************************************************************
 2438: 1			; magsig16        (16,6us @16.777216MHz)
 2439: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2440: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2441: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2442: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2443: 1			;           (f0 en f1 zijn 1 als negatief)
 2444: 1			;
 2445: 1			; output:   r1,r0 = 2's complement
 2446: 1			;
 2447: 1			; vernietigt: niets
 2448: 1			;*******************************************************************************
 2449: 1  0785	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2450: 1  0787	C0 D0		               push    psw
 2451: 1  0789	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2452: 1  078C	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2453: 1  078F	80 0F		               sjmp    magsig16c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2454: 1
 2455: 1  0791	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2456: 1  0794	80 0A		               sjmp    magsig16c
 2457: 1
 2458: 1  0796	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2459: 1  0797	F4		               cpl     a                ;complementeer het dan
 2460: 1  0798	24 01		               add     a, #1            ;en tel er 1 bij
 2461: 1  079A	F8		               mov     r0,a
 2462: 1  079B	E9		               mov     a,r1             ;neem volgende byte
 2463: 1  079C	F4		               cpl     a                ;complementeer en tel carry erbij
 2464: 1  079D	34 00		               addc    a,#0
 2465: 1  079F	F9		               mov     r1,a
 2466: 1  07A0	D0 D0		magsig16c:     pop     psw
 2467: 1  07A2	D0 E0		               pop     acc
 2468: 1  07A4	22		               ret
 2469: 1
 2470: 1			;*******************************************************************************
 2471: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2472: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2473: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2474: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2475: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2476: 1			;           (f0 en f1 zijn 1 als negatief)
 2477: 1			;
 2478: 1			; output:   r5,r4 = 2's complement
 2479: 1			;
 2480: 1			; vernietigt: niets
 2481: 1			;*******************************************************************************
 2482: 1  07A5	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2483: 1  07A7	C0 D0		                push    psw
 2484: 1  07A9	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2485: 1  07AC	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2486: 1  07AF	80 0F		                sjmp    magsig16acc1c
 2487: 1
 2488: 1  07B1	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2489: 1  07B4	80 0A		                sjmp    magsig16acc1c
 2490: 1
 2491: 1  07B6	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2492: 1  07B7	F4		                cpl     a                   ;complementeer het dan
 2493: 1  07B8	24 01		                add     a,#1                ;en tel er 1 bij
 2494: 1  07BA	FC		                mov     r4,a
 2495: 1  07BB	ED		                mov     a,r5                ;neem volgende byte
 2496: 1  07BC	F4		                cpl     a                   ;complementeer en tel carry erbij
 2497: 1  07BD	34 00		                addc    a,#0
 2498: 1  07BF	FD		                mov     r5,a
 2499: 1  07C0	D0 D0		magsig16acc1c:  pop     psw
 2500: 1  07C2	D0 E0		                pop     acc
 2501: 1  07C4	22		                ret
 2502: 1
 2503: 1			;*******************************************************************************
 2504: 1			; magsig32        (22,2us @16.777216MHz)
 2505: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2506: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2507: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2508: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2509: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2510: 1			;           (f0 en f1 zijn 1 als negatief)
 2511: 1			;
 2512: 1			; output:   r3,r2,r1,r0 = 2's complement
 2513: 1			;
 2514: 1			; vernietigt: niets
 2515: 1			;*******************************************************************************
 2516: 1  07C5	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2517: 1  07C7	C0 D0		               push    psw
 2518: 1  07C9	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2519: 1  07CC	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2520: 1  07CF	80 19		               sjmp    magsig32c
 2521: 1
 2522: 1  07D1	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2523: 1  07D4	80 14		               sjmp    magsig32c
 2524: 1
 2525: 1  07D6	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2526: 1  07D7	F4		               cpl     a                 ;complementeer het dan
 2527: 1  07D8	24 01		               add     a,#1             ;en tel er 1 bij
 2528: 1  07DA	F8		               mov     r0,a
 2529: 1  07DB	E9		               mov     a,r1             ;neem volgende byte
 2530: 1  07DC	F4		               cpl     a                 ;complementeer en tel carry erbij
 2531: 1  07DD	34 00		               addc    a,#0
 2532: 1  07DF	F9		               mov     r1,a
 2533: 1  07E0	EA		               mov     a,r2            ;neem volgende byte
 2534: 1  07E1	F4		               cpl     a                ;complementeer en tel carry erbij
 2535: 1  07E2	34 00		               addc    a,#0
 2536: 1  07E4	FA		               mov     r2,a
 2537: 1  07E5	EB		               mov     a,r3            ;neem volgende byte
 2538: 1  07E6	F4		               cpl     a                ;complementeer en tel carry erbij
 2539: 1  07E7	34 00		               addc    a,#0
 2540: 1  07E9	FB		               mov     r3,a
 2541: 1
 2542: 1  07EA	D0 D0		magsig32c:     pop     psw
 2543: 1  07EC	D0 E0		               pop     acc
 2544: 1  07EE	22		               ret
 2545: 1
 2546: 1
 2547: 1
 2548: 1			;*******************************************************************************
 2549: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2550: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2551: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2552: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2553: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2554: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2555: 1			;           (f0 en f1 zijn 1 als negatief)
 2556: 1			;
 2557: 1			; output:   r7,r6,r5,r4 = 2's complement
 2558: 1			;
 2559: 1			; vernietigt: niets
 2560: 1			;*******************************************************************************
 2561: 1  07EF	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2562: 1  07F1	C0 D0		               push    psw
 2563: 1  07F3	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2564: 1  07F6	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2565: 1  07F9	80 19		               sjmp    magsig32acc1c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2566: 1
 2567: 1  07FB	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2568: 1  07FE	80 14		               sjmp    magsig32acc1c
 2569: 1
 2570: 1  0800	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2571: 1  0801	F4		               cpl     a                 ;complementeer het dan
 2572: 1  0802	24 01		               add     a,#1             ;en tel er 1 bij
 2573: 1  0804	FC		               mov     r4,a
 2574: 1  0805	ED		               mov     a,r5             ;neem volgende byte
 2575: 1  0806	F4		               cpl     a                 ;complementeer en tel carry erbij
 2576: 1  0807	34 00		               addc    a,#0
 2577: 1  0809	FD		               mov     r5,a
 2578: 1  080A	EE		               mov     a,r6             ;neem volgende byte
 2579: 1  080B	F4		               cpl     a                 ;complementeer en tel carry erbij
 2580: 1  080C	34 00		               addc    a,#0
 2581: 1  080E	FE		               mov     r6,a
 2582: 1  080F	EF		               mov     a,r7             ;neem volgende byte
 2583: 1  0810	F4		               cpl     a                ;complementeer en tel carry erbij
 2584: 1  0811	34 00		               addc    a,#0
 2585: 1  0813	FF		               mov     r7,a
 2586: 1
 2587: 1  0814	D0 D0		magsig32acc1c: pop     psw
 2588: 1  0816	D0 E0		               pop     acc
 2589: 1  0818	22		               ret
 2590: 1
 2591: 1
 2592: 1			;*******************************************************************************
 2593: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2594: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2595: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2596: 1			; input:     r0 = 2's complement byte in acc0
 2597: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2598: 1			; output:    r0 = absolute waarde
 2599: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2600: 1			;
 2601: 1			; vernietigt: niets
 2602: 1			;*******************************************************************************
 2603: 1
 2604: 1  0819	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2605: 1  081B	C0 D0		                push    psw
 2606: 1  081D	E8		                mov     a,r0               ;neem lsb van acc0
 2607: 1  081E	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2608: 1  0821	D0 D0		                pop     psw
 2609: 1  0823	C2 D5		                clr     f0                 ;nee, positief...klaar
 2610: 1  0825	D0 E0		                pop     acc
 2611: 1  0827	22		                ret
 2612: 1  0828	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2613: 1  0829	04		                inc     a                   ;een erbij
 2614: 1  082A	F8		                mov     r0,a               ;bewaar
 2615: 1  082B	D0 D0		                pop     psw
 2616: 1  082D	D2 D5		                setb    f0                 ;f0=1 als negatief
 2617: 1  082F	D0 E0		                pop     acc
 2618: 1  0831	22		                ret
 2619: 1
 2620: 1			;*******************************************************************************
 2621: 1			; sigmag8acc1        (13,0us @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2622: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2623: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2624: 1			; input:     r4 = 2's complement byte in acc1
 2625: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2626: 1			; output:    r4 = absolute waarde
 2627: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2628: 1			;
 2629: 1			; vernietigt: niets
 2630: 1			;*******************************************************************************
 2631: 1
 2632: 1  0832	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2633: 1  0834	C0 D0		                push    psw
 2634: 1  0836	EC		                mov     a,r4               ;neem lsb van acc0
 2635: 1  0837	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2636: 1  083A	D0 D0		                pop     psw
 2637: 1  083C	C2 D1		                clr     f1                 ;nee, positief...klaar
 2638: 1  083E	D0 E0		                pop     acc
 2639: 1  0840	22		                ret
 2640: 1  0841	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2641: 1  0842	04		                inc     a                   ;een erbij
 2642: 1  0843	FC		                mov     r4,a               ;bewaar
 2643: 1  0844	D0 D0		                pop     psw
 2644: 1  0846	D2 D1		                setb    f1                 ;f0=1 als negatief
 2645: 1  0848	D0 E0		                pop     acc
 2646: 1  084A	22		                ret
 2647: 1
 2648: 1			;*******************************************************************************
 2649: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2650: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2651: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2652: 1			; input:     r1,r0 = 2's complement word in acc0
 2653: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2654: 1			; output:    r1,r0 = absolute waarde
 2655: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2656: 1			;
 2657: 1			; vernietigt: niets
 2658: 1			;*******************************************************************************
 2659: 1
 2660: 1  084B	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2661: 1  084D	C0 D0		                push    psw
 2662: 1  084F	E9		                mov     a,r1               ; neem msb van acc0
 2663: 1  0850	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2664: 1  0853	D0 D0		                pop     psw
 2665: 1  0855	C2 D5		                clr     f0                 ;f0=0 als positief
 2666: 1  0857	D0 E0		                pop     acc
 2667: 1  0859	22		                ret                        ;klaar
 2668: 1
 2669: 1  085A	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2670: 1  085B	F4		                cpl     a                  ;complementeren
 2671: 1  085C	24 01		                add     a,#1               ;en een bijtellen
 2672: 1  085E	F8		                mov     r0,a
 2673: 1  085F	E9		                mov     a,r1
 2674: 1  0860	F4		                cpl     a                  ;complement eer volgende byte
 2675: 1  0861	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2676: 1  0863	F9		                mov     r1,a
 2677: 1  0864	D0 D0		                pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2678: 1  0866	D2 D5		                setb    f0                 ;f0=1 als negatief
 2679: 1  0868	D0 E0		                pop     acc
 2680: 1  086A	22		                ret
 2681: 1
 2682: 1
 2683: 1			;*******************************************************************************
 2684: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2685: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2686: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2687: 1			; input:     r5,r4 = 2's complement word in acc1
 2688: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2689: 1			; output:    r5,r4 = absolute waarde
 2690: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2691: 1			;
 2692: 1			; vernietigt: niets
 2693: 1			;*******************************************************************************
 2694: 1
 2695: 1  086B	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2696: 1  086D	C0 D0		                push    psw
 2697: 1  086F	ED		                mov     a,r5               ;neem msb van acc1
 2698: 1  0870	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2699: 1  0873	D0 D0		                pop     psw
 2700: 1  0875	C2 D1		                clr     f1                 ;f1=0 als positief
 2701: 1  0877	D0 E0		                pop    acc
 2702: 1  0879	22		                ret                        ;klaar
 2703: 1
 2704: 1  087A	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2705: 1  087B	F4		                cpl     a                   ;complementeren
 2706: 1  087C	24 01		                add     a,#1               ;en een bijtellen
 2707: 1  087E	FC		                mov     r4,a
 2708: 1  087F	ED		                mov     a,r5
 2709: 1  0880	F4		                cpl     a                  ;complementeer volgende byte
 2710: 1  0881	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2711: 1  0883	FD		                mov     r5,a
 2712: 1  0884	D0 D0		                pop     psw
 2713: 1  0886	D2 D1		                setb    f1                ;f1=1 als negatief
 2714: 1  0888	D0 E0		                pop     acc
 2715: 1  088A	22		                ret
 2716: 1
 2717: 1
 2718: 1			;*******************************************************************************
 2719: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2720: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2721: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2722: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2723: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2724: 1			; output:    r7,r6 = absolute waarde
 2725: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2726: 1			;
 2727: 1			; vernietigt: niets
 2728: 1			;*******************************************************************************
 2729: 1
 2730: 1  088B	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2731: 1  088D	C0 D0		                push    psw
 2732: 1  088F	EF		                mov     a,r7                ; neem msb van acc1 high
 2733: 1  0890	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2734: 1  0893	D0 D0		                pop     psw
 2735: 1  0895	C2 D5		                clr     f0                  ;f0=0 als positief
 2736: 1  0897	D0 E0		                pop     acc
 2737: 1  0899	22		                ret                         ;klaar
 2738: 1
 2739: 1  089A	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2740: 1  089B	F4		                cpl     a                   ;complementeren
 2741: 1  089C	24 01		                add     a,#1               ;en een bijtellen
 2742: 1  089E	FE		                mov     r6,a
 2743: 1  089F	EF		                mov     a,r7
 2744: 1  08A0	F4		                cpl     a                  ;complementeer volgende byte
 2745: 1  08A1	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2746: 1  08A3	FF		                mov     r7,a
 2747: 1  08A4	D0 D0		                pop     psw
 2748: 1  08A6	D2 D5		                setb    f0                ;f0=1 als negatief
 2749: 1  08A8	D0 E0		                pop     acc
 2750: 1  08AA	22		                ret
 2751: 1
 2752: 1
 2753: 1			;*******************************************************************************
 2754: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2755: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2756: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 2757: 1			;
 2758: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2759: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2760: 1			;            (-2147483648 tot +2147483647)
 2761: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2762: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2763: 1			;
 2764: 1			; vernietigt: niets
 2765: 1			;*******************************************************************************
 2766: 1
 2767: 1  08AB	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2768: 1  08AD	C0 D0		                push    psw
 2769: 1  08AF	EB		                mov     a,r3               ;neem msb van acc0
 2770: 1  08B0	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2771: 1  08B3	D0 D0		                pop     psw                ;nee, positief
 2772: 1  08B5	C2 D5		                clr     f0
 2773: 1  08B7	D0 E0		                pop     acc
 2774: 1  08B9	22		                ret                        ;klaar
 2775: 1
 2776: 1  08BA	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2777: 1  08BB	F4		                cpl     a                  ;complementeren
 2778: 1  08BC	24 01		                add     a,#1               ;en een bijtellen
 2779: 1  08BE	F8		                mov     r0,a
 2780: 1  08BF	E9		                mov     a,r1               ;neem volgende byte
 2781: 1  08C0	F4		                cpl     a                  ;complementeer volgende byte
 2782: 1  08C1	34 00		                addc    a,#0
 2783: 1  08C3	F9		                mov     r1,a
 2784: 1  08C4	EA		                mov     a,r2               ;neem volgende byte
 2785: 1  08C5	F4		                cpl     a                  ;complementeer volgende byte
 2786: 1  08C6	34 00		                addc    a,#0
 2787: 1  08C8	FA		                mov     r2,a
 2788: 1  08C9	EB		                mov     a,r3               ;neem volgende byte
 2789: 1  08CA	F4		                cpl     a                  ;complementeer volgende byte

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2790: 1  08CB	34 00		                addc    a,#0
 2791: 1  08CD	FB		                mov     r3,a
 2792: 1  08CE	D0 D0		                pop     psw
 2793: 1  08D0	D2 D5		                setb    f0                 ;negatief: f0=1
 2794: 1  08D2	D0 E0		                pop     acc
 2795: 1  08D4	22		                ret                        ;klaar
 2796: 1
 2797: 1			;*******************************************************************************
 2798: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2799: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2800: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2801: 1			;
 2802: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2803: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2804: 1			;            (-2147483648 tot +2147483647)
 2805: 1			; output:    r7,r6,r5,r4 = absolute waarde
 2806: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2807: 1			;
 2808: 1			; vernietigt: niets
 2809: 1			;*******************************************************************************
 2810: 1
 2811: 1  08D5	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2812: 1  08D7	C0 D0		                push    psw
 2813: 1  08D9	EF		                mov     a,r7               ;neem msb van acc0
 2814: 1  08DA	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2815: 1  08DD	D0 D0		                pop     psw                ;nee, positief
 2816: 1  08DF	C2 D1		                clr     f1
 2817: 1  08E1	D0 E0		                pop     acc
 2818: 1  08E3	22		                ret                        ;klaar
 2819: 1
 2820: 1  08E4	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2821: 1  08E5	F4		                cpl     a                   ;complementeren
 2822: 1  08E6	24 01		                add     a,#1               ;en een bijtellen
 2823: 1  08E8	FC		                mov     r4,a
 2824: 1  08E9	ED		                mov     a,r5               ;neem volgende byte
 2825: 1  08EA	F4		                cpl     a                  ;complementeer volgende byte
 2826: 1  08EB	34 00		                addc    a,#0
 2827: 1  08ED	FD		                mov     r5,a
 2828: 1  08EE	EE		                mov     a,r6               ;neem volgende byte
 2829: 1  08EF	F4		                cpl     a                  ;complementeer volgende byte
 2830: 1  08F0	34 00		                addc    a,#0
 2831: 1  08F2	FE		                mov     r6,a
 2832: 1  08F3	EF		                mov     a,r7               ;neem volgende byte
 2833: 1  08F4	F4		                cpl     a                  ;complementeer volgende byte
 2834: 1  08F5	34 00		                addc    a,#0
 2835: 1  08F7	FF		                mov     r7,a
 2836: 1  08F8	D0 D0		                pop     psw
 2837: 1  08FA	D2 D1		                setb    f1                 ;negatief: f0=1
 2838: 1  08FC	D0 E0		                pop     acc
 2839: 1  08FE	22		                ret                        ;klaar
 2840: 1
 2841: 1
 2842: 1			;*******************************************************************************
 2843: 1			; s_add16        (19,35us @16.777216MHz)
 2844: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2845: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2846: 1			; input:     r1,r0 = acc0
 2847: 1			;            r5,r4 = acc1
 2848: 1			;
 2849: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2850: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2851: 1			;                  gebruik van r3,r2 is niet nodig
 2852: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2853: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2854: 1			;
 2855: 1			; vernietigt:  niets
 2856: 1			;*******************************************************************************
 2857: 1  08FF	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2858: 1  0901	C0 D0		               push    psw
 2859: 1
 2860: 1  0903	E8		               mov     a,r0           ;tel de soft accumulators op
 2861: 1  0904	2C		               add     a,r4           ;low byte eerst
 2862: 1  0905	F8		               mov     r0,a           ;resultaat bewaren
 2863: 1  0906	E9		               mov     a,r1           ;nu de high bytes
 2864: 1  0907	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2865: 1  0908	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2866: 1
 2867: 1  0909	92 D5		               mov     f0,c
 2868: 1  090B	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 2869: 1  090D	92 D1		               mov     f1,c
 2870: 1  090F	A2 D5		               mov     c,f0           ;herstel carrybit
 2871: 1
 2872: 1  0911	74 00		               mov     a,#00h
 2873: 1  0913	34 00		               addc    a,#00h
 2874: 1  0915	FA		               mov     r2,a            ;24bit resultaat klaar
 2875: 1
 2876: 1  0916	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2877: 1
 2878: 1  0919	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2879: 1  091A	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2880: 1  091D	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 2881: 1  091F	7B FF		               mov     r3,#0ffh
 2882: 1  0921	80 04		               sjmp    s_add162
 2883: 1  0923	7A 00		s_add161:      mov     r2,#00h
 2884: 1  0925	7B 00		               mov     r3,#00h
 2885: 1  0927	D0 D0		s_add162:      pop     psw
 2886: 1  0929	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2887: 1  092A	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2888: 1  092C	22		               ret
 2889: 1
 2890: 1  092D	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2891: 1  092F	C3		               clr     c
 2892: 1  0930	D0 E0		               pop     acc
 2893: 1  0932	22		               ret
 2894: 1
 2895: 1			;*******************************************************************************
 2896: 1			; add16        (13,6us @16.777216MHz)
 2897: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2898: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2899: 1			; input:     r1,r0 = acc0
 2900: 1			;            r5,r4 = acc1
 2901: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2902: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2903: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 2904: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2905: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 2906: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 2907: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 2908: 1			;
 2909: 1			; vernietigt:  niets
 2910: 1			;*******************************************************************************
 2911: 1
 2912: 1  0933	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 2913: 1  0935	C0 D0		               push    psw
 2914: 1  0937	E8		               mov     a,r0           ;tel de soft accumulators op
 2915: 1  0938	2C		               add     a,r4           ;low byte eerst
 2916: 1  0939	F8		               mov     r0,a           ;resultaat bewaren
 2917: 1  093A	E9		               mov     a,r1           ;nu de high bytes
 2918: 1  093B	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2919: 1  093C	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2920: 1  093D	50 08		               jnc     add161          ;geen 24 bit resultaat
 2921: 1
 2922: 1  093F	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 2923: 1  0941	D0 D0		               pop     psw
 2924: 1  0943	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2925: 1  0944	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 2926: 1  0946	22		               ret
 2927: 1
 2928: 1  0947	7A 00		add161:        mov     r2,#00h
 2929: 1  0949	D0 D0		               pop     psw
 2930: 1  094B	C3		               clr     c               ;aangeven aan de gebruiker dat het
 2931: 1  094C	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 2932: 1  094E	22		               ret
 2933: 1
 2934: 1			;*******************************************************************************
 2935: 1			; s_add32        (28,0us @16.777216MHz)
 2936: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2937: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 2938: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2939: 1			; input:     r3,r2,r1,r0 = acc0
 2940: 1			;            r7,r6,r5,r4 = acc1
 2941: 1			;
 2942: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2943: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2944: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 2945: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 2946: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 2947: 1			;
 2948: 1			; vernietigt:  niets
 2949: 1			;*******************************************************************************
 2950: 1  094F	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 2951: 1  0951	C0 D0		               push    psw
 2952: 1
 2953: 1  0953	E8		               mov     a,r0           ;tel de soft accumulators op
 2954: 1  0954	2C		               add     a,r4           ;low byte eerst
 2955: 1  0955	F8		               mov     r0,a           ;resultaat bewaren
 2956: 1  0956	E9		               mov     a,r1           ;nu de hogere bytes
 2957: 1  0957	3D		               addc    a,r5           ;optellen met eventuele overdracht

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2958: 1  0958	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2959: 1
 2960: 1  0959	EA		               mov     a,r2           ;derde bytes optellen
 2961: 1  095A	3E		               addc    a,r6           ;optellen met eventuele overdracht
 2962: 1  095B	FA		               mov     r2,a           ;24bit resultaat is klaar
 2963: 1  095C	EB		               mov     a,r3           ;nu de ms bytes
 2964: 1  095D	3F		               addc    a,r7           ;optellen met eventuele overdracht
 2965: 1  095E	FB		               mov     r3,a           ;32 bit resultaat is klaar
 2966: 1
 2967: 1  095F	92 D5		               mov     f0,c
 2968: 1  0961	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 2969: 1  0963	92 D1		               mov     f1,c
 2970: 1  0965	A2 D5		               mov     c,f0           ;herstel carrybit
 2971: 1
 2972: 1  0967	74 00		               mov     a,#00h
 2973: 1  0969	34 00		               addc    a,#00h
 2974: 1  096B	FC		               mov     r4,a            ;40bit resultaat klaar
 2975: 1
 2976: 1  096C	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 2977: 1  096F	EC		               mov     a,r4            ;ja, sign extention toepassen!
 2978: 1  0970	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 2979: 1  0973	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 2980: 1  0975	80 02		               sjmp    s_add322
 2981: 1  0977	7C 00		s_add321:      mov     r4,#00h
 2982: 1  0979	D0 D0		s_add322:      pop     psw
 2983: 1  097B	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2984: 1  097C	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 2985: 1  097E	22		               ret
 2986: 1
 2987: 1  097F	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 2988: 1  0981	C3		               clr     c
 2989: 1  0982	D0 E0		               pop     acc
 2990: 1  0984	22		               ret
 2991: 1
 2992: 1
 2993: 1			;*******************************************************************************
 2994: 1			; add32        (18,0us @16.777216MHz)
 2995: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 2996: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 2997: 1			; input:     r3,r2,r1,r0 = acc0
 2998: 1			;            r7,r6,r5,r4 = acc1
 2999: 1			;
 3000: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 3001: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3002: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3003: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 3004: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3005: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3006: 1			;
 3007: 1			; vernietigt:  niets
 3008: 1			;*******************************************************************************
 3009: 1  0985	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 3010: 1  0987	C0 D0		               push    psw
 3011: 1  0989	E8		               mov     a,r0           ;tel de soft accumulators op
 3012: 1  098A	2C		               add     a,r4           ;low byte eerst
 3013: 1  098B	F8		               mov     r0,a           ;resultaat bewaren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3014: 1  098C	E9		               mov     a,r1           ;nu de hogere bytes
 3015: 1  098D	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3016: 1  098E	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3017: 1
 3018: 1  098F	EA		               mov     a,r2           ;derde bytes optellen
 3019: 1  0990	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3020: 1  0991	FA		               mov     r2,a           ;24bit resultaat is klaar
 3021: 1  0992	EB		               mov     a,r3           ;nu de ms bytes
 3022: 1  0993	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3023: 1  0994	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3024: 1
 3025: 1  0995	50 08		               jnc     add321          ;geen 40 bit resultaat
 3026: 1
 3027: 1  0997	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3028: 1  0999	D0 D0		               pop     psw
 3029: 1  099B	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3030: 1  099C	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3031: 1  099E	22		               ret
 3032: 1
 3033: 1  099F	7C 00		add321:        mov     r4,#00h
 3034: 1  09A1	D0 D0		               pop     psw
 3035: 1  09A3	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3036: 1  09A4	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3037: 1  09A6	22		               ret
 3038: 1
 3039: 1
 3040: 1			;*******************************************************************************
 3041: 1			; s_sub16        (24,4us @16.777216MHz)
 3042: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3043: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3044: 1			; input:     r1,r0 = acc0
 3045: 1			;            r5,r4 = acc1
 3046: 1			;
 3047: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3048: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3049: 1			;                  gebruik van r3,r2 is niet nodig
 3050: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3051: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3052: 1			;
 3053: 1			; vernietigt:  niets
 3054: 1			;*******************************************************************************
 3055: 1  09A7	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3056: 1  09A9	C0 D0		                push    psw
 3057: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3058: 1
 3059: 1  09AB	EC		                mov   	a,r4            ;verander het teken van acc1
 3060: 1  09AC	F4		                cpl    	a               ;door het 2's complement te nemen
 3061: 1  09AD	24 01		                add   	a,#1
 3062: 1  09AF	FC		                mov    	r4,a
 3063: 1  09B0	ED		                mov    	a,r5
 3064: 1  09B1	F4		                cpl    	a
 3065: 1  09B2	34 00		                addc	a,#0
 3066: 1  09B4	FD		                mov    	r5,a
 3067: 1			;acc0+acc1
 3068: 1  09B5	E8						mov		a,r0
 3069: 1  09B6	2C						add		a,r4

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3070: 1  09B7	F8						mov		r0,a
 3071: 1  09B8	E9						mov		a,r1
 3072: 1  09B9	3D						addc	a,r5
 3073: 1  09BA	F9						mov		r1,a
 3074: 1
 3075: 1  09BB	92 D5		                mov    f0,c
 3076: 1  09BD	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3077: 1  09BF	92 D1		                mov    f1,c
 3078: 1  09C1	A2 D5		                mov    c,f0            ;herstel carrybit
 3079: 1
 3080: 1  09C3	74 00		                mov    a,#00h
 3081: 1  09C5	34 00		                addc   a,#00h
 3082: 1  09C7	FA		                mov    r2,a            ;24bit resultaat klaar
 3083: 1
 3084: 1  09C8	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3085: 1  09CB	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3086: 1  09CC	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3087: 1  09CF	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3088: 1  09D1	7B FF		                mov    r3,#0ffh
 3089: 1  09D3	80 04		                sjmp   s_sub162
 3090: 1  09D5	7A 00		s_sub161:       mov    r2,#00h
 3091: 1  09D7	7B 00		                mov    r3,#00h
 3092: 1  09D9	D0 D0		s_sub162:       pop    psw
 3093: 1  09DB	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3094: 1  09DC	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3095: 1  09DE	22		                ret
 3096: 1
 3097: 1  09DF	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3098: 1  09E1	C3		                clr    c
 3099: 1  09E2	D0 E0		                pop    acc
 3100: 1  09E4	22		                ret
 3101: 1
 3102: 1			;*******************************************************************************
 3103: 1			; sub16            (14,4us @16.777216MHz)
 3104: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3105: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3106: 1			; input:     r1,r0 = acc0
 3107: 1			;            r5,r4 = acc1
 3108: 1			;
 3109: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3110: 1			;            bij een underflow r2 op ffh zetten
 3111: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3112: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3113: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3114: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3115: 1			;
 3116: 1			; vernietigt:  niets
 3117: 1			;*******************************************************************************
 3118: 1
 3119: 1  09E5	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3120: 1  09E7	C0 D0		                push    psw
 3121: 1  09E9	C3		                clr     c
 3122: 1  09EA	E8		                mov     a,r0            ;tel de soft accumulators op
 3123: 1  09EB	9C		                subb    a,r4            ;low byte eerst
 3124: 1  09EC	F8		                mov     r0,a            ;resultaat bewaren
 3125: 1  09ED	E9		                mov     a,r1            ;nu de high bytes

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3126: 1  09EE	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3127: 1  09EF	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3128: 1  09F0	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3129: 1
 3130: 1  09F2	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3131: 1  09F4	D0 D0		                pop     psw
 3132: 1  09F6	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3133: 1  09F7	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3134: 1  09F9	22		                ret
 3135: 1
 3136: 1  09FA	7A 00		sub161:         mov     r2,#00h
 3137: 1  09FC	D0 D0		                pop     psw
 3138: 1  09FE	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3139: 1  09FF	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3140: 1  0A01	22		                ret
 3141: 1
 3142: 1			;*******************************************************************************
 3143: 1			; s_sub32        (27,2us @16.777216MHz)
 3144: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3145: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3146: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3147: 1			; input:     r3,r2,r1,r0 = acc0
 3148: 1			;            r7,r6,r5,r4 = acc1
 3149: 1			;
 3150: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3151: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3152: 1			;                  gebruik van r4 is niet nodig
 3153: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3154: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3155: 1			;
 3156: 1			; vernietigt:  niets
 3157: 1			;*******************************************************************************
 3158: 1  0A02	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3159: 1  0A04	C0 D0		                push   psw
 3160: 1
 3161: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3162: 1
 3163: 1  0A06	EC		                mov    	a,r4            ;verander het teken van acc1
 3164: 1  0A07	F4		                cpl    	a               ;door het 2's complement te nemen
 3165: 1  0A08	24 01		                add    	a,#1
 3166: 1  0A0A	FC		                mov    	r4,a
 3167: 1  0A0B	ED		                mov    	a,r5
 3168: 1  0A0C	F4		                cpl    	a
 3169: 1  0A0D	34 00		                addc	a,#0
 3170: 1  0A0F	FD		                mov    	r5,a
 3171: 1  0A10	EE		                mov    	a,r6
 3172: 1  0A11	F4		                cpl    	a
 3173: 1  0A12	34 00		                addc   	a,#0
 3174: 1  0A14	FE		                mov    	r6,a
 3175: 1  0A15	EF		                mov    	a,r7
 3176: 1  0A16	F4		                cpl    	a
 3177: 1  0A17	34 00		                addc   	a,#0
 3178: 1  0A19	FF		                mov    	r7,a
 3179: 1			;acc0+acc1
 3180: 1  0A1A	E8						mov		a,r0
 3181: 1  0A1B	2C						add		a,r4

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3182: 1  0A1C	F8						mov		r0,a
 3183: 1  0A1D	E9						mov		a,r1
 3184: 1  0A1E	3D						addc	a,r5
 3185: 1  0A1F	F9						mov		r1,a
 3186: 1  0A20	EA						mov		a,r2
 3187: 1  0A21	3E						addc	a,r6
 3188: 1  0A22	FA						mov		r2,a
 3189: 1  0A23	EB						mov		a,r3
 3190: 1  0A24	3F						addc	a,r7
 3191: 1  0A25	FB						mov		r3,a
 3192: 1
 3193: 1  0A26	92 D5		                mov   f0,c
 3194: 1  0A28	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3195: 1  0A2A	92 D1		                mov   f1,c
 3196: 1  0A2C	A2 D5		                mov   c,f0            ;herstel carrybit
 3197: 1
 3198: 1  0A2E	74 00		                mov   a,#00h
 3199: 1  0A30	34 00		                addc  a,#00h
 3200: 1  0A32	FC		                mov   r4,a            ;40bit resultaat klaar
 3201: 1
 3202: 1  0A33	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3203: 1
 3204: 1  0A36	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3205: 1  0A37	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3206: 1  0A3A	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3207: 1  0A3C	80 02		                sjmp   s_sub322
 3208: 1  0A3E	7C 00		s_sub321:       mov   r4,#00h
 3209: 1  0A40	D0 D0		s_sub322:       pop   psw
 3210: 1  0A42	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3211: 1  0A43	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3212: 1  0A45	22		                ret
 3213: 1
 3214: 1  0A46	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3215: 1  0A48	C3		                clr   c
 3216: 1  0A49	D0 E0		                pop   acc
 3217: 1  0A4B	22		                ret
 3218: 1
 3219: 1
 3220: 1			;*******************************************************************************
 3221: 1			; sub32        (18,7us @16.777216MHz)
 3222: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3223: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3224: 1			; input:     r3,r2,r1,r0 = acc0
 3225: 1			;            r7,r6,r5,r4 = acc1
 3226: 1			;
 3227: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3228: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3229: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3230: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3231: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3232: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3233: 1			;
 3234: 1			; vernietigt:  niets
 3235: 1			;*******************************************************************************
 3236: 1  0A4C	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3237: 1  0A4E	C0 D0		               push    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3238: 1  0A50	C3		               clr       c
 3239: 1  0A51	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3240: 1  0A52	9C		               subb    a,r4           ;low byte eerst
 3241: 1  0A53	F8		               mov     r0,a           ;resultaat bewaren
 3242: 1  0A54	E9		               mov     a,r1           ;nu de hogere bytes
 3243: 1  0A55	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3244: 1  0A56	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3245: 1
 3246: 1  0A57	EA		               mov     a,r2           ;derde bytes optellen
 3247: 1  0A58	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3248: 1  0A59	FA		               mov     r2,a           ;24bit resultaat is klaar
 3249: 1  0A5A	EB		               mov     a,r3           ;nu de ms bytes
 3250: 1  0A5B	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3251: 1  0A5C	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3252: 1
 3253: 1  0A5D	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3254: 1
 3255: 1  0A5F	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3256: 1  0A61	D0 D0		               pop     psw
 3257: 1  0A63	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3258: 1  0A64	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3259: 1  0A66	22		               ret
 3260: 1
 3261: 1  0A67	7C 00		sub321:        mov     r4,#00h
 3262: 1  0A69	D0 D0		               pop     psw
 3263: 1  0A6B	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3264: 1  0A6C	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3265: 1  0A6E	22		               ret
 3266: 1
 3267: 1
 3268: 1
 3269: 1			;*******************************************************************************
 3270: 1			; mul16        (71,2us @16.777216MHz)
 3271: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3272: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3273: 1			; input:     r1,r0 = acc0
 3274: 1			;            r5,r4 = acc1
 3275: 1			;
 3276: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3277: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3278: 1			;
 3279: 1			; vernietigt:  niets
 3280: 1			;*******************************************************************************
 3281: 1  0A6F	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3282: 1  0A71	C0 D0		                push    psw
 3283: 1  0A73	C0 F0		                push    b
 3284: 1  0A75	C0 82		                push    dpl
 3285: 1  0A77	C0 83		                push    dph
 3286: 1
 3287: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3288: 1
 3289: 1  0A79	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3290: 1  0A7B	89 83		                mov     dph,r1
 3291: 1  0A7D	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3292: 1  0A7F	08		                inc     r0              ;pointer naar eerste vrije plaats
 3293: 1  0A80	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3294: 1  0A82	E5 81		                mov     a,sp            ;plaats alloceren
 3295: 1  0A84	24 03		                add     a,#3            ;3 bytes nodig
 3296: 1  0A86	F5 81		                mov     sp,a            ;stackpointer verzetten
 3297: 1
 3298: 1  0A88	E5 82		                mov     a,dpl            ;acc0 lsb
 3299: 1  0A8A	8C F0		                mov     b,r4            ;acc1 lsb
 3300: 1  0A8C	A4		                mul     ab
 3301: 1  0A8D	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3302: 1  0A8E	08		                inc     r0
 3303: 1  0A8F	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3304: 1
 3305: 1  0A91	E5 83		                mov     a,dph            ;acc0 msb
 3306: 1  0A93	8C F0		                mov     b,r4            ;acc1 lsb
 3307: 1  0A95	A4		                mul     ab
 3308: 1
 3309: 1  0A96	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3310: 1  0A97	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3311: 1  0A98	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3312: 1  0A9A	34 00		                addc    a,#0
 3313: 1  0A9C	08		                inc     r0               ;bewaar als tussenresultaat
 3314: 1  0A9D	F6		                mov     @r0,a
 3315: 1
 3316: 1  0A9E	E5 82		                mov     a,dpl            ;acc0 lsb
 3317: 1  0AA0	8D F0		                mov     b,r5             ;acc1 msb
 3318: 1  0AA2	A4		                mul     ab
 3319: 1  0AA3	18		                dec     r0
 3320: 1  0AA4	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3321: 1  0AA5	F6		                mov     @r0,a            ;en bewaar weer
 3322: 1  0AA6	08		                inc     r0
 3323: 1  0AA7	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3324: 1  0AA9	36		                addc    a,@r0
 3325: 1  0AAA	F6		                mov     @r0,a            ;en bewaar weer
 3326: 1  0AAB	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3327: 1
 3328: 1  0AAD	E5 83		                mov     a,dph            ;acc0 msb
 3329: 1  0AAF	8D F0		                mov     b,r5             ;acc1 msb
 3330: 1  0AB1	A4		                mul     AB
 3331: 1  0AB2	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3332: 1  0AB3	FA		                mov     r2,a
 3333: 1  0AB4	E5 F0		                mov     a,b
 3334: 1  0AB6	34 00		                addc    a,#0
 3335: 1
 3336: 1  0AB8	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3337: 1  0ABA	34 00		                addc    a,#0
 3338: 1
 3339: 1  0ABC	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3340: 1  0ABD	18		                dec     r0
 3341: 1  0ABE	86 83		                mov     dph,@r0
 3342: 1  0AC0	18		                dec     r0
 3343: 1  0AC1	86 82		                mov     dpl,@r0
 3344: 1
 3345: 1  0AC3	89 81		                mov     sp,r1            ;zet stackpointer terug
 3346: 1  0AC5	A9 83		                mov     r1,dph
 3347: 1  0AC7	A8 82		                mov     r0,dpl
 3348: 1
 3349: 1  0AC9	D0 83		                pop     dph              ;herstel de bewaarde registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3350: 1  0ACB	D0 82		                pop     dpl
 3351: 1  0ACD	D0 F0		                pop     b
 3352: 1  0ACF	D0 D0		                pop     psw
 3353: 1  0AD1	D0 E0		                pop     acc
 3354: 1  0AD3	22		                ret
 3355: 1
 3356: 1
 3357: 1
 3358: 1			;*******************************************************************************
 3359: 1			; mul16acc1        (71,2us @16.777216MHz)
 3360: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3361: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3362: 1			; input:     r5,r4 = acc1 low
 3363: 1			;            r7,r6 = acc1 high
 3364: 1			;
 3365: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3366: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3367: 1			;
 3368: 1			; vernietigt:  niets
 3369: 1			;*******************************************************************************
 3370: 1  0AD4	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3371: 1  0AD6	C0 D0		                push    psw
 3372: 1  0AD8	C0 F0		                push    b
 3373: 1  0ADA	C0 82		                push    dpl
 3374: 1  0ADC	C0 83		                push    dph
 3375: 1
 3376: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3377: 1
 3378: 1  0ADE	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3379: 1  0AE0	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3380: 1
 3381: 1  0AE2	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3382: 1  0AE4	08		                inc     r0               ;pointer naar eerste vrije plaats
 3383: 1  0AE5	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3384: 1  0AE7	E5 81		                mov     a,sp             ;plaats alloceren
 3385: 1  0AE9	24 03		                add     a,#3             ;3 bytes nodig
 3386: 1  0AEB	F5 81		                mov     sp,a             ;stackpointer verzetten
 3387: 1
 3388: 1  0AED	EC		                mov     a,r4             ;acc1 low lsb
 3389: 1  0AEE	8E F0		                mov     b,r6             ;acc1 high lsb
 3390: 1  0AF0	A4		                mul     ab
 3391: 1  0AF1	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3392: 1  0AF2	08		                inc     r0
 3393: 1  0AF3	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3394: 1
 3395: 1  0AF5	ED		                mov     a,r5             ;acc1 low msb
 3396: 1  0AF6	8E F0		                mov     b,r6             ;acc1 high lsb
 3397: 1  0AF8	A4		                mul     ab
 3398: 1
 3399: 1  0AF9	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3400: 1  0AFA	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3401: 1  0AFB	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3402: 1  0AFD	34 00		                addc    a,#0
 3403: 1  0AFF	08		                inc     r0               ;bewaar als tussenresultaat
 3404: 1  0B00	F6		                mov     @r0,a
 3405: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3406: 1  0B01	EC		                mov     a,r4             ;acc1 low lsb
 3407: 1  0B02	8F F0		                mov     b,r7             ;acc1 high msb
 3408: 1  0B04	A4		                mul     ab
 3409: 1  0B05	18		                dec     r0
 3410: 1  0B06	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3411: 1  0B07	F6		                mov     @r0,a            ;en bewaar weer
 3412: 1  0B08	08		                inc     r0
 3413: 1  0B09	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3414: 1  0B0B	36		                addc    a,@r0
 3415: 1  0B0C	F6		                mov     @r0,a            ;en bewaar weer
 3416: 1  0B0D	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3417: 1
 3418: 1  0B0F	ED		                mov     a,r5             ;acc1 low msb
 3419: 1  0B10	8F F0		                mov     b,r7             ;acc1 high msb
 3420: 1  0B12	A4		                mul     AB
 3421: 1
 3422: 1  0B13	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3423: 1  0B14	FE		                mov     r6,a             ;deze byte van product is al klaar
 3424: 1  0B15	E5 F0		                mov     a,b
 3425: 1  0B17	34 00		                addc    a,#0
 3426: 1  0B19	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3427: 1  0B1B	34 00		                addc    a,#0
 3428: 1
 3429: 1  0B1D	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3430: 1  0B1E	18		                dec     r0
 3431: 1  0B1F	E6		                mov     a,@r0
 3432: 1  0B20	FD		                mov     r5,a
 3433: 1  0B21	18		                dec     r0
 3434: 1  0B22	E6		                mov     a,@r0
 3435: 1  0B23	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3436: 1
 3437: 1  0B24	89 81		                mov     sp,r1            ;zet stackpointer terug
 3438: 1  0B26	A9 83		                mov     r1,dph
 3439: 1  0B28	A8 82		                mov     r0,dpl
 3440: 1
 3441: 1  0B2A	D0 83		                pop     dph              ;herstel de bewaarde registers
 3442: 1  0B2C	D0 82		                pop     dpl
 3443: 1  0B2E	D0 F0		                pop     b
 3444: 1  0B30	D0 D0		                pop     psw
 3445: 1  0B32	D0 E0		                pop     acc
 3446: 1  0B34	22		                ret
 3447: 1
 3448: 1			;*******************************************************************************
 3449: 1			; s_mul16        (121,1us @16.777216MHz)
 3450: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3451: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3452: 1			; input:     r1,r0 = acc0
 3453: 1			;            r5,r4 = acc1
 3454: 1			;
 3455: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3456: 1			;                                  -1073709056 tot +1073741824
 3457: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3458: 1			;
 3459: 1			; vernietigt:  niets
 3460: 1			;*******************************************************************************
 3461: 1  0B35	12 08 4B	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3462: 1  0B38	12 08 6B	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3463: 1  0B3B	12 0A 6F	                lcall    mul16           ;maak product
 3464: 1  0B3E	12 07 C5	                lcall    magsig32        ;maak 2's complement formaat
 3465: 1  0B41	22		                ret                      ;klaar
 3466: 1
 3467: 1			;*******************************************************************************
 3468: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3469: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3470: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3471: 1			; input:     r5,r4 = acc1 low
 3472: 1			;            r7,r6 = acc1 high
 3473: 1			;
 3474: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3475: 1			;                                  -1073709056 tot +1073741824
 3476: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3477: 1			; vernietigt:  niets
 3478: 1			;*******************************************************************************
 3479: 1  0B42	12 08 6B	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3480: 1  0B45	12 08 8B	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3481: 1  0B48	12 0A D4	                lcall    mul16acc1       ;maak product
 3482: 1  0B4B	12 07 EF	                lcall    magsig32acc1    ;maak 2's complement formaat
 3483: 1  0B4E	22		                ret                      ;klaar
 3484: 1
 3485: 1			;*******************************************************************************
 3486: 1			; s_mul816        (83,5us @16.777216MHz)
 3487: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3488: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3489: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3490: 1			; input:     r1,r0 = acc0
 3491: 1			;               r4 = acc1
 3492: 1			;
 3493: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3494: 1			;                                  -4194176 tot +4194304
 3495: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3496: 1			; vernietigt:  niets
 3497: 1			;*******************************************************************************
 3498: 1  0B4F	12 08 4B	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3499: 1  0B52	12 08 32	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3500: 1  0B55	12 0B 5C	                lcall    mul816          ;8bit x 16 bit product
 3501: 1  0B58	12 07 C5	                lcall    magsig32        ;abs. waarde naar 2's complement
 3502: 1  0B5B	22		                ret
 3503: 1
 3504: 1			;*******************************************************************************
 3505: 1			; mul816        (29,4us @16.777216MHz)
 3506: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3507: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3508: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3509: 1			; input:     r1,r0 = acc0
 3510: 1			;               r4 = acc1
 3511: 1			;
 3512: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3513: 1			;                           0..16711425 (000000h..feff01h)
 3514: 1			;
 3515: 1			; vernietigt:  niets
 3516: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3517: 1  0B5C	C0 E0		mul816:         push    acc             ;bewaar registers
 3518: 1  0B5E	C0 F0		                push    b
 3519: 1  0B60	C0 D0		                push    psw
 3520: 1  0B62	EC		                mov     a,r4            ;neem acc1
 3521: 1  0B63	88 F0		                mov     b,r0            ;neem lsb van acc0
 3522: 1  0B65	A4		                mul     ab              ;maak product
 3523: 1  0B66	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3524: 1  0B67	C0 F0		                push    b               ;bewaar lsb van het product
 3525: 1  0B69	EC		                mov     a,r4            ;neem acc1
 3526: 1  0B6A	89 F0		                mov     b,r1            ;neem msb can acc0
 3527: 1  0B6C	A4		                mul     ab              ;maak product
 3528: 1  0B6D	AA F0		                mov     r2,b            ;bewaar msb van product even
 3529: 1  0B6F	F5 F0		                mov     b,a             ;verplaats lsb van product
 3530: 1  0B71	D0 E0		                pop     acc             ;neem msb van vorig product
 3531: 1  0B73	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3532: 1  0B75	F9		                mov     r1,a            ;de middenste byte is klaar
 3533: 1  0B76	EA		                mov     a,r2            ;tel nu de eventuele
 3534: 1  0B77	34 00		                addc    a,#0            ;carry bij de msb
 3535: 1  0B79	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3536: 1  0B7A	7B 00		                mov     r3,#0
 3537: 1  0B7C	D0 D0		                pop     psw
 3538: 1  0B7E	D0 F0		                pop     b
 3539: 1  0B80	D0 E0		                pop     acc
 3540: 1  0B82	22		                ret
 3541: 1
 3542: 1			;*******************************************************************************
 3543: 1			; s_mac16        (145,1us @16.777216MHz)
 3544: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3545: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3546: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3547: 1			; input:     r7,r6 = acc1 (high word)
 3548: 1			;            r5,r4 = acc1 (low  word)
 3549: 1			;
 3550: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3551: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3552: 1			;                          -2147483648 tot +2147483647
 3553: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3554: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3555: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3556: 1			;
 3557: 1			; vernietigt:  niets
 3558: 1			;*******************************************************************************
 3559: 1  0B83	12 0B 42	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3560: 1  0B86	C0 E0		                push    acc
 3561: 1  0B88	C0 D0		                push    psw
 3562: 1  0B8A	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3563: 1  0B8B	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3564: 1  0B8C	F8		                mov     r0,a
 3565: 1  0B8D	ED		                mov     a,r5
 3566: 1  0B8E	39		                addc    a,r1
 3567: 1  0B8F	F9		                mov     r1,a
 3568: 1  0B90	EE		                mov     a,r6
 3569: 1  0B91	3A		                addc    a,r2
 3570: 1  0B92	FA		                mov     r2,a
 3571: 1  0B93	EF		                mov     a,r7
 3572: 1  0B94	3B		                addc    a,r3

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3573: 1  0B95	FB		                mov     r3,a
 3574: 1  0B96	20 D2 06	                jb      ov,s_mac161
 3575: 1  0B99	D0 D0		                pop     psw
 3576: 1  0B9B	C3		                clr     c                ;ok, 32bit som binnen bereik
 3577: 1  0B9C	D0 E0		                pop     acc
 3578: 1  0B9E	22		                ret
 3579: 1  0B9F	D0 D0		s_mac161:       pop     psw
 3580: 1  0BA1	D3		                setb    c                ;fout! 32bit som buiten bereik
 3581: 1  0BA2	D0 E0		                pop     acc
 3582: 1  0BA4	22		                ret
 3583: 1
 3584: 1
 3585: 1			;*******************************************************************************
 3586: 1			; s_div8        (78us @16.777216MHz)
 3587: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3588: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3589: 1			; input:    r0 = acc0 deeltal (2's compl)
 3590: 1			;           r4 = acc1 deler   (2's compl)
 3591: 1			;
 3592: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3593: 1			;           r4 = rest (2's compl)
 3594: 1			;           cy=1 bij acc1=0 (deling door nul)
 3595: 1			;            cy=0 in andere gevallen
 3596: 1			;
 3597: 1			; vernietigt: niets
 3598: 1			;*******************************************************************************
 3599: 1  0BA5	12 08 19	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3600: 1  0BA8	12 08 32	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3601: 1  0BAB	12 0B B7	                lcall   div8
 3602: 1  0BAE	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3603: 1  0BB0	12 07 51	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3604: 1  0BB3	12 07 6B	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3605: 1  0BB6	22		s_div81:        ret
 3606: 1
 3607: 1			;*******************************************************************************
 3608: 1			; div8        (19,4us @16.777216MHz)
 3609: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3610: 1			; absolute waarde
 3611: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3612: 1			; input:    r0 = acc0 deeltal
 3613: 1			;           r4 = acc1 deler
 3614: 1			;
 3615: 1			; output:   r0 = quotient van deling acc0/acc1
 3616: 1			;           r4 = rest
 3617: 1			;           cy=1 bij acc1=0 (deling door nul)
 3618: 1			;            cy=0 in andere gevallen
 3619: 1			;
 3620: 1			; vernietigt: niets
 3621: 1			;*******************************************************************************
 3622: 1  0BB7	C0 E0		div8:           push    acc             ;bewaar registers
 3623: 1  0BB9	C0 F0		                push    b
 3624: 1  0BBB	C0 D0		                push    psw
 3625: 1  0BBD	EC		                mov     a,r4            ;neem deler
 3626: 1  0BBE	60 0F		                jz      div81           ;deling door nul?
 3627: 1  0BC0	E8		                mov     a,r0            ;nee, neem deeltal
 3628: 1  0BC1	8C F0		                mov     b,r4            ;en deler

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3629: 1  0BC3	84		                div     ab              ;en maak deling
 3630: 1  0BC4	F8		                mov     r0,a            ;bewaar quotient in acc0
 3631: 1  0BC5	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3632: 1  0BC7	D0 D0		                pop     psw             ;herstel registers
 3633: 1  0BC9	D0 F0		                pop     b
 3634: 1  0BCB	D0 E0		                pop     acc
 3635: 1  0BCD	C3		                clr     c                ;geen deling door nul
 3636: 1  0BCE	22		                ret
 3637: 1
 3638: 1  0BCF	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3639: 1  0BD1	D0 F0		                pop     b
 3640: 1  0BD3	D0 E0		                pop     acc
 3641: 1  0BD5	D3		                setb    c
 3642: 1  0BD6	22		                ret
 3643: 1
 3644: 1
 3645: 1			;*******************************************************************************
 3646: 1			; s_div16        (469,1us @16.777216MHz)
 3647: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3648: 1			; 2's Complement Format
 3649: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3650: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3651: 1			;           r5, r4 = acc1 deler   (2's compl)
 3652: 1			;
 3653: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3654: 1			;           r5, r4 = rest
 3655: 1			;           cy=1 bij acc1=0 (deling door nul)
 3656: 1			;            cy=0 in andere gevallen
 3657: 1			;
 3658: 1			; vernietigt: niets
 3659: 1			;*******************************************************************************
 3660: 1  0BD7	C0 E0		s_div16:        push    acc
 3661: 1  0BD9	C0 D0		                push    psw
 3662: 1  0BDB	ED		                mov     a,r5            ;neem msb van deler
 3663: 1  0BDC	4C		                orl     a,r4            ;combineer met lsb van deler
 3664: 1  0BDD	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3665: 1  0BDF	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3666: 1  0BE1	D0 E0		                pop     acc
 3667: 1  0BE3	D3		                setb    C               ;fout, deling door nul!
 3668: 1  0BE4	22		                ret
 3669: 1
 3670: 1  0BE5	12 08 4B	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3671: 1  0BE8	12 08 6B	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3672: 1  0BEB	12 0B FA	                lcall   div16
 3673: 1  0BEE	12 07 85	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3674: 1  0BF1	12 07 A5	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3675: 1  0BF4	D0 D0		                pop     psw
 3676: 1  0BF6	C3		                clr     C               ;delig ok
 3677: 1  0BF7	D0 E0		                pop     acc
 3678: 1  0BF9	22		                ret                     ;klaar
 3679: 1
 3680: 1			;*******************************************************************************
 3681: 1			; div16            (405,1us @16.777216MHz)
 3682: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3683: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3684: 1			; input:    r1, r0 = Deeltal (acc0)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3685: 1			;           r5, r4 = Deler   (acc1)
 3686: 1			;
 3687: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3688: 1			;           r5, r4 = rest van de deling acc0/acc1
 3689: 1			;            cy=1 bij deling door nul (acc1=0)
 3690: 1			;            cy=0 bij normale deling
 3691: 1			;
 3692: 1			; vernietigt: niets
 3693: 1			;*******************************************************************************
 3694: 1
 3695: 1  0BFA	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3696: 1  0BFC	C0 D0		                push    psw
 3697: 1			;check voor deling door nul
 3698: 1  0BFE	EC		                mov     a,r4           ;neem lsb deler
 3699: 1  0BFF	4D		                orl     a,r5           ;combineer met msb van deler
 3700: 1  0C00	70 06		                jnz     div160         ;niet nul, dan verder werken
 3701: 1  0C02	D0 D0		                pop     psw            ;als nul, dikke snul
 3702: 1  0C04	D3		                setb    c              ;terug met errorstatus
 3703: 1  0C05	D0 E0		                pop     acc
 3704: 1  0C07	22		                ret
 3705: 1
 3706: 1  0C08	C0 F0		div160:         push    b              ;registers verder bewaren
 3707: 1  0C0A	EF		                mov     a,r7
 3708: 1  0C0B	C0 E0		                push    acc            ;push r7 op stack
 3709: 1  0C0D	EE		                mov     a,r6
 3710: 1  0C0E	C0 E0		                push    acc            ;push r6 op stack
 3711: 1  0C10	EB		                mov     a,r3
 3712: 1  0C11	C0 E0		                push    acc            ;push r3 op stack
 3713: 1  0C13	EA		                mov     a,r2
 3714: 1  0C14	C0 E0		                push    acc            ;push r2 op stack
 3715: 1  0C16	C0 83		                push    dph
 3716: 1  0C18	C0 82		                push    dpl
 3717: 1
 3718: 1  0C1A	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3719: 1  0C1C	7B 00		                mov     r3,#0
 3720: 1  0C1E	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3721: 1  0C20	7E 00		                mov     r6,#0
 3722: 1  0C22	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3723: 1
 3724: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3725: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3726: 1			;het aantal significante bits af in de lusteller b
 3727: 1
 3728: 1  0C25	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3729: 1  0C26	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3730: 1  0C29	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3731: 1  0C2A	E8		                mov     a,r0            ;lsb van deeltal nemen
 3732: 1  0C2B	33		                rlc     a                ;en opschuiven
 3733: 1  0C2C	F8		                mov     r0,a
 3734: 1  0C2D	E9		                mov     a,r1            ;msb van deeltal nemen
 3735: 1  0C2E	33		                rlc     a
 3736: 1  0C2F	F9		                mov     r1,a
 3737: 1  0C30	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3738: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3739: 1  0C33	7C 00		                mov     r4,#0
 3740: 1  0C35	7D 00		                mov     r5,#0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3741: 1  0C37	80 2E		                sjmp    div164          ;klaar!
 3742: 1
 3743: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3744: 1
 3745: 1  0C39	C3		div162:            clr     C            ;start met carry op nul
 3746: 1  0C3A	E8		                mov     a,r0            ;schuif deeltal naar links
 3747: 1  0C3B	33		                rlc     a
 3748: 1  0C3C	F8		                mov     r0,a
 3749: 1  0C3D	E9		                mov     a,r1
 3750: 1  0C3E	33		                rlc     a
 3751: 1  0C3F	F9		                mov     r1,a
 3752: 1  0C40	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3753: 1  0C41	33		                rlc     a               ;gedeeltelijke rest
 3754: 1  0C42	FE		                mov     r6,a
 3755: 1  0C43	EF		                mov     a,r7
 3756: 1  0C44	33		                rlc     a
 3757: 1  0C45	FF		                mov     r7,a
 3758: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3759: 1  0C46	EE		                mov     a,r6
 3760: 1  0C47	C3		                clr     C
 3761: 1  0C48	9C		                subb    a,r4
 3762: 1  0C49	F5 82		                mov     dpl,a
 3763: 1  0C4B	EF		                mov     a,r7
 3764: 1  0C4C	9D		                subb    a,r5
 3765: 1  0C4D	F5 83		                mov     dph,a
 3766: 1  0C4F	40 04		                jc      div163
 3767: 1  0C51	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3768: 1  0C53	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3769: 1
 3770: 1  0C55	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3771: 1  0C56	EA		                mov     a,r2            ;binnenschuiven
 3772: 1  0C57	33		                rlc     a
 3773: 1  0C58	FA		                mov     r2,a
 3774: 1  0C59	EB		                mov     a,r3
 3775: 1  0C5A	33		                rlc     a
 3776: 1  0C5B	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 3777: 1  0C5C	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3778: 1
 3779: 1  0C5F	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3780: 1  0C60	F9		                mov     r1,a
 3781: 1  0C61	EA		                mov     a,r2
 3782: 1  0C62	F8		                mov     r0,a
 3783: 1  0C63	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3784: 1  0C64	FD		                mov     r5,a
 3785: 1  0C65	EE		                mov     a,r6
 3786: 1  0C66	FC		                mov     r4,a
 3787: 1
 3788: 1  0C67	D0 82		div164:         pop     dpl             ;registers herstellen
 3789: 1  0C69	D0 83		                pop     dph
 3790: 1  0C6B	D0 E0		                pop     acc
 3791: 1  0C6D	FA		                mov     r2,a            ;r2 van stack halen
 3792: 1  0C6E	D0 E0		                pop     acc
 3793: 1  0C70	FB		                mov     r3,a            ;r3 van stack halen
 3794: 1  0C71	D0 E0		                pop     acc
 3795: 1  0C73	FE		                mov     r6,a            ;r6 van stack halen
 3796: 1  0C74	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3797: 1  0C76	FF		                mov     r7,a            ;r7 van stack halen
 3798: 1  0C77	D0 F0		                pop     b
 3799: 1  0C79	D0 D0		                pop     psw
 3800: 1  0C7B	C3		                clr     c               ;deling ok
 3801: 1  0C7C	D0 E0		                pop     acc
 3802: 1  0C7E	22		                ret
 3803: 1
 3804: 1
 3805: 1			;*******************************************************************************
 3806: 1			; s_div32        (2,15ms @16.777216MHz)
 3807: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3808: 1			; 2's Complement Format
 3809: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3810: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3811: 1			;
 3812: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 3813: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3814: 1			;
 3815: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3816: 1			;           r7,r6,r5, r4 = rest
 3817: 1			;           cy=1 bij acc1=0 (deling door nul)
 3818: 1			;            cy=0 in andere gevallen
 3819: 1			;
 3820: 1			; vernietigt: niets
 3821: 1			;*******************************************************************************
 3822: 1  0C7F	C0 E0		s_div32:        push    acc
 3823: 1  0C81	C0 D0		                push    psw
 3824: 1  0C83	EF		                mov     a,r7            ;neem msb van deler
 3825: 1  0C84	4E		                orl     a,r6            ;combineer met lsb's van deler
 3826: 1  0C85	4D		                orl     a,r5
 3827: 1  0C86	4C		                orl     a,r4
 3828: 1  0C87	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3829: 1  0C89	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3830: 1  0C8B	D0 E0		                pop     acc
 3831: 1  0C8D	D3		                setb    C                ;fout, deling door nul!
 3832: 1  0C8E	22		                ret
 3833: 1
 3834: 1  0C8F	12 08 AB	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3835: 1  0C92	12 08 D5	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3836: 1  0C95	12 0C A4	                lcall   div32            ;deel 32bit/32bit
 3837: 1  0C98	12 07 C5	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3838: 1  0C9B	12 07 EF	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3839: 1  0C9E	D0 D0		                pop     psw
 3840: 1  0CA0	C3		                clr     C                ;delig ok
 3841: 1  0CA1	D0 E0		                pop     acc
 3842: 1  0CA3	22		                ret                        ;klaar
 3843: 1
 3844: 1
 3845: 1			;*******************************************************************************
 3846: 1			; div32        (2,09ms @16.777216MHz)
 3847: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3848: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3849: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3850: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3851: 1			;
 3852: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3853: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3854: 1			;            cy=1 bij deling door nul (acc1=0)
 3855: 1			;            cy=0 bij normale deling
 3856: 1			;
 3857: 1			; vernietigt: niets
 3858: 1			;*******************************************************************************
 3859: 1  0CA4	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3860: 1  0CA6	C0 D0		                push    psw
 3861: 1			;check voor deling door nul
 3862: 1  0CA8	EF		                mov     a,r7            ;neem msb van deler
 3863: 1  0CA9	4E		                orl     a,r6            ;combineer met lsb's van deler
 3864: 1  0CAA	4D		                orl     a,r5
 3865: 1  0CAB	4C		                orl     a,r4
 3866: 1  0CAC	70 06		                jnz     div320          ;niet nul, dan verder werken
 3867: 1  0CAE	D0 D0		                pop     psw             ;als nul, dikke snul
 3868: 1  0CB0	D3		                setb    c               ;terug met errorstatus
 3869: 1  0CB1	D0 E0		                pop     acc
 3870: 1  0CB3	22		                ret
 3871: 1
 3872: 1  0CB4	C0 F0		div320:         push    b                ;registers verder bewaren
 3873: 1  0CB6	C0 83		                push    dph
 3874: 1  0CB8	C0 82		                push    dpl
 3875: 1
 3876: 1  0CBA	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3877: 1
 3878: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3879: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3880: 1			;het aantal significante bits af in de lusteller b
 3881: 1
 3882: 1  0CBD	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3883: 1  0CBE	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3884: 1  0CC1	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3885: 1  0CC2	E8		                mov     a,r0            ;lsb van deeltal nemen
 3886: 1  0CC3	33		                rlc     a               ;en opschuiven
 3887: 1  0CC4	F8		                mov     r0,a
 3888: 1  0CC5	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 3889: 1  0CC6	33		                rlc     a
 3890: 1  0CC7	F9		                mov     r1,a
 3891: 1  0CC8	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3892: 1  0CC9	33		                rlc     a
 3893: 1  0CCA	FA		                mov     r2,a
 3894: 1  0CCB	EB		                mov     a,r3           ;lsb van deeltal nemen
 3895: 1  0CCC	33		                rlc     a
 3896: 1  0CCD	FB		                mov     r3,a
 3897: 1  0CCE	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3898: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3899: 1  0CD1	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3900: 1  0CD3	7E 00		                mov     r6,#0
 3901: 1  0CD5	7D 00		                mov     r5,#0
 3902: 1  0CD7	7C 00		                mov     r4,#0
 3903: 1  0CD9	02 0D A2	                ljmp    div324           ;klaar!
 3904: 1
 3905: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 3906: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 3907: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 3908: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3909: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 3910: 1
 3911: 1  0CDC			div320b:
 3912: 1  0CDC	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 3913: 1
 3914: 1  0CDF	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 3915: 1  0CE1	24 0C		                add     a,#12           ;met 12 plaatsen
 3916: 1  0CE3	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 3917: 1
 3918: 1  0CE5	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 3919: 1  0CE6	C0 E0		                push    acc
 3920: 1  0CE8	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 3921: 1  0CE9	C0 E0		                push    acc
 3922: 1
 3923: 1  0CEB	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 3924: 1  0CED	08		                inc     r0              ;de deler
 3925: 1  0CEE	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 3926: 1  0CF0	24 05		                add     a,#5            ;het tijdelijk verschil X
 3927: 1  0CF2	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 3928: 1  0CF3	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 3929: 1  0CF5	24 09		                add     a,#9            ;quotient
 3930: 1  0CF7	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 3931: 1
 3932: 1			;Eenmalig de variabelen op stack initaliseren
 3933: 1			;Tijdelijk quotient op nul zetten
 3934: 1
 3935: 1  0CF9	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 3936: 1  0CFB	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 3937: 1  0CFC	C0 F0		                push    b                ;loopteller deling bewaren
 3938: 1  0CFE	75 F0 04	                mov     b,#4
 3939: 1  0D01	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 3940: 1  0D03	09		                inc     r1
 3941: 1  0D04	D5 F0 FA	                djnz    b,div320c
 3942: 1  0D07	D0 F0		                pop     b                ;loopteller deling ophalen
 3943: 1  0D09	19		                dec     r1
 3944: 1  0D0A	19		                dec     r1
 3945: 1  0D0B	19		                dec     r1
 3946: 1  0D0C	19		                dec     r1               ;pointer weer op startadres quotient
 3947: 1  0D0D	C9		                xch     a,r1             ;weer omwisselen
 3948: 1  0D0E	C5 82		                xch     a,dpl
 3949: 1
 3950: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 3951: 1  0D10	EC		                mov     a,r4
 3952: 1  0D11	F6		                mov     @r0,a
 3953: 1  0D12	08		                inc     r0
 3954: 1  0D13	ED		                mov     a,r5
 3955: 1  0D14	F6		                mov     @r0,a
 3956: 1  0D15	08		                inc     r0
 3957: 1  0D16	EE		                mov     a,r6
 3958: 1  0D17	F6		                mov     @r0,a
 3959: 1  0D18	08		                inc     r0
 3960: 1  0D19	EF		                mov     a,r7
 3961: 1  0D1A	F6		                mov     @r0,a
 3962: 1  0D1B	18		                dec     r0             ;pointer herstellen naar lsb van deler
 3963: 1  0D1C	18		                dec     r0
 3964: 1  0D1D	18		                dec     r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3965: 1
 3966: 1  0D1E	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 3967: 1  0D20	7E 00		                mov     r6,#0
 3968: 1  0D22	7D 00		                mov     r5,#0
 3969: 1  0D24	7C 00		                mov     r4,#0
 3970: 1
 3971: 1
 3972: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 3973: 1  0D26	C3		div322:         clr     C               ;start met carry op nul
 3974: 1
 3975: 1  0D27	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 3976: 1  0D29	33		                rlc     a
 3977: 1  0D2A	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 3978: 1  0D2C	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 3979: 1  0D2E	D0 E0		                pop     acc             ;r1 van deeltal van stack
 3980: 1  0D30	33		                rlc     a
 3981: 1  0D31	C0 E0		                push    acc             ;en weer bewaren
 3982: 1  0D33	05 81		                inc     sp              ;stackpointer weer corrigeren
 3983: 1
 3984: 1  0D35	EA		                mov     a,r2
 3985: 1  0D36	33		                rlc     a
 3986: 1  0D37	FA		                mov     r2,a
 3987: 1  0D38	EB		                mov     a,r3
 3988: 1  0D39	33		                rlc     a
 3989: 1  0D3A	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 3990: 1
 3991: 1  0D3B	EC		                mov     a,r4            ;schuif carry van deeltal in de
 3992: 1  0D3C	33		                rlc     a               ;gedeeltelijke rest r7..r4
 3993: 1  0D3D	FC		                mov     r4,a
 3994: 1  0D3E	ED		                mov     a,r5
 3995: 1  0D3F	33		                rlc     a
 3996: 1  0D40	FD		                mov     r5,a
 3997: 1  0D41	EE		                mov     a,r6
 3998: 1  0D42	33		                rlc     a
 3999: 1  0D43	FE		                mov     r6,a
 4000: 1  0D44	EF		                mov     a,r7
 4001: 1  0D45	33		                rlc     a
 4002: 1  0D46	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 4003: 1
 4004: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 4005: 1
 4006: 1  0D47	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 4007: 1  0D48	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 4008: 1  0D49	96		                subb    a,@r0           ;trek er de lsb deler af
 4009: 1  0D4A	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4010: 1  0D4B	08		                inc     r0              ;pointers aanpassen
 4011: 1  0D4C	09		                inc     r1
 4012: 1  0D4D	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4013: 1  0D4E	96		                subb    a,@r0           ;trek er volgende byte deler af
 4014: 1  0D4F	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4015: 1  0D50	08		                inc     r0              ;pointers aanpassen
 4016: 1  0D51	09		                inc     r1
 4017: 1  0D52	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4018: 1  0D53	96		                subb    a,@r0           ;trek er volgende byte deler af
 4019: 1  0D54	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4020: 1  0D55	08		                inc     r0              ;pointers aanpassen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4021: 1  0D56	09		                inc     r1
 4022: 1  0D57	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4023: 1  0D58	96		                subb    a,@r0           ;trek er msb deler af
 4024: 1  0D59	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4025: 1  0D5A	18		                dec     r0              ;pointers herstellen naar lsb's
 4026: 1  0D5B	18		                dec     r0
 4027: 1  0D5C	18		                dec     r0
 4028: 1  0D5D	19		                dec     r1
 4029: 1  0D5E	19		                dec     r1
 4030: 1  0D5F	19		                dec     r1
 4031: 1
 4032: 1  0D60	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4033: 1  0D62	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4034: 1  0D63	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4035: 1  0D64	09		                inc     r1
 4036: 1  0D65	E7		                mov     a,@r1
 4037: 1  0D66	FD		                mov     r5,a
 4038: 1  0D67	09		                inc     r1
 4039: 1  0D68	E7		                mov     a,@r1
 4040: 1  0D69	FE		                mov     r6,a
 4041: 1  0D6A	09		                inc     r1
 4042: 1  0D6B	E7		                mov     a,@r1
 4043: 1  0D6C	FF		                mov     r7,a
 4044: 1  0D6D	19		                dec     r1              ;met pointer weer naar lsb van
 4045: 1  0D6E	19		                dec     r1              ;het tijdelijk verschil wijzen
 4046: 1  0D6F	19		                dec     r1
 4047: 1
 4048: 1
 4049: 1  0D70	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4050: 1  0D71	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4051: 1  0D73	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4052: 1  0D74	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4053: 1  0D76	E7		                mov     a,@r1           ;neem lsb van qoutient
 4054: 1  0D77	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4055: 1  0D78	F7		                mov     @r1,a
 4056: 1  0D79	09		                inc     r1              ;volgende byte
 4057: 1  0D7A	E7		                mov     a,@r1
 4058: 1  0D7B	33		                rlc     a
 4059: 1  0D7C	F7		                mov     @r1,a
 4060: 1  0D7D	09		                inc     r1              ;volgende byte
 4061: 1  0D7E	E7		                mov     a,@r1
 4062: 1  0D7F	33		                rlc     a
 4063: 1  0D80	F7		                mov     @r1,a
 4064: 1  0D81	09		                inc     r1              ;volgende byte
 4065: 1  0D82	E7		                mov     a,@r1
 4066: 1  0D83	33		                rlc     a
 4067: 1  0D84	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4068: 1  0D85	19		                dec     r1
 4069: 1  0D86	19		                dec     r1
 4070: 1  0D87	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4071: 1  0D88	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4072: 1  0D8A	C9		                xch     a,r1            ;r1=pointer naar verschil
 4073: 1  0D8B	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4074: 1
 4075: 1  0D8D	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4076: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4077: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4078: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4079: 1
 4080: 1  0D90	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4081: 1  0D92	18		                dec     r0
 4082: 1  0D93	18		                dec     r0
 4083: 1  0D94	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4084: 1  0D95	FB		                mov     r3,a            ;en verplaatsen
 4085: 1  0D96	18		                dec     r0              ;volgende byte
 4086: 1  0D97	E6		                mov     a,@r0
 4087: 1  0D98	FA		                mov     r2,a
 4088: 1  0D99	18		                dec     r0              ;volgende byte
 4089: 1  0D9A	E6		                mov     a,@r0
 4090: 1  0D9B	F9		                mov     r1,a
 4091: 1  0D9C	18		                dec     r0              ;volgende byte
 4092: 1  0D9D	E6		                mov     a,@r0
 4093: 1  0D9E	F8		                mov     r0,a            ;laatste byte verplaatst!
 4094: 1
 4095: 1  0D9F	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4096: 1			                                         ;weer vrijgeven
 4097: 1
 4098: 1
 4099: 1  0DA2	D0 82		div324:         pop     dpl             ;registers herstellen
 4100: 1  0DA4	D0 83		                pop     dph
 4101: 1  0DA6	D0 F0		                pop     b
 4102: 1  0DA8	D0 D0		                pop     psw
 4103: 1  0DAA	C3		                clr     c               ;normale deling
 4104: 1  0DAB	D0 E0		                pop     acc
 4105: 1  0DAD	22		                ret
 4106: 1
 4107: 1			;*******************************************************************************
 4108: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4109: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4110: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4111: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4112: 1			;
 4113: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4114: 1			;
 4115: 1			; input:     r5,r4 = acc1 (low word product)
 4116: 1			;            r7,r6 = acc1 (high word product)
 4117: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4118: 1			;
 4119: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4120: 1			;            r7,r6,r5,r4 = acc1 = rest
 4121: 1			;                          -2147483648 tot +2147483647
 4122: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4123: 1			;             cy=1 bij deling door nul (acc0=0)
 4124: 1			;             cy=0 bij normale deling
 4125: 1			;
 4126: 1			; vernietigt:  niets
 4127: 1			;*******************************************************************************
 4128: 1  0DAE	C0 E0		s_muldiv:       push    acc
 4129: 1  0DB0	C0 D0		                push    psw
 4130: 1  0DB2	E8		                mov     a,r0            ;neem msb van deler
 4131: 1  0DB3	49		                orl     a,r1            ;combineer met lsb's van deler
 4132: 1  0DB4	4A		                orl     a,r2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4133: 1  0DB5	4B		                orl     a,r3
 4134: 1  0DB6	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4135: 1  0DB8	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4136: 1  0DBA	D0 E0		                pop     acc
 4137: 1  0DBC	D3		                setb    C               ;fout, deling door nul!
 4138: 1  0DBD	22		                ret
 4139: 1
 4140: 1  0DBE	12 08 6B	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4141: 1  0DC1	12 08 8B	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4142: 1  0DC4	12 0D D3	                lcall    muldiv          ;maak product en daarna de deling
 4143: 1  0DC7	12 07 C5	                lcall    magsig32        ;quotient naar 2's complement
 4144: 1  0DCA	12 07 EF	                lcall    magsig32acc1    ;rest naar 2's complement
 4145: 1  0DCD	D0 D0		                pop     psw
 4146: 1  0DCF	C3		                clr     c                ;deling is ok
 4147: 1  0DD0	D0 E0		                pop    acc
 4148: 1  0DD2	22		                ret
 4149: 1
 4150: 1			;*******************************************************************************
 4151: 1			; muldiv        (2,0ms @16.777216MHz)
 4152: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4153: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4154: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4155: 1			; 32bit rest in acc1.
 4156: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4157: 1			;
 4158: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4159: 1			;
 4160: 1			; input:     r5,r4 = acc1 (low word product)
 4161: 1			;            r7,r6 = acc1 (high word product)
 4162: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4163: 1			;
 4164: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4165: 1			;            r7,r6,r5,r4 = acc1 = rest
 4166: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4167: 1			;             cy=1 bij deling door nul (acc0=0)
 4168: 1			;             cy=0 bij normale deling
 4169: 1			;
 4170: 1			; vernietigt:  niets
 4171: 1			;*******************************************************************************
 4172: 1  0DD3	C0 E0		muldiv:         push    acc
 4173: 1  0DD5	C0 D0		                push    psw
 4174: 1  0DD7	E8		                mov     a,r0            ;neem msb van deler
 4175: 1  0DD8	49		                orl     a,r1            ;combineer met lsb's van deler
 4176: 1  0DD9	4A		                orl     a,r2
 4177: 1  0DDA	4B		                orl     a,r3
 4178: 1  0DDB	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4179: 1  0DDD	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4180: 1  0DDF	D0 E0		                pop     acc
 4181: 1  0DE1	D3		                setb    C               ;fout, deling door nul!
 4182: 1  0DE2	22		                ret
 4183: 1
 4184: 1  0DE3	12 0A D4	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4185: 1  0DE6	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4186: 1  0DE7	C0 E0		                push    acc
 4187: 1  0DE9	ED		                mov     a,r5
 4188: 1  0DEA	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4189: 1  0DEC	EE		                mov     a,r6
 4190: 1  0DED	C0 E0		                push    acc
 4191: 1  0DEF	EF		                mov     a,r7
 4192: 1  0DF0	C0 E0		                push    acc             ;product staat nu op stack
 4193: 1
 4194: 1  0DF2	E8		                mov     a,r0            ;deler in acc1 stoppen
 4195: 1  0DF3	FC		                mov     r4,a
 4196: 1  0DF4	E9		                mov     a,r1
 4197: 1  0DF5	FD		                mov     r5,a
 4198: 1  0DF6	EA		                mov     a,r2
 4199: 1  0DF7	FE		                mov     r6,a
 4200: 1  0DF8	EB		                mov     a,r3
 4201: 1  0DF9	FF		                mov     r7,a            ;deler zit volledig in acc1
 4202: 1
 4203: 1  0DFA	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4204: 1  0DFC	FB		                mov     r3,a
 4205: 1  0DFD	D0 E0		                pop     acc
 4206: 1  0DFF	FA		                mov     r2,a
 4207: 1  0E00	D0 E0		                pop     acc
 4208: 1  0E02	F9		                mov     r1,a
 4209: 1  0E03	D0 E0		                pop     acc
 4210: 1  0E05	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4211: 1  0E06	12 0C A4	                lcall   div32           ;maak deling
 4212: 1
 4213: 1  0E09	D0 D0		                pop     psw            ;herstel registers
 4214: 1  0E0B	D0 E0		                pop     acc
 4215: 1  0E0D	C3		                clr     C              ;resultaat ok!
 4216: 1  0E0E	22		                ret
 4217: 1
 4218: 1			;*******************************************************************************
 4219: 1			; mul16_pi        (257,1us @16.777216MHz)
 4220: 1			; acc0 = acc0 x pi
 4221: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4222: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4223: 1			;
 4224: 1			; input:     r1,r0 = acc0 (low word)
 4225: 1			;
 4226: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4227: 1			;
 4228: 1			; vernietigt:  niets
 4229: 1			;*******************************************************************************
 4230: 1  0E0F	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4231: 1  0E11	C0 D0		                push    psw
 4232: 1  0E13	EC		                mov     a,r4
 4233: 1  0E14	C0 E0		                push    acc
 4234: 1  0E16	ED		                mov     a,r5
 4235: 1  0E17	C0 E0		                push    acc
 4236: 1  0E19	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4237: 1  0E1B	7C 0F		                mov     r4,#0fH
 4238: 1  0E1D	12 0A 6F	                lcall   mul16           ;acc0 = acc0 x acc1
 4239: 1  0E20	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4240: 1  0E22	12 10 0B	                lcall   shiftright32    ;om te delen door 2^14
 4241: 1  0E25	D0 E0		                pop     acc
 4242: 1  0E27	FD		                mov     r5,a
 4243: 1  0E28	D0 E0		                pop     acc
 4244: 1  0E2A	FC		                mov     r4,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4245: 1  0E2B	D0 D0		                pop     psw
 4246: 1  0E2D	D0 E0		                pop     acc
 4247: 1  0E2F	22		                ret
 4248: 1
 4249: 1			;*******************************************************************************
 4250: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4251: 1			; acc0 = acc0 x 1/pi
 4252: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4253: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4254: 1			;
 4255: 1			; input:     r1,r0 = acc0 (low word)
 4256: 1			;
 4257: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4258: 1			;
 4259: 1			; vernietigt:  niets
 4260: 1			;*******************************************************************************
 4261: 1  0E30	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4262: 1  0E32	C0 D0		                push    psw
 4263: 1  0E34	EC		                mov     a,r4
 4264: 1  0E35	C0 E0		                push    acc
 4265: 1  0E37	ED		                mov     a,r5
 4266: 1  0E38	C0 E0		                push    acc
 4267: 1  0E3A	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4268: 1  0E3C	7C 7D		                mov     r4,#07dH
 4269: 1  0E3E	12 0A 6F	                lcall    mul16          ;acc0 = acc0 x acc1
 4270: 1  0E41	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4271: 1  0E43	12 10 0B	                lcall   shiftright32    ;om te delen door 2^16
 4272: 1  0E46	D0 E0		                pop     acc
 4273: 1  0E48	FD		                mov     r5,a
 4274: 1  0E49	D0 E0		                pop     acc
 4275: 1  0E4B	FC		                mov     r4,a
 4276: 1  0E4C	D0 D0		                pop     psw
 4277: 1  0E4E	D0 E0		                pop     acc
 4278: 1  0E50	22		                ret
 4279: 1
 4280: 1			;*******************************************************************************
 4281: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4282: 1			; acc0 = acc0 x sqrt2
 4283: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4284: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4285: 1			;
 4286: 1			; input:     r1,r0 = acc0 (low word)
 4287: 1			;
 4288: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4289: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4290: 1			;
 4291: 1			; vernietigt:  niets
 4292: 1			;*******************************************************************************
 4293: 1  0E51	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4294: 1  0E53	C0 D0		                push    psw
 4295: 1  0E55	EC		                mov     a,r4
 4296: 1  0E56	C0 E0		                push    acc
 4297: 1  0E58	ED		                mov     a,r5
 4298: 1  0E59	C0 E0		                push    acc
 4299: 1  0E5B	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4300: 1  0E5D	7C 05		                mov     r4,#005H

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4301: 1  0E5F	12 0A 6F	                lcall   mul16           ;acc0 = acc0 x acc1
 4302: 1  0E62	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4303: 1  0E64	12 10 0B	                lcall   shiftright32    ;om te delen door 2^15
 4304: 1  0E67	D0 E0		                pop     acc
 4305: 1  0E69	FD		                mov     r5,a
 4306: 1  0E6A	D0 E0		                pop     acc
 4307: 1  0E6C	FC		                mov     r4,a
 4308: 1  0E6D	D0 D0		                pop     psw
 4309: 1  0E6F	D0 E0		                pop     acc
 4310: 1  0E71	22		                ret
 4311: 1
 4312: 1
 4313: 1
 4314: 1			;*******************************************************************************
 4315: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4316: 1			; acc0 = acc0 x 1/sqrt2
 4317: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4318: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4319: 1			;
 4320: 1			; input:     r1,r0 = acc0 (low word)
 4321: 1			;
 4322: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4323: 1			;
 4324: 1			; vernietigt:  niets
 4325: 1			;*******************************************************************************
 4326: 1  0E72	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4327: 1  0E74	C0 D0		                push    psw
 4328: 1  0E76	EC		                mov     a,r4
 4329: 1  0E77	C0 E0		                push    acc
 4330: 1  0E79	ED		                mov     a,r5
 4331: 1  0E7A	C0 E0		                push    acc
 4332: 1  0E7C	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4333: 1  0E7E	7C 05		                mov     r4,#005H
 4334: 1  0E80	12 0A 6F	                lcall   mul16           ;acc0 = acc0 x acc1
 4335: 1  0E83	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4336: 1  0E85	12 10 0B	                lcall   shiftright32    ;om te delen door 2^16
 4337: 1  0E88	D0 E0		                pop     acc
 4338: 1  0E8A	FD		                mov     r5,a
 4339: 1  0E8B	D0 E0		                pop     acc
 4340: 1  0E8D	FC		                mov     r4,a
 4341: 1  0E8E	D0 D0		                pop     psw
 4342: 1  0E90	D0 E0		                pop     acc
 4343: 1  0E92	22		                ret
 4344: 1
 4345: 1			;*******************************************************************************
 4346: 1			; mul16_10        (98,7us @16.777216MHz)
 4347: 1			; acc0 = acc0 x 10
 4348: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4349: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4350: 1			;
 4351: 1			; input:     r1,r0 = acc0 (low word)
 4352: 1			;
 4353: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4354: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4355: 1			; vernietigt:  niets
 4356: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4357: 1  0E93	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4358: 1  0E95	C0 D0		                push    psw
 4359: 1  0E97	EC		                mov     a,r4
 4360: 1  0E98	C0 E0		                push    acc
 4361: 1  0E9A	7C 01		                mov     r4,#1           ;acc0 x2
 4362: 1  0E9C	12 10 37	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4363: 1  0E9F	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4364: 1  0EA0	C0 E0		                push    acc
 4365: 1  0EA2	EA		                mov     a,r2
 4366: 1  0EA3	C0 E0		                push    acc
 4367: 1  0EA5	E9		                mov     a,r1
 4368: 1  0EA6	C0 E0		                push    acc
 4369: 1  0EA8	E8		                mov     a,r0
 4370: 1  0EA9	C0 E0		                push    acc             ;acc0 op stack
 4371: 1  0EAB	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4372: 1  0EAD	12 10 37	                lcall   shiftleft32     ;acc0 =acc0 x4
 4373: 1  0EB0	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4374: 1  0EB2	28		                add     a,r0            ;tel bij huidige acc0
 4375: 1  0EB3	F8		                mov     r0,a
 4376: 1  0EB4	D0 E0		                pop     acc
 4377: 1  0EB6	39		                addc    a,r1
 4378: 1  0EB7	F9		                mov     r1,a
 4379: 1  0EB8	D0 E0		                pop     acc
 4380: 1  0EBA	3A		                addc    a,r2
 4381: 1  0EBB	FA		                mov     r2,a
 4382: 1  0EBC	D0 E0		                pop     acc
 4383: 1  0EBE	3B		                addc    a,r3
 4384: 1  0EBF	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4385: 1
 4386: 1
 4387: 1  0EC0	D0 E0		                pop     acc
 4388: 1  0EC2	FC		                mov     r4,a
 4389: 1  0EC3	D0 D0		                pop     psw
 4390: 1  0EC5	D0 E0		                pop     acc
 4391: 1  0EC7	22		                ret
 4392: 1
 4393: 1			;*******************************************************************************
 4394: 1			; mul16_100        (169,1us @16.777216MHz)
 4395: 1			; acc0 = acc0 x 100
 4396: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4397: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4398: 1			;
 4399: 1			; input:     r1,r0 = acc0 (low word)
 4400: 1			;
 4401: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4402: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4403: 1			; vernietigt:  niets
 4404: 1			;*******************************************************************************
 4405: 1  0EC8	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4406: 1  0ECA	C0 D0		                push    psw
 4407: 1  0ECC	EC		                mov     a,r4
 4408: 1  0ECD	C0 E0		                push    acc
 4409: 1  0ECF	7C 02		                mov     r4,#2           ;acc0 x4
 4410: 1  0ED1	12 10 37	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4411: 1  0ED4	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4412: 1  0ED5	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4413: 1  0ED7	EA		                mov     a,r2
 4414: 1  0ED8	C0 E0		                push    acc
 4415: 1  0EDA	E9		                mov     a,r1
 4416: 1  0EDB	C0 E0		                push    acc
 4417: 1  0EDD	E8		                mov     a,r0
 4418: 1  0EDE	C0 E0		                push    acc             ;acc0 op stack
 4419: 1
 4420: 1  0EE0	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4421: 1  0EE2	12 10 37	                lcall   shiftleft32     ;acc0 =acc0 x8
 4422: 1  0EE5	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4423: 1  0EE6	C0 E0		                push    acc
 4424: 1  0EE8	EA		                mov     a,r2
 4425: 1  0EE9	C0 E0		                push    acc
 4426: 1  0EEB	E9		                mov     a,r1
 4427: 1  0EEC	C0 E0		                push    acc
 4428: 1  0EEE	E8		                mov     a,r0
 4429: 1  0EEF	C0 E0		                push    acc             ;acc0 op stack
 4430: 1
 4431: 1  0EF1	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4432: 1  0EF3	12 10 37	                lcall   shiftleft32     ;acc0 =acc0 x2
 4433: 1  0EF6	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4434: 1  0EF8	28		                add     a,r0            ;tel bij huidige acc0
 4435: 1  0EF9	F8		                mov     r0,a
 4436: 1  0EFA	D0 E0		                pop     acc
 4437: 1  0EFC	39		                addc    a,r1
 4438: 1  0EFD	F9		                mov     r1,a
 4439: 1  0EFE	D0 E0		                pop     acc
 4440: 1  0F00	3A		                addc    a,r2
 4441: 1  0F01	FA		                mov     r2,a
 4442: 1  0F02	D0 E0		                pop     acc
 4443: 1  0F04	3B		                addc    a,r3
 4444: 1  0F05	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4445: 1
 4446: 1  0F06	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4447: 1  0F08	28		                add     a,r0            ;tel bij huidige acc0
 4448: 1  0F09	F8		                mov     r0,a
 4449: 1  0F0A	D0 E0		                pop     acc
 4450: 1  0F0C	39		                addc    a,r1
 4451: 1  0F0D	F9		                mov     r1,a
 4452: 1  0F0E	D0 E0		                pop     acc
 4453: 1  0F10	3A		                addc    a,r2
 4454: 1  0F11	FA		                mov     r2,a
 4455: 1  0F12	D0 E0		                pop     acc
 4456: 1  0F14	3B		                addc    a,r3
 4457: 1  0F15	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4458: 1
 4459: 1  0F16	D0 E0		                pop     acc
 4460: 1  0F18	FC		                mov     r4,a
 4461: 1  0F19	D0 D0		                pop     psw
 4462: 1  0F1B	D0 E0		                pop     acc
 4463: 1  0F1D	22		                ret
 4464: 1
 4465: 1			;*******************************************************************************
 4466: 1			; sqrt32        (2,99ms @16.777216MHz)
 4467: 1			; acc0 = acc0 ^(1/2)
 4468: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4469: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4470: 1			;
 4471: 1			; input:     r3,r2,r1,r0 = acc0
 4472: 1			;
 4473: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4474: 1			;
 4475: 1			; vernietigt:  niets
 4476: 1			;*******************************************************************************
 4477: 1  0F1E	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4478: 1  0F20	C0 F0		                push    b
 4479: 1  0F22	C0 D0		                push    psw
 4480: 1  0F24	C0 82		                push    dpl
 4481: 1  0F26	C0 83		                push    dph
 4482: 1  0F28	EC		                mov     a,r4
 4483: 1  0F29	C0 E0		                push    acc
 4484: 1  0F2B	ED		                mov     a,r5
 4485: 1  0F2C	C0 E0		                push    acc
 4486: 1  0F2E	EE		                mov     a,r6
 4487: 1  0F2F	C0 E0		                push    acc
 4488: 1  0F31	EF		                mov     a,r7
 4489: 1  0F32	C0 E0		                push    acc
 4490: 1
 4491: 1  0F34	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4492: 1  0F36	7D 00		                mov     r5,#0
 4493: 1  0F38	7E 00		                mov     r6,#0
 4494: 1  0F3A	7F 00		                mov     r7,#0
 4495: 1  0F3C	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4496: 1  0F3F	75 83 00	                mov     dph,#0
 4497: 1  0F42	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4498: 1			;hier start het algorithme voor het berekenen van de wortel
 4499: 1  0F45	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4500: 1  0F47	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4501: 1  0F4A	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4502: 1  0F4B	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4503: 1  0F4C	33		                rlc     a                ;getest worden om een wortelbit te
 4504: 1  0F4D	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4505: 1  0F4E	E9		                mov     a,r1            ;met nullen!
 4506: 1  0F4F	33		                rlc     a
 4507: 1  0F50	F9		                mov     r1,a
 4508: 1  0F51	EA		                mov     a,r2
 4509: 1  0F52	33		                rlc     a
 4510: 1  0F53	FA		                mov     r2,a
 4511: 1  0F54	EB		                mov     a,r3
 4512: 1  0F55	33		                rlc     a
 4513: 1  0F56	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4514: 1
 4515: 1  0F57	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4516: 1  0F58	33		                rlc     a
 4517: 1  0F59	FC		                mov     r4,a
 4518: 1  0F5A	ED		                mov     a,r5
 4519: 1  0F5B	33		                rlc     a
 4520: 1  0F5C	FD		                mov     r5,a
 4521: 1  0F5D	EE		                mov     a,r6
 4522: 1  0F5E	33		                rlc     a
 4523: 1  0F5F	FE		                mov     r6,a
 4524: 1  0F60	EF		                mov     a,r7

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4525: 1  0F61	33		                rlc     a
 4526: 1  0F62	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4527: 1  0F63	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4528: 1
 4529: 1  0F66	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4530: 1
 4531: 1  0F68	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4532: 1  0F69	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4533: 1  0F6B	33		                rlc     a
 4534: 1  0F6C	F5 82		                mov     dpl,a
 4535: 1  0F6E	E5 83		                mov     a,dph
 4536: 1  0F70	33		                rlc     a
 4537: 1  0F71	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4538: 1
 4539: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4540: 1  0F73	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4541: 1  0F74	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4542: 1  0F76	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4543: 1  0F77	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4544: 1  0F79	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4545: 1  0F7A	C0 E0		                push    acc             ;van acc1
 4546: 1  0F7C	EB		                mov     a,r3
 4547: 1  0F7D	C0 E0		                push    acc
 4548: 1  0F7F	EC		                mov     a,r4
 4549: 1  0F80	C0 E0		                push    acc
 4550: 1  0F82	ED		                mov     a,r5
 4551: 1  0F83	C0 E0		                push    acc
 4552: 1  0F85	EE		                mov     a,r6
 4553: 1  0F86	C0 E0		                push    acc
 4554: 1  0F88	EF		                mov     a,r7
 4555: 1  0F89	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4556: 1
 4557: 1  0F8B	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4558: 1  0F8D	AD 83		                mov     r5,dph
 4559: 1  0F8F	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4560: 1  0F91	AF 83		                mov     r7,dph
 4561: 1  0F93	12 0A D4	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4562: 1
 4563: 1  0F96	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4564: 1  0F98	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4565: 1  0F99	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4566: 1  0F9B	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4567: 1  0F9C	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4568: 1  0F9E	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4569: 1  0F9F	D0 E0		                pop     acc             ;de stack...
 4570: 1  0FA1	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4571: 1
 4572: 1  0FA2	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4573: 1  0FA3	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4574: 1  0FA4	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4575: 1  0FA5	E9		                mov     a,r1            ;in acc1.
 4576: 1  0FA6	9D		                subb    a,r5            ;We doen dit door de carry van het
 4577: 1  0FA7	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4578: 1  0FA8	9E		                subb    a,r6
 4579: 1  0FA9	EB		                mov     a,r3
 4580: 1  0FAA	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4581: 1  0FAB	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4582: 1			                                        ;wortel behouden
 4583: 1  0FAD	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4584: 1  0FAF	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4585: 1  0FB1	F5 82		                mov     dpl,a          ;wortel aanpassen
 4586: 1
 4587: 1  0FB3	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4588: 1  0FB5	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4589: 1  0FB7	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4590: 1
 4591: 1  0FB9	D0 E0		                pop     acc            ;haal acc1 weer op
 4592: 1  0FBB	FF		                mov     r7,a
 4593: 1  0FBC	D0 E0		                pop     acc
 4594: 1  0FBE	FE		                mov     r6,a
 4595: 1  0FBF	D0 E0		                pop     acc
 4596: 1  0FC1	FD		                mov     r5,a
 4597: 1  0FC2	D0 E0		                pop     acc
 4598: 1  0FC4	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4599: 1
 4600: 1  0FC5	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4601: 1  0FC7	FB		                mov     r3,a
 4602: 1  0FC8	D0 E0		                pop     acc
 4603: 1  0FCA	FA		                mov     r2,a
 4604: 1  0FCB	D0 E0		                pop     acc
 4605: 1  0FCD	F9		                mov     r1,a
 4606: 1  0FCE	D0 E0		                pop     acc
 4607: 1  0FD0	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4608: 1
 4609: 1  0FD1	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4610: 1  0FD4	80 03		                sjmp    sqrt325
 4611: 1  0FD6	02 0F 45	sqrt324:        ljmp    sqrt320        ;uit acc0
 4612: 1
 4613: 1  0FD9	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4614: 1  0FDB	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4615: 1
 4616: 1  0FDD	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4617: 1  0FDF	FF		                mov     r7,a
 4618: 1  0FE0	D0 E0		                pop     acc
 4619: 1  0FE2	FE		                mov     r6,a
 4620: 1  0FE3	D0 E0		                pop     acc
 4621: 1  0FE5	FD		                mov     r5,a
 4622: 1  0FE6	D0 E0		                pop     acc
 4623: 1  0FE8	FC		                mov     r4,a           ;acc1 is hersteld
 4624: 1  0FE9	D0 83		                pop     dph
 4625: 1  0FEB	D0 82		                pop     dpl
 4626: 1  0FED	D0 D0		                pop     psw
 4627: 1  0FEF	D0 F0		                pop     b
 4628: 1  0FF1	D0 E0		                pop     acc
 4629: 1
 4630: 1  0FF3	22		                ret                    ;eindelijk klaar...
 4631: 1
 4632: 1			;*******************************************************************************
 4633: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4634: 1			; acc0 = acc0 ^(1/2)
 4635: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4636: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4637: 1			;                           (-2147483648 tot +2147483647)
 4638: 1			; input:     r3,r2,r1,r0 = acc0
 4639: 1			;
 4640: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4641: 1			;            CY = 1 als acc0 negatief is
 4642: 1			; vernietigt:  niets
 4643: 1			;*******************************************************************************
 4644: 1  0FF4	C0 E0		s_sqrt32:       push    acc
 4645: 1  0FF6	C0 D0		                push    psw
 4646: 1  0FF8	EB		                mov     a,r3
 4647: 1  0FF9	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4648: 1  0FFC	D0 D0		                pop     psw
 4649: 1  0FFE	D3		                setb    c                ;als negatief dan error
 4650: 1  0FFF	D0 E0		                pop     acc
 4651: 1  1001	22		                ret
 4652: 1  1002	D0 D0		s_sqrt321:      pop     psw
 4653: 1  1004	D0 E0		                pop     acc
 4654: 1  1006	12 0F 1E	                lcall   sqrt32            ;wortel trekken
 4655: 1  1009	C3		                clr     c                 ;wortel ok
 4656: 1  100A	22		                ret                       ;klaar
 4657: 1
 4658: 1			;*******************************************************************************
 4659: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4660: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4661: 1			; (logical shift)
 4662: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4663: 1			;
 4664: 1			; input:     r3,r2,r1,r0 = acc0
 4665: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4666: 1			;
 4667: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4668: 1			;            CY=1 als N>=32
 4669: 1			; vernietigt:  niets
 4670: 1			;*******************************************************************************
 4671: 1  100B	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4672: 1  100D	C0 D0		                push    psw
 4673: 1  100F	EC		                mov     a,r4            ;neem aantal shifts
 4674: 1  1010	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4675: 1  1013	40 06		shiftright1:    jc      shiftright2
 4676: 1  1015	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4677: 1  1017	D3		                setb    c               ;N buiten bereik
 4678: 1  1018	D0 E0		                pop     acc
 4679: 1  101A	22		                ret
 4680: 1
 4681: 1  101B	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4682: 1  101D	8C F0		                mov     b,r4            ;lusteller initialiseren
 4683: 1  101F	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4684: 1  1020	EB		                mov     a,r3            ;start bij msb
 4685: 1  1021	13		                rrc     a
 4686: 1  1022	FB		                mov     r3,a
 4687: 1  1023	EA		                mov     a,r2
 4688: 1  1024	13		                rrc     a
 4689: 1  1025	FA		                mov     r2,a
 4690: 1  1026	E9		                mov     a,r1
 4691: 1  1027	13		                rrc     a
 4692: 1  1028	F9		                mov     r1,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4693: 1  1029	E8		                mov     a,r0
 4694: 1  102A	13		                rrc     a
 4695: 1  102B	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4696: 1  102C	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4697: 1  102F	D0 F0		                pop     b               ;registers herstellen
 4698: 1  1031	D0 D0		                pop     psw
 4699: 1  1033	C3		                clr     c               ;N is binnen bereik
 4700: 1  1034	D0 E0		                pop     acc
 4701: 1  1036	22		                ret
 4702: 1
 4703: 1			;*******************************************************************************
 4704: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4705: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4706: 1			; (logical shift)
 4707: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4708: 1			;
 4709: 1			; input:     r3,r2,r1,r0 = acc0
 4710: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4711: 1			;
 4712: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4713: 1			;
 4714: 1			; vernietigt:  niets
 4715: 1			;*******************************************************************************
 4716: 1  1037	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4717: 1  1039	C0 D0		                push    psw
 4718: 1  103B	EC		                mov     a,r4            ;neem aantal shifts
 4719: 1  103C	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4720: 1  103F	40 06		shiftleft1:     jc      shiftleft2
 4721: 1  1041	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4722: 1  1043	D3		                setb    c               ;N buiten bereik
 4723: 1  1044	D0 E0		                pop     acc
 4724: 1  1046	22		                ret
 4725: 1
 4726: 1  1047	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4727: 1  1049	8C F0		                mov     b,r4            ;lusteller initialiseren
 4728: 1  104B	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4729: 1  104C	E8		                mov     a,r0            ;start bij lsb
 4730: 1  104D	33		                rlc     a
 4731: 1  104E	F8		                mov     r0,a
 4732: 1  104F	E9		                mov     a,r1
 4733: 1  1050	33		                rlc     a
 4734: 1  1051	F9		                mov     r1,a
 4735: 1  1052	EA		                mov     a,r2
 4736: 1  1053	33		                rlc     a
 4737: 1  1054	FA		                mov     r2,a
 4738: 1  1055	EB		                mov     a,r3
 4739: 1  1056	33		                rlc     a
 4740: 1  1057	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4741: 1  1058	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4742: 1  105B	D0 F0		                pop     b               ;registers herstellen
 4743: 1  105D	D0 D0		                pop     psw
 4744: 1  105F	C3		                clr     c               ;N is binnen bereik
 4745: 1  1060	D0 E0		                pop     acc
 4746: 1  1062	22		                ret
 4747: 1
 4748: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4749: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4750: 1			; (arithmetic shift)
 4751: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4752: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4753: 1			; niet van teken!
 4754: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4755: 1			;                       (-2147483648 tot +2147483647)
 4756: 1			;
 4757: 1			; input:     r3,r2,r1,r0 = acc0
 4758: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4759: 1			;
 4760: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4761: 1			;            CY=1 als N>=31
 4762: 1			; vernietigt:  niets
 4763: 1			;*******************************************************************************
 4764: 1  1063	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 4765: 1  1065	C0 D0		                push    psw
 4766: 1  1067	EC		                mov     a,r4            ;neem aantal shifts
 4767: 1  1068	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4768: 1  106B	40 06		s_shiftright1:  jc      s_shiftright2
 4769: 1  106D	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4770: 1  106F	D3		                setb    c               ;N buiten bereik
 4771: 1  1070	D0 E0		                pop     acc
 4772: 1  1072	22		                ret
 4773: 1
 4774: 1  1073	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4775: 1  1075	8C F0		                mov     b,r4            ;lusteller initialiseren
 4776: 1  1077	EB		                mov     a,r3
 4777: 1  1078	20 E7 04	                jb      acc.7,s_shiftright20
 4778: 1  107B	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4779: 1  107D	80 02		                sjmp    s_shiftright3
 4780: 1  107F	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4781: 1
 4782: 1  1081	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4783: 1  1083	EB		                mov     a,r3            ;start bij msb
 4784: 1  1084	13		                rrc     a
 4785: 1  1085	FB		                mov     r3,a
 4786: 1  1086	EA		                mov     a,r2
 4787: 1  1087	13		                rrc     a
 4788: 1  1088	FA		                mov     r2,a
 4789: 1  1089	E9		                mov     a,r1
 4790: 1  108A	13		                rrc     a
 4791: 1  108B	F9		                mov     r1,a
 4792: 1  108C	E8		                mov     a,r0
 4793: 1  108D	13		                rrc     a
 4794: 1  108E	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4795: 1  108F	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4796: 1  1092	D0 F0		                pop     b               ;registers herstellen
 4797: 1  1094	D0 D0		                pop     psw
 4798: 1  1096	C3		                clr     c               ;N is binnen bereik
 4799: 1  1097	D0 E0		                pop     acc
 4800: 1  1099	22		                ret
 4801: 1
 4802: 1			;*******************************************************************************
 4803: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4804: 1			; (arithmetic shift)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4805: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4806: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 4807: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4808: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4809: 1			;                       (-2147483648 tot +2147483647)
 4810: 1			;
 4811: 1			; input:     r3,r2,r1,r0 = acc0
 4812: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4813: 1			;
 4814: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4815: 1			;            CY=1 als N>=31
 4816: 1			; vernietigt:  niets
 4817: 1			;*******************************************************************************
 4818: 1  109A	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 4819: 1  109C	C0 D0		                push    psw
 4820: 1  109E	EC		                mov     a,r4            ;neem aantal shifts
 4821: 1  109F	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4822: 1  10A2	40 06		s_shiftleft1:   jc      s_shiftleft2
 4823: 1  10A4	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4824: 1  10A6	D3		                setb    c               ;N buiten bereik
 4825: 1  10A7	D0 E0		                pop     acc
 4826: 1  10A9	22		                ret
 4827: 1
 4828: 1  10AA	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4829: 1  10AC	8C F0		                mov     b,r4            ;lusteller initialiseren
 4830: 1
 4831: 1
 4832: 1
 4833: 1  10AE	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4834: 1  10AF	E8		                mov     a,r0             ;start bij lsb
 4835: 1  10B0	33		                rlc     a
 4836: 1  10B1	F8		                mov     r0,a
 4837: 1  10B2	E9		                mov     a,r1
 4838: 1  10B3	33		                rlc     a
 4839: 1  10B4	F9		                mov     r1,a
 4840: 1  10B5	EA		                mov     a,r2
 4841: 1  10B6	33		                rlc     a
 4842: 1  10B7	FA		                mov     r2,a
 4843: 1  10B8	EB		                mov     a,r3
 4844: 1  10B9	33		                rlc     a
 4845: 1  10BA	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4846: 1  10BC	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4847: 1  10BD	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4848: 1  10C0	D0 F0		                pop     b                ;registers herstellen
 4849: 1  10C2	D0 D0		                pop     psw
 4850: 1  10C4	C3		                clr     c                ;N is binnen bereik
 4851: 1  10C5	D0 E0		                pop     acc
 4852: 1  10C7	22		                ret
 4853: 1
 4854: 1			;*******************************************************************************
 4855: 1			; s_cmp16    (29,5us @16.777216MHz)
 4856: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4857: 1			;
 4858: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4859: 1			;
 4860: 1			; input:     r1,r0 = acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4861: 1			;            r5,r4 = acc1
 4862: 1			;
 4863: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4864: 1			;             f0=0,cy=0  als acc0 > acc1
 4865: 1			;             f0=1 cy=0    als acc1 = acc0
 4866: 1			;
 4867: 1			; vernietigt:  niets
 4868: 1			;*******************************************************************************
 4869: 1  10C8	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4870: 1  10CA	C0 D0		                push    psw
 4871: 1  10CC	E8		                mov     a,r0
 4872: 1  10CD	C0 E0		                push    acc
 4873: 1  10CF	E9		                mov     a,r1
 4874: 1  10D0	C0 E0		                push    acc
 4875: 1
 4876: 1  10D2	E9		                mov     a,r1            ;neem msb van acc0
 4877: 1  10D3	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4878: 1  10D4	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4879: 1  10D7	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4880: 1			                                        ;negatief is
 4881: 1  10D8	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4882: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4883: 1
 4884: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4885: 1			;acc0>acc1
 4886: 1  10DB	D0 E0		s_cmp160:       pop     acc
 4887: 1  10DD	F9		                mov     r1,a
 4888: 1  10DE	D0 E0		                pop     acc
 4889: 1  10E0	F8		                mov     r0,a
 4890: 1  10E1	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4891: 1  10E3	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4892: 1  10E5	C3		                clr     c               ;geef dit aan in de outputstatus
 4893: 1  10E6	D0 E0		                pop     acc
 4894: 1  10E8	22		                ret
 4895: 1			;acc0<acc1
 4896: 1  10E9	D0 E0		s_cmp161:       pop     acc
 4897: 1  10EB	F9		                mov     r1,a
 4898: 1  10EC	D0 E0		                pop     acc
 4899: 1  10EE	F8		                mov     r0,a
 4900: 1  10EF	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4901: 1  10F1	D3		                setb    c               ;groter dan acc0
 4902: 1  10F2	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4903: 1  10F4	D0 E0		                pop     acc
 4904: 1  10F6	22		                ret
 4905: 1			;gelijk teken, maak verschil
 4906: 1  10F7	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 4907: 1  10F8	E8		                mov     a,r0            ;acc0-acc1
 4908: 1  10F9	9C		                subb    a,r4
 4909: 1  10FA	F8		                mov     r0,a
 4910: 1  10FB	E9		                mov     a,r1
 4911: 1  10FC	9D		                subb    a,r5
 4912: 1  10FD	F9		                mov     r1,a
 4913: 1  10FE	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 4914: 1  1101	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 4915: 1  1102	60 02		                jz      s_cmp163        ;acc0=acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4916: 1  1104	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 4917: 1			;acc0=acc1
 4918: 1  1106	D0 E0		s_cmp163:       pop     acc
 4919: 1  1108	F9		                mov     r1,a
 4920: 1  1109	D0 E0		                pop     acc
 4921: 1  110B	F8		                mov     r0,a
 4922: 1  110C	D0 D0		                pop     psw             ;acc0=acc1
 4923: 1  110E	C3		                clr     c               ;geef dit aan in de outputstatus
 4924: 1  110F	D2 D5		                setb    f0
 4925: 1  1111	D0 E0		                pop     acc
 4926: 1  1113	22		                ret
 4927: 1
 4928: 1			;*******************************************************************************
 4929: 1			; cmp16            (19,9us @16.777216MHz)
 4930: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 4931: 1			;
 4932: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 4933: 1			;
 4934: 1			; input:     r1,r0 = acc0
 4935: 1			;            r5,r4 = acc1
 4936: 1			;
 4937: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4938: 1			;             f0=0,cy=0  als acc0 > acc1
 4939: 1			;             f0=1 cy=0    als acc1 = acc0
 4940: 1			;
 4941: 1			; vernietigt:  niets
 4942: 1			;*******************************************************************************
 4943: 1  1114	C0 E0		cmp16:          push    acc             ;bewaar registers
 4944: 1  1116	C0 F0		                push    b
 4945: 1  1118	C0 D0		                push    psw
 4946: 1
 4947: 1  111A	C3		                clr     c               ;vergelijk acc0 met acc1
 4948: 1  111B	E9		                mov     a,r1            ;eerst de msb's
 4949: 1  111C	8D F0		                mov     b,r5            ;test r1-r5
 4950: 1  111E	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4951: 1
 4952: 1  1121	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 4953: 1  1122	8C F0		                mov     b,r4            ;test r0-r4
 4954: 1  1124	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4955: 1			;acc0=acc1
 4956: 1  1127	D0 D0		                pop     psw
 4957: 1  1129	D2 D5		                setb    f0
 4958: 1  112B	C3		                clr     c
 4959: 1  112C	D0 F0		                pop     b
 4960: 1  112E	D0 E0		                pop     acc
 4961: 1  1130	22		                ret
 4962: 1  1131	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 4963: 1			;acc0>acc1
 4964: 1  1133	D0 D0		                pop     psw
 4965: 1  1135	C2 D5		                clr     f0
 4966: 1  1137	C3		                clr     c
 4967: 1  1138	D0 F0		                pop     b
 4968: 1  113A	D0 E0		                pop     acc
 4969: 1  113C	22		                ret
 4970: 1			;acc0<acc1
 4971: 1  113D	D0 D0		cmp162:         pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4972: 1  113F	D3		                setb    c
 4973: 1  1140	C2 D5		                clr     f0
 4974: 1  1142	D0 F0		                pop     b
 4975: 1  1144	D0 E0		                pop     acc
 4976: 1  1146	22		                ret
 4977: 1
 4978: 1			;*******************************************************************************
 4979: 1			; s_cmp32        (44,3us @16.777216MHz)
 4980: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 4981: 1			;
 4982: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4983: 1			;                         -2147483648 tot +2147483647
 4984: 1			; input:     r1,r0 = acc0
 4985: 1			;            r5,r4 = acc1
 4986: 1			;
 4987: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4988: 1			;             f0=0,cy=0  als acc0 > acc1
 4989: 1			;             f0=1 cy=0    als acc1 = acc0
 4990: 1			;
 4991: 1			; vernietigt:  niets
 4992: 1			;*******************************************************************************
 4993: 1  1147	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 4994: 1  1149	C0 D0		                push    psw
 4995: 1  114B	E8		                mov     a,r0
 4996: 1  114C	C0 E0		                push    acc
 4997: 1  114E	E9		                mov     a,r1
 4998: 1  114F	C0 E0		                push    acc
 4999: 1  1151	EA		                mov     a,r2
 5000: 1  1152	C0 E0		                push    acc
 5001: 1  1154	EB		                mov     a,r3
 5002: 1  1155	C0 E0		                push    acc
 5003: 1
 5004: 1  1157	EB		                mov     a,r3            ;neem msb van acc0
 5005: 1  1158	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 5006: 1  1159	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 5007: 1  115B	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 5008: 1  115D	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 5009: 1  115E	A2 E7		                mov     c,acc.7         ;negatief is
 5010: 1  1160	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 5011: 1			                                        ;acc1 positief. Dus acc1>acc0
 5012: 1			;acc0>acc1
 5013: 1  1162	D0 E0		s_cmp320:       pop     acc
 5014: 1  1164	FB		                mov     r3,a
 5015: 1  1165	D0 E0		                pop     acc
 5016: 1  1167	FA		                mov     r2,a
 5017: 1  1168	D0 E0		                pop     acc
 5018: 1  116A	F9		                mov     r1,a
 5019: 1  116B	D0 E0		                pop     acc
 5020: 1  116D	F8		                mov     r0,a
 5021: 1  116E	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5022: 1  1170	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5023: 1  1172	C3		                clr     c               ;geef dit aan in de outputstatus
 5024: 1  1173	D0 E0		                pop     acc
 5025: 1  1175	22		                ret
 5026: 1			;acc0<acc1
 5027: 1  1176	D0 E0		s_cmp321:       pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5028: 1  1178	FB		                mov     r3,a
 5029: 1  1179	D0 E0		                pop     acc
 5030: 1  117B	FA		                mov     r2,a
 5031: 1  117C	D0 E0		                pop     acc
 5032: 1  117E	F9		                mov     r1,a
 5033: 1  117F	D0 E0		                pop     acc
 5034: 1  1181	F8		                mov     r0,a
 5035: 1  1182	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5036: 1  1184	D3		                setb    c               ;groter dan acc0
 5037: 1  1185	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5038: 1  1187	D0 E0		                pop     acc
 5039: 1  1189	22		                ret
 5040: 1			;gelijk teken, maak verschil
 5041: 1  118A	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5042: 1  118B	E8		                mov     a,r0            ;acc0-acc1
 5043: 1  118C	9C		                subb    a,r4
 5044: 1  118D	F8		                mov     r0,a
 5045: 1  118E	E9		                mov     a,r1
 5046: 1  118F	9D		                subb    a,r5
 5047: 1  1190	F9		                mov     r1,a
 5048: 1  1191	EA		                mov     a,r2
 5049: 1  1192	9E		                subb    a,r6
 5050: 1  1193	FA		                mov     r2,a
 5051: 1  1194	EB		                mov     a,r3
 5052: 1  1195	9F		                subb    a,r7
 5053: 1  1196	FB		                mov     r3,a
 5054: 1  1197	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5055: 1  119A	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5056: 1  119B	49		                orl     a,r1
 5057: 1  119C	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5058: 1  119D	60 02		                jz      s_cmp323        ;acc0=acc1
 5059: 1  119F	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5060: 1			;acc0=acc1
 5061: 1  11A1	D0 E0		s_cmp323:       pop     acc
 5062: 1  11A3	FB		                mov     r3,a
 5063: 1  11A4	D0 E0		                pop     acc
 5064: 1  11A6	FA		                mov     r2,a
 5065: 1  11A7	D0 E0		                pop     acc
 5066: 1  11A9	F9		                mov     r1,a
 5067: 1  11AA	D0 E0		                pop     acc
 5068: 1  11AC	F8		                mov     r0,a
 5069: 1  11AD	D0 D0		                pop     psw             ;acc0=acc1
 5070: 1  11AF	C3		                clr     c               ;geef dit aan in de outputstatus
 5071: 1  11B0	D2 D5		                setb    f0
 5072: 1  11B2	D0 E0		                pop     acc
 5073: 1  11B4	22		                ret
 5074: 1
 5075: 1			;*******************************************************************************
 5076: 1			; cmp32        (27,14us @16.777216MHz)
 5077: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5078: 1			;
 5079: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5080: 1			;
 5081: 1			; input:     r3,r2,r1,r0 = acc0
 5082: 1			;            r7,r6,r5,r4 = acc1
 5083: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5084: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5085: 1			;            f0=0,cy=0  als acc0 > acc1
 5086: 1			;            f0=1 cy=0    als acc1 = acc0
 5087: 1			;
 5088: 1			; vernietigt:  niets
 5089: 1			;*******************************************************************************
 5090: 1  11B5	C0 E0		cmp32:          push    acc             ;bewaar registers
 5091: 1  11B7	C0 F0		                push    b
 5092: 1  11B9	C0 D0		                push    psw
 5093: 1
 5094: 1  11BB	C3		                clr     c               ;vergelijk acc0 met acc1
 5095: 1  11BC	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5096: 1  11BD	8F F0		                mov     b,r7            ;test r3-r7
 5097: 1  11BF	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5098: 1
 5099: 1  11C2	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5100: 1  11C3	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5101: 1  11C5	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5102: 1
 5103: 1  11C8	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5104: 1  11C9	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5105: 1  11CB	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5106: 1
 5107: 1  11CE	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5108: 1  11CF	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5109: 1  11D1	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5110: 1			;acc0=acc1
 5111: 1  11D4	D0 D0		                pop     psw
 5112: 1  11D6	D2 D5		                setb    f0
 5113: 1  11D8	C3		                clr     c
 5114: 1  11D9	D0 F0		                pop     b
 5115: 1  11DB	D0 E0		                pop     acc
 5116: 1  11DD	22		                ret
 5117: 1  11DE	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5118: 1			;acc0>acc1, indien cy=0
 5119: 1  11E0	D0 D0		                pop     psw
 5120: 1  11E2	C2 D5		                clr     f0
 5121: 1  11E4	C3		                clr     c
 5122: 1  11E5	D0 F0		                pop     b
 5123: 1  11E7	D0 E0		                pop     acc
 5124: 1  11E9	22		                ret
 5125: 1			;acc0<acc1
 5126: 1  11EA	D0 D0		cmp322:         pop     psw
 5127: 1  11EC	D3		                setb    c
 5128: 1  11ED	C2 D5		                clr     f0
 5129: 1  11EF	D0 F0		                pop     b
 5130: 1  11F1	D0 E0		                pop     acc
 5131: 1  11F3	22		                ret
 5132: 1
 5133: 1
 5134: 1			;*******************************************************************************
 5135: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5136: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5137: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5138: 1			; adres zitten.
 5139: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5140: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5141: 1			;
 5142: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5143: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5144: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5145: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5146: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5147: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5148: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5149: 1			;                cy = 0  lookup is ok
 5150: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5151: 1			; vernietigt:  niets
 5152: 1			;*******************************************************************************
 5153: 1  11F4	C0 E0		table_lu:       push    acc             ;bewaren registers
 5154: 1  11F6	C0 D0		                push    psw
 5155: 1  11F8	C0 82		                push    dpl
 5156: 1  11FA	C0 83		                push    dph
 5157: 1
 5158: 1  11FC	A2 D5		                mov     c,f0            ;byte of word items?
 5159: 1  11FE	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5160: 1			;tabel met byte items
 5161: 1  1200	E5 82		                mov     a,dpl           ;datapointer plus index
 5162: 1  1202	28		                add     a,r0
 5163: 1  1203	F5 82		                mov     dpl,a
 5164: 1  1205	E5 83		                mov     a,dph
 5165: 1  1207	39		                addc    a,r1
 5166: 1  1208	F5 83		                mov     dph,a
 5167: 1  120A	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5168: 1  120C	A2 D1		                mov     c,f1            ;code of datageheugen?
 5169: 1  120E	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5170: 1
 5171: 1			;bytetabel in codegeheugen
 5172: 1  1210	74 00		                mov     a,#0
 5173: 1  1212	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5174: 1  1213	F8		                mov     r0,a            ;en stop in acc0
 5175: 1  1214	79 00		                mov     r1,#0
 5176: 1  1216	02 12 75	                ljmp    table_lu4       ;en klaar
 5177: 1
 5178: 1			;bytetabel in datageheugen
 5179: 1  1219	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5180: 1  121A	F8		                mov     r0,a            ;en stop in acc0
 5181: 1  121B	79 00		                mov     r1,#0
 5182: 1  121D	02 12 75	                ljmp    table_lu4       ;en klaar
 5183: 1
 5184: 1  1220	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5185: 1  1222	D0 82		                pop     dpl
 5186: 1  1224	D0 D0		                pop     psw
 5187: 1  1226	D3		                setb    c              ;foutstatus teruggeven!
 5188: 1  1227	D0 E0		                pop     acc
 5189: 1  1229	22		                ret
 5190: 1
 5191: 1			;tabel met word items
 5192: 1  122A	E8		table_lu2:      mov     a,r0            ;index op stack
 5193: 1  122B	C0 E0		                push    acc
 5194: 1  122D	E9		                mov     a,r1
 5195: 1  122E	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5196: 1
 5197: 1  1230	C3		                clr      c              ;index maal 2 (word items)
 5198: 1  1231	E8		                mov     a,r0
 5199: 1  1232	33		                rlc     a
 5200: 1  1233	F8		                mov     r0,a
 5201: 1  1234	E9		                mov     a,r1
 5202: 1  1235	33		                rlc     a
 5203: 1  1236	F9		                mov     r1,a
 5204: 1
 5205: 1  1237	E5 82		                mov     a,dpl           ;datapointer plus index
 5206: 1  1239	28		                add     a,r0
 5207: 1  123A	F5 82		                mov     dpl,a
 5208: 1  123C	E5 83		                mov     a,dph
 5209: 1  123E	39		                addc    a,r1
 5210: 1  123F	F5 83		                mov     dph,a
 5211: 1
 5212: 1  1241	D0 E0		                pop     acc             ;index weer van stack
 5213: 1  1243	F9		                mov     r1,a
 5214: 1  1244	D0 E0		                pop     acc
 5215: 1  1246	F8		                mov     r0,a
 5216: 1
 5217: 1  1247	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5218: 1  1249	A2 D1		                mov     c,f1            ;code of datageheugen?
 5219: 1  124B	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5220: 1			;wordtabel in codegeheugen
 5221: 1  124D	74 00		                mov     a,#0
 5222: 1  124F	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5223: 1  1250	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5224: 1  1251	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5225: 1  1253	24 01		                add     a,#1
 5226: 1  1255	F5 82		                mov     dpl,a
 5227: 1  1257	E5 83		                mov     a,dph
 5228: 1  1259	34 00		                addc    a,#0
 5229: 1  125B	F5 83		                mov     dph,a
 5230: 1  125D	74 00		                mov     a,#0
 5231: 1  125F	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5232: 1  1260	F9		                mov     r1,a            ;msb in acc0 stoppen
 5233: 1  1261	80 12		                sjmp    table_lu4        ;en klaar
 5234: 1			;wordtabel    in datageheugen
 5235: 1  1263	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5236: 1  1264	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5237: 1  1265	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5238: 1  1267	24 01		                add     a,#1
 5239: 1  1269	F5 82		                mov     dpl,a
 5240: 1  126B	E5 83		                mov     a,dph
 5241: 1  126D	34 00		                addc    a,#0
 5242: 1  126F	F5 83		                mov     dph,a
 5243: 1  1271	74 00		                mov     a,#0
 5244: 1  1273	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5245: 1  1274	F9		                mov     r1,a            ;msb in acc0 stoppen
 5246: 1			                                        ;en klaar
 5247: 1
 5248: 1  1275	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5249: 1  1277	D0 82		                pop     dpl
 5250: 1  1279	D0 D0		                pop     psw
 5251: 1  127B	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5252: 1  127D	22		                ret
 5253: 1
 5254: 1
 5255: 1
 5256: 1			;*******************************************************************************
 5257: 1			; Cordic        (2,11ms @16.777216MHz)
 5258: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5259: 1			; waarde (2's complement) opgegeven hoek.
 5260: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5261: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5262: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5263: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5264: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5265: 1			; als geschaalde getallen ter beschikking komen.
 5266: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5267: 1			;
 5268: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5269: 1			;
 5270: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5271: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5272: 1			;            cy = 0 : hoek binnen bereik
 5273: 1			;            cy = 1 : error, hoek buiten bereik
 5274: 1			;            nauwkeurigheid: 12 msbits
 5275: 1			; vernietigt:  niets
 5276: 1			;*******************************************************************************
 5277: 1  127E	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5278: 1  1280	C0 D0		                push    psw
 5279: 1  1282	C0 83		                push    dph
 5280: 1  1284	C0 82		                push    dpl
 5281: 1  1286	C0 F0		                push    b
 5282: 1
 5283: 1  1288	EF		                mov     a,r7
 5284: 1  1289	C0 E0		                push    acc
 5285: 1  128B	EE		                mov     a,r6
 5286: 1  128C	C0 E0		                push    acc
 5287: 1  128E	ED		                mov     a,r5
 5288: 1  128F	C0 E0		                push    acc
 5289: 1  1291	EC		                mov     a,r4
 5290: 1  1292	C0 E0		                push    acc
 5291: 1
 5292: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5293: 1			;en niet groter dan pi/2 radialen (6478h)
 5294: 1  1294	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5295: 1  1296	7D 64		                mov     r5,#64h
 5296: 1  1298	12 11 14	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5297: 1  129B	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5298: 1  129E	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5299: 1  12A0	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5300: 1
 5301: 1  12A2	C2 A0		cordic000:      clr     p2.0
 5302: 1  12A4	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5303: 1  12A6	7D 9B		                mov     r5,#9bh
 5304: 1  12A8	12 11 14	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5305: 1  12AB	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5306: 1  12AE	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5307: 1  12B0	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5308: 1
 5309: 1  12B2	C2 A1		cordic_error:   clr     p2.1
 5310: 1  12B4	02 13 66	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5311: 1
 5312: 1			;Hoek is -pi/2 resultaat gekend
 5313: 1  12B7	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5314: 1  12B9	7A 00		                mov     r2,#000h
 5315: 1  12BB	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5316: 1  12BD	78 00		                mov     r0,#000h
 5317: 1  12BF	C3		                clr     c
 5318: 1  12C0	02 13 66	                ljmp    cordic40        ;en klaar
 5319: 1			;hoek is +pi/2 resultaat gekend
 5320: 1  12C3	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5321: 1  12C5	7A FF		                mov     r2,#0ffh
 5322: 1  12C7	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5323: 1  12C9	78 00		                mov     r0,#000h
 5324: 1  12CB	C3		                clr     c
 5325: 1  12CC	02 13 66	                ljmp    cordic40        ;en klaar
 5326: 1
 5327: 1  12CF	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5328: 1  12D1	7D 00		                mov     r5,#00h
 5329: 1  12D3	12 11 14	                lcall   cmp16            ;vergelijk de hoeken
 5330: 1  12D6	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5331: 1  12D9	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5332: 1			;hoek is 0, resultaat gekend
 5333: 1  12DB	C2 A7		cordic_nul:     clr     p2.7
 5334: 1  12DD	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5335: 1  12DF	7A 00		                mov     r2,#000h
 5336: 1  12E1	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5337: 1  12E3	78 FF		                mov     r0,#0ffh
 5338: 1  12E5	C3		                clr     c
 5339: 1  12E6	02 13 66	                ljmp    cordic40        ;en klaar
 5340: 1
 5341: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5342: 1  12E9	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5343: 1  12EA	C0 E0		                push    acc
 5344: 1  12EC	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5345: 1  12ED	C0 E0		                push    acc
 5346: 1
 5347: 1  12EF	7B 00		                mov     r3,#00h         ;y=0
 5348: 1  12F1	7A 00		                mov     r2,#00h
 5349: 1  12F3	79 26		                mov     r1,#026h        ;x = K * 2^14
 5350: 1  12F5	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5351: 1
 5352: 1  12F7	75 F0 00	                mov     b,#00h          ;loopteller=0
 5353: 1
 5354: 1  12FA	90 13 BE	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5355: 1
 5356: 1  12FD	EB		cordic1:        mov     a,r3            ;sry=y
 5357: 1  12FE	FF		                mov     r7,a
 5358: 1  12FF	EA		                mov     a,r2
 5359: 1  1300	FE		                mov     r6,a
 5360: 1  1301	E9		                mov     a,r1            ;srx=x
 5361: 1  1302	FD		                mov     r5,a
 5362: 1  1303	E8		                mov     a,r0
 5363: 1  1304	FC		                mov     r4,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5364: 1
 5365: 1  1305	12 13 85	                lcall   cordic5          ;srx en sry >> loopteller
 5366: 1
 5367: 1  1308	D0 E0		                pop     acc
 5368: 1  130A	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5369: 1
 5370: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5371: 1  130D	C3		                clr     c
 5372: 1  130E	E8		                mov     a,r0            ;bereken x=x-sry
 5373: 1  130F	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5374: 1  1310	F8		                mov     r0,a
 5375: 1  1311	E9		                mov     a,r1
 5376: 1  1312	9F		                subb    a,r7
 5377: 1  1313	F9		                mov     r1,a
 5378: 1
 5379: 1  1314	EA		                mov     a,r2            ;bereken y=y+srx
 5380: 1  1315	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5381: 1  1316	FA		                mov     r2,a
 5382: 1  1317	EB		                mov     a,r3
 5383: 1  1318	3D		                addc    a,r5
 5384: 1  1319	FB		                mov     r3,a
 5385: 1
 5386: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5387: 1  131A	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5388: 1  131C	93		                movc    a,@a+dptr
 5389: 1  131D	A3		                inc     dptr
 5390: 1  131E	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5391: 1  131F	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5392: 1  1321	C3		                clr     c               ;verklein de hoek
 5393: 1  1322	9C		                subb    a,r4
 5394: 1  1323	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5395: 1  1325	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5396: 1
 5397: 1  1327	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5398: 1  1329	93		                movc    a,@a+dptr
 5399: 1  132A	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5400: 1  132B	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5401: 1  132C	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5402: 1  132E	9D		                subb    a,r5            ;verklein de hoek
 5403: 1  132F	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5404: 1
 5405: 1			;loopteller incrementeren en testen op einde van de iteratie
 5406: 1  1331	05 F0		cordic2:        inc     b               ;loopteller++
 5407: 1  1333	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5408: 1  1335	65 F0		                xrl     a,b             ;test op gelijkheid
 5409: 1  1337	60 28		                jz      cordic4         ;ja klaar!
 5410: 1  1339	02 12 FD	                ljmp    cordic1         ;nee, nog even verder...
 5411: 1
 5412: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5413: 1  133C	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5414: 1  133D	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5415: 1  133E	F8		                mov     r0,a
 5416: 1  133F	E9		                mov     a,r1
 5417: 1  1340	3F		                addc    a,r7
 5418: 1  1341	F9		                mov     r1,a
 5419: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5420: 1  1342	C3		                clr     c
 5421: 1  1343	EA		                mov     a,r2            ;bereken y=y-srx
 5422: 1  1344	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5423: 1  1345	FA		                mov     r2,a
 5424: 1  1346	EB		                mov     a,r3
 5425: 1  1347	9D		                subb    a,r5
 5426: 1  1348	FB		                mov     r3,a
 5427: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5428: 1  1349	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5429: 1  134B	93		                movc    a,@a+dptr
 5430: 1  134C	A3		                inc     dptr
 5431: 1  134D	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5432: 1  134E	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5433: 1  1350	2C		                add     a,r4            ;vergroot de hoek
 5434: 1  1351	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5435: 1  1353	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5436: 1
 5437: 1  1355	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5438: 1  1357	93		                movc    a,@a+dptr
 5439: 1  1358	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5440: 1  1359	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5441: 1  135A	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5442: 1  135C	3D		                addc    a,r5            ;vergroot de hoek
 5443: 1  135D	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5444: 1
 5445: 1  135F	80 D0		                sjmp    cordic2
 5446: 1
 5447: 1  1361	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5448: 1  1363	D0 E0		                pop     acc             ;dummy hoek van stack
 5449: 1  1365	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5450: 1
 5451: 1  1366	D0 E0		cordic40:       pop     acc
 5452: 1  1368	FC		                mov     r4,a
 5453: 1  1369	D0 E0		                pop     acc
 5454: 1  136B	FD		                mov     r5,a
 5455: 1  136C	D0 E0		                pop     acc
 5456: 1  136E	FE		                mov     r6,a
 5457: 1  136F	D0 E0		                pop     acc
 5458: 1  1371	FF		                mov     r7,a
 5459: 1  1372	D0 F0		                pop     b
 5460: 1  1374	D0 82		                pop     dpl
 5461: 1  1376	D0 83		                pop     dph
 5462: 1  1378	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5463: 1  137A	D0 D0		                pop     psw
 5464: 1  137C	D0 E0		                pop     acc
 5465: 1  137E	22		                ret
 5466: 1
 5467: 1  137F	D0 D0		cordic41:       pop     psw
 5468: 1  1381	D3		                setb    c
 5469: 1  1382	D0 E0		                pop     acc
 5470: 1  1384	22		                ret
 5471: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5472: 1			;over het aantal posities aangegeven in het B register.
 5473: 1  1385	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5474: 1  1387	74 00		                mov     a,#0            ;test of loopteller=0
 5475: 1  1389	65 F0		                xrl     a,b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5476: 1  138B	60 2E		                jz      cordic52        ;klaar
 5477: 1
 5478: 1  138D	ED		                mov     a,r5            ;test teken van srx
 5479: 1  138E	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5480: 1  1391	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5481: 1  1393	80 02		                sjmp    cordic50
 5482: 1  1395	D2 D5		cordic5a:       setb    f0
 5483: 1  1397	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5484: 1  1399	ED		                mov     a,r5            ;eerst de msb
 5485: 1  139A	13		                rrc     a
 5486: 1  139B	FD		                mov     r5,a
 5487: 1  139C	EC		                mov     a,r4            ;dan de lsb
 5488: 1  139D	13		                rrc     a
 5489: 1  139E	FC		                mov     r4,a
 5490: 1  139F	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5491: 1  13A2	D0 F0		                pop     b               ;haal de loopteller van stack
 5492: 1  13A4	C0 F0		                push    b               ;en bewaar hem weer
 5493: 1  13A6	EF		                mov     a,r7            ;test teken van sry
 5494: 1  13A7	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5495: 1  13AA	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5496: 1  13AC	80 02		                sjmp    cordic51
 5497: 1  13AE	D2 D5		cordic5b:       setb    f0
 5498: 1  13B0	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5499: 1  13B2	EF		                mov     a,r7            ;eerst de msb
 5500: 1  13B3	13		                rrc     a
 5501: 1  13B4	FF		                mov     r7,a
 5502: 1  13B5	EE		                mov     a,r6            ;dan de lsb
 5503: 1  13B6	13		                rrc     a
 5504: 1  13B7	FE		                mov     r6,a
 5505: 1  13B8	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5506: 1
 5507: 1  13BB	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5508: 1  13BD	22		                ret
 5509: 1
 5510: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5511: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5512: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5513: 1  13BE	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5514: 1  13C0	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5515: 1  13C2	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5516: 1  13C4	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5517: 1  13C6	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5518: 1  13C8	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5519: 1  13CA	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5520: 1  13CC	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5521: 1  13CE	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5522: 1  13D0	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5523: 1  13D2	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5524: 1  13D4	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5525: 1  13D6	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5526: 1  13D8	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5527: 1  13DA	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5528: 1
 5529: 1			endif        ;einde van aduc_math
 5530: 1			;******************************************************************************
 5531: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5532: 1			ifdef        aduc_adc    ;A/D conversie routines
 5533: 1			;*******************************************************************************
 5534: 1			; ADuCADC_mide
 5535: 1			; Geschreven door [dp] op 5/1/2014
 5536: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5537: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5538: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5539: 1			; bron instellen.
 5540: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5541: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5542: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5543: 1			;
 5544: 1			;*******************************************************************************
 5545: 1
 5546: 1			;*******************************************************************************
 5547: 1			; adc_init
 5548: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5549: 1			; -  4 track&hold clockperiodes
 5550: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5551: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5552: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5553: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5554: 1			;
 5555: 1			; input: R0 =  0  : Interne referentiebron
 5556: 1			;        R0 <> 0  : Externe referentiebron
 5557: 1			;
 5558: 1			; Deze routine vernietigt niets
 5559: 1			;*******************************************************************************
 5560: 1  13DC	C0 E0		adc_init:       push    acc                 ;registers op stack
 5561: 1  13DE	C0 D0		                push    psw
 5562: 1  13E0	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5563: 1  13E3	E8		                mov     a,r0                ;welke referentiebron?
 5564: 1  13E4	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5565: 1  13E6	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5566: 1  13E9	D0 D0		adc_init1:      pop     psw
 5567: 1  13EB	D0 E0		                pop     acc
 5568: 1  13ED	22		                ret
 5569: 1
 5570: 1			;*******************************************************************************
 5571: 1			; adc_single
 5572: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5573: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5574: 1			; (2's complement) formaat van de meetwaarde.
 5575: 1			; _____________________________________________________________
 5576: 1			; resolutie  |     unsigned      |           signed            |
 5577: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5578: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5579: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5580: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5581: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5582: 1			; _____________________________________________________________
 5583: 1			;
 5584: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5585: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5586: 1			; De ingangsparameter wordt doorgegeven via R0.
 5587: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5588: 1			; input:
 5589: 1			;             7    6    5    4    3    2    1    0
 5590: 1			;           _______________________________________
 5591: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5592: 1			;           ---------------------------------------
 5593: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5594: 1			;                                         1000b = temp.sensor
 5595: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5596: 1			;                                   10b = 12 bits, 11b = 12 bits
 5597: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5598: 1			;
 5599: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5600: 1			;         cy=0  bij conversie ok
 5601: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5602: 1			;
 5603: 1			; Deze routine vernietigt niets
 5604: 1			;*******************************************************************************
 5605: 1  13EE	C0 E0		adc_single:     push    acc                 ;registers op stack
 5606: 1  13F0	C0 D0		                push    psw
 5607: 1  13F2	C0 F0		                push    b
 5608: 1  13F4	E8		                mov     a,r0                ;neem inputparameter
 5609: 1  13F5	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5610: 1  13F7	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5611: 1  13FA	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5612: 1  13FC	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5613: 1  13FE	D2 DC		                setb    sconv               ;start een meting
 5614: 1  1400	E8		                mov     a,r0                ;neem parameter terug
 5615: 1  1401	A2 E6		                mov     c,acc.6
 5616: 1  1403	92 D5		                mov     f0,c                ;bewaar format bit
 5617: 1  1405	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5618: 1  1408	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5619: 1  140B	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5620: 1  140E	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5621: 1			;*******************************************************************************
 5622: 1			;8 bit resultaat gevraagd
 5623: 1			;*******************************************************************************
 5624: 1  1411	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5625: 1  1413	C4		                swap    a                    ;swap nibbles
 5626: 1  1414	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5627: 1  1416	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5628: 1  1418	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5629: 1  141A	C4		                swap    a
 5630: 1  141B	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5631: 1  141D	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5632: 1			;8 bit unsigned formaat
 5633: 1  1420	79 00		                mov     r1,#00h              ;unsigned
 5634: 1  1422	F8		                mov     r0,a
 5635: 1  1423	80 63		                sjmp    adc_single42
 5636: 1			;8 bit signed formaat
 5637: 1  1425	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5638: 1  1428	24 80		                add     a,#80h                ;negatief getal van maken
 5639: 1  142A	F8		                mov     r0,a
 5640: 1  142B	79 FF		                mov     r1,#0ffh
 5641: 1  142D	80 59		                sjmp    adc_single42
 5642: 1  142F	C3		adc_single20:   clr     c
 5643: 1  1430	94 80		                subb    a,#80h                ;positief deel verkleinen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5644: 1  1432	F8		                mov     r0,a
 5645: 1  1433	79 00		                mov     r1,#00h
 5646: 1  1435	80 51		                sjmp    adc_single42
 5647: 1
 5648: 1  1437	02 14 90	adc_single21:   ljmp    adc_single43
 5649: 1			;*******************************************************************************
 5650: 1			;10 bit resultaat gevraagd
 5651: 1			;*******************************************************************************
 5652: 1  143A	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5653: 1  143C	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5654: 1  143E	03		                rr     a              ;naar msbits roteren
 5655: 1  143F	03		                rr     a
 5656: 1  1440	F5 F0		                mov    b,a            ;even bewaren
 5657: 1  1442	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5658: 1  1444	03		                rr     a              ;twee plaatsen opschuiven
 5659: 1  1445	03		                rr     a
 5660: 1  1446	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5661: 1  1448	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5662: 1  144A	F5 F0		                mov    b,a            ;low byte even bewaren
 5663: 1  144C	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5664: 1  144E	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5665: 1  1450	03		                rr     a               ;en op hun plaats schuiven
 5666: 1  1451	03		                rr     a
 5667: 1  1452	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5668: 1			;10 bit unsigned formaat
 5669: 1  1455	F9		                mov    r1,a            ;unsigned
 5670: 1  1456	A8 F0		                mov    r0,b
 5671: 1  1458	80 2E		                sjmp   adc_single42
 5672: 1			;10 bit signed formaat
 5673: 1  145A	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5674: 1  145D	24 FE		                add    a,#0feh             ;negatief getal van maken
 5675: 1  145F	F9		                mov    r1,a
 5676: 1  1460	A8 F0		                mov    r0,b
 5677: 1  1462	80 24		                sjmp   adc_single42
 5678: 1  1464	C3		adc_single31:   clr    c
 5679: 1  1465	94 02		                subb   a,#02h              ;positief deel verkleinen
 5680: 1  1467	F9		                mov    r1,a
 5681: 1  1468	A8 F0		                mov    r0,b
 5682: 1  146A	80 1C		                sjmp   adc_single42
 5683: 1
 5684: 1			;*******************************************************************************
 5685: 1			;12 bit resultaat gevraagd
 5686: 1			;*******************************************************************************
 5687: 1  146C	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5688: 1  146E	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5689: 1  1470	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5690: 1			;12 bit unsigned formaat
 5691: 1  1473	A8 D9		                mov    r0,adcdatal           ;unsigned
 5692: 1  1475	F9		                mov    r1,a
 5693: 1  1476	80 10		                sjmp   adc_single42
 5694: 1			;12 bit signed formaat
 5695: 1  1478	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5696: 1  147B	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5697: 1  147D	F9		                mov    r1,a
 5698: 1  147E	A8 D9		                mov    r0,adcdatal
 5699: 1  1480	80 06		                sjmp   adc_single42

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5700: 1  1482	C3		adc_single41:   clr    c
 5701: 1  1483	94 08		                subb   a,#08h                ;positief deel verkleinen
 5702: 1  1485	F9		                mov    r1,a
 5703: 1  1486	A8 D9		                mov    r0,adcdatal
 5704: 1  1488	D0 F0		adc_single42:   pop    b
 5705: 1  148A	D0 D0		                pop    psw
 5706: 1  148C	C3		                clr    c
 5707: 1  148D	D0 E0		                pop    acc
 5708: 1  148F	22		                ret
 5709: 1
 5710: 1  1490	D0 F0		adc_single43:   pop    b
 5711: 1  1492	D0 D0		                pop    psw
 5712: 1  1494	D3		                setb   c
 5713: 1  1495	D0 E0		                pop    acc
 5714: 1  1497	22		                ret
 5715: 1
 5716: 1			endif        ;einde van aduc_adc
 5717: 1			;*******************************************************************************
 5718: 1
 5719: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5720: 1			;******************************************************************************
 5721: 1			; ADuCKEY_mide.inc
 5722: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5723: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5724: 1			;
 5725: 1			;     V2.0      V1.1
 5726: 1			;                           |   |   |   |
 5727: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5728: 1			;                   |       |   |   |   |
 5729: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5730: 1			;                   |       |   |   |   |
 5731: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5732: 1			;                   |       |   |   |   |
 5733: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5734: 1			;                   |       |   |   |   |
 5735: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5736: 1			;                   |           |   |   |
 5737: 1			;     P0.5      P3.5|-K2--------|   |   |
 5738: 1			;                   |               |   |
 5739: 1			;     P0.6      P3.6|-K3------------|   |
 5740: 1			;                   |                   |
 5741: 1			;     P0.7      P3.7|-K4----------------|
 5742: 1			;
 5743: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5744: 1			; gebruikt.
 5745: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5746: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5747: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5748: 1			; en als ingang wordt aangeboden.
 5749: 1			;
 5750: 1			;                                  ___                 ___
 5751: 1			;                     ____________|   |  |------------|   |
 5752: 1			;              ____  |   ____     |   |  |   ____     |   |
 5753: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5754: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5755: 1			; '1'= toets  | cl |    | cl |              | cl |

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5756: 1			;  ingedrukt  |____|    |____|              |____|
 5757: 1			;                |         |                   |
 5758: 1			;      CLOCK     |         |                   |
 5759: 1			;         _______|_________|___________________|
 5760: 1			;
 5761: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 5762: 1			;
 5763: 1			;              MAP0      MAP1                 MAP2         MAP3
 5764: 1			;
 5765: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5766: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5767: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5768: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5769: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 5770: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5771: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 5772: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5773: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5774: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5775: 1			;
 5776: 1			;          MAP0    MAP1          MAP2    MAP3
 5777: 1			;         _______________       _______________
 5778: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 5779: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5780: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5781: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5782: 1			;
 5783: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5784: 1			;         | | | | | | | |       | | | | | | | |
 5785: 1			;        K K K K K K K K       K K K K K K K K
 5786: 1			;         O O O O O O O O       O O O O O O O O
 5787: 1			;         L L L L L L L L       L L L L L L L L
 5788: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5789: 1			;
 5790: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 5791: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 5792: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5793: 1			; van bitmaps van voor naar achter.
 5794: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5795: 1			;
 5796: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5797: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5798: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5799: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 5800: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5801: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5802: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5803: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5804: 1			; deze toetswaarde weer.
 5805: 1			;
 5806: 1			;
 5807: 1			;
 5808: 1			;******************************************************************************
 5809: 1
 5810: 1
 5811: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5812: 1			; key_init
 5813: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 5814: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5815: 1			; input: niets
 5816: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 5817: 1			;         (map0,map1,map2,map3 =0)
 5818: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5819: 1			; Deze routine vernietigt niets
 5820: 1			;******************************************************************************
 5821: 1
 5822: 1  1498	C0 E0		Key_init:       push    acc          ;bewaar registers
 5823: 1  149A	C0 D0		                push    psw
 5824: 1  149C	E8		                mov     a,r0
 5825: 1  149D	C0 E0		                push    acc
 5826: 1  149F	E9		                mov     a,r1
 5827: 1  14A0	C0 E0		                push    acc
 5828: 1  14A2	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5829: 1  14A4	79 09		                mov     r1,#9        ;9 bytes in de maps
 5830: 1  14A6	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5831: 1  14A8	08		                inc     r0           ;volgende byte nemen
 5832: 1  14A9	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5833: 1  14AB	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5834: 1  14AD	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 5835: 1  14AF	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5836: 1  14B2	D0 E0		                pop     acc          ;herstel registers
 5837: 1  14B4	F9		                mov     r1,a
 5838: 1  14B5	D0 E0		                pop     acc
 5839: 1  14B7	F8		                mov     r0,a
 5840: 1  14B8	D0 D0		                pop     psw
 5841: 1  14BA	D0 E0		                pop     acc
 5842: 1  14BC	22		                ret                    ;terug naar caller
 5843: 1			;******************************************************************************
 5844: 1
 5845: 1
 5846: 1			;******************************************************************************
 5847: 1			; toets_flank
 5848: 1			; Deze routine detecteert de indrukflank van een toets.
 5849: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5850: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5851: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5852: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5853: 1			; minder dan 20ms duurt.
 5854: 1			; input : niets
 5855: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5856: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5857: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5858: 1			;
 5859: 1			; Deze routine vernietigt geen registers.
 5860: 1			;******************************************************************************
 5861: 1  14BD	C0 E0		Toets_flank:    push    acc
 5862: 1  14BF	C0 D0		                push    psw
 5863: 1  14C1	12 14 DB	                lcall   Keyscan
 5864: 1  14C4	12 15 57	                lcall   Keyedge
 5865: 1  14C7	D0 D0		                pop     psw
 5866: 1  14C9	D0 E0		                pop     acc
 5867: 1  14CB	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5868: 1
 5869: 1			;******************************************************************************
 5870: 1			; toets_ingedrukt
 5871: 1			; Deze routine detecteert een ingedrukte toets.
 5872: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5873: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5874: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5875: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5876: 1			; minder dan 20ms duurt.
 5877: 1			; input : niets
 5878: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5879: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5880: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5881: 1			;
 5882: 1			; Deze routine vernietigt geen registers.
 5883: 1			;******************************************************************************
 5884: 1  14CC	C0 E0		Toets_ingedrukt:push    acc
 5885: 1  14CE	C0 D0		                push    psw
 5886: 1  14D0	12 14 DB	                lcall   Keyscan
 5887: 1  14D3	12 15 3E	                lcall   Keydown
 5888: 1  14D6	D0 D0		                pop     psw
 5889: 1  14D8	D0 E0		                pop     acc
 5890: 1  14DA	22		                ret
 5891: 1
 5892: 1
 5893: 1			;******************************************************************************
 5894: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5895: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5896: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5897: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5898: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5899: 1			; zoals aangegeven in het blokschema van het algorithme.
 5900: 1			; input : niets
 5901: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5902: 1			;         ervan weergeven
 5903: 1			;
 5904: 1			; Deze routine vernietigt geen registers
 5905: 1			;******************************************************************************
 5906: 1
 5907: 1  14DB	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 5908: 1  14DD	C0 D0		                push    psw
 5909: 1  14DF	C0 F0		                push    b
 5910: 1  14E1	E8		                mov     a,r0
 5911: 1  14E2	C0 E0		                push    acc
 5912: 1  14E4	E9		                mov     a,r1
 5913: 1  14E5	C0 E0		                push    acc
 5914: 1  14E7	EA		                mov     a,r2
 5915: 1  14E8	C0 E0		                push    acc
 5916: 1  14EA	EE		                mov     a,r6
 5917: 1  14EB	C0 E0		                push    acc
 5918: 1
 5919: 1  14ED	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 5920: 1  14EF	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 5921: 1  14F2	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 5922: 1  14F4	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 5923: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5924: 1  14F6			Scanloop:
 5925: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 5926: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 5927: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 5928: 1			                mov     p0.0,c
 5929: 1			                mov     c,acc.1
 5930: 1			                mov     p0.1,c
 5931: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 5932: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 5933: 1			endif
 5934: 1
 5935: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 5936: 1  14F6	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 5937: 1			                                      ;een rij-lijn
 5938: 1			endif
 5939: 1
 5940: 1			; Eerst de flipflops implementeren.
 5941: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 5942: 1			; te lezen van de kolomlijnen
 5943: 1  14F8	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 5944: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5945: 1  14F9	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 5946: 1  14FA	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 5947: 1  14FB	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 5948: 1  14FC	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 5949: 1  14FE	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 5950: 1  14FF	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 5951: 1  1500	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 5952: 1  1502	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 5953: 1  1503	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 5954: 1  1504	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 5955: 1  1505	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 5956: 1  1506	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 5957: 1  1508	FA		                mov     r2,a          ;even bewaren in register
 5958: 1
 5959: 1
 5960: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 5961: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 5962: 1			                                      ;poort3 kolomlijnen
 5963: 1			endif
 5964: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 5965: 1  1509	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 5966: 1			                                     ;poort0 kolomlijnen
 5967: 1			endif
 5968: 1  150B	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 5969: 1  150C	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 5970: 1  150E	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 5971: 1  150F	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 5972: 1
 5973: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 5974: 1			; Nu volgen de logische functies uit het blokschema
 5975: 1
 5976: 1  1510	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 5977: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5978: 1  1511	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 5979: 1  1512	C4		                swap    a            ;MAP0 en MAP1 omwisselen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5980: 1  1513	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 5981: 1  1514	54 0F		                anl     a,#00001111b ;low nibble houden
 5982: 1  1516	FA		                mov     r2,a         ;resultaat bewaren
 5983: 1  1517	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 5984: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 5985: 1  1518	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 5986: 1  1519	C4		                swap    a            ;map2 naar low nibble schuiven
 5987: 1  151A	5A		                anl     a,r2         ;combineren met output vorige and poort
 5988: 1  151B	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 5989: 1  151D	FA		                mov     r2,a         ;even bewaren
 5990: 1  151E	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 5991: 1  151F	54 F0		                anl     a,#11110000b ;map2 overhouden
 5992: 1  1521	4A		                orl     a,r2         ;en combineren met nieuwe map3
 5993: 1  1522	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 5994: 1
 5995: 1			; We gaan nu de volgende lijn scannen
 5996: 1
 5997: 1  1523	EE		                mov     a,r6         ;scanpatroon nemen
 5998: 1  1524	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 5999: 1  1525	FE		                mov     r6,a         ;scanpatroon bewaren
 6000: 1
 6001: 1  1526	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 6002: 1  1527	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 6003: 1  1528	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 6004: 1  152B	D0 E0		                pop     acc          ;herstel registers
 6005: 1  152D	FE		                mov     r6,a
 6006: 1  152E	D0 E0		                pop     acc
 6007: 1  1530	FA		                mov     r2,a
 6008: 1  1531	D0 E0		                pop     acc
 6009: 1  1533	F9		                mov     r1,a
 6010: 1  1534	D0 E0		                pop     acc
 6011: 1  1536	F8		                mov     r0,a
 6012: 1  1537	D0 F0		                pop     b
 6013: 1  1539	D0 D0		                pop     psw
 6014: 1  153B	D0 E0		                pop     acc
 6015: 1  153D	22		                ret                    ;terug naar caller
 6016: 1			;******************************************************************************
 6017: 1
 6018: 1
 6019: 1			;******************************************************************************
 6020: 1			; Keydown, Keyedge (twee entry's)
 6021: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6022: 1			;
 6023: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6024: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6025: 1			; Er zijn twee detectie-modes:
 6026: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6027: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6028: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6029: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6030: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6031: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6032: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6033: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6034: 1			;
 6035: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6036: 1			; (flankdetectie mode).
 6037: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6038: 1			; (toets ingedrukt mode).
 6039: 1			;
 6040: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6041: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6042: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6043: 1			; geldt voor een standaard 4x4 keypad.
 6044: 1			;
 6045: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6046: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6047: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6048: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6049: 1			;
 6050: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6051: 1			; output: key = gedetecteerde toets
 6052: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6053: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6054: 1			;
 6055: 1			; Deze routine vernietigt geen registers
 6056: 1			;******************************************************************************
 6057: 1
 6058: 1			;'Toets ingedrukt mode' enty van de routine
 6059: 1  153E	C0 E0		Keydown:        push    acc            ;registers bewaren
 6060: 1  1540	C0 D0		                push    psw
 6061: 1  1542	C0 F0		                push    b
 6062: 1  1544	C0 82		                push    dpl
 6063: 1  1546	C0 83		                push    dph
 6064: 1  1548	E8		                mov     a,r0
 6065: 1  1549	C0 E0		                push    acc
 6066: 1  154B	E9		                mov     a,r1
 6067: 1  154C	C0 E0		                push    acc
 6068: 1  154E	EA		                mov     a,r2
 6069: 1  154F	C0 E0		                push    acc
 6070: 1  1551	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6071: 1  1553	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6072: 1  1555	80 15		                sjmp    Key1           ;continue
 6073: 1
 6074: 1			;'Flankdetectiemode' entry van de routine
 6075: 1  1557	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6076: 1  1559	C0 D0		                push    psw
 6077: 1  155B	C0 F0		                push    b
 6078: 1  155D	C0 82		                push    dpl
 6079: 1  155F	C0 83		                push    dph
 6080: 1  1561	E8		                mov     a,r0
 6081: 1  1562	C0 E0		                push    acc
 6082: 1  1564	E9		                mov     a,r1
 6083: 1  1565	C0 E0		                push    acc
 6084: 1  1567	EA		                mov     a,r2
 6085: 1  1568	C0 E0		                push    acc
 6086: 1  156A	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6087: 1  156C	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6088: 1  156E	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6089: 1  1570	E6		                mov     a,@r0         ;map entry ophalen
 6090: 1  1571	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6091: 1  1574	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6092: 1  1576	C4		                swap    a             ;map1 en map0 omwisselen
 6093: 1  1577	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6094: 1  1579	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6095: 1  157A	33		                rlc     a             ;kolombit testen
 6096: 1  157B	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6097: 1  157D	33		                rlc    a              ;nee, dan verder roteren
 6098: 1  157E	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6099: 1  1580	08		                inc     r0            ;rijpointer in maps verder zetten
 6100: 1  1581	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6101: 1  1583	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6102: 1
 6103: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6104: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6105: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6106: 1
 6107: 1  1585	1A		toetsin:        dec     r2            ;rij-1
 6108: 1  1586	19		                dec     r1            ;kolom-1
 6109: 1  1587	EA		                mov     a,r2          ;neem rij-1
 6110: 1  1588	23		                rl      a             ;(rij-1)x2
 6111: 1  1589	23		                rl      a              ;(rij-1)x4
 6112: 1  158A	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6113: 1  158B	90 15 A9	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6114: 1  158E	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6115: 1  158F	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6116: 1  1591	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6117: 1  1593	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6118: 1  1595	D0 E0		                pop     acc            ;herstellen registers
 6119: 1  1597	FA		                mov     r2,a
 6120: 1  1598	D0 E0		                pop     acc
 6121: 1  159A	F9		                mov     r1,a
 6122: 1  159B	D0 E0		                pop     acc
 6123: 1  159D	F8		                mov     r0,a
 6124: 1  159E	D0 83		                pop     dph
 6125: 1  15A0	D0 82		                pop     dpl
 6126: 1  15A2	D0 F0		                pop     b
 6127: 1  15A4	D0 D0		                pop     psw
 6128: 1  15A6	D0 E0		                pop     acc
 6129: 1  15A8	22		                ret                    ;terug naar caller
 6130: 1			;******************************************************************************
 6131: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6132: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6133: 1
 6134: 1  15A9	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6135: 1  15AA	30		                db    '0'    ;kolom2@rij4 toets
 6136: 1  15AB	23		                db    '#'    ;kolom3@rij4 toets
 6137: 1  15AC	44		                db    'D'    ;kolom4@rij4 toets
 6138: 1
 6139: 1  15AD	37		                db    '7'    ;kolom1@rij3 toets
 6140: 1  15AE	38		                db    '8'    ;kolom2@rij3 toets
 6141: 1  15AF	39		                db    '9'    ;kolom3@rij3 toets
 6142: 1  15B0	43		                db    'C'    ;kolom4@rij3 toets
 6143: 1
 6144: 1  15B1	34		                db    '4'    ;kolom1@rij2 toets
 6145: 1  15B2	35		                db    '5'    ;kolom2@rij2 toets
 6146: 1  15B3	36		                db    '6'    ;kolom3@rij2 toets
 6147: 1  15B4	42		                db    'B'    ;kolom4@rij2 toets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6148: 1
 6149: 1  15B5	31		                db    '1'    ;kolom1@rij1 toets
 6150: 1  15B6	32		                db    '2'    ;kolom2@rij1 toets
 6151: 1  15B7	33		                db    '3'    ;kolom3@rij1 toets
 6152: 1  15B8	41		                db    'A'    ;kolom4@rij1 toets
 6153: 1
 6154: 1			;******************************************************************************
 6155: 1			; switch_init
 6156: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6157: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6158: 1			; input : niets
 6159: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6160: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6161: 1			;
 6162: 1			; Deze routine vernietigt niets
 6163: 1			;******************************************************************************
 6164: 1
 6165: 1  15B9	C0 E0		switch_init:    push    acc
 6166: 1  15BB	C0 D0		                push    psw
 6167: 1  15BD	C0 F0		                push    b
 6168: 1  15BF	E8		                mov     a,r0         ;bewaar registers
 6169: 1  15C0	C0 E0		                push    acc
 6170: 1
 6171: 1  15C2	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6172: 1  15C4	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6173: 1  15C7	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6174: 1  15C9	08		                inc     r0           ;volgende byte nemen
 6175: 1  15CA	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6176: 1  15CD	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6177: 1  15CF	C2 03		                clr     negvalid
 6178: 1  15D1	C2 04		                clr     posvalid
 6179: 1
 6180: 1  15D3	D0 E0		                pop     acc
 6181: 1  15D5	F8		                mov     r0,a
 6182: 1  15D6	D0 F0		                pop     b
 6183: 1  15D8	D0 D0		                pop     psw
 6184: 1  15DA	D0 E0		                pop     acc
 6185: 1  15DC	22		                ret                   ;terug naar caller
 6186: 1
 6187: 1			;******************************************************************************
 6188: 1			; read_switch
 6189: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6190: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6191: 1			; Deze routine werkt volgens onderstaand blokschema.
 6192: 1			;
 6193: 1			;                                  ___                    ___
 6194: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6195: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6196: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6197: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6198: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6199: 1			;             |____|    |____|              |____|  ----o| 3 |
 6200: 1			;                |         |                   |      |  |   |
 6201: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6202: 1			;         _______*_________*___________________|       --|___|---- posedge
 6203: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6204: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6205: 1			;                              (swvalid-flag)
 6206: 1			;            switch1   switch2    debounce      closed
 6207: 1			;
 6208: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6209: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6210: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6211: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6212: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6213: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6214: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6215: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6216: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6217: 1			; een detector voor positieve flanken (posedge).
 6218: 1			;
 6219: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6220: 1			;         bij aduc832v1.1 :
 6221: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6222: 1			;         bij aduc832v2.0 :
 6223: 1			;         als f0=0 dan: schakelaars op p0
 6224: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6225: 1			;
 6226: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6227: 1			;         geactualiseerd.
 6228: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6229: 1			;                  schakelaars weergeeft
 6230: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6231: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6232: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6233: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6234: 1			;                  werd gedetecteerd op een schakelaar.
 6235: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6236: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6237: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6238: 1			;                  werd gedetecteerd op een schakelaar.
 6239: 1			;
 6240: 1			;
 6241: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6242: 1			; en flags te initialiseren.
 6243: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6244: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6245: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6246: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6247: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6248: 1			; bijhorende flag resetten.
 6249: 1			;
 6250: 1			; Deze routine vernietigt niets
 6251: 1			;******************************************************************************
 6252: 1  15DD	C0 E0		read_switch:    push    acc            ;registers bewaren
 6253: 1  15DF	C0 D0		                push    psw
 6254: 1  15E1	C0 F0		                push    b
 6255: 1			;Flipflops uitvoeren is bytes doorschuiven
 6256: 1  15E3	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6257: 1  15E6	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6258: 1
 6259: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6260: 1			                clr      a
 6261: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6262: 1			                mov     acc.0,c
 6263: 1			                mov     c,p0.1
 6264: 1			                mov     acc.1,c
 6265: 1			                mov     b,a            ;even bewaren
 6266: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6267: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6268: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6269: 1			endif        ;einde aduc832_v1_1
 6270: 1
 6271: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6272: 1  15E9	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6273: 1  15EC	E5 80		                mov     a,p0           ;lees de schakelaars
 6274: 1  15EE	80 04		                sjmp    lowlogic
 6275: 1  15F0	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6276: 1  15F2	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6277: 1			endif        ;einde aduc832_2_0
 6278: 1
 6279: 1  15F4	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6280: 1  15F5	F5 40		                mov     switch1,a      ;en sample opslaan
 6281: 1
 6282: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6283: 1
 6284: 1  15F7	E5 40		                mov     a,switch1      ;neem laatste sample
 6285: 1  15F9	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6286: 1  15FB	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6287: 1  15FD	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6288: 1			;negatieve flankdetectie
 6289: 1  15FF	E5 43		                mov     a,closed      ;neem 3de FF
 6290: 1  1601	F4		                cpl     a             ;complementeer
 6291: 1  1602	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6292: 1  1604	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6293: 1  1606	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6294: 1  1608	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6295: 1  160A	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6296: 1			;positieve flankdetectie
 6297: 1  160C	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6298: 1  160E	F4		                cpl     a             ;complementeer
 6299: 1  160F	55 43		                anl     a,closed      ;combineer met 3de FF
 6300: 1  1611	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6301: 1  1613	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6302: 1  1615	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6303: 1  1617	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6304: 1  1619	D0 D0		                pop     psw
 6305: 1  161B	D0 E0		                pop     acc
 6306: 1  161D	22		                ret
 6307: 1
 6308: 1			endif    ;einde van aduc_key
 6309: 1
 6310: 1
 6311:				end





ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111




                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 148
ACC				  DATA	      E0	  67
ADCCON1				  DATA	      EF	  70
ADCCON2				  DATA	      D8	  63
ADCCON3				  DATA	      F5	  76
ADCDATAH			  DATA	      DA	  65
ADCDATAL			  DATA	      D9	  64
ADCGAINH			  DATA	      F4	  75
ADCGAINL			  DATA	      F3	  74
ADCI				  BIT	      DF	 157
ADCOFSH				  DATA	      F2	  73
ADCOFSL				  DATA	      F1	  72
ADC_INIT			  CODE	    13DC	5560
ADC_INIT1			  CODE	    13E9	5566
ADC_SINGLE			  CODE	    13EE	5605
ADC_SINGLE1			  CODE	    13FA	5611
ADC_SINGLE2			  CODE	    1425	5637
ADC_SINGLE20			  CODE	    142F	5642
ADC_SINGLE21			  CODE	    1437	5648
ADC_SINGLE3			  CODE	    143A	5652
ADC_SINGLE30			  CODE	    145A	5673
ADC_SINGLE31			  CODE	    1464	5678
ADC_SINGLE4			  CODE	    146C	5687
ADC_SINGLE40			  CODE	    1478	5695
ADC_SINGLE41			  CODE	    1482	5700
ADC_SINGLE42			  CODE	    1488	5704
ADC_SINGLE43			  CODE	    1490	5710
ADD16				  CODE	    0933	2912
ADD161				  CODE	    0947	2928
ADD32				  CODE	    0985	3009
ADD321				  CODE	    099F	3033
ADUC832_V2_0			  NUMBER    0001	 218
ADUC_ADC			  NUMBER    0001	 239
ADUC_I2C			  NUMBER    0001	 236
ADUC_KEY			  NUMBER    0001	 240
ADUC_LCD			  NUMBER    0001	 233
ADUC_MATH			  NUMBER    0001	 238
ADUC_SIO			  NUMBER    0001	 237
ASCBINTRANS			  CODE	    05E3	1965
ASCBINTRANS1			  CODE	    05F8	1976
ASCBINTRANS2			  CODE	    05F7	1975
ASCBINTRANS3			  CODE	    05EB	1969
ASCBINTRANS4			  CODE	    05F4	1973
ASCCTR				  CODE	    05BA	1911
ASCCTR1				  CODE	    05BD	1912
ASCCTR2				  CODE	    05C2	1914
ASCCTR3				  CODE	    05C6	1917
ASCII1				  CODE	    05F9	1987

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII2				  CODE	    05FE	2001
ASCII21				  CODE	    0610	2010
ASCII4				  CODE	    0613	2024
ASCII41				  CODE	    0622	2031
B				  DATA	      F0	  71
BACKLIGHT			  BIT	      F6	 385
BACKSP				  NUMBER    0008	1610
BARCHARS			  CODE	    02A3	1011
BAREINDE			  CODE	    02CA	1054
BARLCD				  CODE	    023E	 932
BARLCD1				  CODE	    0279	 966
BARLCD2				  CODE	    0280	 971
BARLCD3				  CODE	    0289	 979
BARLCD4				  CODE	    028E	 983
BARLCDE				  CODE	    0296	 988
BARLCD_1			  CODE	    0259	 948
BATRANS				  CODE	    05D5	1947
BATRANS1			  CODE	    05DA	1949
BATRANS2			  CODE	    05DE	1951
BCDHEX16			  CODE	    0698	2226
BCDHEX161			  CODE	    06A6	2234
BCDHEX1611			  CODE	    06AF	2238
BCDHEX1612			  CODE	    06B9	2243
BCDHEX1613			  CODE	    06C2	2247
BCDHEX162			  CODE	    070D	2301
BCDHEX8				  CODE	    0623	2117
BCDHEX81			  CODE	    0631	2125
BCDHEX811			  CODE	    063A	2129
BCDHEX82			  CODE	    065C	2153
BDELETE				  CODE	    0595	1877
BDELETE1			  CODE	    05A3	1885
BDELETE2			  CODE	    05B6	1896
BDELETE3			  CODE	    05A7	1887
BEEP				  NUMBER    0007	1611
BLANK				  NUMBER    0020	1605
BUILD				  CODE	    02CB	1086
BUILD1				  CODE	    02E3	1128
BUILD2				  CODE	    02F2	1135
BUILD3				  CODE	    02E6	1129
BUILD_ADR			  CODE	    02D9	1123
BUZZER				  BIT	      F7	 386
CAP2				  BIT	      C8	 134
CCONV				  BIT	      DD	 155
CFG832				  DATA	      AF	  36
CGRAM				  NUMBER    0040	 401
CHIPID				  DATA	      C2	  50
CLEARDISP			  NUMBER    0001	 391
CLOSED				  NUMBER    0043	 305
CMP16				  CODE	    1114	4943
CMP161				  CODE	    1131	4962
CMP162				  CODE	    113D	4971
CMP32				  CODE	    11B5	5090
CMP321				  CODE	    11DE	5117
CMP322				  CODE	    11EA	5126
CNT2				  BIT	      C9	 135
CORDIC				  CODE	    127E	5277

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CORDIC0				  CODE	    12E9	5342
CORDIC00			  CODE	    12CF	5327
CORDIC000			  CODE	    12A2	5301
CORDIC1				  CODE	    12FD	5356
CORDIC2				  CODE	    1331	5406
CORDIC3				  CODE	    133C	5413
CORDIC4				  CODE	    1361	5447
CORDIC40			  CODE	    1366	5451
CORDIC41			  CODE	    137F	5467
CORDIC5				  CODE	    1385	5473
CORDIC50			  CODE	    1397	5483
CORDIC51			  CODE	    13B0	5498
CORDIC52			  CODE	    13BB	5507
CORDIC5A			  CODE	    1395	5482
CORDIC5B			  CODE	    13AE	5497
CORDIC_ATAN			  CODE	    13BE	5513
CORDIC_ERROR			  CODE	    12B2	5309
CORDIC_MIN90			  CODE	    12B7	5313
CORDIC_NUL			  CODE	    12DB	5333
CORDIC_PLUS90			  CODE	    12C3	5320
CPHA				  BIT	      FA	 172
CPOL				  BIT	      FB	 173
CR				  NUMBER    000D	1608
CS0				  BIT	      D8	 150
CS1				  BIT	      D9	 151
CS2				  BIT	      DA	 152
CS3				  BIT	      DB	 153
CURSATHOM			  NUMBER    0002	 392
CURSOROFF			  NUMBER    000C	 397
CURSORONB			  NUMBER    000F	 398
CURSORONN			  NUMBER    000E	 399
CY				  BIT	      D7	 149
D0				  BIT	      ED	 159
D0EN				  BIT	      EB	 158
D1				  BIT	      EF	 161
D1EN				  BIT	      EE	 160
DAC0H				  DATA	      FA	  80
DAC0L				  DATA	      F9	  79
DAC1H				  DATA	      FC	  82
DAC1L				  DATA	      FB	  81
DACCON				  DATA	      FD	  83
DCON				  DATA	      E8	  68
DDRAM				  NUMBER    0080	 402
DEBOUNCE			  NUMBER    0042	 304
DELAY2MS			  CODE	    0300	1152
DELAY2MS1			  CODE	    0306	1155
DELAY60US			  CODE	    0311	1172
DELAY60US1			  CODE	    0323	1186
DELAY60US2			  CODE	    0321	1185
DIPSWITCH			  NUMBER    0001	 258
DISPDPTR			  CODE	    04EB	1719
DISPDPTRLCD			  CODE	    0105	 607
DISPLAYOF			  NUMBER    0008	 396
DISPLAYON			  NUMBER    0001	 395
DIV16				  CODE	    0BFA	3695
DIV160				  CODE	    0C08	3706

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DIV161				  CODE	    0C26	3729
DIV162				  CODE	    0C39	3745
DIV163				  CODE	    0C55	3770
DIV164				  CODE	    0C67	3788
DIV32				  CODE	    0CA4	3859
DIV320				  CODE	    0CB4	3872
DIV320A				  CODE	    0CBE	3883
DIV320B				  CODE	    0CDC	3911
DIV320C				  CODE	    0D01	3939
DIV322				  CODE	    0D26	3973
DIV323				  CODE	    0D70	4049
DIV324				  CODE	    0DA2	4099
DIV8				  CODE	    0BB7	3622
DIV81				  CODE	    0BCF	3638
DMA				  BIT	      DE	 156
DMAH				  DATA	      D3	  60
DMAL				  DATA	      D2	  59
DMAP				  DATA	      D4	  61
DPCON				  DATA	      A7	  32
DPH				  DATA	      83	   9
DPL				  DATA	      82	   8
DPP				  DATA	      84	  10
E				  BIT	      F1	 383
EA				  BIT	      AF	 109
EADC				  BIT	      AE	 108
EADRH				  DATA	      C7	  52
EADRL				  DATA	      C6	  51
ECON				  DATA	      B9	  44
EDATA1				  DATA	      BC	  45
EDATA2				  DATA	      BD	  46
EDATA3				  DATA	      BE	  47
EDATA4				  DATA	      BF	  48
ENDBUF				  NUMBER    007F	1617
ENTRYMODE			  NUMBER    0006	 394
ES				  BIT	      AC	 106
ET0				  BIT	      A9	 103
ET1				  BIT	      AB	 105
ET2				  BIT	      AD	 107
EX0				  BIT	      A8	 102
EX1				  BIT	      AA	 104
EXEN2				  BIT	      CB	 137
EXF2				  BIT	      CE	 140
F0				  BIT	      D5	 147
F1				  BIT	      D1	 143
FF				  NUMBER    000C	1607
FUNCTIONS			  NUMBER    0028	 400
HEXBCD16			  CODE	    0716	2337
HEXBCD161			  CODE	    0724	2344
HEXBCD16_U			  CODE	    0719	2338
HEXBCD8				  CODE	    0665	2178
HEXBCD81			  CODE	    066F	2183
HEXBCD82			  CODE	    0674	2185
HEXBCD83			  CODE	    067E	2191
HEXBUF2LCD			  CODE	    01E1	 873
HEXBUF2LCD1			  CODE	    0205	 889
HEXBUF2LCDE			  CODE	    021C	 900

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBUFTXT			  CODE	    022A	 909
HOUR				  DATA	      A5	  30
HTHSEC				  DATA	      A2	  27
I2CADD				  DATA	      9B	  22
I2CCON				  DATA	      E8	  69
I2CDAT				  DATA	      9A	  21
I2CI				  BIT	      E8	 162
I2CINBYTEA1			  CODE	    036D	1294
I2CINBYTEACK			  CODE	    0366	1291
I2CINBYTEN1			  CODE	    038E	1318
I2CINBYTENACK			  CODE	    0387	1315
I2CINIT				  CODE	    032B	1236
I2CM				  BIT	      EB	 165
I2COUTBYTE			  CODE	    0346	1268
I2COUTBYTE1			  CODE	    034D	1271
I2CPCF8574			  NUMBER    0040	1227
I2CPCF8574A			  NUMBER    0070	1228
I2CRCVDATA			  CODE	    03E8	1420
I2CRCVDATA1			  CODE	    0407	1438
I2CRCVDATA2			  CODE	    0410	1442
I2CRCVDATA3			  CODE	    0417	1447
I2CRCVERROR			  CODE	    0423	1455
I2CRS				  BIT	      EA	 164
I2CSENDDATA			  CODE	    03A8	1358
I2CSENDDATA1			  CODE	    03C7	1375
I2CSENDERROR			  CODE	    03DD	1388
I2CSTART			  CODE	    0334	1245
I2CSTOP				  CODE	    033D	1254
I2CTX				  BIT	      E9	 163
IE				  DATA	      A8	  33
IE0				  BIT	      89	  85
IE1				  BIT	      8B	  87
IEIP2				  DATA	      A9	  34
INBUFA				  CODE	    055A	1834
INBUFA1				  CODE	    0571	1851
INBUFA2				  CODE	    0560	1837
INBUFA3				  CODE	    057E	1857
INBUFA4				  CODE	    0577	1853
INBUFA5				  CODE	    0591	1865
INBUFA6				  CODE	    0587	1861
INBUFA7				  CODE	    0579	1854
INBYTE				  CODE	    053A	1802
INBYTE1				  CODE	    0557	1814
INCHAR				  CODE	    0532	1786
INITLCD				  CODE	    0035	 417
INITLCD1			  CODE	    0046	 434
INITSIO				  CODE	    0498	1631
INITSIO1			  CODE	    04A1	1635
INITSIOE			  CODE	    04B7	1652
INT0				  BIT	      B2	 112
INT0_ROUT			  CODE	    0023	 197
INT1				  BIT	      B3	 113
INTVAL				  DATA	      A6	  31
IP				  DATA	      B8	  43
ISPI				  BIT	      FF	 177
IT0				  BIT	      88	  84

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
IT1				  BIT	      8A	  86
KEY				  NUMBER    0038	 291
KEY1				  CODE	    156C	6087
KEY2				  CODE	    1579	6094
KEYDOWN				  CODE	    153E	6059
KEYEDGE				  CODE	    1557	6075
KEYFLAGS			  NUMBER    0020	 266
KEYINIT1			  CODE	    14A6	5830
KEYMAP				  NUMBER    0030	 285
KEYMODE				  BIT	      01	 270
KEYSCAN				  CODE	    14DB	5907
KEYVALID			  BIT	      00	 268
KEY_INIT			  CODE	    1498	5822
KOLOMLOOP			  CODE	    157B	6096
LCDBUZOFF			  CODE	    0487	1576
LCDBUZON			  CODE	    047A	1560
LCDLIGHTOFF			  CODE	    046D	1544
LCDLIGHTON			  CODE	    0460	1527
LCDPORT				  NUMBER    00F0	 382
LCDTOPORT			  CODE	    0447	1501
LF				  NUMBER    000A	1609
LOOP				  CODE	    0021	 195
LOWLOGIC			  CODE	    15F4	6279
LOWUPTR				  CODE	    05C8	1931
LOWUPTR1			  CODE	    05CB	1932
LOWUPTR2			  CODE	    05D4	1936
LOWUPTR3			  CODE	    05D0	1934
MAGSIG16			  CODE	    0785	2449
MAGSIG16A			  CODE	    0796	2458
MAGSIG16ACC1			  CODE	    07A5	2482
MAGSIG16ACC1A			  CODE	    07B6	2491
MAGSIG16ACC1B			  CODE	    07B1	2488
MAGSIG16ACC1C			  CODE	    07C0	2499
MAGSIG16B			  CODE	    0791	2455
MAGSIG16C			  CODE	    07A0	2466
MAGSIG32			  CODE	    07C5	2516
MAGSIG32A			  CODE	    07D6	2525
MAGSIG32ACC1			  CODE	    07EF	2561
MAGSIG32ACC1A			  CODE	    0800	2570
MAGSIG32ACC1B			  CODE	    07FB	2567
MAGSIG32ACC1C			  CODE	    0814	2587
MAGSIG32B			  CODE	    07D1	2522
MAGSIG32C			  CODE	    07EA	2542
MAGSIG8				  CODE	    0751	2390
MAGSIG8A			  CODE	    0762	2399
MAGSIG8ACC1			  CODE	    076B	2420
MAGSIG8ACC1A			  CODE	    077C	2429
MAGSIG8ACC1B			  CODE	    0777	2426
MAGSIG8ACC1C			  CODE	    0780	2433
MAGSIG8B			  CODE	    075D	2396
MAGSIG8C			  CODE	    0766	2403
MAP01PTR			  NUMBER    0030	 287
MAP23PTR			  NUMBER    0034	 290
MATRIX				  NUMBER    0001	 256
MCO				  BIT	      ED	 167
MDE				  BIT	      EE	 168

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MDI				  BIT	      EC	 166
MDO				  BIT	      EF	 169
MIN				  DATA	      A4	  29
MUL16				  CODE	    0A6F	3281
MUL16ACC1			  CODE	    0AD4	3370
MUL16_10			  CODE	    0E93	4357
MUL16_100			  CODE	    0EC8	4405
MUL16_I_PI			  CODE	    0E30	4261
MUL16_I_SQRT2			  CODE	    0E72	4326
MUL16_PI			  CODE	    0E0F	4230
MUL16_SQRT2			  CODE	    0E51	4293
MUL816				  CODE	    0B5C	3517
MULDIV				  CODE	    0DD3	4172
MULDIV1				  CODE	    0DE3	4184
NEGEDGE				  NUMBER    0044	 306
NEGVALID			  BIT	      03	 275
NOKEY				  CODE	    1593	6117
OUTBYTE				  CODE	    04D7	1699
OUTBYTELCD			  CODE	    00F4	 588
OUTC				  CODE	    01A1	 794
OUTCHAR				  CODE	    04BB	1666
OUTCHAR1			  CODE	    04BD	1667
OUTCHARLCD			  CODE	    0093	 503
OUTCHARLCD1			  CODE	    009A	 506
OUTCHARLCD2			  CODE	    00A4	 510
OUTCHARLCD2_0			  CODE	    009F	 508
OUTCHARLCD3			  CODE	    00AD	 520
OUTCHARLCD4			  CODE	    00B4	 524
OUTCHARLCD5			  CODE	    00BB	 528
OUTCHARLCD6			  CODE	    00C2	 532
OUTCHARLCD7			  CODE	    00C9	 536
OUTCHARLCD8			  CODE	    00D0	 544
OUTCHARLCD9			  CODE	    00D5	 552
OUTCHARLCDE			  CODE	    00D8	 553
OUTD				  CODE	    0167	 716
OUTHNIBC			  CODE	    01B7	 836
OUTHNIBD			  CODE	    0177	 764
OUTMSGA				  CODE	    04FE	1738
OUTMSGA1			  CODE	    0513	1749
OUTMSGA2			  CODE	    0506	1742
OUTMSGALCD			  CODE	    0118	 631
OUTMSGALCD1			  CODE	    0120	 638
OUTMSGALCDE			  CODE	    012B	 648
OUTNIB				  CODE	    04C3	1680
OUTNIBLCD			  CODE	    00DD	 567
OUTNIBLCD1			  CODE	    00E8	 572
OUTNIBLCDE			  CODE	    00EC	 574
OV				  BIT	      D2	 144
P				  BIT	      D0	 142
P0				  DATA	      80	   6
P1				  DATA	      90	  18
P2				  DATA	      A0	  25
P3				  DATA	      B0	  37
PADC				  BIT	      BE	 124
PCF8574A			  NUMBER    0001	1230
PCON				  DATA	      87	  11

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
PLLCON				  DATA	      D7	  62
PORTTOLCD			  CODE	    042E	1473
POSEDGE				  NUMBER    0045	 307
POSVALID			  BIT	      04	 277
PRE0				  BIT	      C4	 130
PRE1				  BIT	      C5	 131
PRE2				  BIT	      C6	 132
PRE3				  BIT	      C7	 133
PS				  BIT	      BC	 122
PSI				  BIT	      BF	 125
PSMCON				  DATA	      DF	  66
PSW				  DATA	      D0	  58
PT0				  BIT	      B9	 119
PT1				  BIT	      BB	 121
PT2				  BIT	      BD	 123
PWM0H				  DATA	      B2	  39
PWM0L				  DATA	      B1	  38
PWM1H				  DATA	      B4	  41
PWM1L				  DATA	      B3	  40
PWMCON				  DATA	      AE	  35
PX0				  BIT	      B8	 118
PX1				  BIT	      BA	 120
RB8				  BIT	      9A	  96
RCAP2H				  DATA	      CB	  55
RCAP2L				  DATA	      CA	  54
RCLK				  BIT	      CD	 139
RD				  BIT	      B7	 117
READ_PORT3			  CODE	    15F0	6275
READ_SWITCH			  CODE	    15DD	6252
READ_SWITCH1			  CODE	    160C	6297
READ_SWITCH2			  CODE	    1617	6303
REGTOLCD			  CODE	    0134	 668
REGTOLCD1			  CODE	    0145	 678
REGTOLCD2			  CODE	    0153	 688
REN				  BIT	      9C	  98
RI				  BIT	      98	  94
RIJLOOP				  CODE	    156E	6088
RS				  BIT	      F0	 384
RS0				  BIT	      D3	 145
RS1				  BIT	      D4	 146
RXD				  BIT	      B0	 110
SBUF				  DATA	      99	  20
SCANLOOP			  CODE	    14F6	5924
SCON				  DATA	      98	  19
SCONV				  BIT	      DC	 154
SEC				  DATA	      A3	  28
SHIFTLEFT1			  CODE	    103F	4720
SHIFTLEFT2			  CODE	    1047	4726
SHIFTLEFT3			  CODE	    104B	4728
SHIFTLEFT32			  CODE	    1037	4716
SHIFTRIGHT1			  CODE	    1013	4675
SHIFTRIGHT2			  CODE	    101B	4681
SHIFTRIGHT3			  CODE	    101F	4683
SHIFTRIGHT32			  CODE	    100B	4671
SIGMAG16ACC0			  CODE	    084B	2660
SIGMAG16ACC0A			  CODE	    085A	2669

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SIGMAG16ACC1			  CODE	    086B	2695
SIGMAG16ACC1A			  CODE	    087A	2704
SIGMAG16ACC1H			  CODE	    088B	2730
SIGMAG16ACC1HA			  CODE	    089A	2739
SIGMAG32ACC0			  CODE	    08AB	2767
SIGMAG32ACC0A			  CODE	    08BA	2776
SIGMAG32ACC1			  CODE	    08D5	2811
SIGMAG32ACC1A			  CODE	    08E4	2820
SIGMAG8ACC0			  CODE	    0819	2604
SIGMAG8ACC0A			  CODE	    0828	2612
SIGMAG8ACC1			  CODE	    0832	2632
SIGMAG8ACC1A			  CODE	    0841	2640
SM0				  BIT	      9F	 101
SM1				  BIT	      9E	 100
SM2				  BIT	      9D	  99
SP				  DATA	      81	   7
SPE				  BIT	      FD	 175
SPH				  DATA	      B7	  42
SPICON				  DATA	      F8	  78
SPIDAT				  DATA	      F7	  77
SPIM				  BIT	      FC	 174
SPR0				  BIT	      F8	 170
SPR1				  BIT	      F9	 171
SQRT32				  CODE	    0F1E	4477
SQRT320				  CODE	    0F45	4499
SQRT321				  CODE	    0F4A	4501
SQRT322				  CODE	    0FAD	4583
SQRT323				  CODE	    0FB3	4587
SQRT324				  CODE	    0FD6	4611
SQRT3240			  CODE	    0FD1	4609
SQRT325				  CODE	    0FD9	4613
STACK_INIT			  NUMBER    007F	 180
START				  CODE	    000E	 187
STRTBUF				  NUMBER    0054	1616
SUB16				  CODE	    09E5	3119
SUB161				  CODE	    09FA	3136
SUB32				  CODE	    0A4C	3236
SUB321				  CODE	    0A67	3261
SWINIT				  CODE	    15C7	6173
SWITCH1				  NUMBER    0040	 302
SWITCH2				  NUMBER    0041	 303
SWITCHMAP			  NUMBER    0040	 301
SWITCH_INIT			  CODE	    15B9	6165
SWVALID				  BIT	      02	 273
S_ADD16				  CODE	    08FF	2857
S_ADD161			  CODE	    0923	2883
S_ADD162			  CODE	    0927	2885
S_ADD163			  CODE	    092D	2890
S_ADD32				  CODE	    094F	2950
S_ADD321			  CODE	    0977	2981
S_ADD322			  CODE	    0979	2982
S_ADD323			  CODE	    097F	2987
S_CMP16				  CODE	    10C8	4869
S_CMP160			  CODE	    10DB	4886
S_CMP161			  CODE	    10E9	4896
S_CMP162			  CODE	    10F7	4906

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_CMP163			  CODE	    1106	4918
S_CMP32				  CODE	    1147	4993
S_CMP320			  CODE	    1162	5013
S_CMP321			  CODE	    1176	5027
S_CMP322			  CODE	    118A	5041
S_CMP323			  CODE	    11A1	5061
S_DIV16				  CODE	    0BD7	3660
S_DIV161			  CODE	    0BE5	3670
S_DIV32				  CODE	    0C7F	3822
S_DIV321			  CODE	    0C8F	3834
S_DIV8				  CODE	    0BA5	3599
S_DIV81				  CODE	    0BB6	3605
S_MAC16				  CODE	    0B83	3559
S_MAC161			  CODE	    0B9F	3579
S_MUL16				  CODE	    0B35	3461
S_MUL16ACC1			  CODE	    0B42	3479
S_MUL816			  CODE	    0B4F	3498
S_MULDIV			  CODE	    0DAE	4128
S_MULDIV1			  CODE	    0DBE	4140
S_SHIFTLEFT1			  CODE	    10A2	4822
S_SHIFTLEFT2			  CODE	    10AA	4828
S_SHIFTLEFT3			  CODE	    10AE	4833
S_SHIFTLEFT32			  CODE	    109A	4818
S_SHIFTRIGHT1			  CODE	    106B	4768
S_SHIFTRIGHT2			  CODE	    1073	4774
S_SHIFTRIGHT20			  CODE	    107F	4780
S_SHIFTRIGHT3			  CODE	    1081	4782
S_SHIFTRIGHT32			  CODE	    1063	4764
S_SQRT32			  CODE	    0FF4	4644
S_SQRT321			  CODE	    1002	4652
S_SUB16				  CODE	    09A7	3055
S_SUB161			  CODE	    09D5	3090
S_SUB162			  CODE	    09D9	3092
S_SUB163			  CODE	    09DF	3097
S_SUB32				  CODE	    0A02	3158
S_SUB321			  CODE	    0A3E	3208
S_SUB322			  CODE	    0A40	3209
S_SUB323			  CODE	    0A46	3214
T0				  BIT	      B4	 114
T1				  BIT	      B5	 115
T2				  BIT	      90	  92
T2CON				  DATA	      C8	  53
T2EX				  BIT	      91	  93
T3CON				  DATA	      9E	  23
T3FD				  DATA	      9D	  24
TABLE_LU			  CODE	    11F4	5153
TABLE_LU1			  CODE	    1219	5179
TABLE_LU2			  CODE	    122A	5192
TABLE_LU3			  CODE	    1263	5235
TABLE_LU4			  CODE	    1275	5248
TABLE_LU_10			  CODE	    1220	5184
TB8				  BIT	      9B	  97
TCLK				  BIT	      CC	 138
TCON				  DATA	      88	  12
TEXT				  CODE	    0032	 206
TF0				  BIT	      8D	  89

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TF1				  BIT	      8F	  91
TF2				  BIT	      CF	 141
TH0				  DATA	      8C	  16
TH1				  DATA	      8D	  17
TH2				  DATA	      CD	  57
TI				  BIT	      99	  95
TIMECON				  DATA	      A1	  26
TL0				  DATA	      8A	  14
TL1				  DATA	      8B	  15
TL2				  DATA	      CC	  56
TMOD				  DATA	      89	  13
TOETSIN				  CODE	    1585	6107
TOETSTABEL			  CODE	    15A9	6134
TOETS_FLANK			  CODE	    14BD	5861
TOETS_INGEDRUKT			  CODE	    14CC	5884
TR0				  BIT	      8C	  88
TR1				  BIT	      8E	  90
TR2				  BIT	      CA	 136
TXD				  BIT	      B1	 111
WCOL				  BIT	      FE	 176
WDCON				  DATA	      C0	  49
WDE				  BIT	      C1	 127
WDIR				  BIT	      C3	 129
WDS				  BIT	      C2	 128
WDWR				  BIT	      C0	 126
WISSEN				  CODE	    0494	1613
WR				  BIT	      B6	 116
XOFF				  NUMBER    0013	1606
XONXOFF				  CODE	    051C	1766
XONXOFF1			  CODE	    0528	1772
XONXOFF2			  CODE	    0523	1769
XONXOFF3			  CODE	    052D	1774
