
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\Hartslagmeter.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\Hartslagmeter.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\Hartslagmeter.lst



 Line  I  Addr  Code            Source

    1:				;Anton Peeters & Pieter-Jan Steeman
    2:
    3:				$nolist
  181:
  182:		N      0090	stack_init	equ	090h
  183:		N      0001	tijd		equ	1
  184:		N      0080	startbuffer	equ	080h
  185:		N      0000			org	0000h
  186:
  187:	  0000	02 00 03			ljmp	start
  188:
  189:	  0003	75 81 90	start:		mov	sp,#stack_init		;init van de stack
  190:	  0006	7E 80				mov	r6,#startbuffer		;locatie van de start van de barrel
  191:	  0008	78 01				mov	r0,#1			;voor lcd init
  192:	  000A	12 00 87			lcall	initlcd
  193:	  000D	12 04 B2			lcall	lcdlighton
  194:
  195:	  0010	12 14 2E			lcall 	adc_init
  196:	  0013	75 FD 1D			mov	daccon,#00011101b
  197:
  198:	  0016	90 02 F5			mov	dptr,#barchars
  199:	  0019	12 03 1D			lcall	build
  200:
  201:	  001C	12 00 2A	infloop:	lcall	adcbuffer		;adc en buffer toewijzing
  202:	  001F	12 00 40			lcall	bar			;zet de waardes om naar een barchart
  203:	  0022	90 00 01			mov	dptr,#tijd		;zet de gewenste delay in de dptr
  204:	  0025	12 00 65			lcall	wait_sel_ms		;wacht het gekozen aantal miliseconden
  205:	  0028	80 F2				sjmp	infloop			;oneindige lus
  206:
  207:	  002A	78 27		adcbuffer:	mov	r0,#00100111b		;initialiseer de nodige waardes voor een 12bit signa
				al
  208:	  002C	12 14 40			lcall	adc_single
  209:	  002F	E8				mov	a,r0			;zet ingelezen waardes in r2 en r3(lsb en msb)
  210:	  0030	FA				mov	r2,a
  211:	  0031	E9				mov	a,r1
  212:	  0032	FB				mov	r3,a
  213:	  0033	EE				mov	a,r6
  214:	  0034	F8				mov	r0,a
  215:	  0035	EA				mov	a,r2
  216:	  0036	F6				mov	@r0,a			;zet lsb in barrel
  217:	  0037	08				inc	r0
  218:	  0038	EB				mov	a,r3
  219:	  0039	F6				mov	@r0,a			;zet msb in barrel

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  220:	  003A	08				inc	r0
  221:	  003B	E8				mov	a,r0
  222:	  003C	54 8F				anl	a,#08fh			;indien buiten barrelregister zou gaan -> terug naar
				 onder
  223:	  003E	FE				mov	r6,a
  224:	  003F	22				ret
  225:
  226:	  0040	EE		bar:		mov	a,r6
  227:	  0041	B4 80 02			cjne	a,#80h,skip_add		;indien je onderaan het barrelregister zit ga terug
				naar boven
  228:	  0044	24 10				add	a,#10h
  229:	  0046	14		skip_add:	dec	a			;ga naar de plaats van de msb
  230:	  0047	F9				mov	r1,a
  231:	  0048	F8				mov	r0,a
  232:	  0049	E7				mov	a,@r1			;zet de msb in r1
  233:	  004A	F9				mov	r1,a
  234:	  004B	89 FA				mov	dac0h,r1		;msb naar DAC
  235:	  004D	18				dec	r0			;ga naar de plaats van de lsb
  236:	  004E	E6				mov	a,@r0			;zet de lsb in r0
  237:	  004F	F8				mov	r0,a
  238:	  0050	88 F9				mov	dac0l,r0		;lsb naar DAC
  239:	  0052	7D 00				mov	r5,#0
  240:	  0054	7C 69				mov	r4,#105			;nodig voor div16 (4096/40)
  241:	  0056	12 0C 4C			lcall	div16			;quotient terug in r0
  242:	  0059	E8				mov	a,r0
  243:						;lcall	outbytelcd
  244:	  005A	FA				mov	r2,a			;zet de waarde om in bars
  245:	  005B	78 28				mov	r0,#40
  246:	  005D	74 40				mov	a,#40h
  247:	  005F	8A F0				mov	b,r2
  248:	  0061	12 02 90			lcall	barlcd
  249:	  0064	22				ret
  250:
  251:	  0065	74 00		wait_sel_ms:	mov	a,#0
  252:	  0067	C3				clr 	c
  253:	  0068	95 82				subb 	a,dpl
  254:	  006A	F5 82				mov	dpl,a
  255:	  006C	74 00				mov	a,#0
  256:	  006E	95 83				subb	a,dph
  257:	  0070	F5 83				mov	dph,a
  258:	  0072	E4		wait_1ms:	clr	a
  259:	  0073	A3				inc	dptr
  260:	  0074	74 C7				mov	a,#199
  261:	  0076	F8		delay:		mov	r0,a
  262:	  0077	E8				mov	a,r0
  263:	  0078	F8				mov	r0,a
  264:	  0079	E8				mov	a,r0
  265:	  007A	94 01				subb	a,#1
  266:	  007C	70 F8				jnz	delay
  267:	  007E	E5 82				mov	a,dpl
  268:	  0080	70 F0				jnz	wait_1ms
  269:	  0082	E5 83				mov	a,dph
  270:	  0084	70 EC				jnz	wait_1ms
  271:	  0086	22				ret
  272:
  273:				$include (c:/aduc800_mideA.inc)

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  274: 1			;******************************************************************************
  275: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  276: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  277: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  278: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  279: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  280: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  281: 1			;******************************************************************************
  282: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  283: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  284: 1			;******************************************************************************
  285: 1
  286: 1
  287: 1			;******************************************************************************
  288: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  289: 1			; hebben voor onze toepassing. Door een module te definieren via het
  290: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  291: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  292: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  293: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  294: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  295: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  296: 1			; definities.
  297: 1			;******************************************************************************
  298: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  299: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  300: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  301: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  302: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  303: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  304: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  305: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  306: 1
  307: 1			ifdef    aduc_key
  308: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  309: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  310: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  311: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  312: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  313: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  314: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  315: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  316: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  317: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  318: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  319: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  320: 1			;definities wel gemaakt worden.
  321: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  322: 1			                            ;anders commentaar van maken!
  323: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  324: 1			                            ;gelezen, anders commentaar van maken!
  325: 1			;******************************************************************************
  326: 1			;Declaraties van de flags voor de aduc_key driver.
  327: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  328: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  329: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  330: 1			;switch_init en read_switch.
  331: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  332: 1			                                ;bereik = 20h-2fh!
  333: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  334: 1			                                   ;een geldige waarde bevat
  335: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  336: 1			                                   ;die de detectie mode aangeeft
  337: 1			;declaratie van de read_switch flags
  338: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  339: 1			                                   ;ontdenderde schakelaars zijn
  340: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  341: 1			                                   ;flanken zijn
  342: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  343: 1			                                   ;flanken zijn
  344: 1			ifdef    matrix        ;matrix keyboard
  345: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  346: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  347: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  348: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  349: 1			;toepassing.
  350: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  351: 1			                                ;geheugenbuffer
  352: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  353: 1			                                ;debounce en de flankdetectie samples stockeren
  354: 1			                                ;de eerste 4 bytes dienen voor debouncing
  355: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  356: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  357: 1			                                ;toetswaarde aangeeft
  358: 1			                                ;bij een geldige keyvalid flag ('1')
  359: 1			endif    ;einde matrix keyboard
  360: 1
  361: 1			ifdef    dipswitch
  362: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  363: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  364: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  365: 1			;toepassing
  366: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  367: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  368: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  369: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  370: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  371: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  372: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  373: 1			endif    ;einde dipswitch
  374: 1			;******************************************************************************
  375: 1			endif    ;einde aduc_key
  376: 1
  377: 1
  378: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  379: 1
  380: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  381: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  382: 1			endif                               ;dus doen we dit hier nog eens!
  383: 1			;******************************************************************************
  384: 1
  385: 1			;******************************************************************************

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  386: 1			;
  387: 1			; ADuc_lcd.inc
  388: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  389: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  390: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  391: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  392: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  393: 1			; het plaatsen van de cursor op een correcte plaats).
  394: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  395: 1			; display gebruiken.
  396: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  397: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  398: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  399: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  400: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  401: 1			;
  402: 1			; Versie ADuC832v1.1:
  403: 1			; Hier is het LCD verbonden met pinnen van poort0
  404: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  405: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  406: 1			;
  407: 1			; Versie ADuC832v2.2:
  408: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  409: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  410: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  411: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  412: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  413: 1			;
  414: 1			;
  415: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  416: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  417: 1			;  aduclcd0.inc
  418: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  419: 1			;  aduclcd1.inc
  420: 1			;    -00dh en 00ah worden door outchar verwerkt
  421: 1			;    -bij de init wordt het display anders opgestart
  422: 1			;
  423: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  424: 1			;  van gebruik en uitgebreid  met :
  425: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  426: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  427: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  428: 1			;    debug doeleinden
  429: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  430: 1			;    user codes aan te maken
  431: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  432: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  433: 1			;
  434: 1			; Beschikbare routines:
  435: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  436: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  437: 1			; build_adr, delay2ms, delay60us
  438: 1			;******************************************************************************
  439: 1
  440: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  441: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  442: 1			e             bit    lcdport.2            ;enable
  443: 1			rs            bit    lcdport.3            ;register select
  444: 1			endif    ;einde aduc832_v1_1
  445: 1
  446: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  447: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  448: 1	B	 F1	e             bit    lcdport.1            ;enable
  449: 1	B	 F0	rs            bit    lcdport.0            ;register select
  450: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  451: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  452: 1			endif    ;einde aduc832_v2_0
  453: 1
  454: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  455: 1			;het uitvoeren van de overeenkomstige commando's.
  456: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  457: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  458: 1
  459: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  460: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  461: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  462: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  463: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  464: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  465: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  466: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  467: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  468: 1
  469: 1			;******************************************************************************
  470: 1			;
  471: 1			; initlcd
  472: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  473: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  474: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  475: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  476: 1			; Na initialisering wordt het scherm leeg gemaakt.
  477: 1			;
  478: 1			; registergebruik: geen
  479: 1			;
  480: 1			;******************************************************************************
  481: 1
  482: 1  0087	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  483: 1  0089	C0 D0		              push   psw
  484: 1  008B	C0 F0		              push   b
  485: 1			ifdef  aduc832_v1_1
  486: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  487: 1			                                   ;let op:twee laagste bits worden
  488: 1			                                   ;niet gebruikt
  489: 1			endif
  490: 1
  491: 1			ifdef    aduc832_v2_0
  492: 1  008D	12 03 7D	              lcall  i2cinit              ;LCD via een I2C bus
  493: 1  0090	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  494: 1			                                          ;buzzer en backlight  op 1 gezet
  495: 1  0093	12 04 80	              lcall  porttolcd            ;data uit b naar het scherm
  496: 1			endif
  497: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  498: 1  0096	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  499: 1  0098	12 03 52	initlcd1:     lcall  delay2ms
  500: 1  009B	D5 E0 FA	              djnz   acc,initlcd1
  501: 1  009E	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  502: 1  00A0	12 02 09	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  503: 1  00A3	12 03 52	              lcall  delay2ms      ;om het display altijd opgestart
  504: 1  00A6	74 30		              mov    a,#00110000b  ;te krijgen.
  505: 1  00A8	12 02 09	              lcall  outhnibc
  506: 1  00AB	12 03 52	              lcall  delay2ms
  507: 1  00AE	74 30		              mov    a,#00110000b
  508: 1  00B0	12 02 09	              lcall  outhnibc
  509: 1  00B3	12 03 52	              lcall  delay2ms
  510: 1  00B6	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  511: 1  00B8	12 02 09	              lcall  outhnibc      ;hoge nibble naar het controleregister
  512: 1  00BB	12 03 52	              lcall  delay2ms      ;niet nodig volgens datasheet
  513: 1  00BE	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  514: 1  00C0	12 01 F3	              lcall  outc          ;naar display
  515: 1  00C3	12 03 52	              lcall  delay2ms      ;is iets te lang volgens datasheet
  516: 1  00C6	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  517: 1  00C8	12 01 F3	              lcall  outc
  518: 1  00CB	12 03 52	              lcall  delay2ms      ;ook deze delay is iets te lang
  519: 1  00CE	74 01		              mov    a,#displayon  ;clear display and home cursor
  520: 1  00D0	12 01 F3	              lcall  outc
  521: 1  00D3	12 03 52	              lcall  delay2ms      ;deze wachttijd is bijna juist
  522: 1  00D6	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  523: 1  00D8	12 01 F3	              lcall  outc
  524: 1  00DB	12 03 52	              lcall  delay2ms      ;wachten weer veel te lang
  525: 1  00DE	D0 F0		              pop    b
  526: 1  00E0	D0 D0		              pop    psw           ;registers terug in orde zetten
  527: 1  00E2	D0 E0		              pop    acc
  528: 1  00E4	22		              ret                  ;einde van de initialisatie
  529: 1
  530: 1			;******************************************************************************
  531: 1			;
  532: 1			; outcharlcd
  533: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  534: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  535: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  536: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  537: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  538: 1			; De controlekarakters komen overeen met volgende acties:
  539: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  540: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  541: 1			;              (line feed+ carriage return!)
  542: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  543: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  544: 1			;      011h   =cursor on, blink mode
  545: 1			;      012h   =cursor on, no blink mode
  546: 1			;      013h   =cursor off
  547: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  548: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  549: 1			;              van het LCD
  550: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  551: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  552: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  553: 1			; positie 6 (C5H-80H=45H)

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  554: 1			;
  555: 1			; Deze routine vernietigt geen registers
  556: 1			;
  557: 1			;******************************************************************************
  558: 1
  559: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  560: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  561: 1			; dataregister van het scherm.
  562: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  563: 1			; controlebyte doorsturen naar het LCD.
  564: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  565: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  566: 1			; naar de LCD sturen.
  567: 1
  568: 1  00E5	C0 E0		outcharlcd:   push   acc           ;registers op stack
  569: 1  00E7	C0 D0		              push   psw
  570: 1  00E9	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  571: 1  00EC	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  572: 1  00EE	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  573: 1  00F1	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  574: 1  00F3	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  575: 1  00F6	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  576: 1
  577: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  578: 1			; Als het een commando is, moeten we het uitvoeren.
  579: 1			; Indien niet, gewoon terug zonder actie!
  580: 1
  581: 1  00F8	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  582: 1  00FB	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  583: 1  00FD	80 28		              sjmp   outcharlcd9          ;afsluiten
  584: 1
  585: 1  00FF	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  586: 1  0102	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  587: 1  0104	80 21		              sjmp   outcharlcd9
  588: 1
  589: 1  0106	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  590: 1  0109	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  591: 1  010B	80 1A		              sjmp   outcharlcd9
  592: 1
  593: 1  010D	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  594: 1  0110	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  595: 1  0112	80 13		              sjmp   outcharlcd9
  596: 1
  597: 1  0114	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  598: 1  0117	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  599: 1  0119	80 0C		              sjmp   outcharlcd9
  600: 1
  601: 1  011B	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  602: 1  011E	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  603: 1  0120	80 05		              sjmp   outcharlcd9
  604: 1
  605: 1
  606: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  607: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  608: 1
  609: 1  0122	12 01 B9	outcharlcd8:  lcall  outd          ;display het karakter op het LCD

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  610: 1  0125	80 03		              sjmp   outcharlcde   ;einde routine
  611: 1
  612: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  613: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  614: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  615: 1			; op dat adres te zetten.
  616: 1
  617: 1  0127	12 01 F3	outcharlcd9:  lcall  outc          ;klaar
  618: 1  012A	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  619: 1  012C	D0 E0		              pop    acc
  620: 1  012E	22		              ret
  621: 1
  622: 1			;******************************************************************************
  623: 1			;
  624: 1			; outniblcd
  625: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  626: 1			; op het lcd scherm.
  627: 1			;
  628: 1			; de routine vernietigt geen registers
  629: 1			;
  630: 1			;******************************************************************************
  631: 1
  632: 1  012F	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  633: 1  0131	C0 D0		              push   psw
  634: 1  0133	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  635: 1  0135	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  636: 1  0137	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  637: 1  013A	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  638: 1  013C	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  639: 1  013E	12 01 B9	outniblcde:   lcall  outd          ;naar het scherm
  640: 1  0141	D0 D0		              pop    psw
  641: 1  0143	D0 E0		              pop    acc
  642: 1  0145	22		              ret
  643: 1
  644: 1			;******************************************************************************
  645: 1			;
  646: 1			; outbytelcd
  647: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  648: 1			;
  649: 1			; de routine vernietigt geen registers
  650: 1			;
  651: 1			;******************************************************************************
  652: 1
  653: 1  0146	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  654: 1  0148	C0 D0		              push   psw
  655: 1  014A	C4		              swap   a             ;bitjes omruilen
  656: 1  014B	12 01 2F	              lcall  outniblcd
  657: 1  014E	C4		              swap   a             ;nog eens
  658: 1  014F	12 01 2F	              lcall  outniblcd
  659: 1  0152	D0 D0		              pop    psw
  660: 1  0154	D0 E0		              pop    acc
  661: 1  0156	22		              ret
  662: 1
  663: 1			;******************************************************************************
  664: 1			;
  665: 1			; dispdptrlcd

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  666: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  667: 1			;
  668: 1			; de routine vernietigt geen registers
  669: 1			;
  670: 1			;******************************************************************************
  671: 1
  672: 1  0157	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  673: 1  0159	C0 D0		              push   psw
  674: 1  015B	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  675: 1  015D	12 01 46	              lcall  outbytelcd
  676: 1  0160	E5 82		              mov    a,dpl         ;dan het lage deel
  677: 1  0162	12 01 46	              lcall  outbytelcd
  678: 1  0165	D0 D0		              pop    psw
  679: 1  0167	D0 E0		              pop    acc
  680: 1  0169	22		              ret
  681: 1
  682: 1			;******************************************************************************
  683: 1			;
  684: 1			; outmsgalcd
  685: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  686: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  687: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  688: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  689: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  690: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  691: 1			;
  692: 1			; de routine vernietigt geen registers
  693: 1			;
  694: 1			;******************************************************************************
  695: 1
  696: 1  016A	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  697: 1  016C	C0 D0		              push   psw
  698: 1  016E	C0 83		              push   dph           ;ook de data pointer
  699: 1  0170	C0 82		              push   dpl
  700: 1
  701: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  702: 1
  703: 1  0172	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  704: 1  0173	93		              movc   a,@a+dptr     ;waarde lezen
  705: 1  0174	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  706: 1
  707: 1			; de code is niet 0 dus versturen met outchar
  708: 1
  709: 1  0176	12 00 E5	              lcall  outcharlcd    ;weg er mee
  710: 1  0179	A3		              inc    dptr          ;naar volgende ascii code wijzen
  711: 1  017A	02 01 72	              ljmp   outmsgalcd1   ;lus sluiten
  712: 1
  713: 1  017D	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  714: 1  017F	D0 83		              pop    dph
  715: 1  0181	D0 D0		              pop    psw
  716: 1  0183	D0 E0		              pop    acc
  717: 1  0185	22		              ret
  718: 1
  719: 1			;******************************************************************************
  720: 1			;
  721: 1			; regtolcd

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  722: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  723: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  724: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  725: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  726: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  727: 1			;
  728: 1			; de routine vernietigt geen registers
  729: 1			;
  730: 1			;******************************************************************************
  731: 1
  732: 1
  733: 1  0186	C0 E0		regtolcd:     push   acc           ;registers op de stack
  734: 1  0188	C0 D0		              push   psw
  735: 1  018A	E8		              mov    a,r0
  736: 1  018B	C0 E0		              push   acc
  737: 1  018D	E9		              mov    a,r1
  738: 1  018E	C0 E0		              push   acc
  739: 1  0190	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  740: 1  0192	12 00 E5	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  741: 1			                                   ;plaats
  742: 1  0195	79 00		              mov    r1,#000h      ;werkt als loopcounter
  743: 1  0197	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  744: 1  0198	12 00 E5	              lcall  outcharlcd    ;weg er mee
  745: 1  019B	08		              inc    r0
  746: 1  019C	09		              inc    r1
  747: 1  019D	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  748: 1			                                          ;nieuwe lijn genomen worden
  749: 1  01A0	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  750: 1  01A2	12 00 E5	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  751: 1			                                   ;plaats
  752: 1
  753: 1  01A5	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  754: 1  01A6	12 00 E5	              lcall  outcharlcd    ;weg er mee
  755: 1  01A9	08		              inc    r0
  756: 1  01AA	09		              inc    r1
  757: 1  01AB	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  758: 1  01AE	D0 E0		              pop    acc
  759: 1  01B0	F9		              mov    r1,a
  760: 1  01B1	D0 E0		              pop    acc
  761: 1  01B3	F8		              mov    r0,a
  762: 1  01B4	D0 D0		              pop    psw           ;registers herstellen
  763: 1  01B6	D0 E0		              pop    acc
  764: 1  01B8	22		              ret
  765: 1
  766: 1			;******************************************************************************
  767: 1			;
  768: 1			; outd
  769: 1			; Is een routine die naar het data register van het display een
  770: 1			; volledige byte stuurt.
  771: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  772: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  773: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  774: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  775: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  776: 1			;
  777: 1			; De routine vernietigt geen registers.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  778: 1			;
  779: 1			;******************************************************************************
  780: 1
  781: 1  01B9	C0 E0		outd:         push   acc           ;registers op stack zetten
  782: 1  01BB	C0 D0		              push   psw
  783: 1  01BD	12 01 C9	              lcall  outhnibd      ;hoogste vier bits verzenden
  784: 1			ifdef     aduc832_v1_1
  785: 1			              lcall  delay60us     ;niet echt nodig
  786: 1			endif
  787: 1  01C0	C4		              swap   a             ;bitjes omruilen
  788: 1  01C1	12 01 C9	              lcall  outhnibd      ;naar het scherm sturen
  789: 1
  790: 1			ifdef    aduc832_v1_1
  791: 1			              lcall  delay60us     ;altijd goed
  792: 1			endif
  793: 1
  794: 1  01C4	D0 D0		              pop    psw           ;registers terug herstellen
  795: 1  01C6	D0 E0		              pop    acc
  796: 1  01C8	22		              ret
  797: 1
  798: 1			;******************************************************************************
  799: 1			;
  800: 1			; outhnibd
  801: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  802: 1			; lcd scherm.
  803: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  804: 1			; de routine vernietigt geen registers.
  805: 1			;
  806: 1			;******************************************************************************
  807: 1			ifdef     aduc832_v1_1
  808: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  809: 1			              push   psw
  810: 1			              setb   rs            ;controle lijn in orde
  811: 1			              clr    e             ;deselectie display
  812: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  813: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  814: 1			              mov     c,acc.6      ;afblijven!
  815: 1			              mov     lcdport.6,c
  816: 1			              mov     c,acc.5
  817: 1			              mov     lcdport.5,c
  818: 1			              mov     c,acc.4
  819: 1			              mov     lcdport.4,c
  820: 1			              setb   e             ;display enabelen
  821: 1			              nop                  ;450ns is normaal gezien voldoende
  822: 1			              clr    e             ;display deselecteren
  823: 1			              pop    psw           ;registers herstellen
  824: 1			              pop    acc
  825: 1			              ret
  826: 1			endif
  827: 1
  828: 1			ifdef    aduc832_v2_0
  829: 1  01C9	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  830: 1  01CB	C0 D0		              push   psw
  831: 1  01CD	C0 F0		              push   b             ;werkregister
  832: 1  01CF	12 04 99	              lcall  lcdtoport     ;lees de expander naar b register
  833: 1  01D2	D2 F0		              setb   rs            ;controle lijn in orde

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  834: 1  01D4	C2 F1		              clr    e             ;deselectie display
  835: 1  01D6	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  836: 1  01D8	03		              rr     a             ;bits op juiste plaats zetten
  837: 1  01D9	03		              rr     a             ;voor b reg
  838: 1  01DA	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  839: 1  01DD	42 F0		              orl    b,a           ;bij elkaar voegen
  840: 1  01DF	12 04 80	              lcall  porttolcd     ;naar expander
  841: 1  01E2	D2 F1		              setb   e             ;display enabelen
  842: 1  01E4	12 04 80	              lcall  porttolcd
  843: 1  01E7	C2 F1		              clr    e             ;display deselecteren
  844: 1  01E9	12 04 80	              lcall  porttolcd
  845: 1  01EC	D0 F0		              pop    b
  846: 1  01EE	D0 D0		              pop    psw           ;registers herstellen
  847: 1  01F0	D0 E0		              pop    acc
  848: 1  01F2	22		              ret
  849: 1			endif
  850: 1			;******************************************************************************
  851: 1			;
  852: 1			; outc
  853: 1			; Is een routine die naar het controleregister van het display een
  854: 1			; volledige byte (commando) stuurt.
  855: 1			; De routine vernietigt geen registers.
  856: 1			;
  857: 1			;******************************************************************************
  858: 1
  859: 1  01F3	C0 E0		outc:         push   acc           ;registers op stack zetten
  860: 1  01F5	C0 D0		              push   psw
  861: 1  01F7	12 02 09	              lcall  outhnibc      ;hoogste vier bits verzenden
  862: 1  01FA	12 03 52	              lcall  delay2ms      ;niet echt nodig
  863: 1  01FD	C4		              swap   a             ;bitjes omruilen
  864: 1  01FE	12 02 09	              lcall  outhnibc      ;naar het scherm sturen
  865: 1  0201	12 03 52	              lcall  delay2ms      ;altijd goed voor traagste commando
  866: 1  0204	D0 D0		              pop    psw           ;registers terug herstellen
  867: 1  0206	D0 E0		              pop    acc
  868: 1  0208	22		              ret
  869: 1
  870: 1			;******************************************************************************
  871: 1			;
  872: 1			; outhnibc
  873: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  874: 1			; het lcd scherm.
  875: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  876: 1			; de routine vernietigt geen registers.
  877: 1			;
  878: 1			;******************************************************************************
  879: 1			ifdef     aduc832_v1_1
  880: 1			outhnibc:     push   acc           ;registers op stack plaatsen
  881: 1			              push   psw
  882: 1			              clr    rs            ;controle lijn in orde
  883: 1			              clr    e             ;deselectie display
  884: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  885: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  886: 1			              mov     c,acc.6      ;afblijven!
  887: 1			              mov     lcdport.6,c
  888: 1			              mov     c,acc.5
  889: 1			              mov     lcdport.5,c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  890: 1			              mov     c,acc.4
  891: 1			              mov     lcdport.4,c
  892: 1			              setb   e             ;display enabelen
  893: 1			              nop                  ;450ns is normaal gezien voldoende
  894: 1			              clr    e             ;display deselecteren
  895: 1			              pop    psw           ;registers herstellen
  896: 1			              pop    acc
  897: 1			              ret
  898: 1			endif
  899: 1
  900: 1			ifdef    aduc832_v2_0
  901: 1  0209	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
  902: 1  020B	C0 D0		              push   psw
  903: 1  020D	C0 F0		              push   b             ;werkregister
  904: 1  020F	12 04 99	              lcall  lcdtoport     ;lees de expander naar b register
  905: 1  0212	C2 F0		              clr    rs            ;controle lijn in orde
  906: 1  0214	C2 F1		              clr    e             ;deselectie display
  907: 1  0216	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  908: 1  0218	03		              rr     a             ;bits op juiste plaats zetten
  909: 1  0219	03		              rr     a             ;voor b reg
  910: 1  021A	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  911: 1  021D	42 F0		              orl    b,a           ;bij elkaar voegen
  912: 1  021F	12 04 80	              lcall  porttolcd     ;naar expnder
  913: 1  0222	D2 F1		              setb   e             ;display enabelen
  914: 1  0224	12 04 80	              lcall  porttolcd
  915: 1  0227	C2 F1		              clr    e             ;display deselecteren
  916: 1  0229	12 04 80	              lcall  porttolcd
  917: 1  022C	D0 F0		              pop    b
  918: 1  022E	D0 D0		              pop    psw           ;registers herstellen
  919: 1  0230	D0 E0		              pop    acc
  920: 1  0232	22		              ret
  921: 1			endif
  922: 1
  923: 1			;******************************************************************************
  924: 1			; hexbuf2lcd
  925: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  926: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  927: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  928: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  929: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  930: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  931: 1			;
  932: 1			; ADR| HEX DATA  |
  933: 1			; 42 |AF 2D 23 5A|
  934: 1			;
  935: 1			; Deze routine vernietigt geen registers
  936: 1			;******************************************************************************
  937: 1
  938: 1  0233	C0 E0		hexbuf2lcd:   push   acc
  939: 1  0235	C0 F0		              push   b
  940: 1  0237	C0 D0		              push   psw
  941: 1  0239	C0 82		              push   dpl
  942: 1  023B	C0 83		              push   dph
  943: 1  023D	E8		              mov     a,r0
  944: 1  023E	C0 E0		              push   acc
  945: 1  0240	90 02 7C	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  946: 1  0243	12 01 6A	              lcall   outmsgalcd
  947: 1  0246	E8		              mov    a,r0            ;neem pointerwaarde
  948: 1  0247	12 01 46	              lcall  outbytelcd      ;byte afdrukken als startadres
  949: 1  024A	74 20		              mov    a,#' '          ;spatie afdrukken
  950: 1  024C	12 00 E5	              lcall  outcharlcd
  951: 1  024F	74 7C		              mov    a,#'|'          ;pipe afdrukken
  952: 1  0251	12 00 E5	              lcall  outcharlcd
  953: 1  0254	75 F0 04	              mov    b,#4            ;bytecounter=4
  954: 1  0257	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  955: 1  0258	12 01 46	              lcall  outbytelcd      ;byte naar buiten
  956: 1  025B	74 20		              mov    a,#' '          ;neem whitespace char
  957: 1  025D	12 00 E5	              lcall  outcharlcd       ;druk af
  958: 1  0260	08		              inc    r0              ;volgende byte
  959: 1  0261	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
  960: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  961: 1  0264	74 CF		              mov    a,#0cfh         ;adres laatste char
  962: 1  0266	12 00 E5	              lcall   outcharlcd
  963: 1  0269	74 7C		              mov    a,#'|'          ;neem pipe
  964: 1  026B	12 00 E5	              lcall  outcharlcd      ;ascii code afdrukken
  965: 1  026E	D0 E0		hexbuf2lcde:  pop    acc
  966: 1  0270	F8		              mov   r0,a
  967: 1  0271	D0 83		              pop   dph
  968: 1  0273	D0 82		              pop   dpl
  969: 1  0275	D0 D0		              pop   psw
  970: 1  0277	D0 F0		              pop   b
  971: 1  0279	D0 E0		              pop   acc
  972: 1  027B	22		              ret
  973: 1			                        ;'0123456789abcdef'
  974: 1  027C	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  0280	52 7C 20 48
       1  0284	45 58 20 44
       1  0288	41 54 41 20
       1  028C	20 7C C0 00
  975: 1
  976: 1
  977: 1			;******************************************************************************
  978: 1			; barlcd
  979: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
  980: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
  981: 1			; de inhoud van A
  982: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
  983: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
  984: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
  985: 1			; aangemaakt in de LCD CGRAM.
  986: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
  987: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
  988: 1			;       lcall build
  989: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
  990: 1			;       mov     a, #42h     ;de startlocatie is 42h
  991: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
  992: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
  993: 1			;
  994: 1			; Deze routine vernietigt geen registers.
  995: 1			;******************************************************************************
  996: 1
  997: 1  0290	C0 82		barlcd:       push   dpl

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

  998: 1  0292	88 82		              mov     dpl,r0
  999: 1  0294	C0 82		              push   dpl
 1000: 1  0296	C0 E0		              push   acc            ;bewaar startlocatie
 1001: 1  0298	C0 D0		              push   psw            ;bewaar status
 1002: 1  029A	C0 F0		              push   b              ;bewaar aantal bar's
 1003: 1  029C	F5 F0		              mov    b,a            ;bewaar startlocatie
 1004: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
 1005: 1  029E	E8		              mov    a,r0           ;neem maximum aantal bar's
 1006: 1  029F	C0 F0		              push   b              ;bewaar startadres
 1007: 1  02A1	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
 1008: 1  02A4	84		              div    ab             ;bereken dus het aantal nodige blokjes
 1009: 1  02A5	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
 1010: 1  02A6	E5 F0		              mov    a,b            ;neem restbars
 1011: 1  02A8	60 01		              jz     barlcd_1       ;als nul dan verder
 1012: 1  02AA	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
 1013: 1  02AB	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
 1014: 1  02AD	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
 1015: 1  02AF	12 00 E5	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
 1016: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
 1017: 1  02B2	74 13		              mov    a,#13h         ;cursor off
 1018: 1  02B4	12 00 E5	              lcall  outcharlcd     ;stuur naar LCD
 1019: 1  02B7	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
 1020: 1  02B9	C0 F0		              push   b              ;en weer bewaren
 1021: 1  02BB	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
 1022: 1  02BD	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
 1023: 1  02BF	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
 1024: 1  02C2	84		              div    ab             ;A=aantal volle blokjes, B=rest
 1025: 1  02C3	C0 F0		              push   b              ;bewaar rest
 1026: 1  02C5	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
 1027: 1  02C7	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
 1028: 1
 1029: 1			;Druk de volle 5x8 blokjes af van de bargraph
 1030: 1  02C9	74 04		              mov    a,#4           ;neem code voor vol blokje
 1031: 1  02CB	12 01 B9	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
 1032: 1  02CE	18		              dec    r0             ;verminder karaktersteller
 1033: 1  02CF	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
 1034: 1
 1035: 1			;Druk het onvolledige blokje (rest) af
 1036: 1  02D2	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
 1037: 1  02D4	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
 1038: 1  02D6	14		              dec    a              ;converteer rest naar code voor de
 1039: 1			                                    ;overeenkomende bar's
 1040: 1  02D7	12 01 B9	              lcall  outd           ;druk resterende bar's af
 1041: 1  02DA	18		              dec    r0             ;verminder karakterteller
 1042: 1
 1043: 1			;Test of we aan het einde van de bargraph zitten..
 1044: 1  02DB	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
 1045: 1  02DE	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
 1046: 1
 1047: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
 1048: 1  02E0	74 20		barlcd4:      mov    a,#' '         ;neem spatie
 1049: 1  02E2	12 01 B9	              lcall  outd           ;en druk af
 1050: 1  02E5	18		              dec    r0             ;karakterteller verminderen
 1051: 1  02E6	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
 1052: 1
 1053: 1  02E8	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1054: 1  02EA	D0 D0		              pop    psw            ;haal status weer
 1055: 1  02EC	D0 E0		              pop    acc            ;haal startlocatie weer
 1056: 1  02EE	D0 82		              pop    dpl
 1057: 1  02F0	A8 82		              mov    r0,dpl
 1058: 1  02F2	D0 82		              pop    dpl
 1059: 1  02F4	22		              ret
 1060: 1
 1061: 1
 1062: 1
 1063: 1			;******************************************************************************
 1064: 1			; barchars
 1065: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
 1066: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
 1067: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
 1068: 1			; kunnen pas daarna worden gebruikt.
 1069: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
 1070: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
 1071: 1			; (max. 3 extra char's).
 1072: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
 1073: 1			; opgeslagen met MSB=1.
 1074: 1			;******************************************************************************
 1075: 1
 1076: 1  02F5	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1077: 1  02F6	10		              db 00010000b
 1078: 1  02F7	10		              db 00010000b
 1079: 1  02F8	10		              db 00010000b
 1080: 1  02F9	10		              db 00010000b
 1081: 1  02FA	10		              db 00010000b
 1082: 1  02FB	10		              db 00010000b
 1083: 1  02FC	10		              db 00010000b
 1084: 1
 1085: 1  02FD	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1086: 1  02FE	18		              db 00011000b
 1087: 1  02FF	18		              db 00011000b
 1088: 1  0300	18		              db 00011000b
 1089: 1  0301	18		              db 00011000b
 1090: 1  0302	18		              db 00011000b
 1091: 1  0303	18		              db 00011000b
 1092: 1  0304	18		              db 00011000b
 1093: 1
 1094: 1  0305	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1095: 1  0306	1C		              db 00011100b
 1096: 1  0307	1C		              db 00011100b
 1097: 1  0308	1C		              db 00011100b
 1098: 1  0309	1C		              db 00011100b
 1099: 1  030A	1C		              db 00011100b
 1100: 1  030B	1C		              db 00011100b
 1101: 1  030C	1C		              db 00011100b
 1102: 1
 1103: 1  030D	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1104: 1  030E	1E		              db 00011110b
 1105: 1  030F	1E		              db 00011110b
 1106: 1  0310	1E		              db 00011110b
 1107: 1  0311	1E		              db 00011110b
 1108: 1  0312	1E		              db 00011110b
 1109: 1  0313	1E		              db 00011110b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1110: 1  0314	1E		              db 00011110b
 1111: 1
 1112: 1  0315	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1113: 1  0316	1F		              db 00011111b
 1114: 1  0317	1F		              db 00011111b
 1115: 1  0318	1F		              db 00011111b
 1116: 1  0319	1F		              db 00011111b
 1117: 1  031A	1F		              db 00011111b
 1118: 1  031B	1F		              db 00011111b
 1119: 1  031C	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1120: 1
 1121: 1			;******************************************************************************
 1122: 1			;
 1123: 1			; build
 1124: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1125: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1126: 1			; overeen komen met de ASCII codes 00h-07h.
 1127: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1128: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1129: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1130: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1131: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1132: 1			;
 1133: 1			; De routine vernietigt geen registers.
 1134: 1			;
 1135: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1136: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1137: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1138: 1			;      lcall  outcharlcd         ; druk de karakter af
 1139: 1			;
 1140: 1			;eigenkarakter:
 1141: 1			;      db 00001110b
 1142: 1			;      db 00001010b
 1143: 1			;      db 00001110b
 1144: 1			;      db 00000100b
 1145: 1			;      db 00011111b
 1146: 1			;      db 00000100b
 1147: 1			;      db 00001010b
 1148: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1149: 1			;******************************************************************************
 1150: 1
 1151: 1  031D	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1152: 1  031F	C0 D0		              push   psw
 1153: 1  0321	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1154: 1  0323	12 03 2B	              lcall  build_adr
 1155: 1  0326	D0 D0		              pop    psw
 1156: 1  0328	D0 E0		              pop    acc
 1157: 1  032A	22		              ret                  ;terug
 1158: 1
 1159: 1			;******************************************************************************
 1160: 1			; build_adr
 1161: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1162: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1163: 1			; die overeen komen met de ASCII codes 00h-07h.
 1164: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1165: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1166: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1167: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1168: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1169: 1			;
 1170: 1			; De routine vernietigt geen registers.
 1171: 1			;
 1172: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1173: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1174: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1175: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1176: 1			;      lcall  outcharlcd        ; druk de karakter af
 1177: 1			;
 1178: 1			;eigenkarakters:
 1179: 1			;      db 00001110b
 1180: 1			;      db 00001010b
 1181: 1			;      db 00001110b
 1182: 1			;       db 00000100b
 1183: 1			;      db 00011111b
 1184: 1			;      db 00000100b
 1185: 1			;      db 00001010b
 1186: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1187: 1			;******************************************************************************
 1188: 1  032B	C0 E0		build_adr:      push   acc
 1189: 1  032D	C0 D0		              push   psw
 1190: 1  032F	C0 83		              push   dph
 1191: 1  0331	C0 82		              push   dpl
 1192: 1  0333	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1193: 1  0335	12 01 F3	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1194: 1  0338	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1195: 1  033A	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1196: 1  033B	12 01 B9	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1197: 1  033E	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1198: 1  0341	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1199: 1  0342	80 F4		              sjmp   build3
 1200: 1  0344	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1201: 1  0346	12 01 F3	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1202: 1  0349	D0 82		              pop    dpl
 1203: 1  034B	D0 83		              pop    dph
 1204: 1  034D	D0 D0		              pop    psw
 1205: 1  034F	D0 E0		              pop    acc
 1206: 1  0351	22		              ret
 1207: 1
 1208: 1			;******************************************************************************
 1209: 1			;
 1210: 1			; delay2ms
 1211: 1			; Is een vertragingsroutine van 2ms.
 1212: 1			;
 1213: 1			; De routine vernietigt geen registers.
 1214: 1			;
 1215: 1			;******************************************************************************
 1216: 1
 1217: 1  0352	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1218: 1  0354	C0 D0		              push   psw
 1219: 1  0356	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1220: 1  0358	12 03 63	delay2ms1:    lcall  delay60us
 1221: 1  035B	D5 E0 FA	              djnz   acc,delay2ms1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1222: 1  035E	D0 D0		              pop    psw           ;registers herstellen
 1223: 1  0360	D0 E0		              pop    acc
 1224: 1  0362	22		              ret
 1225: 1
 1226: 1			;******************************************************************************
 1227: 1			;
 1228: 1			; delay60us.
 1229: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1230: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1231: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1232: 1			;
 1233: 1			; de routine vernietigt geen registers.
 1234: 1			;
 1235: 1			;******************************************************************************
 1236: 1
 1237: 1  0363	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1238: 1  0365	C0 D0		              push   psw
 1239: 1  0367	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1240: 1  0369	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1241: 1
 1242: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1243: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1244: 1
 1245: 1  036B	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1246: 1  036E	D0 E0		              pop    acc           ;registers herstellen
 1247: 1  0370	D0 D0		              pop    psw
 1248: 1  0372	22		              ret
 1249: 1
 1250: 1  0373	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1251: 1  0375	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1252: 1  0378	D0 D0		              pop    psw
 1253: 1  037A	D0 E0		              pop    acc
 1254: 1  037C	22		              ret
 1255: 1
 1256: 1			endif        ;einde van aduc_lcd
 1257: 1
 1258: 1
 1259: 1
 1260: 1
 1261: 1			ifdef aduc_i2c
 1262: 1			;******************************************************************************
 1263: 1			;
 1264: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1265: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1266: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1267: 1			;
 1268: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1269: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1270: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1271: 1			;
 1272: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1273: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1274: 1			;
 1275: 1			; Beschikbare routines:
 1276: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1277: 1			; i2cstart     :verzenden van een start conditie

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1278: 1			; i2cstop      :verzenden van een stop conditie
 1279: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1280: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1281: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1282: 1			;               negende klokpuls
 1283: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1284: 1			;               negende klokpuls
 1285: 1			;
 1286: 1			; Toevoeging [dp]
 1287: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1288: 1			;               een slavedevice
 1289: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1290: 1			;               en plaatst deze in een geheugenbuffer
 1291: 1			;******************************************************************************
 1292: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1293: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1294: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1295: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1296: 1
 1297: 1			;******************************************************************************
 1298: 1			; i2cinit
 1299: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1300: 1			;******************************************************************************
 1301: 1  037D	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1302: 1  037F	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1303: 1  0381	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1304: 1  0383	D2 EB		                setb    i2cm            ;master mode inschakelen
 1305: 1  0385	22		                ret
 1306: 1			;******************************************************************************
 1307: 1			; i2cstart
 1308: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1309: 1			;******************************************************************************
 1310: 1  0386	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1311: 1  0388	C2 EF		                clr     mdo             ;data moet laag worden
 1312: 1  038A	D2 EE		                setb    mde             ;data pin enable
 1313: 1  038C	C2 ED		                clr     mco             ;klok laag maken
 1314: 1  038E	22		                ret
 1315: 1			;******************************************************************************
 1316: 1			; i2cstop
 1317: 1			; Dit is een subroutine die de stop conditie opwekt.
 1318: 1			;******************************************************************************
 1319: 1  038F	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1320: 1  0391	D2 EE		                setb    mde             ;data mag naar buiten
 1321: 1  0393	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1322: 1  0395	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1323: 1  0397	22		                ret
 1324: 1
 1325: 1			;******************************************************************************
 1326: 1			; i2coutbyte
 1327: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1328: 1			; De routine vernietigt geen registers.
 1329: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1330: 1			; output: De carry zal de waarde van de ack bit bevatten na het

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1331: 1			;         uitvoeren van de routine.
 1332: 1			;******************************************************************************
 1333: 1  0398	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1334: 1  039A	C0 F0		                push    b
 1335: 1  039C	75 F0 08	                mov     b,#008h         ;loopcounter
 1336: 1  039F	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1337: 1  03A0	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1338: 1  03A2	D2 EE		                setb    mde             ;pin als output activeren
 1339: 1  03A4	D2 ED		                setb    mco             ;klokpukls hoog
 1340: 1  03A6	C2 ED		                clr     mco             ;klokpuls laag
 1341: 1  03A8	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1342: 1  03AB	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1343: 1  03AD	D2 ED		                setb    mco             ;klokpuls hoog
 1344: 1  03AF	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1345: 1  03B1	C2 ED		                clr     mco             ;klokpuls terug laag
 1346: 1  03B3	D0 F0		                pop     b
 1347: 1  03B5	D0 E0		                pop     acc             ;registers herstellen
 1348: 1  03B7	22		                ret
 1349: 1
 1350: 1			;******************************************************************************
 1351: 1			; i2cinbyteack
 1352: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1353: 1			; De routine vernietigt geen registers. De routine zal als
 1354: 1			; negende bit een ack verzenden.
 1355: 1			;******************************************************************************
 1356: 1  03B8	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1357: 1  03BA	C0 D0		                push    psw
 1358: 1  03BC	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1359: 1  03BF	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1360: 1  03C1	D2 ED		                setb    mco             ;klokpuls hoog
 1361: 1  03C3	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1362: 1  03C5	C2 ED		                clr     mco             ;klokpuls terug laag
 1363: 1  03C7	33		                rlc     a               ;in accu shiften
 1364: 1  03C8	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1365: 1  03CB	C3		                clr     c               ;ack verzenden
 1366: 1  03CC	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1367: 1  03CE	D2 EE		                setb    mde             ;pin als output activeren
 1368: 1  03D0	D2 ED		                setb    mco             ;klokpukls hoog
 1369: 1  03D2	C2 ED		                clr     mco             ;klokpuls laag
 1370: 1  03D4	D0 D0		                pop     psw             ;registers herstellen
 1371: 1  03D6	D0 F0		                pop     b
 1372: 1  03D8	22		                ret
 1373: 1
 1374: 1			;******************************************************************************
 1375: 1			; i2cinbytenack
 1376: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1377: 1			; De routine vernietigt geen registers. De routine zal als
 1378: 1			; negende bit een nack verzenden.
 1379: 1			;******************************************************************************
 1380: 1  03D9	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1381: 1  03DB	C0 D0		                push    psw
 1382: 1  03DD	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1383: 1  03E0	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1384: 1  03E2	D2 ED		                setb    mco             ;klokpuls hoog
 1385: 1  03E4	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1386: 1  03E6	C2 ED		                clr     mco             ;klokpuls terug laag

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1387: 1  03E8	33		                rlc     a               ;in accu shiften
 1388: 1  03E9	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1389: 1  03EC	D3		                setb    c               ;nack verzenden
 1390: 1  03ED	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1391: 1  03EF	D2 EE		                setb    mde             ;pin als output activeren
 1392: 1  03F1	D2 ED		                setb    mco             ;klokpukls hoog
 1393: 1  03F3	C2 ED		                clr     mco             ;klokpuls laag
 1394: 1  03F5	D0 D0		                pop     psw             ;registers herstellen
 1395: 1  03F7	D0 F0		                pop     b
 1396: 1  03F9	22		                ret
 1397: 1
 1398: 1			;******************************************************************************
 1399: 1			; i2csenddata
 1400: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1401: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1402: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1403: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1404: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1405: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1406: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1407: 1			;
 1408: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1409: 1			; pointer naar deze data.  .
 1410: 1
 1411: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1412: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1413: 1			;         B       = aantal te versturen bytes (minimum 1)
 1414: 1			;         R0      = startadres van te versturen datablok
 1415: 1			;
 1416: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1417: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1418: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1419: 1			;               verzonden byte waarvoor er geen ack kwam.
 1420: 1			;
 1421: 1			; Deze routine vernietigt niets...
 1422: 1			;******************************************************************************
 1423: 1  03FA	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1424: 1  03FC	C0 D0		                    push   psw
 1425: 1  03FE	E8		                    mov    a,r0
 1426: 1  03FF	C0 E0		                    push   acc           ;r0 op stack
 1427: 1
 1428: 1  0401	12 03 86	                    lcall  i2cstart      ;genereer startconditie
 1429: 1  0404	E5 83		                    mov    a,dph         ;neem adresbyte
 1430: 1  0406	12 03 98	                    lcall  i2coutbyte    ;en verstuur naar slave
 1431: 1  0409	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1432: 1  040B	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1433: 1  040D	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1434: 1  040F	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1435: 1			;10 bit adressering!
 1436: 1  0412	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1437: 1  0414	12 03 98	                    lcall  i2coutbyte    ;en verstuur naar slave
 1438: 1  0417	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1439: 1			;7 bit adressering!
 1440: 1  0419	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1441: 1  041A	12 03 98	                    lcall  i2coutbyte    ;en verstuur naar slave
 1442: 1  041D	40 10		                    jc     i2csenderror  ;indien geen ack, fout!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1443: 1  041F	08		                    inc    r0            ;volgende byte
 1444: 1  0420	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1445: 1  0423	12 03 8F	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1446: 1  0426	D0 E0		                    pop    acc
 1447: 1  0428	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1448: 1  0429	D0 D0		                    pop    psw
 1449: 1  042B	C3		                    clr    c             ;alles is ok!
 1450: 1  042C	D0 E0		                    pop    acc
 1451: 1  042E	22		                    ret
 1452: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1453: 1  042F	12 03 8F	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1454: 1  0432	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1455: 1  0434	D0 D0		                    pop    psw
 1456: 1  0436	D3		                    setb   c            ;terug met foutmelding
 1457: 1  0437	D0 E0		                    pop    acc
 1458: 1  0439	22		                    ret
 1459: 1
 1460: 1			;******************************************************************************
 1461: 1			; i2crcvdata
 1462: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1463: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1464: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1465: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1466: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1467: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1468: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1469: 1			;
 1470: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1471: 1			; is een pointer naar de start van dit ontvangen datablok.
 1472: 1			;
 1473: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1474: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1475: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1476: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1477: 1			;
 1478: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1479: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1480: 1			;               het adres, wordt de CY bit geset bij return.
 1481: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1482: 1			;
 1483: 1			; Deze routine vernietigt verder niets...
 1484: 1			;******************************************************************************
 1485: 1  043A	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1486: 1  043C	C0 D0		                    push    psw
 1487: 1  043E	E8		                    mov     a,r0            ;r0 op stack
 1488: 1  043F	C0 E0		                    push    acc
 1489: 1
 1490: 1  0441	12 03 86	                    lcall   i2cstart        ;genereer startconditie
 1491: 1  0444	E5 83		                    mov     a,dph           ;neem adresbyte
 1492: 1  0446	12 03 98	                    lcall   i2coutbyte      ;en verstuur naar slave
 1493: 1  0449	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1494: 1  044B	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1495: 1  044D	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1496: 1  044F	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1497: 1			;10 bit adressering!
 1498: 1  0452	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1499: 1  0454	12 03 98	                    lcall   i2coutbyte      ;en verstuur naar slave
 1500: 1  0457	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1501: 1			;7 bit adressering!
 1502: 1
 1503: 1  0459	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1504: 1  045C	12 03 D9	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1505: 1  045F	F6		                    mov     @r0,a           ;en deze ook bewaren
 1506: 1  0460	80 07		                    sjmp    i2crcvdata3
 1507: 1  0462	12 03 B8	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1508: 1  0465	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1509: 1  0466	08		                    inc     r0              ;pointer verhogen
 1510: 1  0467	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1511: 1
 1512: 1  0469	12 03 8F	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1513: 1  046C	D0 E0		                    pop     acc
 1514: 1  046E	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1515: 1  046F	D0 D0		                    pop     psw
 1516: 1  0471	C3		                    clr     c               ;alles is ok!
 1517: 1  0472	D0 E0		                    pop     acc
 1518: 1  0474	22		                    ret
 1519: 1			;fout: geen ack gekregen bij het versturen van het adres
 1520: 1  0475	12 03 8F	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1521: 1  0478	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1522: 1  047A	D0 D0		                    pop        psw
 1523: 1  047C	D3		                    setb    c               ;terug met foutmelding
 1524: 1  047D	D0 E0		                    pop        acc
 1525: 1  047F	22		                    ret
 1526: 1
 1527: 1
 1528: 1			;******************************************************************************
 1529: 1			;
 1530: 1			; porttolcd
 1531: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1532: 1			; scherm stuurt via de port expander.
 1533: 1			;
 1534: 1			; Gebruikt geen registers
 1535: 1			;
 1536: 1			;******************************************************************************
 1537: 1
 1538: 1  0480	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1539: 1  0482	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1540: 1  0484	12 03 86	              lcall  i2cstart      ;vertrokken
 1541: 1			ifdef    pcf8574
 1542: 1			              mov    a,#01000000b  ;schrijven naar expander
 1543: 1			endif
 1544: 1			ifdef    pcf8574A
 1545: 1  0487	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1546: 1			endif
 1547: 1  0489	12 03 98	              lcall  i2coutbyte    ;weg er mee
 1548: 1  048C	E5 F0		              mov    a,b           ;data verzenden
 1549: 1  048E	12 03 98	              lcall  i2coutbyte
 1550: 1  0491	12 03 8F	              lcall  i2cstop       ;transactie sluiten
 1551: 1  0494	D0 D0		              pop    psw
 1552: 1  0496	D0 E0		              pop    acc
 1553: 1  0498	22		              ret
 1554: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1555: 1			;******************************************************************************
 1556: 1			;
 1557: 1			; lcdtoport
 1558: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1559: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1560: 1			; aansturen van de buzzer en backlight.
 1561: 1			;
 1562: 1			; output: b register
 1563: 1			;
 1564: 1			;******************************************************************************
 1565: 1
 1566: 1  0499	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1567: 1  049B	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1568: 1  049D	12 03 86	              lcall  i2cstart      ;vertrokken
 1569: 1			ifdef    pcf8574
 1570: 1			              mov    a,#01000000b  ;schrijven naar expander
 1571: 1			endif
 1572: 1			ifdef    pcf8574A
 1573: 1  04A0	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1574: 1			endif
 1575: 1  04A2	12 03 98	              lcall  i2coutbyte    ;weg er mee
 1576: 1  04A5	12 03 D9	              lcall  i2cinbytenack ;data inlezen
 1577: 1  04A8	12 03 8F	              lcall  i2cstop
 1578: 1  04AB	F5 F0		              mov    b,a
 1579: 1  04AD	D0 D0		              pop    psw
 1580: 1  04AF	D0 E0		              pop    acc
 1581: 1  04B1	22		              ret
 1582: 1
 1583: 1			;******************************************************************************
 1584: 1			;
 1585: 1			; lcdlighton
 1586: 1			; Dit is een subroutine die de backlight inschakeld
 1587: 1			;
 1588: 1			; Gebruikt geen registers
 1589: 1			;
 1590: 1			;******************************************************************************
 1591: 1
 1592: 1  04B2	C0 F0		lcdlighton:   push   b
 1593: 1  04B4	12 04 99	              lcall  lcdtoport     ;expander lezen
 1594: 1  04B7	C2 F6		              clr    b.6           ;licht aan doen
 1595: 1  04B9	12 04 80	              lcall  porttolcd     ;expander schrijven
 1596: 1  04BC	D0 F0		              pop    b
 1597: 1  04BE	22		              ret
 1598: 1
 1599: 1
 1600: 1			;******************************************************************************
 1601: 1			;
 1602: 1			; lcdlightoff
 1603: 1			; Dit is een subroutine die de backlight uitschakeld
 1604: 1			;
 1605: 1			; Gebruikt geen registers
 1606: 1			;
 1607: 1			;******************************************************************************
 1608: 1
 1609: 1  04BF	C0 F0		lcdlightoff:  push   b
 1610: 1  04C1	12 04 99	              lcall  lcdtoport     ;expander lezen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1611: 1  04C4	D2 F6		              setb   b.6           ;licht uit doen
 1612: 1  04C6	12 04 80	              lcall  porttolcd     ;expander schrijven
 1613: 1  04C9	D0 F0		              pop    b
 1614: 1  04CB	22		              ret
 1615: 1
 1616: 1			;******************************************************************************
 1617: 1			;
 1618: 1			; lcdbuzon
 1619: 1			; Dit is een subroutine die de buzzer inschakeld
 1620: 1			;
 1621: 1			; Gebruikt geen registers
 1622: 1			;
 1623: 1			;******************************************************************************
 1624: 1
 1625: 1  04CC	C0 F0		lcdbuzon:     push   b
 1626: 1  04CE	12 04 99	              lcall  lcdtoport     ;expander lezen
 1627: 1  04D1	C2 F7		              clr    b.7           ;buzzer aan doen
 1628: 1  04D3	12 04 80	              lcall  porttolcd     ;expander schrijven
 1629: 1  04D6	D0 F0		              pop    b
 1630: 1  04D8	22		              ret
 1631: 1
 1632: 1			;******************************************************************************
 1633: 1			;
 1634: 1			; lcdbuzoff
 1635: 1			; Dit is een subroutine die de buzzer uitschakeld
 1636: 1			;
 1637: 1			; Gebruikt geen registers
 1638: 1			;
 1639: 1			;******************************************************************************
 1640: 1
 1641: 1  04D9	C0 F0		lcdbuzoff:    push   b
 1642: 1  04DB	12 04 99	              lcall  lcdtoport     ;expander lezen
 1643: 1  04DE	D2 F7		              setb   b.7           ;buzzer aan doen
 1644: 1  04E0	12 04 80	              lcall  porttolcd     ;expander schrijven
 1645: 1  04E3	D0 F0		              pop    b
 1646: 1  04E5	22		              ret
 1647: 1
 1648: 1			endif    ;einde aduc_i2c
 1649: 1			;******************************************************************************
 1650: 1
 1651: 1
 1652: 1
 1653: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1654: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1655: 1			;
 1656: 1			; ADuCsio.inc
 1657: 1			; Is een include file voor de ADuC832 microcontroller.
 1658: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1659: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1660: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1661: 1			; afwijking van de standaard routines is de initsio subroutine.
 1662: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1663: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1664: 1			; zijn.
 1665: 1			;
 1666: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1667: 1			;
 1668: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1669: 1
 1670: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1671: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1672: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1673: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1674: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1675: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1676: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1677: 1
 1678: 1  04E6	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1679: 1			                                                        ;van het scherm
 1680: 1
 1681: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1682: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1683: 1
 1684: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1685: 1			;
 1686: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1687: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1688: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1689: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1690: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1691: 1			;
 1692: 1			; de routine gebruikt de psw
 1693: 1			;
 1694: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1695: 1
 1696: 1  04EA	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1697: 1  04EC	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1698: 1  04EE	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1699: 1  04F0	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1700: 1  04F3	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1701: 1
 1702: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1703: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1704: 1
 1705: 1  04F5	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1706: 1  04F8	F4		              cpl    a             ;bitbangen om laten uit te komen
 1707: 1  04F9	C3		              clr    c             ;verder doen
 1708: 1  04FA	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1709: 1  04FC	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1710: 1  04FE	24 80		              add    a,#080h       ;nu alles in orde
 1711: 1  0500	F5 9E		              mov    t3con,a       ;baud rate klaar
 1712: 1  0502	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1713: 1  0505	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1714: 1  0506	D0 E0		              pop    acc
 1715: 1  0508	22		              ret
 1716: 1
 1717: 1  0509	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1718: 1  050A	D0 E0		              pop    acc
 1719: 1  050C	22		              ret
 1720: 1
 1721: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1722: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1723: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1724: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1725: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1726: 1			;
 1727: 1			; de routine gebruikt geen registers.
 1728: 1			;
 1729: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1730: 1
 1731: 1  050D	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1732: 1  050F	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1733: 1  0512	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1734: 1  0514	22		              RET
 1735: 1
 1736: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1737: 1			;
 1738: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1739: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1740: 1			;
 1741: 1			; de routine gebruikt geen registers.
 1742: 1			;
 1743: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1744: 1
 1745: 1  0515	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1746: 1  0517	C0 D0		              push   psw
 1747: 1  0519	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1748: 1  051B	12 06 27	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1749: 1  051E	12 05 0D	              LCALL  OUTCHAR       ;VERSTUREN
 1750: 1  0521	12 05 6E	              LCALL  XONXOFF       ;FLOW CONTROL
 1751: 1  0524	D0 D0		              pop    psw           ;registers herstellen
 1752: 1  0526	D0 E0		              pop    acc
 1753: 1  0528	22		              RET
 1754: 1
 1755: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1756: 1			;
 1757: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1758: 1			; WORDT XONXOFF GEBRUIKT.
 1759: 1			;
 1760: 1			; de routine gebruikt geen registers.
 1761: 1			;
 1762: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1763: 1
 1764: 1  0529	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1765: 1  052B	C0 D0		              push   psw
 1766: 1  052D	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1767: 1  052F	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1768: 1  0530	12 05 15	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1769: 1  0533	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1770: 1  0535	12 05 15	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1771: 1  0538	D0 D0		              pop    psw           ;registers herstellen
 1772: 1  053A	D0 E0		              pop    acc
 1773: 1  053C	22		              RET
 1774: 1
 1775: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1776: 1			;
 1777: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1778: 1			; VAN DE CURSOR.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1779: 1			;
 1780: 1			; de routine gebruikt geen registers.
 1781: 1			;
 1782: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1783: 1
 1784: 1  053D	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1785: 1  053F	C0 D0		              push   psw
 1786: 1  0541	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1787: 1  0543	12 05 29	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1788: 1  0546	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1789: 1  0548	12 05 29	              LCALL  OUTBYTE       ;WEG ER MEE
 1790: 1  054B	D0 D0		              pop    psw           ;registers herstellen
 1791: 1  054D	D0 E0		              pop    acc
 1792: 1  054F	22		              RET                  ;EINDE
 1793: 1
 1794: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1795: 1			;
 1796: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1797: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1798: 1			;
 1799: 1			; de routine gebruikt geen registers.
 1800: 1			;
 1801: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1802: 1
 1803: 1  0550	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1804: 1  0552	C0 D0		              push   psw
 1805: 1  0554	C0 82		              push   dpl
 1806: 1  0556	C0 83		              push   dph
 1807: 1  0558	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1808: 1  0559	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1809: 1  055A	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1810: 1  055C	12 05 0D	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1811: 1  055F	12 05 6E	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1812: 1  0562	A3		              INC    DPTR          ;DPTR AANPASSEN
 1813: 1  0563	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1814: 1  0565	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1815: 1  0567	D0 82		              pop    dpl
 1816: 1  0569	D0 D0		              pop    psw
 1817: 1  056B	D0 E0		              pop    acc
 1818: 1  056D	22		              RET                  ;EINDE ROUTINE
 1819: 1
 1820: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1821: 1			;
 1822: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1823: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1824: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1825: 1			; VERDER DOORGEGEVEN.
 1826: 1			;
 1827: 1			; de routine gebruikt geen registers.
 1828: 1			;
 1829: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1830: 1
 1831: 1  056E	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1832: 1  0570	C0 D0		              push   psw
 1833: 1  0572	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1834: 1  0575	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1835: 1  0577	D0 E0		              pop    acc
 1836: 1  0579	22		              RET                  ;ANDERS EINDE
 1837: 1  057A	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1838: 1  057C	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1839: 1  057F	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1840: 1  0582	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1841: 1
 1842: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1843: 1			;
 1844: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1845: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1846: 1			;
 1847: 1			; de routine gebruikt de accu.
 1848: 1			;
 1849: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1850: 1
 1851: 1  0584	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 1852: 1  0587	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 1853: 1  0589	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1854: 1  058B	22		              RET
 1855: 1
 1856: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1857: 1			;
 1858: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1859: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1860: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 1861: 1			; DE CARRY OP 1 GEZET WORDEN.
 1862: 1			;
 1863: 1			; De routine gebruikt de accu EN PSW.
 1864: 1			;
 1865: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1866: 1
 1867: 1  058C	C0 F0		INBYTE:       PUSH     B
 1868: 1  058E	12 05 84	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1869: 1  0591	12 06 1A	              LCALL  LOWUPTR
 1870: 1  0594	12 06 35	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1871: 1  0597	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1872: 1  0599	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1873: 1  059A	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1874: 1  059C	12 05 84	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1875: 1  059F	12 06 1A	              LCALL  LOWUPTR
 1876: 1  05A2	12 06 35	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1877: 1  05A5	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1878: 1  05A7	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1879: 1  05A9	D0 F0		INBYTE1:      POP     B
 1880: 1  05AB	22		              RET
 1881: 1
 1882: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1883: 1			;
 1884: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1885: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1886: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1887: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1888: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1889: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1890: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1891: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1892: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1893: 1			; bepalen.
 1894: 1			;
 1895: 1			; De routine gebruikt  r0 .
 1896: 1			;
 1897: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1898: 1
 1899: 1  05AC	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1900: 1  05AE	C0 D0		              push   psw
 1901: 1  05B0	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1902: 1  05B2	12 05 84	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 1903: 1  05B5	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1904: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 1905: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1906: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1907: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 1908: 1			; GEVOERD.
 1909: 1  05B7	12 06 1A	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1910: 1  05BA	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1911: 1  05BD	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1912: 1  05BE	D0 D0		              pop    psw                  ;registers herstellen
 1913: 1  05C0	D0 E0		              pop    acc
 1914: 1  05C2	22		              RET                         ;EINDE VAN DE ROUTINE
 1915: 1
 1916: 1  05C3	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 1917: 1  05C6	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1918: 1  05C9	74 07		INBUFA4:      MOV    A,#BEEP
 1919: 1  05CB	12 05 0D	INBUFA7:      LCALL  OUTCHAR
 1920: 1  05CE	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1921: 1
 1922: 1  05D0	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1923: 1  05D1	90 04 E6	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1924: 1  05D4	12 05 50	              LCALL  OUTMSGA
 1925: 1  05D7	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 1926: 1  05D9	12 06 0C	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1927: 1  05DC	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1928: 1  05DE	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1929: 1  05E1	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1930: 1  05E3	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1931: 1  05E4	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1932: 1  05E5	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1933: 1
 1934: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1935: 1			;
 1936: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1937: 1			;
 1938: 1			; De routine gebruikt niets.
 1939: 1			;
 1940: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1941: 1
 1942: 1  05E7	C0 E0		BDELETE:      PUSH     ACC
 1943: 1  05E9	C0 D0		              PUSH     PSW
 1944: 1  05EB	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1945: 1  05EC	C0 E0		              PUSH     ACC
 1946: 1  05EE	E9		              MOV     A,R1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1947: 1  05EF	C0 E0		              PUSH     ACC
 1948: 1  05F1	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1949: 1  05F3	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1950: 1  05F5	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1951: 1  05F6	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1952: 1  05F9	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1953: 1  05FA	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1954: 1  05FD	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1955: 1  05FF	F9		              MOV     R1,A
 1956: 1  0600	D0 E0		              POP     ACC
 1957: 1  0602	F8		              MOV     R0,A
 1958: 1  0603	D0 D0		              POP     PSW
 1959: 1  0605	D0 E0		              POP     ACC
 1960: 1  0607	22		              RET                         ;EINDE VAN DE ROUTINE
 1961: 1  0608	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1962: 1  0609	09		              INC    R1
 1963: 1  060A	80 ED		              SJMP   BDELETE3
 1964: 1
 1965: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1966: 1			;
 1967: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1968: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1969: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1970: 1			; AANZIEN.
 1971: 1			;
 1972: 1			; De routine gebruikt de accu en de psw.
 1973: 1			;
 1974: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1975: 1
 1976: 1  060C	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 1977: 1  060F	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 1978: 1  0611	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 1979: 1  0614	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 1980: 1  0616	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 1981: 1  0617	22		              RET
 1982: 1  0618	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 1983: 1  0619	22		              RET
 1984: 1
 1985: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1986: 1			;
 1987: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 1988: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 1989: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 1990: 1			; AANGEPAST WORDEN.
 1991: 1			;
 1992: 1			; De routine gebruikt de accu en psw .
 1993: 1			;
 1994: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1995: 1
 1996: 1  061A	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 1997: 1  061D	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 1998: 1  061F	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 1999: 1  0622	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 2000: 1  0624	94 20		              SUBB   A,#020H              ;OMZETTING
 2001: 1  0626	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 2002: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2003: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2004: 1			;
 2005: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 2006: 1			; ASCII CODE.
 2007: 1			;
 2008: 1			; De routine gebruikt de accu .
 2009: 1			;
 2010: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2011: 1
 2012: 1  0627	C0 D0		BATRANS:      PUSH   PSW
 2013: 1  0629	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 2014: 1  062C	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 2015: 1  062E	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 2016: 1  0630	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 2017: 1  0632	D0 D0		              POP     PSW
 2018: 1  0634	22		              RET
 2019: 1
 2020: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2021: 1			;
 2022: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 2023: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 2024: 1			; GEVAL WORDT DE CARRY GEZET.
 2025: 1			;
 2026: 1			; De routine gebruikt de accu en de psw.
 2027: 1			;
 2028: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2029: 1
 2030: 1  0635	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 2031: 1  0636	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 2032: 1  0638	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 2033: 1  063A	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 2034: 1  063D	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 2035: 1  063F	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 2036: 1  0641	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 2037: 1  0643	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 2038: 1  0646	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 2039: 1  0647	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 2040: 1  0649	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 2041: 1  064A	22		ASCBINTRANS1: RET
 2042: 1
 2043: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2044: 1			;
 2045: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 2046: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 2047: 1			;
 2048: 1			; De routine gebruikt de accu en de psw.
 2049: 1			;
 2050: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2051: 1
 2052: 1  064B	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 2053: 1  064C	12 06 35	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 2054: 1  064F	22		              RET                         ;EINDE OMZETTING
 2055: 1
 2056: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2057: 1			;
 2058: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2059: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 2060: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 2061: 1			;
 2062: 1			; De routine gebruikt de accu, r0.
 2063: 1			;
 2064: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2065: 1
 2066: 1  0650	C0 F0		ASCII2:       PUSH   B
 2067: 1  0652	12 06 4B	              LCALL  ASCII1               ;OMZETTEN
 2068: 1  0655	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 2069: 1  0657	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 2070: 1  0658	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 2071: 1  065A	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 2072: 1  065B	12 06 4B	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 2073: 1  065E	40 02		              JC     ASCII21               ;WEG ALS C=1
 2074: 1  0660	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 2075: 1  0662	D0 F0		ASCII21:      POP     B
 2076: 1  0664	22		              RET
 2077: 1
 2078: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2079: 1			;
 2080: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2081: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2082: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2083: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2084: 1			;
 2085: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2086: 1			;
 2087: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2088: 1
 2089: 1  0665	12 06 50	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2090: 1  0668	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2091: 1  066A	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2092: 1  066C	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2093: 1  066D	12 06 50	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2094: 1  0670	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2095: 1  0672	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2096: 1  0674	22		ASCII41:      RET
 2097: 1
 2098: 1			endif        ;einde van aduc_sio
 2099: 1			;*******************************************************************************
 2100: 1
 2101: 1
 2102: 1			ifdef        aduc_math    ;rekenkundige routines
 2103: 1			;*******************************************************************************
 2104: 1			; aduc_math
 2105: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2106: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2107: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2108: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2109: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2110: 1			; zoals aangegeven:
 2111: 1			;
 2112: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2113: 1			;        ---------------------------
 2114: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2115: 1			;        ---------------------------                             statusbit = f0
 2116: 1			;        ---------------------------
 2117: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2118: 1			;        ---------------------------
 2119: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2120: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2121: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2122: 1			; return en moeten hiervoor worden gereserveerd.
 2123: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2124: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2125: 1			; en unsigned getallen.
 2126: 1			;
 2127: 1			; Beschikbare routines:
 2128: 1			;
 2129: 1			; Conversie routines:
 2130: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2131: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2132: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2133: 1			;
 2134: 1			; Som:
 2135: 1			; s_add16, add16, s_add32, add32
 2136: 1			;
 2137: 1			; Verschil:
 2138: 1			; s_sub16, sub16, s_sub32, sub32
 2139: 1			;
 2140: 1			; Vermenigvuldigen:
 2141: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2142: 1			;
 2143: 1			; Delen:
 2144: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2145: 1			;
 2146: 1			; Vemenigvuldig met factor:
 2147: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2148: 1			;
 2149: 1			; Vierkantswortel:
 2150: 1			; sqrt32, s_sqrt32
 2151: 1			;
 2152: 1			; Schuiven:
 2153: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2154: 1			;
 2155: 1			; Vergelijken:
 2156: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2157: 1			;
 2158: 1			; Tabel lookup:
 2159: 1			; table_lu
 2160: 1			;
 2161: 1			; Gonemetrische functies:
 2162: 1			; Cordic = sinus,cosinus
 2163: 1			;
 2164: 1			;*******************************************************************************
 2165: 1
 2166: 1			;*******************************************************************************
 2167: 1			;
 2168: 1			; bcdhex8     (45,77us @16.777216MHz)
 2169: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2170: 1			; naar een 2's complement hex getal.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2171: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2172: 1			; een waarde 00h tot 63h.
 2173: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2174: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2175: 1			; input:      R0 = waarde tussen 00h en 99h.
 2176: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2177: 1			; output:     R0 = 2's complement waarde
 2178: 1			;             cy=1 bij out of range van r0
 2179: 1			;             cy=0 bij conversie ok
 2180: 1			; vernietigt: niets
 2181: 1			;*******************************************************************************
 2182: 1  0675	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2183: 1  0677	C0 D0		              push   psw
 2184: 1  0679	C0 F0		              push   b
 2185: 1
 2186: 1  067B	E8		              mov    a,r0                 ;neem te converteren waarde
 2187: 1  067C	F5 F0		              mov    b,a
 2188: 1  067E	54 0F		              anl    a,#0fh
 2189: 1  0680	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2190: 1  0683	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2191: 1  0685	E5 F0		              mov    a,b
 2192: 1  0687	54 F0		              anl    a,#0f0h
 2193: 1  0689	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2194: 1  068C	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2195: 1
 2196: 1  068E	E8		              mov    a,r0
 2197: 1  068F	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2198: 1  0691	C4		              swap   a
 2199: 1  0692	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2200: 1  0695	A4		              mul    ab
 2201: 1  0696	F5 F0		              mov    b,a                  ;bewaar dit product even
 2202: 1  0698	E8		              mov    a,r0
 2203: 1  0699	54 0F		              anl    a,#00fh
 2204: 1  069B	F8		              mov    r0,a
 2205: 1  069C	E5 F0		              mov    a,b
 2206: 1  069E	28		              add    a,r0                 ;eenheden er bijtellen
 2207: 1  069F	F8		              mov    r0,a
 2208: 1
 2209: 1  06A0	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2210: 1  06A2	12 07 A3	              lcall  magsig8              ;omzetten naar 2's complement
 2211: 1
 2212: 1  06A5	D0 F0		              pop    b
 2213: 1  06A7	D0 D0		              pop    psw
 2214: 1  06A9	C2 D7		              clr    cy                   ;geen fout
 2215: 1  06AB	D0 E0		              pop    acc
 2216: 1  06AD	22		              ret
 2217: 1
 2218: 1  06AE	D0 F0		bcdhex82:     pop    b
 2219: 1  06B0	D0 D0		              pop    psw
 2220: 1  06B2	D2 D7		              setb   cy                   ;fout! r0 out of range
 2221: 1  06B4	D0 E0		              pop    acc
 2222: 1  06B6	22		              ret
 2223: 1
 2224: 1			;*******************************************************************************
 2225: 1			;
 2226: 1			; hexbcd8     (38,4us @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2227: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2228: 1			; naar een 8bit bcd getal.
 2229: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2230: 1			; bcdgetal van 00h tot +99h.
 2231: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2232: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2233: 1			; bcdgetal 00h tot -99h
 2234: 1			;
 2235: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2236: 1			;
 2237: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2238: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2239: 1			;             cy=1 bij out of range van r0
 2240: 1			;             cy=0 bij conversie ok
 2241: 1			; vernietigt: niets
 2242: 1			;*******************************************************************************
 2243: 1  06B7	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2244: 1  06B9	C0 D0		                push    psw
 2245: 1  06BB	C0 F0		                push    b
 2246: 1  06BD	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2247: 1  06BE	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2248: 1  06C1	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2249: 1  06C3	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2250: 1  06C6	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2251: 1  06C8	D0 F0		                pop     b
 2252: 1  06CA	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2253: 1  06CC	D3		                setb    c
 2254: 1  06CD	D0 E0		                pop     acc
 2255: 1  06CF	22		                ret
 2256: 1  06D0	12 08 6B	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2257: 1  06D3	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2258: 1  06D4	75 F0 0A	                mov     b,#10
 2259: 1  06D7	84		                div     ab
 2260: 1  06D8	C4		                swap    a
 2261: 1  06D9	25 F0		                add     a,b
 2262: 1  06DB	F8		                mov     r0,a
 2263: 1  06DC	D0 F0		                pop     b               ;registers herstellen
 2264: 1  06DE	D0 E0		                pop     acc             ;psw van stack halen
 2265: 1  06E0	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2266: 1  06E2	92 E5		                mov     acc.5,c
 2267: 1  06E4	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2268: 1  06E6	C3		                clr     c               ;status: conversie ok
 2269: 1  06E7	D0 E0		                pop     acc
 2270: 1  06E9	22		                ret
 2271: 1
 2272: 1
 2273: 1
 2274: 1			;*******************************************************************************
 2275: 1			;
 2276: 1			; bcdhex16    (86,6us @16.777216MHz)
 2277: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2278: 1			; omzetten naar een 2's complement hex getal.
 2279: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2280: 1			; naareen waarde 0000h tot 270fh.
 2281: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2282: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2283: 1			; van -270fh).
 2284: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2285: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2286: 1			; output:     R1,R0 = 2's complement waarde
 2287: 1			;             cy=1 bij out of range van r1,r0
 2288: 1			;             cy=0 bij conversie ok
 2289: 1			; vernietigt: niets
 2290: 1			;*******************************************************************************
 2291: 1  06EA	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2292: 1  06EC	C0 D0		              push   psw
 2293: 1  06EE	C0 F0		              push   b
 2294: 1
 2295: 1  06F0	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2296: 1  06F1	F5 F0		              mov    b,a
 2297: 1  06F3	54 0F		              anl    a,#0fh
 2298: 1  06F5	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2299: 1  06F8	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2300: 1  06FA	E5 F0		              mov    a,b
 2301: 1  06FC	54 F0		              anl    a,#0f0h
 2302: 1  06FE	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2303: 1  0701	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2304: 1  0703	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2305: 1  0704	F5 F0		              mov    b,a
 2306: 1  0706	54 0F		              anl    a,#0fh
 2307: 1  0708	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2308: 1  070B	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2309: 1  070D	E5 F0		              mov    a,b
 2310: 1  070F	54 F0		              anl    a,#0f0h
 2311: 1  0711	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2312: 1  0714	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2313: 1
 2314: 1  0716	E8		              mov    a,r0                  ;neem low byte voor conversie
 2315: 1  0717	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2316: 1  0719	C0 E0		              push   acc                   ;en even bewaren
 2317: 1
 2318: 1  071B	E8		              mov    a,r0
 2319: 1  071C	C4		              swap   a
 2320: 1  071D	54 0F		              anl    a,#00fh              ;tientallen
 2321: 1  071F	75 F0 0A	              mov    b,#00ah              ;maal tien
 2322: 1  0722	A4		              mul    ab                   ;
 2323: 1  0723	D0 F0		              pop    b                    ;neem eenheden
 2324: 1  0725	25 F0		              add    a,b                  ;tel bij tientallen
 2325: 1  0727	C0 E0		              push   acc                  ;weer bewaren
 2326: 1
 2327: 1  0729	E9		              mov    a,r1                 ;neem high byte voor conversie
 2328: 1  072A	54 F0		              anl    a,#0f0h
 2329: 1  072C	C4		              swap   a
 2330: 1  072D	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2331: 1
 2332: 1  072F	E9		              mov    a,r1                  ;neem high byte voor conversie
 2333: 1  0730	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2334: 1  0732	75 F0 64	              mov    b,#100d              ;en maal honderd
 2335: 1  0735	A4		              mul    ab
 2336: 1  0736	A9 F0		              mov    r1,b
 2337: 1  0738	F8		              mov    r0,a
 2338: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2339: 1  0739	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2340: 1  073B	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2341: 1  073E	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2342: 1  073F	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2343: 1  0742	A4		              mul    ab
 2344: 1  0743	28		              add    a,r0                 ;tel honderdtallen bij de
 2345: 1  0744	F8		              mov    r0,a                 ;duizendtallen
 2346: 1  0745	E9		              mov    a,r1
 2347: 1  0746	35 F0		              addc   a,b
 2348: 1  0748	F9		              mov    r1,a
 2349: 1
 2350: 1  0749	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2351: 1  074B	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2352: 1  074C	F8		              mov    r0,a                 ;duizendtallen
 2353: 1  074D	74 00		              mov    a,#000h
 2354: 1  074F	39		              addc   a,r1
 2355: 1  0750	F9		              mov    r1,a                 ;omzetting klaar
 2356: 1
 2357: 1  0751	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2358: 1  0753	12 07 D7	              lcall  magsig16             ;omzetten naar 2's complement
 2359: 1
 2360: 1  0756	D0 F0		              pop    b
 2361: 1  0758	D0 D0		              pop    psw
 2362: 1  075A	C2 D7		              clr    cy                   ;geen fout
 2363: 1  075C	D0 E0		              pop    acc
 2364: 1  075E	22		              ret
 2365: 1
 2366: 1  075F	D0 F0		bcdhex162:    pop    b
 2367: 1  0761	D0 D0		              pop    psw
 2368: 1  0763	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2369: 1  0765	D0 E0		              pop    acc
 2370: 1  0767	22		              ret
 2371: 1
 2372: 1			;*******************************************************************************
 2373: 1			;
 2374: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2375: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2376: 1			; naar een 24bit bcd getal.
 2377: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2378: 1			; bcdgetal van 000000h tot +032767h.
 2379: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2380: 1			; naar een bcdgetal 000000h tot -032768h
 2381: 1			;
 2382: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2383: 1			;
 2384: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2385: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2386: 1			;
 2387: 1			; vernietigt: niets
 2388: 1			;*******************************************************************************
 2389: 1			;
 2390: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2391: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2392: 1			; naar een 24bit bcd getal.
 2393: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2394: 1			; bcdgetal van 000000h tot 065535h.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2395: 1			;
 2396: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2397: 1			;
 2398: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2399: 1			;
 2400: 1			; vernietigt: niets
 2401: 1			;*******************************************************************************
 2402: 1  0768	12 08 9D	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2403: 1  076B	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2404: 1  076D	C0 D0		                push   psw
 2405: 1  076F	C0 F0		                push   b
 2406: 1  0771	C0 82		                push   dpl
 2407: 1
 2408: 1  0773	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2409: 1  0776	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2410: 1  0778	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2411: 1  077A	12 0C 4C	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2412: 1  077D	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2413: 1  077E	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2414: 1			                                        ;dus eerst eenheden, dan tientallen
 2415: 1			                                        ;honderdtallen, duizendtallen en
 2416: 1			                                        ;tienduizendtallen
 2417: 1  0780	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2418: 1
 2419: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2420: 1
 2421: 1  0783	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2422: 1  0785	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2423: 1  0786	D0 E0		                pop    acc              ;duizendtallen ophalen
 2424: 1  0788	C4		                swap   a                ;en combineren met de
 2425: 1  0789	F5 82		                mov    dpl,a
 2426: 1  078B	D0 E0		                pop    acc              ;honderdtallen van de stack
 2427: 1  078D	25 82		                add    a,dpl
 2428: 1  078F	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2429: 1  0790	D0 E0		                pop    acc              ;tientallen van de stack halen
 2430: 1  0792	C4		                swap   a
 2431: 1  0793	F5 82		                mov    dpl,a
 2432: 1  0795	D0 E0		                pop    acc              ;en combineren met de eenheden
 2433: 1  0797	25 82		                add    a,dpl
 2434: 1  0799	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2435: 1
 2436: 1  079A	D0 82		                pop    dpl              ;registers herstellen
 2437: 1  079C	D0 F0		                pop    b
 2438: 1  079E	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2439: 1  07A0	D0 E0		                pop    acc
 2440: 1  07A2	22		                ret
 2441: 1
 2442: 1			;*******************************************************************************
 2443: 1			; magsig8        (13,6us @16.777216MHz)
 2444: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2445: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2446: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2447: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2448: 1			;           (f0 en f1 zijn 1 als negatief)
 2449: 1			;
 2450: 1			; output:   r0 = 2's complement

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2451: 1			;
 2452: 1			; vernietigt: niets
 2453: 1			;*******************************************************************************
 2454: 1
 2455: 1  07A3	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2456: 1  07A5	C0 D0		               push   psw
 2457: 1  07A7	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2458: 1  07AA	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2459: 1  07AD	80 09		               sjmp   magsig8c
 2460: 1
 2461: 1  07AF	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2462: 1  07B2	80 04		               sjmp   magsig8c
 2463: 1
 2464: 1  07B4	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2465: 1  07B5	F4		               cpl    a                  ;complementeer abs waarde
 2466: 1  07B6	04		               inc    a                  ;r0 = complement(r0)+1
 2467: 1  07B7	F8		               mov    r0,a               ;bewaar in 2's complement
 2468: 1  07B8	D0 D0		magsig8c:      pop    psw
 2469: 1  07BA	D0 E0		               pop    acc
 2470: 1  07BC	22		               ret                        ;klaar
 2471: 1
 2472: 1			;*******************************************************************************
 2473: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2474: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2475: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2476: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2477: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2478: 1			;           (f0 en f1 zijn 1 als negatief)
 2479: 1			;
 2480: 1			; output:   r4 = 2's complement
 2481: 1			;
 2482: 1			; vernietigt: niets
 2483: 1			;*******************************************************************************
 2484: 1
 2485: 1  07BD	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2486: 1  07BF	C0 D0		               push    psw
 2487: 1  07C1	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2488: 1  07C4	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2489: 1  07C7	80 EF		               sjmp    magsig8c
 2490: 1
 2491: 1  07C9	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2492: 1  07CC	80 04		               sjmp    magsig8acc1c
 2493: 1
 2494: 1  07CE	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2495: 1  07CF	F4		               cpl     a                 ;complementeer abs waarde
 2496: 1  07D0	04		               inc     a                 ;r4 = complement(r0)+1
 2497: 1  07D1	FC		               mov     r4,a              ;bewaar in 2's complement
 2498: 1  07D2	D0 D0		magsig8acc1c:  pop     psw
 2499: 1  07D4	D0 E0		               pop     acc
 2500: 1  07D6	22		               ret                       ;klaar
 2501: 1
 2502: 1			;*******************************************************************************
 2503: 1			; magsig16        (16,6us @16.777216MHz)
 2504: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2505: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2506: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2507: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2508: 1			;           (f0 en f1 zijn 1 als negatief)
 2509: 1			;
 2510: 1			; output:   r1,r0 = 2's complement
 2511: 1			;
 2512: 1			; vernietigt: niets
 2513: 1			;*******************************************************************************
 2514: 1  07D7	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2515: 1  07D9	C0 D0		               push    psw
 2516: 1  07DB	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2517: 1  07DE	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2518: 1  07E1	80 0F		               sjmp    magsig16c
 2519: 1
 2520: 1  07E3	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2521: 1  07E6	80 0A		               sjmp    magsig16c
 2522: 1
 2523: 1  07E8	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2524: 1  07E9	F4		               cpl     a                ;complementeer het dan
 2525: 1  07EA	24 01		               add     a, #1            ;en tel er 1 bij
 2526: 1  07EC	F8		               mov     r0,a
 2527: 1  07ED	E9		               mov     a,r1             ;neem volgende byte
 2528: 1  07EE	F4		               cpl     a                ;complementeer en tel carry erbij
 2529: 1  07EF	34 00		               addc    a,#0
 2530: 1  07F1	F9		               mov     r1,a
 2531: 1  07F2	D0 D0		magsig16c:     pop     psw
 2532: 1  07F4	D0 E0		               pop     acc
 2533: 1  07F6	22		               ret
 2534: 1
 2535: 1			;*******************************************************************************
 2536: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2537: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2538: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2539: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2540: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2541: 1			;           (f0 en f1 zijn 1 als negatief)
 2542: 1			;
 2543: 1			; output:   r5,r4 = 2's complement
 2544: 1			;
 2545: 1			; vernietigt: niets
 2546: 1			;*******************************************************************************
 2547: 1  07F7	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2548: 1  07F9	C0 D0		                push    psw
 2549: 1  07FB	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2550: 1  07FE	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2551: 1  0801	80 0F		                sjmp    magsig16acc1c
 2552: 1
 2553: 1  0803	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2554: 1  0806	80 0A		                sjmp    magsig16acc1c
 2555: 1
 2556: 1  0808	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2557: 1  0809	F4		                cpl     a                   ;complementeer het dan
 2558: 1  080A	24 01		                add     a,#1                ;en tel er 1 bij
 2559: 1  080C	FC		                mov     r4,a
 2560: 1  080D	ED		                mov     a,r5                ;neem volgende byte
 2561: 1  080E	F4		                cpl     a                   ;complementeer en tel carry erbij
 2562: 1  080F	34 00		                addc    a,#0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2563: 1  0811	FD		                mov     r5,a
 2564: 1  0812	D0 D0		magsig16acc1c:  pop     psw
 2565: 1  0814	D0 E0		                pop     acc
 2566: 1  0816	22		                ret
 2567: 1
 2568: 1			;*******************************************************************************
 2569: 1			; magsig32        (22,2us @16.777216MHz)
 2570: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2571: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2572: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2573: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2574: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2575: 1			;           (f0 en f1 zijn 1 als negatief)
 2576: 1			;
 2577: 1			; output:   r3,r2,r1,r0 = 2's complement
 2578: 1			;
 2579: 1			; vernietigt: niets
 2580: 1			;*******************************************************************************
 2581: 1  0817	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2582: 1  0819	C0 D0		               push    psw
 2583: 1  081B	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2584: 1  081E	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2585: 1  0821	80 19		               sjmp    magsig32c
 2586: 1
 2587: 1  0823	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2588: 1  0826	80 14		               sjmp    magsig32c
 2589: 1
 2590: 1  0828	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2591: 1  0829	F4		               cpl     a                 ;complementeer het dan
 2592: 1  082A	24 01		               add     a,#1             ;en tel er 1 bij
 2593: 1  082C	F8		               mov     r0,a
 2594: 1  082D	E9		               mov     a,r1             ;neem volgende byte
 2595: 1  082E	F4		               cpl     a                 ;complementeer en tel carry erbij
 2596: 1  082F	34 00		               addc    a,#0
 2597: 1  0831	F9		               mov     r1,a
 2598: 1  0832	EA		               mov     a,r2            ;neem volgende byte
 2599: 1  0833	F4		               cpl     a                ;complementeer en tel carry erbij
 2600: 1  0834	34 00		               addc    a,#0
 2601: 1  0836	FA		               mov     r2,a
 2602: 1  0837	EB		               mov     a,r3            ;neem volgende byte
 2603: 1  0838	F4		               cpl     a                ;complementeer en tel carry erbij
 2604: 1  0839	34 00		               addc    a,#0
 2605: 1  083B	FB		               mov     r3,a
 2606: 1
 2607: 1  083C	D0 D0		magsig32c:     pop     psw
 2608: 1  083E	D0 E0		               pop     acc
 2609: 1  0840	22		               ret
 2610: 1
 2611: 1
 2612: 1
 2613: 1			;*******************************************************************************
 2614: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2615: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2616: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2617: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2618: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2619: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2620: 1			;           (f0 en f1 zijn 1 als negatief)
 2621: 1			;
 2622: 1			; output:   r7,r6,r5,r4 = 2's complement
 2623: 1			;
 2624: 1			; vernietigt: niets
 2625: 1			;*******************************************************************************
 2626: 1  0841	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2627: 1  0843	C0 D0		               push    psw
 2628: 1  0845	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2629: 1  0848	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2630: 1  084B	80 19		               sjmp    magsig32acc1c
 2631: 1
 2632: 1  084D	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2633: 1  0850	80 14		               sjmp    magsig32acc1c
 2634: 1
 2635: 1  0852	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2636: 1  0853	F4		               cpl     a                 ;complementeer het dan
 2637: 1  0854	24 01		               add     a,#1             ;en tel er 1 bij
 2638: 1  0856	FC		               mov     r4,a
 2639: 1  0857	ED		               mov     a,r5             ;neem volgende byte
 2640: 1  0858	F4		               cpl     a                 ;complementeer en tel carry erbij
 2641: 1  0859	34 00		               addc    a,#0
 2642: 1  085B	FD		               mov     r5,a
 2643: 1  085C	EE		               mov     a,r6             ;neem volgende byte
 2644: 1  085D	F4		               cpl     a                 ;complementeer en tel carry erbij
 2645: 1  085E	34 00		               addc    a,#0
 2646: 1  0860	FE		               mov     r6,a
 2647: 1  0861	EF		               mov     a,r7             ;neem volgende byte
 2648: 1  0862	F4		               cpl     a                ;complementeer en tel carry erbij
 2649: 1  0863	34 00		               addc    a,#0
 2650: 1  0865	FF		               mov     r7,a
 2651: 1
 2652: 1  0866	D0 D0		magsig32acc1c: pop     psw
 2653: 1  0868	D0 E0		               pop     acc
 2654: 1  086A	22		               ret
 2655: 1
 2656: 1
 2657: 1			;*******************************************************************************
 2658: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2659: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2660: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2661: 1			; input:     r0 = 2's complement byte in acc0
 2662: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2663: 1			; output:    r0 = absolute waarde
 2664: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2665: 1			;
 2666: 1			; vernietigt: niets
 2667: 1			;*******************************************************************************
 2668: 1
 2669: 1  086B	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2670: 1  086D	C0 D0		                push    psw
 2671: 1  086F	E8		                mov     a,r0               ;neem lsb van acc0
 2672: 1  0870	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2673: 1  0873	D0 D0		                pop     psw
 2674: 1  0875	C2 D5		                clr     f0                 ;nee, positief...klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2675: 1  0877	D0 E0		                pop     acc
 2676: 1  0879	22		                ret
 2677: 1  087A	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2678: 1  087B	04		                inc     a                   ;een erbij
 2679: 1  087C	F8		                mov     r0,a               ;bewaar
 2680: 1  087D	D0 D0		                pop     psw
 2681: 1  087F	D2 D5		                setb    f0                 ;f0=1 als negatief
 2682: 1  0881	D0 E0		                pop     acc
 2683: 1  0883	22		                ret
 2684: 1
 2685: 1			;*******************************************************************************
 2686: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2687: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2688: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2689: 1			; input:     r4 = 2's complement byte in acc1
 2690: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2691: 1			; output:    r4 = absolute waarde
 2692: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2693: 1			;
 2694: 1			; vernietigt: niets
 2695: 1			;*******************************************************************************
 2696: 1
 2697: 1  0884	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2698: 1  0886	C0 D0		                push    psw
 2699: 1  0888	EC		                mov     a,r4               ;neem lsb van acc0
 2700: 1  0889	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2701: 1  088C	D0 D0		                pop     psw
 2702: 1  088E	C2 D1		                clr     f1                 ;nee, positief...klaar
 2703: 1  0890	D0 E0		                pop     acc
 2704: 1  0892	22		                ret
 2705: 1  0893	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2706: 1  0894	04		                inc     a                   ;een erbij
 2707: 1  0895	FC		                mov     r4,a               ;bewaar
 2708: 1  0896	D0 D0		                pop     psw
 2709: 1  0898	D2 D1		                setb    f1                 ;f0=1 als negatief
 2710: 1  089A	D0 E0		                pop     acc
 2711: 1  089C	22		                ret
 2712: 1
 2713: 1			;*******************************************************************************
 2714: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2715: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2716: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2717: 1			; input:     r1,r0 = 2's complement word in acc0
 2718: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2719: 1			; output:    r1,r0 = absolute waarde
 2720: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2721: 1			;
 2722: 1			; vernietigt: niets
 2723: 1			;*******************************************************************************
 2724: 1
 2725: 1  089D	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2726: 1  089F	C0 D0		                push    psw
 2727: 1  08A1	E9		                mov     a,r1               ; neem msb van acc0
 2728: 1  08A2	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2729: 1  08A5	D0 D0		                pop     psw
 2730: 1  08A7	C2 D5		                clr     f0                 ;f0=0 als positief

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2731: 1  08A9	D0 E0		                pop     acc
 2732: 1  08AB	22		                ret                        ;klaar
 2733: 1
 2734: 1  08AC	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2735: 1  08AD	F4		                cpl     a                  ;complementeren
 2736: 1  08AE	24 01		                add     a,#1               ;en een bijtellen
 2737: 1  08B0	F8		                mov     r0,a
 2738: 1  08B1	E9		                mov     a,r1
 2739: 1  08B2	F4		                cpl     a                  ;complement eer volgende byte
 2740: 1  08B3	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2741: 1  08B5	F9		                mov     r1,a
 2742: 1  08B6	D0 D0		                pop     psw
 2743: 1  08B8	D2 D5		                setb    f0                 ;f0=1 als negatief
 2744: 1  08BA	D0 E0		                pop     acc
 2745: 1  08BC	22		                ret
 2746: 1
 2747: 1
 2748: 1			;*******************************************************************************
 2749: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2750: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2751: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2752: 1			; input:     r5,r4 = 2's complement word in acc1
 2753: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2754: 1			; output:    r5,r4 = absolute waarde
 2755: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2756: 1			;
 2757: 1			; vernietigt: niets
 2758: 1			;*******************************************************************************
 2759: 1
 2760: 1  08BD	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2761: 1  08BF	C0 D0		                push    psw
 2762: 1  08C1	ED		                mov     a,r5               ;neem msb van acc1
 2763: 1  08C2	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2764: 1  08C5	D0 D0		                pop     psw
 2765: 1  08C7	C2 D1		                clr     f1                 ;f1=0 als positief
 2766: 1  08C9	D0 E0		                pop    acc
 2767: 1  08CB	22		                ret                        ;klaar
 2768: 1
 2769: 1  08CC	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2770: 1  08CD	F4		                cpl     a                   ;complementeren
 2771: 1  08CE	24 01		                add     a,#1               ;en een bijtellen
 2772: 1  08D0	FC		                mov     r4,a
 2773: 1  08D1	ED		                mov     a,r5
 2774: 1  08D2	F4		                cpl     a                  ;complementeer volgende byte
 2775: 1  08D3	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2776: 1  08D5	FD		                mov     r5,a
 2777: 1  08D6	D0 D0		                pop     psw
 2778: 1  08D8	D2 D1		                setb    f1                ;f1=1 als negatief
 2779: 1  08DA	D0 E0		                pop     acc
 2780: 1  08DC	22		                ret
 2781: 1
 2782: 1
 2783: 1			;*******************************************************************************
 2784: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2785: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2786: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2787: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2788: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2789: 1			; output:    r7,r6 = absolute waarde
 2790: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2791: 1			;
 2792: 1			; vernietigt: niets
 2793: 1			;*******************************************************************************
 2794: 1
 2795: 1  08DD	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2796: 1  08DF	C0 D0		                push    psw
 2797: 1  08E1	EF		                mov     a,r7                ; neem msb van acc1 high
 2798: 1  08E2	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2799: 1  08E5	D0 D0		                pop     psw
 2800: 1  08E7	C2 D5		                clr     f0                  ;f0=0 als positief
 2801: 1  08E9	D0 E0		                pop     acc
 2802: 1  08EB	22		                ret                         ;klaar
 2803: 1
 2804: 1  08EC	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2805: 1  08ED	F4		                cpl     a                   ;complementeren
 2806: 1  08EE	24 01		                add     a,#1               ;en een bijtellen
 2807: 1  08F0	FE		                mov     r6,a
 2808: 1  08F1	EF		                mov     a,r7
 2809: 1  08F2	F4		                cpl     a                  ;complementeer volgende byte
 2810: 1  08F3	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2811: 1  08F5	FF		                mov     r7,a
 2812: 1  08F6	D0 D0		                pop     psw
 2813: 1  08F8	D2 D5		                setb    f0                ;f0=1 als negatief
 2814: 1  08FA	D0 E0		                pop     acc
 2815: 1  08FC	22		                ret
 2816: 1
 2817: 1
 2818: 1			;*******************************************************************************
 2819: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2820: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2821: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 2822: 1			;
 2823: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2824: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2825: 1			;            (-2147483648 tot +2147483647)
 2826: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2827: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2828: 1			;
 2829: 1			; vernietigt: niets
 2830: 1			;*******************************************************************************
 2831: 1
 2832: 1  08FD	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2833: 1  08FF	C0 D0		                push    psw
 2834: 1  0901	EB		                mov     a,r3               ;neem msb van acc0
 2835: 1  0902	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2836: 1  0905	D0 D0		                pop     psw                ;nee, positief
 2837: 1  0907	C2 D5		                clr     f0
 2838: 1  0909	D0 E0		                pop     acc
 2839: 1  090B	22		                ret                        ;klaar
 2840: 1
 2841: 1  090C	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2842: 1  090D	F4		                cpl     a                  ;complementeren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2843: 1  090E	24 01		                add     a,#1               ;en een bijtellen
 2844: 1  0910	F8		                mov     r0,a
 2845: 1  0911	E9		                mov     a,r1               ;neem volgende byte
 2846: 1  0912	F4		                cpl     a                  ;complementeer volgende byte
 2847: 1  0913	34 00		                addc    a,#0
 2848: 1  0915	F9		                mov     r1,a
 2849: 1  0916	EA		                mov     a,r2               ;neem volgende byte
 2850: 1  0917	F4		                cpl     a                  ;complementeer volgende byte
 2851: 1  0918	34 00		                addc    a,#0
 2852: 1  091A	FA		                mov     r2,a
 2853: 1  091B	EB		                mov     a,r3               ;neem volgende byte
 2854: 1  091C	F4		                cpl     a                  ;complementeer volgende byte
 2855: 1  091D	34 00		                addc    a,#0
 2856: 1  091F	FB		                mov     r3,a
 2857: 1  0920	D0 D0		                pop     psw
 2858: 1  0922	D2 D5		                setb    f0                 ;negatief: f0=1
 2859: 1  0924	D0 E0		                pop     acc
 2860: 1  0926	22		                ret                        ;klaar
 2861: 1
 2862: 1			;*******************************************************************************
 2863: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2864: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2865: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2866: 1			;
 2867: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2868: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2869: 1			;            (-2147483648 tot +2147483647)
 2870: 1			; output:    r7,r6,r5,r4 = absolute waarde
 2871: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2872: 1			;
 2873: 1			; vernietigt: niets
 2874: 1			;*******************************************************************************
 2875: 1
 2876: 1  0927	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2877: 1  0929	C0 D0		                push    psw
 2878: 1  092B	EF		                mov     a,r7               ;neem msb van acc0
 2879: 1  092C	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2880: 1  092F	D0 D0		                pop     psw                ;nee, positief
 2881: 1  0931	C2 D1		                clr     f1
 2882: 1  0933	D0 E0		                pop     acc
 2883: 1  0935	22		                ret                        ;klaar
 2884: 1
 2885: 1  0936	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2886: 1  0937	F4		                cpl     a                   ;complementeren
 2887: 1  0938	24 01		                add     a,#1               ;en een bijtellen
 2888: 1  093A	FC		                mov     r4,a
 2889: 1  093B	ED		                mov     a,r5               ;neem volgende byte
 2890: 1  093C	F4		                cpl     a                  ;complementeer volgende byte
 2891: 1  093D	34 00		                addc    a,#0
 2892: 1  093F	FD		                mov     r5,a
 2893: 1  0940	EE		                mov     a,r6               ;neem volgende byte
 2894: 1  0941	F4		                cpl     a                  ;complementeer volgende byte
 2895: 1  0942	34 00		                addc    a,#0
 2896: 1  0944	FE		                mov     r6,a
 2897: 1  0945	EF		                mov     a,r7               ;neem volgende byte
 2898: 1  0946	F4		                cpl     a                  ;complementeer volgende byte

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2899: 1  0947	34 00		                addc    a,#0
 2900: 1  0949	FF		                mov     r7,a
 2901: 1  094A	D0 D0		                pop     psw
 2902: 1  094C	D2 D1		                setb    f1                 ;negatief: f0=1
 2903: 1  094E	D0 E0		                pop     acc
 2904: 1  0950	22		                ret                        ;klaar
 2905: 1
 2906: 1
 2907: 1			;*******************************************************************************
 2908: 1			; s_add16        (19,35us @16.777216MHz)
 2909: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2910: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2911: 1			; input:     r1,r0 = acc0
 2912: 1			;            r5,r4 = acc1
 2913: 1			;
 2914: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2915: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2916: 1			;                  gebruik van r3,r2 is niet nodig
 2917: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2918: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2919: 1			;
 2920: 1			; vernietigt:  niets
 2921: 1			;*******************************************************************************
 2922: 1  0951	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2923: 1  0953	C0 D0		               push    psw
 2924: 1
 2925: 1  0955	E8		               mov     a,r0           ;tel de soft accumulators op
 2926: 1  0956	2C		               add     a,r4           ;low byte eerst
 2927: 1  0957	F8		               mov     r0,a           ;resultaat bewaren
 2928: 1  0958	E9		               mov     a,r1           ;nu de high bytes
 2929: 1  0959	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2930: 1  095A	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2931: 1
 2932: 1  095B	92 D5		               mov     f0,c
 2933: 1  095D	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 2934: 1  095F	92 D1		               mov     f1,c
 2935: 1  0961	A2 D5		               mov     c,f0           ;herstel carrybit
 2936: 1
 2937: 1  0963	74 00		               mov     a,#00h
 2938: 1  0965	34 00		               addc    a,#00h
 2939: 1  0967	FA		               mov     r2,a            ;24bit resultaat klaar
 2940: 1
 2941: 1  0968	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2942: 1
 2943: 1  096B	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2944: 1  096C	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2945: 1  096F	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 2946: 1  0971	7B FF		               mov     r3,#0ffh
 2947: 1  0973	80 04		               sjmp    s_add162
 2948: 1  0975	7A 00		s_add161:      mov     r2,#00h
 2949: 1  0977	7B 00		               mov     r3,#00h
 2950: 1  0979	D0 D0		s_add162:      pop     psw
 2951: 1  097B	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2952: 1  097C	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2953: 1  097E	22		               ret
 2954: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2955: 1  097F	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2956: 1  0981	C3		               clr     c
 2957: 1  0982	D0 E0		               pop     acc
 2958: 1  0984	22		               ret
 2959: 1
 2960: 1			;*******************************************************************************
 2961: 1			; add16        (13,6us @16.777216MHz)
 2962: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2963: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2964: 1			; input:     r1,r0 = acc0
 2965: 1			;            r5,r4 = acc1
 2966: 1			;
 2967: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2968: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 2969: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2970: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 2971: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 2972: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 2973: 1			;
 2974: 1			; vernietigt:  niets
 2975: 1			;*******************************************************************************
 2976: 1
 2977: 1  0985	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 2978: 1  0987	C0 D0		               push    psw
 2979: 1  0989	E8		               mov     a,r0           ;tel de soft accumulators op
 2980: 1  098A	2C		               add     a,r4           ;low byte eerst
 2981: 1  098B	F8		               mov     r0,a           ;resultaat bewaren
 2982: 1  098C	E9		               mov     a,r1           ;nu de high bytes
 2983: 1  098D	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2984: 1  098E	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2985: 1  098F	50 08		               jnc     add161          ;geen 24 bit resultaat
 2986: 1
 2987: 1  0991	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 2988: 1  0993	D0 D0		               pop     psw
 2989: 1  0995	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2990: 1  0996	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 2991: 1  0998	22		               ret
 2992: 1
 2993: 1  0999	7A 00		add161:        mov     r2,#00h
 2994: 1  099B	D0 D0		               pop     psw
 2995: 1  099D	C3		               clr     c               ;aangeven aan de gebruiker dat het
 2996: 1  099E	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 2997: 1  09A0	22		               ret
 2998: 1
 2999: 1			;*******************************************************************************
 3000: 1			; s_add32        (28,0us @16.777216MHz)
 3001: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 3002: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3003: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3004: 1			; input:     r3,r2,r1,r0 = acc0
 3005: 1			;            r7,r6,r5,r4 = acc1
 3006: 1			;
 3007: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 3008: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3009: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 3010: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3011: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3012: 1			;
 3013: 1			; vernietigt:  niets
 3014: 1			;*******************************************************************************
 3015: 1  09A1	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 3016: 1  09A3	C0 D0		               push    psw
 3017: 1
 3018: 1  09A5	E8		               mov     a,r0           ;tel de soft accumulators op
 3019: 1  09A6	2C		               add     a,r4           ;low byte eerst
 3020: 1  09A7	F8		               mov     r0,a           ;resultaat bewaren
 3021: 1  09A8	E9		               mov     a,r1           ;nu de hogere bytes
 3022: 1  09A9	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3023: 1  09AA	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3024: 1
 3025: 1  09AB	EA		               mov     a,r2           ;derde bytes optellen
 3026: 1  09AC	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3027: 1  09AD	FA		               mov     r2,a           ;24bit resultaat is klaar
 3028: 1  09AE	EB		               mov     a,r3           ;nu de ms bytes
 3029: 1  09AF	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3030: 1  09B0	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3031: 1
 3032: 1  09B1	92 D5		               mov     f0,c
 3033: 1  09B3	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 3034: 1  09B5	92 D1		               mov     f1,c
 3035: 1  09B7	A2 D5		               mov     c,f0           ;herstel carrybit
 3036: 1
 3037: 1  09B9	74 00		               mov     a,#00h
 3038: 1  09BB	34 00		               addc    a,#00h
 3039: 1  09BD	FC		               mov     r4,a            ;40bit resultaat klaar
 3040: 1
 3041: 1  09BE	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 3042: 1  09C1	EC		               mov     a,r4            ;ja, sign extention toepassen!
 3043: 1  09C2	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 3044: 1  09C5	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3045: 1  09C7	80 02		               sjmp    s_add322
 3046: 1  09C9	7C 00		s_add321:      mov     r4,#00h
 3047: 1  09CB	D0 D0		s_add322:      pop     psw
 3048: 1  09CD	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3049: 1  09CE	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 3050: 1  09D0	22		               ret
 3051: 1
 3052: 1  09D1	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 3053: 1  09D3	C3		               clr     c
 3054: 1  09D4	D0 E0		               pop     acc
 3055: 1  09D6	22		               ret
 3056: 1
 3057: 1
 3058: 1			;*******************************************************************************
 3059: 1			; add32        (18,0us @16.777216MHz)
 3060: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 3061: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3062: 1			; input:     r3,r2,r1,r0 = acc0
 3063: 1			;            r7,r6,r5,r4 = acc1
 3064: 1			;
 3065: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 3066: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3067: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3068: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 3069: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3070: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3071: 1			;
 3072: 1			; vernietigt:  niets
 3073: 1			;*******************************************************************************
 3074: 1  09D7	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 3075: 1  09D9	C0 D0		               push    psw
 3076: 1  09DB	E8		               mov     a,r0           ;tel de soft accumulators op
 3077: 1  09DC	2C		               add     a,r4           ;low byte eerst
 3078: 1  09DD	F8		               mov     r0,a           ;resultaat bewaren
 3079: 1  09DE	E9		               mov     a,r1           ;nu de hogere bytes
 3080: 1  09DF	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3081: 1  09E0	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3082: 1
 3083: 1  09E1	EA		               mov     a,r2           ;derde bytes optellen
 3084: 1  09E2	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3085: 1  09E3	FA		               mov     r2,a           ;24bit resultaat is klaar
 3086: 1  09E4	EB		               mov     a,r3           ;nu de ms bytes
 3087: 1  09E5	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3088: 1  09E6	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3089: 1
 3090: 1  09E7	50 08		               jnc     add321          ;geen 40 bit resultaat
 3091: 1
 3092: 1  09E9	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3093: 1  09EB	D0 D0		               pop     psw
 3094: 1  09ED	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3095: 1  09EE	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3096: 1  09F0	22		               ret
 3097: 1
 3098: 1  09F1	7C 00		add321:        mov     r4,#00h
 3099: 1  09F3	D0 D0		               pop     psw
 3100: 1  09F5	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3101: 1  09F6	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3102: 1  09F8	22		               ret
 3103: 1
 3104: 1
 3105: 1			;*******************************************************************************
 3106: 1			; s_sub16        (24,4us @16.777216MHz)
 3107: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3108: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3109: 1			; input:     r1,r0 = acc0
 3110: 1			;            r5,r4 = acc1
 3111: 1			;
 3112: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3113: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3114: 1			;                  gebruik van r3,r2 is niet nodig
 3115: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3116: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3117: 1			;
 3118: 1			; vernietigt:  niets
 3119: 1			;*******************************************************************************
 3120: 1  09F9	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3121: 1  09FB	C0 D0		                push    psw
 3122: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3123: 1
 3124: 1  09FD	EC		                mov   	a,r4            ;verander het teken van acc1
 3125: 1  09FE	F4		                cpl    	a               ;door het 2's complement te nemen
 3126: 1  09FF	24 01		                add   	a,#1
 3127: 1  0A01	FC		                mov    	r4,a
 3128: 1  0A02	ED		                mov    	a,r5
 3129: 1  0A03	F4		                cpl    	a
 3130: 1  0A04	34 00		                addc	a,#0
 3131: 1  0A06	FD		                mov    	r5,a
 3132: 1			;acc0+acc1
 3133: 1  0A07	E8						mov		a,r0
 3134: 1  0A08	2C						add		a,r4
 3135: 1  0A09	F8						mov		r0,a
 3136: 1  0A0A	E9						mov		a,r1
 3137: 1  0A0B	3D						addc	a,r5
 3138: 1  0A0C	F9						mov		r1,a
 3139: 1
 3140: 1  0A0D	92 D5		                mov    f0,c
 3141: 1  0A0F	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3142: 1  0A11	92 D1		                mov    f1,c
 3143: 1  0A13	A2 D5		                mov    c,f0            ;herstel carrybit
 3144: 1
 3145: 1  0A15	74 00		                mov    a,#00h
 3146: 1  0A17	34 00		                addc   a,#00h
 3147: 1  0A19	FA		                mov    r2,a            ;24bit resultaat klaar
 3148: 1
 3149: 1  0A1A	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3150: 1  0A1D	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3151: 1  0A1E	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3152: 1  0A21	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3153: 1  0A23	7B FF		                mov    r3,#0ffh
 3154: 1  0A25	80 04		                sjmp   s_sub162
 3155: 1  0A27	7A 00		s_sub161:       mov    r2,#00h
 3156: 1  0A29	7B 00		                mov    r3,#00h
 3157: 1  0A2B	D0 D0		s_sub162:       pop    psw
 3158: 1  0A2D	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3159: 1  0A2E	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3160: 1  0A30	22		                ret
 3161: 1
 3162: 1  0A31	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3163: 1  0A33	C3		                clr    c
 3164: 1  0A34	D0 E0		                pop    acc
 3165: 1  0A36	22		                ret
 3166: 1
 3167: 1			;*******************************************************************************
 3168: 1			; sub16            (14,4us @16.777216MHz)
 3169: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3170: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3171: 1			; input:     r1,r0 = acc0
 3172: 1			;            r5,r4 = acc1
 3173: 1			;
 3174: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3175: 1			;            bij een underflow r2 op ffh zetten
 3176: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3177: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3178: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3179: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3180: 1			;
 3181: 1			; vernietigt:  niets
 3182: 1			;*******************************************************************************
 3183: 1
 3184: 1  0A37	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3185: 1  0A39	C0 D0		                push    psw
 3186: 1  0A3B	C3		                clr     c
 3187: 1  0A3C	E8		                mov     a,r0            ;tel de soft accumulators op
 3188: 1  0A3D	9C		                subb    a,r4            ;low byte eerst
 3189: 1  0A3E	F8		                mov     r0,a            ;resultaat bewaren
 3190: 1  0A3F	E9		                mov     a,r1            ;nu de high bytes
 3191: 1  0A40	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3192: 1  0A41	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3193: 1  0A42	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3194: 1
 3195: 1  0A44	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3196: 1  0A46	D0 D0		                pop     psw
 3197: 1  0A48	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3198: 1  0A49	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3199: 1  0A4B	22		                ret
 3200: 1
 3201: 1  0A4C	7A 00		sub161:         mov     r2,#00h
 3202: 1  0A4E	D0 D0		                pop     psw
 3203: 1  0A50	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3204: 1  0A51	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3205: 1  0A53	22		                ret
 3206: 1
 3207: 1			;*******************************************************************************
 3208: 1			; s_sub32        (27,2us @16.777216MHz)
 3209: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3210: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3211: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3212: 1			; input:     r3,r2,r1,r0 = acc0
 3213: 1			;            r7,r6,r5,r4 = acc1
 3214: 1			;
 3215: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3216: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3217: 1			;                  gebruik van r4 is niet nodig
 3218: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3219: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3220: 1			;
 3221: 1			; vernietigt:  niets
 3222: 1			;*******************************************************************************
 3223: 1  0A54	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3224: 1  0A56	C0 D0		                push   psw
 3225: 1
 3226: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3227: 1
 3228: 1  0A58	EC		                mov    	a,r4            ;verander het teken van acc1
 3229: 1  0A59	F4		                cpl    	a               ;door het 2's complement te nemen
 3230: 1  0A5A	24 01		                add    	a,#1
 3231: 1  0A5C	FC		                mov    	r4,a
 3232: 1  0A5D	ED		                mov    	a,r5
 3233: 1  0A5E	F4		                cpl    	a
 3234: 1  0A5F	34 00		                addc	a,#0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3235: 1  0A61	FD		                mov    	r5,a
 3236: 1  0A62	EE		                mov    	a,r6
 3237: 1  0A63	F4		                cpl    	a
 3238: 1  0A64	34 00		                addc   	a,#0
 3239: 1  0A66	FE		                mov    	r6,a
 3240: 1  0A67	EF		                mov    	a,r7
 3241: 1  0A68	F4		                cpl    	a
 3242: 1  0A69	34 00		                addc   	a,#0
 3243: 1  0A6B	FF		                mov    	r7,a
 3244: 1			;acc0+acc1
 3245: 1  0A6C	E8						mov		a,r0
 3246: 1  0A6D	2C						add		a,r4
 3247: 1  0A6E	F8						mov		r0,a
 3248: 1  0A6F	E9						mov		a,r1
 3249: 1  0A70	3D						addc	a,r5
 3250: 1  0A71	F9						mov		r1,a
 3251: 1  0A72	EA						mov		a,r2
 3252: 1  0A73	3E						addc	a,r6
 3253: 1  0A74	FA						mov		r2,a
 3254: 1  0A75	EB						mov		a,r3
 3255: 1  0A76	3F						addc	a,r7
 3256: 1  0A77	FB						mov		r3,a
 3257: 1
 3258: 1  0A78	92 D5		                mov   f0,c
 3259: 1  0A7A	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3260: 1  0A7C	92 D1		                mov   f1,c
 3261: 1  0A7E	A2 D5		                mov   c,f0            ;herstel carrybit
 3262: 1
 3263: 1  0A80	74 00		                mov   a,#00h
 3264: 1  0A82	34 00		                addc  a,#00h
 3265: 1  0A84	FC		                mov   r4,a            ;40bit resultaat klaar
 3266: 1
 3267: 1  0A85	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3268: 1
 3269: 1  0A88	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3270: 1  0A89	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3271: 1  0A8C	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3272: 1  0A8E	80 02		                sjmp   s_sub322
 3273: 1  0A90	7C 00		s_sub321:       mov   r4,#00h
 3274: 1  0A92	D0 D0		s_sub322:       pop   psw
 3275: 1  0A94	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3276: 1  0A95	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3277: 1  0A97	22		                ret
 3278: 1
 3279: 1  0A98	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3280: 1  0A9A	C3		                clr   c
 3281: 1  0A9B	D0 E0		                pop   acc
 3282: 1  0A9D	22		                ret
 3283: 1
 3284: 1
 3285: 1			;*******************************************************************************
 3286: 1			; sub32        (18,7us @16.777216MHz)
 3287: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3288: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3289: 1			; input:     r3,r2,r1,r0 = acc0
 3290: 1			;            r7,r6,r5,r4 = acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3291: 1			;
 3292: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3293: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3294: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3295: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3296: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3297: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3298: 1			;
 3299: 1			; vernietigt:  niets
 3300: 1			;*******************************************************************************
 3301: 1  0A9E	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3302: 1  0AA0	C0 D0		               push    psw
 3303: 1  0AA2	C3		               clr       c
 3304: 1  0AA3	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3305: 1  0AA4	9C		               subb    a,r4           ;low byte eerst
 3306: 1  0AA5	F8		               mov     r0,a           ;resultaat bewaren
 3307: 1  0AA6	E9		               mov     a,r1           ;nu de hogere bytes
 3308: 1  0AA7	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3309: 1  0AA8	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3310: 1
 3311: 1  0AA9	EA		               mov     a,r2           ;derde bytes optellen
 3312: 1  0AAA	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3313: 1  0AAB	FA		               mov     r2,a           ;24bit resultaat is klaar
 3314: 1  0AAC	EB		               mov     a,r3           ;nu de ms bytes
 3315: 1  0AAD	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3316: 1  0AAE	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3317: 1
 3318: 1  0AAF	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3319: 1
 3320: 1  0AB1	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3321: 1  0AB3	D0 D0		               pop     psw
 3322: 1  0AB5	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3323: 1  0AB6	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3324: 1  0AB8	22		               ret
 3325: 1
 3326: 1  0AB9	7C 00		sub321:        mov     r4,#00h
 3327: 1  0ABB	D0 D0		               pop     psw
 3328: 1  0ABD	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3329: 1  0ABE	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3330: 1  0AC0	22		               ret
 3331: 1
 3332: 1
 3333: 1
 3334: 1			;*******************************************************************************
 3335: 1			; mul16        (71,2us @16.777216MHz)
 3336: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3337: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3338: 1			; input:     r1,r0 = acc0
 3339: 1			;            r5,r4 = acc1
 3340: 1			;
 3341: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3342: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3343: 1			;
 3344: 1			; vernietigt:  niets
 3345: 1			;*******************************************************************************
 3346: 1  0AC1	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3347: 1  0AC3	C0 D0		                push    psw
 3348: 1  0AC5	C0 F0		                push    b
 3349: 1  0AC7	C0 82		                push    dpl
 3350: 1  0AC9	C0 83		                push    dph
 3351: 1
 3352: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3353: 1
 3354: 1  0ACB	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3355: 1  0ACD	89 83		                mov     dph,r1
 3356: 1  0ACF	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3357: 1  0AD1	08		                inc     r0              ;pointer naar eerste vrije plaats
 3358: 1  0AD2	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3359: 1  0AD4	E5 81		                mov     a,sp            ;plaats alloceren
 3360: 1  0AD6	24 03		                add     a,#3            ;3 bytes nodig
 3361: 1  0AD8	F5 81		                mov     sp,a            ;stackpointer verzetten
 3362: 1
 3363: 1  0ADA	E5 82		                mov     a,dpl            ;acc0 lsb
 3364: 1  0ADC	8C F0		                mov     b,r4            ;acc1 lsb
 3365: 1  0ADE	A4		                mul     ab
 3366: 1  0ADF	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3367: 1  0AE0	08		                inc     r0
 3368: 1  0AE1	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3369: 1
 3370: 1  0AE3	E5 83		                mov     a,dph            ;acc0 msb
 3371: 1  0AE5	8C F0		                mov     b,r4            ;acc1 lsb
 3372: 1  0AE7	A4		                mul     ab
 3373: 1
 3374: 1  0AE8	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3375: 1  0AE9	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3376: 1  0AEA	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3377: 1  0AEC	34 00		                addc    a,#0
 3378: 1  0AEE	08		                inc     r0               ;bewaar als tussenresultaat
 3379: 1  0AEF	F6		                mov     @r0,a
 3380: 1
 3381: 1  0AF0	E5 82		                mov     a,dpl            ;acc0 lsb
 3382: 1  0AF2	8D F0		                mov     b,r5             ;acc1 msb
 3383: 1  0AF4	A4		                mul     ab
 3384: 1  0AF5	18		                dec     r0
 3385: 1  0AF6	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3386: 1  0AF7	F6		                mov     @r0,a            ;en bewaar weer
 3387: 1  0AF8	08		                inc     r0
 3388: 1  0AF9	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3389: 1  0AFB	36		                addc    a,@r0
 3390: 1  0AFC	F6		                mov     @r0,a            ;en bewaar weer
 3391: 1  0AFD	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3392: 1
 3393: 1  0AFF	E5 83		                mov     a,dph            ;acc0 msb
 3394: 1  0B01	8D F0		                mov     b,r5             ;acc1 msb
 3395: 1  0B03	A4		                mul     AB
 3396: 1  0B04	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3397: 1  0B05	FA		                mov     r2,a
 3398: 1  0B06	E5 F0		                mov     a,b
 3399: 1  0B08	34 00		                addc    a,#0
 3400: 1
 3401: 1  0B0A	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3402: 1  0B0C	34 00		                addc    a,#0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3403: 1
 3404: 1  0B0E	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3405: 1  0B0F	18		                dec     r0
 3406: 1  0B10	86 83		                mov     dph,@r0
 3407: 1  0B12	18		                dec     r0
 3408: 1  0B13	86 82		                mov     dpl,@r0
 3409: 1
 3410: 1  0B15	89 81		                mov     sp,r1            ;zet stackpointer terug
 3411: 1  0B17	A9 83		                mov     r1,dph
 3412: 1  0B19	A8 82		                mov     r0,dpl
 3413: 1
 3414: 1  0B1B	D0 83		                pop     dph              ;herstel de bewaarde registers
 3415: 1  0B1D	D0 82		                pop     dpl
 3416: 1  0B1F	D0 F0		                pop     b
 3417: 1  0B21	D0 D0		                pop     psw
 3418: 1  0B23	D0 E0		                pop     acc
 3419: 1  0B25	22		                ret
 3420: 1
 3421: 1
 3422: 1
 3423: 1			;*******************************************************************************
 3424: 1			; mul16acc1        (71,2us @16.777216MHz)
 3425: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3426: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3427: 1			; input:     r5,r4 = acc1 low
 3428: 1			;            r7,r6 = acc1 high
 3429: 1			;
 3430: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3431: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3432: 1			;
 3433: 1			; vernietigt:  niets
 3434: 1			;*******************************************************************************
 3435: 1  0B26	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3436: 1  0B28	C0 D0		                push    psw
 3437: 1  0B2A	C0 F0		                push    b
 3438: 1  0B2C	C0 82		                push    dpl
 3439: 1  0B2E	C0 83		                push    dph
 3440: 1
 3441: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3442: 1
 3443: 1  0B30	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3444: 1  0B32	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3445: 1
 3446: 1  0B34	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3447: 1  0B36	08		                inc     r0               ;pointer naar eerste vrije plaats
 3448: 1  0B37	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3449: 1  0B39	E5 81		                mov     a,sp             ;plaats alloceren
 3450: 1  0B3B	24 03		                add     a,#3             ;3 bytes nodig
 3451: 1  0B3D	F5 81		                mov     sp,a             ;stackpointer verzetten
 3452: 1
 3453: 1  0B3F	EC		                mov     a,r4             ;acc1 low lsb
 3454: 1  0B40	8E F0		                mov     b,r6             ;acc1 high lsb
 3455: 1  0B42	A4		                mul     ab
 3456: 1  0B43	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3457: 1  0B44	08		                inc     r0
 3458: 1  0B45	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3459: 1
 3460: 1  0B47	ED		                mov     a,r5             ;acc1 low msb
 3461: 1  0B48	8E F0		                mov     b,r6             ;acc1 high lsb
 3462: 1  0B4A	A4		                mul     ab
 3463: 1
 3464: 1  0B4B	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3465: 1  0B4C	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3466: 1  0B4D	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3467: 1  0B4F	34 00		                addc    a,#0
 3468: 1  0B51	08		                inc     r0               ;bewaar als tussenresultaat
 3469: 1  0B52	F6		                mov     @r0,a
 3470: 1
 3471: 1  0B53	EC		                mov     a,r4             ;acc1 low lsb
 3472: 1  0B54	8F F0		                mov     b,r7             ;acc1 high msb
 3473: 1  0B56	A4		                mul     ab
 3474: 1  0B57	18		                dec     r0
 3475: 1  0B58	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3476: 1  0B59	F6		                mov     @r0,a            ;en bewaar weer
 3477: 1  0B5A	08		                inc     r0
 3478: 1  0B5B	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3479: 1  0B5D	36		                addc    a,@r0
 3480: 1  0B5E	F6		                mov     @r0,a            ;en bewaar weer
 3481: 1  0B5F	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3482: 1
 3483: 1  0B61	ED		                mov     a,r5             ;acc1 low msb
 3484: 1  0B62	8F F0		                mov     b,r7             ;acc1 high msb
 3485: 1  0B64	A4		                mul     AB
 3486: 1
 3487: 1  0B65	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3488: 1  0B66	FE		                mov     r6,a             ;deze byte van product is al klaar
 3489: 1  0B67	E5 F0		                mov     a,b
 3490: 1  0B69	34 00		                addc    a,#0
 3491: 1  0B6B	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3492: 1  0B6D	34 00		                addc    a,#0
 3493: 1
 3494: 1  0B6F	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3495: 1  0B70	18		                dec     r0
 3496: 1  0B71	E6		                mov     a,@r0
 3497: 1  0B72	FD		                mov     r5,a
 3498: 1  0B73	18		                dec     r0
 3499: 1  0B74	E6		                mov     a,@r0
 3500: 1  0B75	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3501: 1
 3502: 1  0B76	89 81		                mov     sp,r1            ;zet stackpointer terug
 3503: 1  0B78	A9 83		                mov     r1,dph
 3504: 1  0B7A	A8 82		                mov     r0,dpl
 3505: 1
 3506: 1  0B7C	D0 83		                pop     dph              ;herstel de bewaarde registers
 3507: 1  0B7E	D0 82		                pop     dpl
 3508: 1  0B80	D0 F0		                pop     b
 3509: 1  0B82	D0 D0		                pop     psw
 3510: 1  0B84	D0 E0		                pop     acc
 3511: 1  0B86	22		                ret
 3512: 1
 3513: 1			;*******************************************************************************
 3514: 1			; s_mul16        (121,1us @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3515: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3516: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3517: 1			; input:     r1,r0 = acc0
 3518: 1			;            r5,r4 = acc1
 3519: 1			;
 3520: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3521: 1			;                                  -1073709056 tot +1073741824
 3522: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3523: 1			;
 3524: 1			; vernietigt:  niets
 3525: 1			;*******************************************************************************
 3526: 1  0B87	12 08 9D	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3527: 1  0B8A	12 08 BD	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3528: 1  0B8D	12 0A C1	                lcall    mul16           ;maak product
 3529: 1  0B90	12 08 17	                lcall    magsig32        ;maak 2's complement formaat
 3530: 1  0B93	22		                ret                      ;klaar
 3531: 1
 3532: 1			;*******************************************************************************
 3533: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3534: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3535: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3536: 1			; input:     r5,r4 = acc1 low
 3537: 1			;            r7,r6 = acc1 high
 3538: 1			;
 3539: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3540: 1			;                                  -1073709056 tot +1073741824
 3541: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3542: 1			; vernietigt:  niets
 3543: 1			;*******************************************************************************
 3544: 1  0B94	12 08 BD	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3545: 1  0B97	12 08 DD	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3546: 1  0B9A	12 0B 26	                lcall    mul16acc1       ;maak product
 3547: 1  0B9D	12 08 41	                lcall    magsig32acc1    ;maak 2's complement formaat
 3548: 1  0BA0	22		                ret                      ;klaar
 3549: 1
 3550: 1			;*******************************************************************************
 3551: 1			; s_mul816        (83,5us @16.777216MHz)
 3552: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3553: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3554: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3555: 1			; input:     r1,r0 = acc0
 3556: 1			;               r4 = acc1
 3557: 1			;
 3558: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3559: 1			;                                  -4194176 tot +4194304
 3560: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3561: 1			; vernietigt:  niets
 3562: 1			;*******************************************************************************
 3563: 1  0BA1	12 08 9D	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3564: 1  0BA4	12 08 84	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3565: 1  0BA7	12 0B AE	                lcall    mul816          ;8bit x 16 bit product
 3566: 1  0BAA	12 08 17	                lcall    magsig32        ;abs. waarde naar 2's complement
 3567: 1  0BAD	22		                ret
 3568: 1
 3569: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3570: 1			; mul816        (29,4us @16.777216MHz)
 3571: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3572: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3573: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3574: 1			; input:     r1,r0 = acc0
 3575: 1			;               r4 = acc1
 3576: 1			;
 3577: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3578: 1			;                           0..16711425 (000000h..feff01h)
 3579: 1			;
 3580: 1			; vernietigt:  niets
 3581: 1			;*******************************************************************************
 3582: 1  0BAE	C0 E0		mul816:         push    acc             ;bewaar registers
 3583: 1  0BB0	C0 F0		                push    b
 3584: 1  0BB2	C0 D0		                push    psw
 3585: 1  0BB4	EC		                mov     a,r4            ;neem acc1
 3586: 1  0BB5	88 F0		                mov     b,r0            ;neem lsb van acc0
 3587: 1  0BB7	A4		                mul     ab              ;maak product
 3588: 1  0BB8	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3589: 1  0BB9	C0 F0		                push    b               ;bewaar lsb van het product
 3590: 1  0BBB	EC		                mov     a,r4            ;neem acc1
 3591: 1  0BBC	89 F0		                mov     b,r1            ;neem msb can acc0
 3592: 1  0BBE	A4		                mul     ab              ;maak product
 3593: 1  0BBF	AA F0		                mov     r2,b            ;bewaar msb van product even
 3594: 1  0BC1	F5 F0		                mov     b,a             ;verplaats lsb van product
 3595: 1  0BC3	D0 E0		                pop     acc             ;neem msb van vorig product
 3596: 1  0BC5	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3597: 1  0BC7	F9		                mov     r1,a            ;de middenste byte is klaar
 3598: 1  0BC8	EA		                mov     a,r2            ;tel nu de eventuele
 3599: 1  0BC9	34 00		                addc    a,#0            ;carry bij de msb
 3600: 1  0BCB	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3601: 1  0BCC	7B 00		                mov     r3,#0
 3602: 1  0BCE	D0 D0		                pop     psw
 3603: 1  0BD0	D0 F0		                pop     b
 3604: 1  0BD2	D0 E0		                pop     acc
 3605: 1  0BD4	22		                ret
 3606: 1
 3607: 1			;*******************************************************************************
 3608: 1			; s_mac16        (145,1us @16.777216MHz)
 3609: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3610: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3611: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3612: 1			; input:     r7,r6 = acc1 (high word)
 3613: 1			;            r5,r4 = acc1 (low  word)
 3614: 1			;
 3615: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3616: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3617: 1			;                          -2147483648 tot +2147483647
 3618: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3619: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3620: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3621: 1			;
 3622: 1			; vernietigt:  niets
 3623: 1			;*******************************************************************************
 3624: 1  0BD5	12 0B 94	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3625: 1  0BD8	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3626: 1  0BDA	C0 D0		                push    psw
 3627: 1  0BDC	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3628: 1  0BDD	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3629: 1  0BDE	F8		                mov     r0,a
 3630: 1  0BDF	ED		                mov     a,r5
 3631: 1  0BE0	39		                addc    a,r1
 3632: 1  0BE1	F9		                mov     r1,a
 3633: 1  0BE2	EE		                mov     a,r6
 3634: 1  0BE3	3A		                addc    a,r2
 3635: 1  0BE4	FA		                mov     r2,a
 3636: 1  0BE5	EF		                mov     a,r7
 3637: 1  0BE6	3B		                addc    a,r3
 3638: 1  0BE7	FB		                mov     r3,a
 3639: 1  0BE8	20 D2 06	                jb      ov,s_mac161
 3640: 1  0BEB	D0 D0		                pop     psw
 3641: 1  0BED	C3		                clr     c                ;ok, 32bit som binnen bereik
 3642: 1  0BEE	D0 E0		                pop     acc
 3643: 1  0BF0	22		                ret
 3644: 1  0BF1	D0 D0		s_mac161:       pop     psw
 3645: 1  0BF3	D3		                setb    c                ;fout! 32bit som buiten bereik
 3646: 1  0BF4	D0 E0		                pop     acc
 3647: 1  0BF6	22		                ret
 3648: 1
 3649: 1
 3650: 1			;*******************************************************************************
 3651: 1			; s_div8        (78us @16.777216MHz)
 3652: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3653: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3654: 1			; input:    r0 = acc0 deeltal (2's compl)
 3655: 1			;           r4 = acc1 deler   (2's compl)
 3656: 1			;
 3657: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3658: 1			;           r4 = rest (2's compl)
 3659: 1			;           cy=1 bij acc1=0 (deling door nul)
 3660: 1			;            cy=0 in andere gevallen
 3661: 1			;
 3662: 1			; vernietigt: niets
 3663: 1			;*******************************************************************************
 3664: 1  0BF7	12 08 6B	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3665: 1  0BFA	12 08 84	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3666: 1  0BFD	12 0C 09	                lcall   div8
 3667: 1  0C00	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3668: 1  0C02	12 07 A3	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3669: 1  0C05	12 07 BD	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3670: 1  0C08	22		s_div81:        ret
 3671: 1
 3672: 1			;*******************************************************************************
 3673: 1			; div8        (19,4us @16.777216MHz)
 3674: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3675: 1			; absolute waarde
 3676: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3677: 1			; input:    r0 = acc0 deeltal
 3678: 1			;           r4 = acc1 deler
 3679: 1			;
 3680: 1			; output:   r0 = quotient van deling acc0/acc1
 3681: 1			;           r4 = rest

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3682: 1			;           cy=1 bij acc1=0 (deling door nul)
 3683: 1			;            cy=0 in andere gevallen
 3684: 1			;
 3685: 1			; vernietigt: niets
 3686: 1			;*******************************************************************************
 3687: 1  0C09	C0 E0		div8:           push    acc             ;bewaar registers
 3688: 1  0C0B	C0 F0		                push    b
 3689: 1  0C0D	C0 D0		                push    psw
 3690: 1  0C0F	EC		                mov     a,r4            ;neem deler
 3691: 1  0C10	60 0F		                jz      div81           ;deling door nul?
 3692: 1  0C12	E8		                mov     a,r0            ;nee, neem deeltal
 3693: 1  0C13	8C F0		                mov     b,r4            ;en deler
 3694: 1  0C15	84		                div     ab              ;en maak deling
 3695: 1  0C16	F8		                mov     r0,a            ;bewaar quotient in acc0
 3696: 1  0C17	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3697: 1  0C19	D0 D0		                pop     psw             ;herstel registers
 3698: 1  0C1B	D0 F0		                pop     b
 3699: 1  0C1D	D0 E0		                pop     acc
 3700: 1  0C1F	C3		                clr     c                ;geen deling door nul
 3701: 1  0C20	22		                ret
 3702: 1
 3703: 1  0C21	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3704: 1  0C23	D0 F0		                pop     b
 3705: 1  0C25	D0 E0		                pop     acc
 3706: 1  0C27	D3		                setb    c
 3707: 1  0C28	22		                ret
 3708: 1
 3709: 1
 3710: 1			;*******************************************************************************
 3711: 1			; s_div16        (469,1us @16.777216MHz)
 3712: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3713: 1			; 2's Complement Format
 3714: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3715: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3716: 1			;           r5, r4 = acc1 deler   (2's compl)
 3717: 1			;
 3718: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3719: 1			;           r5, r4 = rest
 3720: 1			;           cy=1 bij acc1=0 (deling door nul)
 3721: 1			;            cy=0 in andere gevallen
 3722: 1			;
 3723: 1			; vernietigt: niets
 3724: 1			;*******************************************************************************
 3725: 1  0C29	C0 E0		s_div16:        push    acc
 3726: 1  0C2B	C0 D0		                push    psw
 3727: 1  0C2D	ED		                mov     a,r5            ;neem msb van deler
 3728: 1  0C2E	4C		                orl     a,r4            ;combineer met lsb van deler
 3729: 1  0C2F	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3730: 1  0C31	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3731: 1  0C33	D0 E0		                pop     acc
 3732: 1  0C35	D3		                setb    C               ;fout, deling door nul!
 3733: 1  0C36	22		                ret
 3734: 1
 3735: 1  0C37	12 08 9D	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3736: 1  0C3A	12 08 BD	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3737: 1  0C3D	12 0C 4C	                lcall   div16

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3738: 1  0C40	12 07 D7	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3739: 1  0C43	12 07 F7	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3740: 1  0C46	D0 D0		                pop     psw
 3741: 1  0C48	C3		                clr     C               ;delig ok
 3742: 1  0C49	D0 E0		                pop     acc
 3743: 1  0C4B	22		                ret                     ;klaar
 3744: 1
 3745: 1			;*******************************************************************************
 3746: 1			; div16            (405,1us @16.777216MHz)
 3747: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3748: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3749: 1			; input:    r1, r0 = Deeltal (acc0)
 3750: 1			;           r5, r4 = Deler   (acc1)
 3751: 1			;
 3752: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3753: 1			;           r5, r4 = rest van de deling acc0/acc1
 3754: 1			;            cy=1 bij deling door nul (acc1=0)
 3755: 1			;            cy=0 bij normale deling
 3756: 1			;
 3757: 1			; vernietigt: niets
 3758: 1			;*******************************************************************************
 3759: 1
 3760: 1  0C4C	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3761: 1  0C4E	C0 D0		                push    psw
 3762: 1			;check voor deling door nul
 3763: 1  0C50	EC		                mov     a,r4           ;neem lsb deler
 3764: 1  0C51	4D		                orl     a,r5           ;combineer met msb van deler
 3765: 1  0C52	70 06		                jnz     div160         ;niet nul, dan verder werken
 3766: 1  0C54	D0 D0		                pop     psw            ;als nul, dikke snul
 3767: 1  0C56	D3		                setb    c              ;terug met errorstatus
 3768: 1  0C57	D0 E0		                pop     acc
 3769: 1  0C59	22		                ret
 3770: 1
 3771: 1  0C5A	C0 F0		div160:         push    b              ;registers verder bewaren
 3772: 1  0C5C	EF		                mov     a,r7
 3773: 1  0C5D	C0 E0		                push    acc            ;push r7 op stack
 3774: 1  0C5F	EE		                mov     a,r6
 3775: 1  0C60	C0 E0		                push    acc            ;push r6 op stack
 3776: 1  0C62	EB		                mov     a,r3
 3777: 1  0C63	C0 E0		                push    acc            ;push r3 op stack
 3778: 1  0C65	EA		                mov     a,r2
 3779: 1  0C66	C0 E0		                push    acc            ;push r2 op stack
 3780: 1  0C68	C0 83		                push    dph
 3781: 1  0C6A	C0 82		                push    dpl
 3782: 1
 3783: 1  0C6C	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3784: 1  0C6E	7B 00		                mov     r3,#0
 3785: 1  0C70	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3786: 1  0C72	7E 00		                mov     r6,#0
 3787: 1  0C74	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3788: 1
 3789: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3790: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3791: 1			;het aantal significante bits af in de lusteller b
 3792: 1
 3793: 1  0C77	E9		                mov     a,r1            ;neem de msbyte van het deeltal

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3794: 1  0C78	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3795: 1  0C7B	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3796: 1  0C7C	E8		                mov     a,r0            ;lsb van deeltal nemen
 3797: 1  0C7D	33		                rlc     a                ;en opschuiven
 3798: 1  0C7E	F8		                mov     r0,a
 3799: 1  0C7F	E9		                mov     a,r1            ;msb van deeltal nemen
 3800: 1  0C80	33		                rlc     a
 3801: 1  0C81	F9		                mov     r1,a
 3802: 1  0C82	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3803: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3804: 1  0C85	7C 00		                mov     r4,#0
 3805: 1  0C87	7D 00		                mov     r5,#0
 3806: 1  0C89	80 2E		                sjmp    div164          ;klaar!
 3807: 1
 3808: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3809: 1
 3810: 1  0C8B	C3		div162:            clr     C            ;start met carry op nul
 3811: 1  0C8C	E8		                mov     a,r0            ;schuif deeltal naar links
 3812: 1  0C8D	33		                rlc     a
 3813: 1  0C8E	F8		                mov     r0,a
 3814: 1  0C8F	E9		                mov     a,r1
 3815: 1  0C90	33		                rlc     a
 3816: 1  0C91	F9		                mov     r1,a
 3817: 1  0C92	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3818: 1  0C93	33		                rlc     a               ;gedeeltelijke rest
 3819: 1  0C94	FE		                mov     r6,a
 3820: 1  0C95	EF		                mov     a,r7
 3821: 1  0C96	33		                rlc     a
 3822: 1  0C97	FF		                mov     r7,a
 3823: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3824: 1  0C98	EE		                mov     a,r6
 3825: 1  0C99	C3		                clr     C
 3826: 1  0C9A	9C		                subb    a,r4
 3827: 1  0C9B	F5 82		                mov     dpl,a
 3828: 1  0C9D	EF		                mov     a,r7
 3829: 1  0C9E	9D		                subb    a,r5
 3830: 1  0C9F	F5 83		                mov     dph,a
 3831: 1  0CA1	40 04		                jc      div163
 3832: 1  0CA3	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3833: 1  0CA5	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3834: 1
 3835: 1  0CA7	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3836: 1  0CA8	EA		                mov     a,r2            ;binnenschuiven
 3837: 1  0CA9	33		                rlc     a
 3838: 1  0CAA	FA		                mov     r2,a
 3839: 1  0CAB	EB		                mov     a,r3
 3840: 1  0CAC	33		                rlc     a
 3841: 1  0CAD	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 3842: 1  0CAE	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3843: 1
 3844: 1  0CB1	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3845: 1  0CB2	F9		                mov     r1,a
 3846: 1  0CB3	EA		                mov     a,r2
 3847: 1  0CB4	F8		                mov     r0,a
 3848: 1  0CB5	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3849: 1  0CB6	FD		                mov     r5,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3850: 1  0CB7	EE		                mov     a,r6
 3851: 1  0CB8	FC		                mov     r4,a
 3852: 1
 3853: 1  0CB9	D0 82		div164:         pop     dpl             ;registers herstellen
 3854: 1  0CBB	D0 83		                pop     dph
 3855: 1  0CBD	D0 E0		                pop     acc
 3856: 1  0CBF	FA		                mov     r2,a            ;r2 van stack halen
 3857: 1  0CC0	D0 E0		                pop     acc
 3858: 1  0CC2	FB		                mov     r3,a            ;r3 van stack halen
 3859: 1  0CC3	D0 E0		                pop     acc
 3860: 1  0CC5	FE		                mov     r6,a            ;r6 van stack halen
 3861: 1  0CC6	D0 E0		                pop     acc
 3862: 1  0CC8	FF		                mov     r7,a            ;r7 van stack halen
 3863: 1  0CC9	D0 F0		                pop     b
 3864: 1  0CCB	D0 D0		                pop     psw
 3865: 1  0CCD	C3		                clr     c               ;deling ok
 3866: 1  0CCE	D0 E0		                pop     acc
 3867: 1  0CD0	22		                ret
 3868: 1
 3869: 1
 3870: 1			;*******************************************************************************
 3871: 1			; s_div32        (2,15ms @16.777216MHz)
 3872: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3873: 1			; 2's Complement Format
 3874: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3875: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3876: 1			;
 3877: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 3878: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3879: 1			;
 3880: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3881: 1			;           r7,r6,r5, r4 = rest
 3882: 1			;           cy=1 bij acc1=0 (deling door nul)
 3883: 1			;            cy=0 in andere gevallen
 3884: 1			;
 3885: 1			; vernietigt: niets
 3886: 1			;*******************************************************************************
 3887: 1  0CD1	C0 E0		s_div32:        push    acc
 3888: 1  0CD3	C0 D0		                push    psw
 3889: 1  0CD5	EF		                mov     a,r7            ;neem msb van deler
 3890: 1  0CD6	4E		                orl     a,r6            ;combineer met lsb's van deler
 3891: 1  0CD7	4D		                orl     a,r5
 3892: 1  0CD8	4C		                orl     a,r4
 3893: 1  0CD9	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3894: 1  0CDB	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3895: 1  0CDD	D0 E0		                pop     acc
 3896: 1  0CDF	D3		                setb    C                ;fout, deling door nul!
 3897: 1  0CE0	22		                ret
 3898: 1
 3899: 1  0CE1	12 08 FD	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3900: 1  0CE4	12 09 27	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3901: 1  0CE7	12 0C F6	                lcall   div32            ;deel 32bit/32bit
 3902: 1  0CEA	12 08 17	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3903: 1  0CED	12 08 41	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3904: 1  0CF0	D0 D0		                pop     psw
 3905: 1  0CF2	C3		                clr     C                ;delig ok

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3906: 1  0CF3	D0 E0		                pop     acc
 3907: 1  0CF5	22		                ret                        ;klaar
 3908: 1
 3909: 1
 3910: 1			;*******************************************************************************
 3911: 1			; div32        (2,09ms @16.777216MHz)
 3912: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3913: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3914: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3915: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3916: 1			;
 3917: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 3918: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3919: 1			;            cy=1 bij deling door nul (acc1=0)
 3920: 1			;            cy=0 bij normale deling
 3921: 1			;
 3922: 1			; vernietigt: niets
 3923: 1			;*******************************************************************************
 3924: 1  0CF6	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3925: 1  0CF8	C0 D0		                push    psw
 3926: 1			;check voor deling door nul
 3927: 1  0CFA	EF		                mov     a,r7            ;neem msb van deler
 3928: 1  0CFB	4E		                orl     a,r6            ;combineer met lsb's van deler
 3929: 1  0CFC	4D		                orl     a,r5
 3930: 1  0CFD	4C		                orl     a,r4
 3931: 1  0CFE	70 06		                jnz     div320          ;niet nul, dan verder werken
 3932: 1  0D00	D0 D0		                pop     psw             ;als nul, dikke snul
 3933: 1  0D02	D3		                setb    c               ;terug met errorstatus
 3934: 1  0D03	D0 E0		                pop     acc
 3935: 1  0D05	22		                ret
 3936: 1
 3937: 1  0D06	C0 F0		div320:         push    b                ;registers verder bewaren
 3938: 1  0D08	C0 83		                push    dph
 3939: 1  0D0A	C0 82		                push    dpl
 3940: 1
 3941: 1  0D0C	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3942: 1
 3943: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3944: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3945: 1			;het aantal significante bits af in de lusteller b
 3946: 1
 3947: 1  0D0F	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3948: 1  0D10	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3949: 1  0D13	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3950: 1  0D14	E8		                mov     a,r0            ;lsb van deeltal nemen
 3951: 1  0D15	33		                rlc     a               ;en opschuiven
 3952: 1  0D16	F8		                mov     r0,a
 3953: 1  0D17	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 3954: 1  0D18	33		                rlc     a
 3955: 1  0D19	F9		                mov     r1,a
 3956: 1  0D1A	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3957: 1  0D1B	33		                rlc     a
 3958: 1  0D1C	FA		                mov     r2,a
 3959: 1  0D1D	EB		                mov     a,r3           ;lsb van deeltal nemen
 3960: 1  0D1E	33		                rlc     a
 3961: 1  0D1F	FB		                mov     r3,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3962: 1  0D20	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3963: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3964: 1  0D23	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3965: 1  0D25	7E 00		                mov     r6,#0
 3966: 1  0D27	7D 00		                mov     r5,#0
 3967: 1  0D29	7C 00		                mov     r4,#0
 3968: 1  0D2B	02 0D F4	                ljmp    div324           ;klaar!
 3969: 1
 3970: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 3971: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 3972: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 3973: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 3974: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 3975: 1
 3976: 1  0D2E			div320b:
 3977: 1  0D2E	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 3978: 1
 3979: 1  0D31	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 3980: 1  0D33	24 0C		                add     a,#12           ;met 12 plaatsen
 3981: 1  0D35	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 3982: 1
 3983: 1  0D37	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 3984: 1  0D38	C0 E0		                push    acc
 3985: 1  0D3A	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 3986: 1  0D3B	C0 E0		                push    acc
 3987: 1
 3988: 1  0D3D	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 3989: 1  0D3F	08		                inc     r0              ;de deler
 3990: 1  0D40	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 3991: 1  0D42	24 05		                add     a,#5            ;het tijdelijk verschil X
 3992: 1  0D44	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 3993: 1  0D45	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 3994: 1  0D47	24 09		                add     a,#9            ;quotient
 3995: 1  0D49	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 3996: 1
 3997: 1			;Eenmalig de variabelen op stack initaliseren
 3998: 1			;Tijdelijk quotient op nul zetten
 3999: 1
 4000: 1  0D4B	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 4001: 1  0D4D	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 4002: 1  0D4E	C0 F0		                push    b                ;loopteller deling bewaren
 4003: 1  0D50	75 F0 04	                mov     b,#4
 4004: 1  0D53	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 4005: 1  0D55	09		                inc     r1
 4006: 1  0D56	D5 F0 FA	                djnz    b,div320c
 4007: 1  0D59	D0 F0		                pop     b                ;loopteller deling ophalen
 4008: 1  0D5B	19		                dec     r1
 4009: 1  0D5C	19		                dec     r1
 4010: 1  0D5D	19		                dec     r1
 4011: 1  0D5E	19		                dec     r1               ;pointer weer op startadres quotient
 4012: 1  0D5F	C9		                xch     a,r1             ;weer omwisselen
 4013: 1  0D60	C5 82		                xch     a,dpl
 4014: 1
 4015: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 4016: 1  0D62	EC		                mov     a,r4
 4017: 1  0D63	F6		                mov     @r0,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4018: 1  0D64	08		                inc     r0
 4019: 1  0D65	ED		                mov     a,r5
 4020: 1  0D66	F6		                mov     @r0,a
 4021: 1  0D67	08		                inc     r0
 4022: 1  0D68	EE		                mov     a,r6
 4023: 1  0D69	F6		                mov     @r0,a
 4024: 1  0D6A	08		                inc     r0
 4025: 1  0D6B	EF		                mov     a,r7
 4026: 1  0D6C	F6		                mov     @r0,a
 4027: 1  0D6D	18		                dec     r0             ;pointer herstellen naar lsb van deler
 4028: 1  0D6E	18		                dec     r0
 4029: 1  0D6F	18		                dec     r0
 4030: 1
 4031: 1  0D70	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 4032: 1  0D72	7E 00		                mov     r6,#0
 4033: 1  0D74	7D 00		                mov     r5,#0
 4034: 1  0D76	7C 00		                mov     r4,#0
 4035: 1
 4036: 1
 4037: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 4038: 1  0D78	C3		div322:         clr     C               ;start met carry op nul
 4039: 1
 4040: 1  0D79	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 4041: 1  0D7B	33		                rlc     a
 4042: 1  0D7C	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 4043: 1  0D7E	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 4044: 1  0D80	D0 E0		                pop     acc             ;r1 van deeltal van stack
 4045: 1  0D82	33		                rlc     a
 4046: 1  0D83	C0 E0		                push    acc             ;en weer bewaren
 4047: 1  0D85	05 81		                inc     sp              ;stackpointer weer corrigeren
 4048: 1
 4049: 1  0D87	EA		                mov     a,r2
 4050: 1  0D88	33		                rlc     a
 4051: 1  0D89	FA		                mov     r2,a
 4052: 1  0D8A	EB		                mov     a,r3
 4053: 1  0D8B	33		                rlc     a
 4054: 1  0D8C	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 4055: 1
 4056: 1  0D8D	EC		                mov     a,r4            ;schuif carry van deeltal in de
 4057: 1  0D8E	33		                rlc     a               ;gedeeltelijke rest r7..r4
 4058: 1  0D8F	FC		                mov     r4,a
 4059: 1  0D90	ED		                mov     a,r5
 4060: 1  0D91	33		                rlc     a
 4061: 1  0D92	FD		                mov     r5,a
 4062: 1  0D93	EE		                mov     a,r6
 4063: 1  0D94	33		                rlc     a
 4064: 1  0D95	FE		                mov     r6,a
 4065: 1  0D96	EF		                mov     a,r7
 4066: 1  0D97	33		                rlc     a
 4067: 1  0D98	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 4068: 1
 4069: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 4070: 1
 4071: 1  0D99	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 4072: 1  0D9A	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 4073: 1  0D9B	96		                subb    a,@r0           ;trek er de lsb deler af

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4074: 1  0D9C	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4075: 1  0D9D	08		                inc     r0              ;pointers aanpassen
 4076: 1  0D9E	09		                inc     r1
 4077: 1  0D9F	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4078: 1  0DA0	96		                subb    a,@r0           ;trek er volgende byte deler af
 4079: 1  0DA1	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4080: 1  0DA2	08		                inc     r0              ;pointers aanpassen
 4081: 1  0DA3	09		                inc     r1
 4082: 1  0DA4	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4083: 1  0DA5	96		                subb    a,@r0           ;trek er volgende byte deler af
 4084: 1  0DA6	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4085: 1  0DA7	08		                inc     r0              ;pointers aanpassen
 4086: 1  0DA8	09		                inc     r1
 4087: 1  0DA9	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4088: 1  0DAA	96		                subb    a,@r0           ;trek er msb deler af
 4089: 1  0DAB	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4090: 1  0DAC	18		                dec     r0              ;pointers herstellen naar lsb's
 4091: 1  0DAD	18		                dec     r0
 4092: 1  0DAE	18		                dec     r0
 4093: 1  0DAF	19		                dec     r1
 4094: 1  0DB0	19		                dec     r1
 4095: 1  0DB1	19		                dec     r1
 4096: 1
 4097: 1  0DB2	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4098: 1  0DB4	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4099: 1  0DB5	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4100: 1  0DB6	09		                inc     r1
 4101: 1  0DB7	E7		                mov     a,@r1
 4102: 1  0DB8	FD		                mov     r5,a
 4103: 1  0DB9	09		                inc     r1
 4104: 1  0DBA	E7		                mov     a,@r1
 4105: 1  0DBB	FE		                mov     r6,a
 4106: 1  0DBC	09		                inc     r1
 4107: 1  0DBD	E7		                mov     a,@r1
 4108: 1  0DBE	FF		                mov     r7,a
 4109: 1  0DBF	19		                dec     r1              ;met pointer weer naar lsb van
 4110: 1  0DC0	19		                dec     r1              ;het tijdelijk verschil wijzen
 4111: 1  0DC1	19		                dec     r1
 4112: 1
 4113: 1
 4114: 1  0DC2	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4115: 1  0DC3	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4116: 1  0DC5	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4117: 1  0DC6	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4118: 1  0DC8	E7		                mov     a,@r1           ;neem lsb van qoutient
 4119: 1  0DC9	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4120: 1  0DCA	F7		                mov     @r1,a
 4121: 1  0DCB	09		                inc     r1              ;volgende byte
 4122: 1  0DCC	E7		                mov     a,@r1
 4123: 1  0DCD	33		                rlc     a
 4124: 1  0DCE	F7		                mov     @r1,a
 4125: 1  0DCF	09		                inc     r1              ;volgende byte
 4126: 1  0DD0	E7		                mov     a,@r1
 4127: 1  0DD1	33		                rlc     a
 4128: 1  0DD2	F7		                mov     @r1,a
 4129: 1  0DD3	09		                inc     r1              ;volgende byte

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4130: 1  0DD4	E7		                mov     a,@r1
 4131: 1  0DD5	33		                rlc     a
 4132: 1  0DD6	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4133: 1  0DD7	19		                dec     r1
 4134: 1  0DD8	19		                dec     r1
 4135: 1  0DD9	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4136: 1  0DDA	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4137: 1  0DDC	C9		                xch     a,r1            ;r1=pointer naar verschil
 4138: 1  0DDD	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4139: 1
 4140: 1  0DDF	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4141: 1
 4142: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4143: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4144: 1
 4145: 1  0DE2	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4146: 1  0DE4	18		                dec     r0
 4147: 1  0DE5	18		                dec     r0
 4148: 1  0DE6	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4149: 1  0DE7	FB		                mov     r3,a            ;en verplaatsen
 4150: 1  0DE8	18		                dec     r0              ;volgende byte
 4151: 1  0DE9	E6		                mov     a,@r0
 4152: 1  0DEA	FA		                mov     r2,a
 4153: 1  0DEB	18		                dec     r0              ;volgende byte
 4154: 1  0DEC	E6		                mov     a,@r0
 4155: 1  0DED	F9		                mov     r1,a
 4156: 1  0DEE	18		                dec     r0              ;volgende byte
 4157: 1  0DEF	E6		                mov     a,@r0
 4158: 1  0DF0	F8		                mov     r0,a            ;laatste byte verplaatst!
 4159: 1
 4160: 1  0DF1	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4161: 1			                                         ;weer vrijgeven
 4162: 1
 4163: 1
 4164: 1  0DF4	D0 82		div324:         pop     dpl             ;registers herstellen
 4165: 1  0DF6	D0 83		                pop     dph
 4166: 1  0DF8	D0 F0		                pop     b
 4167: 1  0DFA	D0 D0		                pop     psw
 4168: 1  0DFC	C3		                clr     c               ;normale deling
 4169: 1  0DFD	D0 E0		                pop     acc
 4170: 1  0DFF	22		                ret
 4171: 1
 4172: 1			;*******************************************************************************
 4173: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4174: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4175: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4176: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4177: 1			;
 4178: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4179: 1			;
 4180: 1			; input:     r5,r4 = acc1 (low word product)
 4181: 1			;            r7,r6 = acc1 (high word product)
 4182: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4183: 1			;
 4184: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4185: 1			;            r7,r6,r5,r4 = acc1 = rest

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4186: 1			;                          -2147483648 tot +2147483647
 4187: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4188: 1			;             cy=1 bij deling door nul (acc0=0)
 4189: 1			;             cy=0 bij normale deling
 4190: 1			;
 4191: 1			; vernietigt:  niets
 4192: 1			;*******************************************************************************
 4193: 1  0E00	C0 E0		s_muldiv:       push    acc
 4194: 1  0E02	C0 D0		                push    psw
 4195: 1  0E04	E8		                mov     a,r0            ;neem msb van deler
 4196: 1  0E05	49		                orl     a,r1            ;combineer met lsb's van deler
 4197: 1  0E06	4A		                orl     a,r2
 4198: 1  0E07	4B		                orl     a,r3
 4199: 1  0E08	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4200: 1  0E0A	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4201: 1  0E0C	D0 E0		                pop     acc
 4202: 1  0E0E	D3		                setb    C               ;fout, deling door nul!
 4203: 1  0E0F	22		                ret
 4204: 1
 4205: 1  0E10	12 08 BD	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4206: 1  0E13	12 08 DD	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4207: 1  0E16	12 0E 25	                lcall    muldiv          ;maak product en daarna de deling
 4208: 1  0E19	12 08 17	                lcall    magsig32        ;quotient naar 2's complement
 4209: 1  0E1C	12 08 41	                lcall    magsig32acc1    ;rest naar 2's complement
 4210: 1  0E1F	D0 D0		                pop     psw
 4211: 1  0E21	C3		                clr     c                ;deling is ok
 4212: 1  0E22	D0 E0		                pop    acc
 4213: 1  0E24	22		                ret
 4214: 1
 4215: 1			;*******************************************************************************
 4216: 1			; muldiv        (2,0ms @16.777216MHz)
 4217: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4218: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4219: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4220: 1			; 32bit rest in acc1.
 4221: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4222: 1			;
 4223: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4224: 1			;
 4225: 1			; input:     r5,r4 = acc1 (low word product)
 4226: 1			;            r7,r6 = acc1 (high word product)
 4227: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4228: 1			;
 4229: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4230: 1			;            r7,r6,r5,r4 = acc1 = rest
 4231: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4232: 1			;             cy=1 bij deling door nul (acc0=0)
 4233: 1			;             cy=0 bij normale deling
 4234: 1			;
 4235: 1			; vernietigt:  niets
 4236: 1			;*******************************************************************************
 4237: 1  0E25	C0 E0		muldiv:         push    acc
 4238: 1  0E27	C0 D0		                push    psw
 4239: 1  0E29	E8		                mov     a,r0            ;neem msb van deler
 4240: 1  0E2A	49		                orl     a,r1            ;combineer met lsb's van deler
 4241: 1  0E2B	4A		                orl     a,r2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4242: 1  0E2C	4B		                orl     a,r3
 4243: 1  0E2D	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4244: 1  0E2F	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4245: 1  0E31	D0 E0		                pop     acc
 4246: 1  0E33	D3		                setb    C               ;fout, deling door nul!
 4247: 1  0E34	22		                ret
 4248: 1
 4249: 1  0E35	12 0B 26	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4250: 1  0E38	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4251: 1  0E39	C0 E0		                push    acc
 4252: 1  0E3B	ED		                mov     a,r5
 4253: 1  0E3C	C0 E0		                push    acc
 4254: 1  0E3E	EE		                mov     a,r6
 4255: 1  0E3F	C0 E0		                push    acc
 4256: 1  0E41	EF		                mov     a,r7
 4257: 1  0E42	C0 E0		                push    acc             ;product staat nu op stack
 4258: 1
 4259: 1  0E44	E8		                mov     a,r0            ;deler in acc1 stoppen
 4260: 1  0E45	FC		                mov     r4,a
 4261: 1  0E46	E9		                mov     a,r1
 4262: 1  0E47	FD		                mov     r5,a
 4263: 1  0E48	EA		                mov     a,r2
 4264: 1  0E49	FE		                mov     r6,a
 4265: 1  0E4A	EB		                mov     a,r3
 4266: 1  0E4B	FF		                mov     r7,a            ;deler zit volledig in acc1
 4267: 1
 4268: 1  0E4C	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4269: 1  0E4E	FB		                mov     r3,a
 4270: 1  0E4F	D0 E0		                pop     acc
 4271: 1  0E51	FA		                mov     r2,a
 4272: 1  0E52	D0 E0		                pop     acc
 4273: 1  0E54	F9		                mov     r1,a
 4274: 1  0E55	D0 E0		                pop     acc
 4275: 1  0E57	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4276: 1  0E58	12 0C F6	                lcall   div32           ;maak deling
 4277: 1
 4278: 1  0E5B	D0 D0		                pop     psw            ;herstel registers
 4279: 1  0E5D	D0 E0		                pop     acc
 4280: 1  0E5F	C3		                clr     C              ;resultaat ok!
 4281: 1  0E60	22		                ret
 4282: 1
 4283: 1			;*******************************************************************************
 4284: 1			; mul16_pi        (257,1us @16.777216MHz)
 4285: 1			; acc0 = acc0 x pi
 4286: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4287: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4288: 1			;
 4289: 1			; input:     r1,r0 = acc0 (low word)
 4290: 1			;
 4291: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4292: 1			;
 4293: 1			; vernietigt:  niets
 4294: 1			;*******************************************************************************
 4295: 1  0E61	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4296: 1  0E63	C0 D0		                push    psw
 4297: 1  0E65	EC		                mov     a,r4

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4298: 1  0E66	C0 E0		                push    acc
 4299: 1  0E68	ED		                mov     a,r5
 4300: 1  0E69	C0 E0		                push    acc
 4301: 1  0E6B	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4302: 1  0E6D	7C 0F		                mov     r4,#0fH
 4303: 1  0E6F	12 0A C1	                lcall   mul16           ;acc0 = acc0 x acc1
 4304: 1  0E72	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4305: 1  0E74	12 10 5D	                lcall   shiftright32    ;om te delen door 2^14
 4306: 1  0E77	D0 E0		                pop     acc
 4307: 1  0E79	FD		                mov     r5,a
 4308: 1  0E7A	D0 E0		                pop     acc
 4309: 1  0E7C	FC		                mov     r4,a
 4310: 1  0E7D	D0 D0		                pop     psw
 4311: 1  0E7F	D0 E0		                pop     acc
 4312: 1  0E81	22		                ret
 4313: 1
 4314: 1			;*******************************************************************************
 4315: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4316: 1			; acc0 = acc0 x 1/pi
 4317: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4318: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4319: 1			;
 4320: 1			; input:     r1,r0 = acc0 (low word)
 4321: 1			;
 4322: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4323: 1			;
 4324: 1			; vernietigt:  niets
 4325: 1			;*******************************************************************************
 4326: 1  0E82	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4327: 1  0E84	C0 D0		                push    psw
 4328: 1  0E86	EC		                mov     a,r4
 4329: 1  0E87	C0 E0		                push    acc
 4330: 1  0E89	ED		                mov     a,r5
 4331: 1  0E8A	C0 E0		                push    acc
 4332: 1  0E8C	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4333: 1  0E8E	7C 7D		                mov     r4,#07dH
 4334: 1  0E90	12 0A C1	                lcall    mul16          ;acc0 = acc0 x acc1
 4335: 1  0E93	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4336: 1  0E95	12 10 5D	                lcall   shiftright32    ;om te delen door 2^16
 4337: 1  0E98	D0 E0		                pop     acc
 4338: 1  0E9A	FD		                mov     r5,a
 4339: 1  0E9B	D0 E0		                pop     acc
 4340: 1  0E9D	FC		                mov     r4,a
 4341: 1  0E9E	D0 D0		                pop     psw
 4342: 1  0EA0	D0 E0		                pop     acc
 4343: 1  0EA2	22		                ret
 4344: 1
 4345: 1			;*******************************************************************************
 4346: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4347: 1			; acc0 = acc0 x sqrt2
 4348: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4349: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4350: 1			;
 4351: 1			; input:     r1,r0 = acc0 (low word)
 4352: 1			;
 4353: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4354: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4355: 1			;
 4356: 1			; vernietigt:  niets
 4357: 1			;*******************************************************************************
 4358: 1  0EA3	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4359: 1  0EA5	C0 D0		                push    psw
 4360: 1  0EA7	EC		                mov     a,r4
 4361: 1  0EA8	C0 E0		                push    acc
 4362: 1  0EAA	ED		                mov     a,r5
 4363: 1  0EAB	C0 E0		                push    acc
 4364: 1  0EAD	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4365: 1  0EAF	7C 05		                mov     r4,#005H
 4366: 1  0EB1	12 0A C1	                lcall   mul16           ;acc0 = acc0 x acc1
 4367: 1  0EB4	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4368: 1  0EB6	12 10 5D	                lcall   shiftright32    ;om te delen door 2^15
 4369: 1  0EB9	D0 E0		                pop     acc
 4370: 1  0EBB	FD		                mov     r5,a
 4371: 1  0EBC	D0 E0		                pop     acc
 4372: 1  0EBE	FC		                mov     r4,a
 4373: 1  0EBF	D0 D0		                pop     psw
 4374: 1  0EC1	D0 E0		                pop     acc
 4375: 1  0EC3	22		                ret
 4376: 1
 4377: 1
 4378: 1
 4379: 1			;*******************************************************************************
 4380: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4381: 1			; acc0 = acc0 x 1/sqrt2
 4382: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4383: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4384: 1			;
 4385: 1			; input:     r1,r0 = acc0 (low word)
 4386: 1			;
 4387: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4388: 1			;
 4389: 1			; vernietigt:  niets
 4390: 1			;*******************************************************************************
 4391: 1  0EC4	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4392: 1  0EC6	C0 D0		                push    psw
 4393: 1  0EC8	EC		                mov     a,r4
 4394: 1  0EC9	C0 E0		                push    acc
 4395: 1  0ECB	ED		                mov     a,r5
 4396: 1  0ECC	C0 E0		                push    acc
 4397: 1  0ECE	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4398: 1  0ED0	7C 05		                mov     r4,#005H
 4399: 1  0ED2	12 0A C1	                lcall   mul16           ;acc0 = acc0 x acc1
 4400: 1  0ED5	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4401: 1  0ED7	12 10 5D	                lcall   shiftright32    ;om te delen door 2^16
 4402: 1  0EDA	D0 E0		                pop     acc
 4403: 1  0EDC	FD		                mov     r5,a
 4404: 1  0EDD	D0 E0		                pop     acc
 4405: 1  0EDF	FC		                mov     r4,a
 4406: 1  0EE0	D0 D0		                pop     psw
 4407: 1  0EE2	D0 E0		                pop     acc
 4408: 1  0EE4	22		                ret
 4409: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4410: 1			;*******************************************************************************
 4411: 1			; mul16_10        (98,7us @16.777216MHz)
 4412: 1			; acc0 = acc0 x 10
 4413: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4414: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4415: 1			;
 4416: 1			; input:     r1,r0 = acc0 (low word)
 4417: 1			;
 4418: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4419: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4420: 1			; vernietigt:  niets
 4421: 1			;*******************************************************************************
 4422: 1  0EE5	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4423: 1  0EE7	C0 D0		                push    psw
 4424: 1  0EE9	EC		                mov     a,r4
 4425: 1  0EEA	C0 E0		                push    acc
 4426: 1  0EEC	7C 01		                mov     r4,#1           ;acc0 x2
 4427: 1  0EEE	12 10 89	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4428: 1  0EF1	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4429: 1  0EF2	C0 E0		                push    acc
 4430: 1  0EF4	EA		                mov     a,r2
 4431: 1  0EF5	C0 E0		                push    acc
 4432: 1  0EF7	E9		                mov     a,r1
 4433: 1  0EF8	C0 E0		                push    acc
 4434: 1  0EFA	E8		                mov     a,r0
 4435: 1  0EFB	C0 E0		                push    acc             ;acc0 op stack
 4436: 1  0EFD	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4437: 1  0EFF	12 10 89	                lcall   shiftleft32     ;acc0 =acc0 x4
 4438: 1  0F02	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4439: 1  0F04	28		                add     a,r0            ;tel bij huidige acc0
 4440: 1  0F05	F8		                mov     r0,a
 4441: 1  0F06	D0 E0		                pop     acc
 4442: 1  0F08	39		                addc    a,r1
 4443: 1  0F09	F9		                mov     r1,a
 4444: 1  0F0A	D0 E0		                pop     acc
 4445: 1  0F0C	3A		                addc    a,r2
 4446: 1  0F0D	FA		                mov     r2,a
 4447: 1  0F0E	D0 E0		                pop     acc
 4448: 1  0F10	3B		                addc    a,r3
 4449: 1  0F11	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4450: 1
 4451: 1
 4452: 1  0F12	D0 E0		                pop     acc
 4453: 1  0F14	FC		                mov     r4,a
 4454: 1  0F15	D0 D0		                pop     psw
 4455: 1  0F17	D0 E0		                pop     acc
 4456: 1  0F19	22		                ret
 4457: 1
 4458: 1			;*******************************************************************************
 4459: 1			; mul16_100        (169,1us @16.777216MHz)
 4460: 1			; acc0 = acc0 x 100
 4461: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4462: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4463: 1			;
 4464: 1			; input:     r1,r0 = acc0 (low word)
 4465: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4466: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4467: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4468: 1			; vernietigt:  niets
 4469: 1			;*******************************************************************************
 4470: 1  0F1A	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4471: 1  0F1C	C0 D0		                push    psw
 4472: 1  0F1E	EC		                mov     a,r4
 4473: 1  0F1F	C0 E0		                push    acc
 4474: 1  0F21	7C 02		                mov     r4,#2           ;acc0 x4
 4475: 1  0F23	12 10 89	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4476: 1  0F26	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4477: 1  0F27	C0 E0		                push    acc
 4478: 1  0F29	EA		                mov     a,r2
 4479: 1  0F2A	C0 E0		                push    acc
 4480: 1  0F2C	E9		                mov     a,r1
 4481: 1  0F2D	C0 E0		                push    acc
 4482: 1  0F2F	E8		                mov     a,r0
 4483: 1  0F30	C0 E0		                push    acc             ;acc0 op stack
 4484: 1
 4485: 1  0F32	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4486: 1  0F34	12 10 89	                lcall   shiftleft32     ;acc0 =acc0 x8
 4487: 1  0F37	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4488: 1  0F38	C0 E0		                push    acc
 4489: 1  0F3A	EA		                mov     a,r2
 4490: 1  0F3B	C0 E0		                push    acc
 4491: 1  0F3D	E9		                mov     a,r1
 4492: 1  0F3E	C0 E0		                push    acc
 4493: 1  0F40	E8		                mov     a,r0
 4494: 1  0F41	C0 E0		                push    acc             ;acc0 op stack
 4495: 1
 4496: 1  0F43	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4497: 1  0F45	12 10 89	                lcall   shiftleft32     ;acc0 =acc0 x2
 4498: 1  0F48	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4499: 1  0F4A	28		                add     a,r0            ;tel bij huidige acc0
 4500: 1  0F4B	F8		                mov     r0,a
 4501: 1  0F4C	D0 E0		                pop     acc
 4502: 1  0F4E	39		                addc    a,r1
 4503: 1  0F4F	F9		                mov     r1,a
 4504: 1  0F50	D0 E0		                pop     acc
 4505: 1  0F52	3A		                addc    a,r2
 4506: 1  0F53	FA		                mov     r2,a
 4507: 1  0F54	D0 E0		                pop     acc
 4508: 1  0F56	3B		                addc    a,r3
 4509: 1  0F57	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4510: 1
 4511: 1  0F58	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4512: 1  0F5A	28		                add     a,r0            ;tel bij huidige acc0
 4513: 1  0F5B	F8		                mov     r0,a
 4514: 1  0F5C	D0 E0		                pop     acc
 4515: 1  0F5E	39		                addc    a,r1
 4516: 1  0F5F	F9		                mov     r1,a
 4517: 1  0F60	D0 E0		                pop     acc
 4518: 1  0F62	3A		                addc    a,r2
 4519: 1  0F63	FA		                mov     r2,a
 4520: 1  0F64	D0 E0		                pop     acc
 4521: 1  0F66	3B		                addc    a,r3

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4522: 1  0F67	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4523: 1
 4524: 1  0F68	D0 E0		                pop     acc
 4525: 1  0F6A	FC		                mov     r4,a
 4526: 1  0F6B	D0 D0		                pop     psw
 4527: 1  0F6D	D0 E0		                pop     acc
 4528: 1  0F6F	22		                ret
 4529: 1
 4530: 1			;*******************************************************************************
 4531: 1			; sqrt32        (2,99ms @16.777216MHz)
 4532: 1			; acc0 = acc0 ^(1/2)
 4533: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4534: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4535: 1			;
 4536: 1			; input:     r3,r2,r1,r0 = acc0
 4537: 1			;
 4538: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4539: 1			;
 4540: 1			; vernietigt:  niets
 4541: 1			;*******************************************************************************
 4542: 1  0F70	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4543: 1  0F72	C0 F0		                push    b
 4544: 1  0F74	C0 D0		                push    psw
 4545: 1  0F76	C0 82		                push    dpl
 4546: 1  0F78	C0 83		                push    dph
 4547: 1  0F7A	EC		                mov     a,r4
 4548: 1  0F7B	C0 E0		                push    acc
 4549: 1  0F7D	ED		                mov     a,r5
 4550: 1  0F7E	C0 E0		                push    acc
 4551: 1  0F80	EE		                mov     a,r6
 4552: 1  0F81	C0 E0		                push    acc
 4553: 1  0F83	EF		                mov     a,r7
 4554: 1  0F84	C0 E0		                push    acc
 4555: 1
 4556: 1  0F86	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4557: 1  0F88	7D 00		                mov     r5,#0
 4558: 1  0F8A	7E 00		                mov     r6,#0
 4559: 1  0F8C	7F 00		                mov     r7,#0
 4560: 1  0F8E	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4561: 1  0F91	75 83 00	                mov     dph,#0
 4562: 1  0F94	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4563: 1			;hier start het algorithme voor het berekenen van de wortel
 4564: 1  0F97	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4565: 1  0F99	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4566: 1  0F9C	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4567: 1  0F9D	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4568: 1  0F9E	33		                rlc     a                ;getest worden om een wortelbit te
 4569: 1  0F9F	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4570: 1  0FA0	E9		                mov     a,r1            ;met nullen!
 4571: 1  0FA1	33		                rlc     a
 4572: 1  0FA2	F9		                mov     r1,a
 4573: 1  0FA3	EA		                mov     a,r2
 4574: 1  0FA4	33		                rlc     a
 4575: 1  0FA5	FA		                mov     r2,a
 4576: 1  0FA6	EB		                mov     a,r3
 4577: 1  0FA7	33		                rlc     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4578: 1  0FA8	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4579: 1
 4580: 1  0FA9	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4581: 1  0FAA	33		                rlc     a
 4582: 1  0FAB	FC		                mov     r4,a
 4583: 1  0FAC	ED		                mov     a,r5
 4584: 1  0FAD	33		                rlc     a
 4585: 1  0FAE	FD		                mov     r5,a
 4586: 1  0FAF	EE		                mov     a,r6
 4587: 1  0FB0	33		                rlc     a
 4588: 1  0FB1	FE		                mov     r6,a
 4589: 1  0FB2	EF		                mov     a,r7
 4590: 1  0FB3	33		                rlc     a
 4591: 1  0FB4	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4592: 1  0FB5	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4593: 1
 4594: 1  0FB8	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4595: 1
 4596: 1  0FBA	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4597: 1  0FBB	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4598: 1  0FBD	33		                rlc     a
 4599: 1  0FBE	F5 82		                mov     dpl,a
 4600: 1  0FC0	E5 83		                mov     a,dph
 4601: 1  0FC2	33		                rlc     a
 4602: 1  0FC3	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4603: 1
 4604: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4605: 1  0FC5	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4606: 1  0FC6	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4607: 1  0FC8	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4608: 1  0FC9	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4609: 1  0FCB	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4610: 1  0FCC	C0 E0		                push    acc             ;van acc1
 4611: 1  0FCE	EB		                mov     a,r3
 4612: 1  0FCF	C0 E0		                push    acc
 4613: 1  0FD1	EC		                mov     a,r4
 4614: 1  0FD2	C0 E0		                push    acc
 4615: 1  0FD4	ED		                mov     a,r5
 4616: 1  0FD5	C0 E0		                push    acc
 4617: 1  0FD7	EE		                mov     a,r6
 4618: 1  0FD8	C0 E0		                push    acc
 4619: 1  0FDA	EF		                mov     a,r7
 4620: 1  0FDB	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4621: 1
 4622: 1  0FDD	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4623: 1  0FDF	AD 83		                mov     r5,dph
 4624: 1  0FE1	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4625: 1  0FE3	AF 83		                mov     r7,dph
 4626: 1  0FE5	12 0B 26	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4627: 1
 4628: 1  0FE8	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4629: 1  0FEA	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4630: 1  0FEB	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4631: 1  0FED	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4632: 1  0FEE	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4633: 1  0FF0	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4634: 1  0FF1	D0 E0		                pop     acc             ;de stack...
 4635: 1  0FF3	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4636: 1
 4637: 1  0FF4	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4638: 1  0FF5	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4639: 1  0FF6	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4640: 1  0FF7	E9		                mov     a,r1            ;in acc1.
 4641: 1  0FF8	9D		                subb    a,r5            ;We doen dit door de carry van het
 4642: 1  0FF9	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4643: 1  0FFA	9E		                subb    a,r6
 4644: 1  0FFB	EB		                mov     a,r3
 4645: 1  0FFC	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4646: 1  0FFD	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4647: 1			                                        ;wortel behouden
 4648: 1  0FFF	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4649: 1  1001	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4650: 1  1003	F5 82		                mov     dpl,a          ;wortel aanpassen
 4651: 1
 4652: 1  1005	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4653: 1  1007	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4654: 1  1009	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4655: 1
 4656: 1  100B	D0 E0		                pop     acc            ;haal acc1 weer op
 4657: 1  100D	FF		                mov     r7,a
 4658: 1  100E	D0 E0		                pop     acc
 4659: 1  1010	FE		                mov     r6,a
 4660: 1  1011	D0 E0		                pop     acc
 4661: 1  1013	FD		                mov     r5,a
 4662: 1  1014	D0 E0		                pop     acc
 4663: 1  1016	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4664: 1
 4665: 1  1017	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4666: 1  1019	FB		                mov     r3,a
 4667: 1  101A	D0 E0		                pop     acc
 4668: 1  101C	FA		                mov     r2,a
 4669: 1  101D	D0 E0		                pop     acc
 4670: 1  101F	F9		                mov     r1,a
 4671: 1  1020	D0 E0		                pop     acc
 4672: 1  1022	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4673: 1
 4674: 1  1023	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4675: 1  1026	80 03		                sjmp    sqrt325
 4676: 1  1028	02 0F 97	sqrt324:        ljmp    sqrt320        ;uit acc0
 4677: 1
 4678: 1  102B	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4679: 1  102D	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4680: 1
 4681: 1  102F	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4682: 1  1031	FF		                mov     r7,a
 4683: 1  1032	D0 E0		                pop     acc
 4684: 1  1034	FE		                mov     r6,a
 4685: 1  1035	D0 E0		                pop     acc
 4686: 1  1037	FD		                mov     r5,a
 4687: 1  1038	D0 E0		                pop     acc
 4688: 1  103A	FC		                mov     r4,a           ;acc1 is hersteld
 4689: 1  103B	D0 83		                pop     dph

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4690: 1  103D	D0 82		                pop     dpl
 4691: 1  103F	D0 D0		                pop     psw
 4692: 1  1041	D0 F0		                pop     b
 4693: 1  1043	D0 E0		                pop     acc
 4694: 1
 4695: 1  1045	22		                ret                    ;eindelijk klaar...
 4696: 1
 4697: 1			;*******************************************************************************
 4698: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4699: 1			; acc0 = acc0 ^(1/2)
 4700: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4701: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4702: 1			;                           (-2147483648 tot +2147483647)
 4703: 1			; input:     r3,r2,r1,r0 = acc0
 4704: 1			;
 4705: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4706: 1			;            CY = 1 als acc0 negatief is
 4707: 1			; vernietigt:  niets
 4708: 1			;*******************************************************************************
 4709: 1  1046	C0 E0		s_sqrt32:       push    acc
 4710: 1  1048	C0 D0		                push    psw
 4711: 1  104A	EB		                mov     a,r3
 4712: 1  104B	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4713: 1  104E	D0 D0		                pop     psw
 4714: 1  1050	D3		                setb    c                ;als negatief dan error
 4715: 1  1051	D0 E0		                pop     acc
 4716: 1  1053	22		                ret
 4717: 1  1054	D0 D0		s_sqrt321:      pop     psw
 4718: 1  1056	D0 E0		                pop     acc
 4719: 1  1058	12 0F 70	                lcall   sqrt32            ;wortel trekken
 4720: 1  105B	C3		                clr     c                 ;wortel ok
 4721: 1  105C	22		                ret                       ;klaar
 4722: 1
 4723: 1			;*******************************************************************************
 4724: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4725: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4726: 1			; (logical shift)
 4727: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4728: 1			;
 4729: 1			; input:     r3,r2,r1,r0 = acc0
 4730: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4731: 1			;
 4732: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4733: 1			;            CY=1 als N>=32
 4734: 1			; vernietigt:  niets
 4735: 1			;*******************************************************************************
 4736: 1  105D	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4737: 1  105F	C0 D0		                push    psw
 4738: 1  1061	EC		                mov     a,r4            ;neem aantal shifts
 4739: 1  1062	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4740: 1  1065	40 06		shiftright1:    jc      shiftright2
 4741: 1  1067	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4742: 1  1069	D3		                setb    c               ;N buiten bereik
 4743: 1  106A	D0 E0		                pop     acc
 4744: 1  106C	22		                ret
 4745: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4746: 1  106D	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4747: 1  106F	8C F0		                mov     b,r4            ;lusteller initialiseren
 4748: 1  1071	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4749: 1  1072	EB		                mov     a,r3            ;start bij msb
 4750: 1  1073	13		                rrc     a
 4751: 1  1074	FB		                mov     r3,a
 4752: 1  1075	EA		                mov     a,r2
 4753: 1  1076	13		                rrc     a
 4754: 1  1077	FA		                mov     r2,a
 4755: 1  1078	E9		                mov     a,r1
 4756: 1  1079	13		                rrc     a
 4757: 1  107A	F9		                mov     r1,a
 4758: 1  107B	E8		                mov     a,r0
 4759: 1  107C	13		                rrc     a
 4760: 1  107D	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4761: 1  107E	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4762: 1  1081	D0 F0		                pop     b               ;registers herstellen
 4763: 1  1083	D0 D0		                pop     psw
 4764: 1  1085	C3		                clr     c               ;N is binnen bereik
 4765: 1  1086	D0 E0		                pop     acc
 4766: 1  1088	22		                ret
 4767: 1
 4768: 1			;*******************************************************************************
 4769: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4770: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4771: 1			; (logical shift)
 4772: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4773: 1			;
 4774: 1			; input:     r3,r2,r1,r0 = acc0
 4775: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4776: 1			;
 4777: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4778: 1			;
 4779: 1			; vernietigt:  niets
 4780: 1			;*******************************************************************************
 4781: 1  1089	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4782: 1  108B	C0 D0		                push    psw
 4783: 1  108D	EC		                mov     a,r4            ;neem aantal shifts
 4784: 1  108E	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4785: 1  1091	40 06		shiftleft1:     jc      shiftleft2
 4786: 1  1093	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4787: 1  1095	D3		                setb    c               ;N buiten bereik
 4788: 1  1096	D0 E0		                pop     acc
 4789: 1  1098	22		                ret
 4790: 1
 4791: 1  1099	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4792: 1  109B	8C F0		                mov     b,r4            ;lusteller initialiseren
 4793: 1  109D	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4794: 1  109E	E8		                mov     a,r0            ;start bij lsb
 4795: 1  109F	33		                rlc     a
 4796: 1  10A0	F8		                mov     r0,a
 4797: 1  10A1	E9		                mov     a,r1
 4798: 1  10A2	33		                rlc     a
 4799: 1  10A3	F9		                mov     r1,a
 4800: 1  10A4	EA		                mov     a,r2
 4801: 1  10A5	33		                rlc     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4802: 1  10A6	FA		                mov     r2,a
 4803: 1  10A7	EB		                mov     a,r3
 4804: 1  10A8	33		                rlc     a
 4805: 1  10A9	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4806: 1  10AA	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4807: 1  10AD	D0 F0		                pop     b               ;registers herstellen
 4808: 1  10AF	D0 D0		                pop     psw
 4809: 1  10B1	C3		                clr     c               ;N is binnen bereik
 4810: 1  10B2	D0 E0		                pop     acc
 4811: 1  10B4	22		                ret
 4812: 1
 4813: 1			;*******************************************************************************
 4814: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4815: 1			; (arithmetic shift)
 4816: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4817: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4818: 1			; niet van teken!
 4819: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4820: 1			;                       (-2147483648 tot +2147483647)
 4821: 1			;
 4822: 1			; input:     r3,r2,r1,r0 = acc0
 4823: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4824: 1			;
 4825: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4826: 1			;            CY=1 als N>=31
 4827: 1			; vernietigt:  niets
 4828: 1			;*******************************************************************************
 4829: 1  10B5	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 4830: 1  10B7	C0 D0		                push    psw
 4831: 1  10B9	EC		                mov     a,r4            ;neem aantal shifts
 4832: 1  10BA	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4833: 1  10BD	40 06		s_shiftright1:  jc      s_shiftright2
 4834: 1  10BF	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4835: 1  10C1	D3		                setb    c               ;N buiten bereik
 4836: 1  10C2	D0 E0		                pop     acc
 4837: 1  10C4	22		                ret
 4838: 1
 4839: 1  10C5	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4840: 1  10C7	8C F0		                mov     b,r4            ;lusteller initialiseren
 4841: 1  10C9	EB		                mov     a,r3
 4842: 1  10CA	20 E7 04	                jb      acc.7,s_shiftright20
 4843: 1  10CD	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4844: 1  10CF	80 02		                sjmp    s_shiftright3
 4845: 1  10D1	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4846: 1
 4847: 1  10D3	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4848: 1  10D5	EB		                mov     a,r3            ;start bij msb
 4849: 1  10D6	13		                rrc     a
 4850: 1  10D7	FB		                mov     r3,a
 4851: 1  10D8	EA		                mov     a,r2
 4852: 1  10D9	13		                rrc     a
 4853: 1  10DA	FA		                mov     r2,a
 4854: 1  10DB	E9		                mov     a,r1
 4855: 1  10DC	13		                rrc     a
 4856: 1  10DD	F9		                mov     r1,a
 4857: 1  10DE	E8		                mov     a,r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4858: 1  10DF	13		                rrc     a
 4859: 1  10E0	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4860: 1  10E1	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4861: 1  10E4	D0 F0		                pop     b               ;registers herstellen
 4862: 1  10E6	D0 D0		                pop     psw
 4863: 1  10E8	C3		                clr     c               ;N is binnen bereik
 4864: 1  10E9	D0 E0		                pop     acc
 4865: 1  10EB	22		                ret
 4866: 1
 4867: 1			;*******************************************************************************
 4868: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4869: 1			; (arithmetic shift)
 4870: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4871: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 4872: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4873: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4874: 1			;                       (-2147483648 tot +2147483647)
 4875: 1			;
 4876: 1			; input:     r3,r2,r1,r0 = acc0
 4877: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4878: 1			;
 4879: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4880: 1			;            CY=1 als N>=31
 4881: 1			; vernietigt:  niets
 4882: 1			;*******************************************************************************
 4883: 1  10EC	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 4884: 1  10EE	C0 D0		                push    psw
 4885: 1  10F0	EC		                mov     a,r4            ;neem aantal shifts
 4886: 1  10F1	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4887: 1  10F4	40 06		s_shiftleft1:   jc      s_shiftleft2
 4888: 1  10F6	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4889: 1  10F8	D3		                setb    c               ;N buiten bereik
 4890: 1  10F9	D0 E0		                pop     acc
 4891: 1  10FB	22		                ret
 4892: 1
 4893: 1  10FC	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4894: 1  10FE	8C F0		                mov     b,r4            ;lusteller initialiseren
 4895: 1
 4896: 1
 4897: 1
 4898: 1  1100	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4899: 1  1101	E8		                mov     a,r0             ;start bij lsb
 4900: 1  1102	33		                rlc     a
 4901: 1  1103	F8		                mov     r0,a
 4902: 1  1104	E9		                mov     a,r1
 4903: 1  1105	33		                rlc     a
 4904: 1  1106	F9		                mov     r1,a
 4905: 1  1107	EA		                mov     a,r2
 4906: 1  1108	33		                rlc     a
 4907: 1  1109	FA		                mov     r2,a
 4908: 1  110A	EB		                mov     a,r3
 4909: 1  110B	33		                rlc     a
 4910: 1  110C	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4911: 1  110E	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4912: 1  110F	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4913: 1  1112	D0 F0		                pop     b                ;registers herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4914: 1  1114	D0 D0		                pop     psw
 4915: 1  1116	C3		                clr     c                ;N is binnen bereik
 4916: 1  1117	D0 E0		                pop     acc
 4917: 1  1119	22		                ret
 4918: 1
 4919: 1			;*******************************************************************************
 4920: 1			; s_cmp16    (29,5us @16.777216MHz)
 4921: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4922: 1			;
 4923: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4924: 1			;
 4925: 1			; input:     r1,r0 = acc0
 4926: 1			;            r5,r4 = acc1
 4927: 1			;
 4928: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4929: 1			;             f0=0,cy=0  als acc0 > acc1
 4930: 1			;             f0=1 cy=0    als acc1 = acc0
 4931: 1			;
 4932: 1			; vernietigt:  niets
 4933: 1			;*******************************************************************************
 4934: 1  111A	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4935: 1  111C	C0 D0		                push    psw
 4936: 1  111E	E8		                mov     a,r0
 4937: 1  111F	C0 E0		                push    acc
 4938: 1  1121	E9		                mov     a,r1
 4939: 1  1122	C0 E0		                push    acc
 4940: 1
 4941: 1  1124	E9		                mov     a,r1            ;neem msb van acc0
 4942: 1  1125	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4943: 1  1126	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4944: 1  1129	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4945: 1			                                        ;negatief is
 4946: 1  112A	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4947: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4948: 1
 4949: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4950: 1			;acc0>acc1
 4951: 1  112D	D0 E0		s_cmp160:       pop     acc
 4952: 1  112F	F9		                mov     r1,a
 4953: 1  1130	D0 E0		                pop     acc
 4954: 1  1132	F8		                mov     r0,a
 4955: 1  1133	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4956: 1  1135	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4957: 1  1137	C3		                clr     c               ;geef dit aan in de outputstatus
 4958: 1  1138	D0 E0		                pop     acc
 4959: 1  113A	22		                ret
 4960: 1			;acc0<acc1
 4961: 1  113B	D0 E0		s_cmp161:       pop     acc
 4962: 1  113D	F9		                mov     r1,a
 4963: 1  113E	D0 E0		                pop     acc
 4964: 1  1140	F8		                mov     r0,a
 4965: 1  1141	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4966: 1  1143	D3		                setb    c               ;groter dan acc0
 4967: 1  1144	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4968: 1  1146	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4969: 1  1148	22		                ret
 4970: 1			;gelijk teken, maak verschil
 4971: 1  1149	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 4972: 1  114A	E8		                mov     a,r0            ;acc0-acc1
 4973: 1  114B	9C		                subb    a,r4
 4974: 1  114C	F8		                mov     r0,a
 4975: 1  114D	E9		                mov     a,r1
 4976: 1  114E	9D		                subb    a,r5
 4977: 1  114F	F9		                mov     r1,a
 4978: 1  1150	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 4979: 1  1153	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 4980: 1  1154	60 02		                jz      s_cmp163        ;acc0=acc1
 4981: 1  1156	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 4982: 1			;acc0=acc1
 4983: 1  1158	D0 E0		s_cmp163:       pop     acc
 4984: 1  115A	F9		                mov     r1,a
 4985: 1  115B	D0 E0		                pop     acc
 4986: 1  115D	F8		                mov     r0,a
 4987: 1  115E	D0 D0		                pop     psw             ;acc0=acc1
 4988: 1  1160	C3		                clr     c               ;geef dit aan in de outputstatus
 4989: 1  1161	D2 D5		                setb    f0
 4990: 1  1163	D0 E0		                pop     acc
 4991: 1  1165	22		                ret
 4992: 1
 4993: 1			;*******************************************************************************
 4994: 1			; cmp16            (19,9us @16.777216MHz)
 4995: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 4996: 1			;
 4997: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 4998: 1			;
 4999: 1			; input:     r1,r0 = acc0
 5000: 1			;            r5,r4 = acc1
 5001: 1			;
 5002: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5003: 1			;             f0=0,cy=0  als acc0 > acc1
 5004: 1			;             f0=1 cy=0    als acc1 = acc0
 5005: 1			;
 5006: 1			; vernietigt:  niets
 5007: 1			;*******************************************************************************
 5008: 1  1166	C0 E0		cmp16:          push    acc             ;bewaar registers
 5009: 1  1168	C0 F0		                push    b
 5010: 1  116A	C0 D0		                push    psw
 5011: 1
 5012: 1  116C	C3		                clr     c               ;vergelijk acc0 met acc1
 5013: 1  116D	E9		                mov     a,r1            ;eerst de msb's
 5014: 1  116E	8D F0		                mov     b,r5            ;test r1-r5
 5015: 1  1170	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 5016: 1
 5017: 1  1173	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 5018: 1  1174	8C F0		                mov     b,r4            ;test r0-r4
 5019: 1  1176	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 5020: 1			;acc0=acc1
 5021: 1  1179	D0 D0		                pop     psw
 5022: 1  117B	D2 D5		                setb    f0
 5023: 1  117D	C3		                clr     c
 5024: 1  117E	D0 F0		                pop     b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5025: 1  1180	D0 E0		                pop     acc
 5026: 1  1182	22		                ret
 5027: 1  1183	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 5028: 1			;acc0>acc1
 5029: 1  1185	D0 D0		                pop     psw
 5030: 1  1187	C2 D5		                clr     f0
 5031: 1  1189	C3		                clr     c
 5032: 1  118A	D0 F0		                pop     b
 5033: 1  118C	D0 E0		                pop     acc
 5034: 1  118E	22		                ret
 5035: 1			;acc0<acc1
 5036: 1  118F	D0 D0		cmp162:         pop     psw
 5037: 1  1191	D3		                setb    c
 5038: 1  1192	C2 D5		                clr     f0
 5039: 1  1194	D0 F0		                pop     b
 5040: 1  1196	D0 E0		                pop     acc
 5041: 1  1198	22		                ret
 5042: 1
 5043: 1			;*******************************************************************************
 5044: 1			; s_cmp32        (44,3us @16.777216MHz)
 5045: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 5046: 1			;
 5047: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 5048: 1			;                         -2147483648 tot +2147483647
 5049: 1			; input:     r1,r0 = acc0
 5050: 1			;            r5,r4 = acc1
 5051: 1			;
 5052: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5053: 1			;             f0=0,cy=0  als acc0 > acc1
 5054: 1			;             f0=1 cy=0    als acc1 = acc0
 5055: 1			;
 5056: 1			; vernietigt:  niets
 5057: 1			;*******************************************************************************
 5058: 1  1199	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 5059: 1  119B	C0 D0		                push    psw
 5060: 1  119D	E8		                mov     a,r0
 5061: 1  119E	C0 E0		                push    acc
 5062: 1  11A0	E9		                mov     a,r1
 5063: 1  11A1	C0 E0		                push    acc
 5064: 1  11A3	EA		                mov     a,r2
 5065: 1  11A4	C0 E0		                push    acc
 5066: 1  11A6	EB		                mov     a,r3
 5067: 1  11A7	C0 E0		                push    acc
 5068: 1
 5069: 1  11A9	EB		                mov     a,r3            ;neem msb van acc0
 5070: 1  11AA	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 5071: 1  11AB	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 5072: 1  11AD	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 5073: 1  11AF	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 5074: 1  11B0	A2 E7		                mov     c,acc.7         ;negatief is
 5075: 1  11B2	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 5076: 1			                                        ;acc1 positief. Dus acc1>acc0
 5077: 1			;acc0>acc1
 5078: 1  11B4	D0 E0		s_cmp320:       pop     acc
 5079: 1  11B6	FB		                mov     r3,a
 5080: 1  11B7	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5081: 1  11B9	FA		                mov     r2,a
 5082: 1  11BA	D0 E0		                pop     acc
 5083: 1  11BC	F9		                mov     r1,a
 5084: 1  11BD	D0 E0		                pop     acc
 5085: 1  11BF	F8		                mov     r0,a
 5086: 1  11C0	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5087: 1  11C2	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5088: 1  11C4	C3		                clr     c               ;geef dit aan in de outputstatus
 5089: 1  11C5	D0 E0		                pop     acc
 5090: 1  11C7	22		                ret
 5091: 1			;acc0<acc1
 5092: 1  11C8	D0 E0		s_cmp321:       pop     acc
 5093: 1  11CA	FB		                mov     r3,a
 5094: 1  11CB	D0 E0		                pop     acc
 5095: 1  11CD	FA		                mov     r2,a
 5096: 1  11CE	D0 E0		                pop     acc
 5097: 1  11D0	F9		                mov     r1,a
 5098: 1  11D1	D0 E0		                pop     acc
 5099: 1  11D3	F8		                mov     r0,a
 5100: 1  11D4	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5101: 1  11D6	D3		                setb    c               ;groter dan acc0
 5102: 1  11D7	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5103: 1  11D9	D0 E0		                pop     acc
 5104: 1  11DB	22		                ret
 5105: 1			;gelijk teken, maak verschil
 5106: 1  11DC	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5107: 1  11DD	E8		                mov     a,r0            ;acc0-acc1
 5108: 1  11DE	9C		                subb    a,r4
 5109: 1  11DF	F8		                mov     r0,a
 5110: 1  11E0	E9		                mov     a,r1
 5111: 1  11E1	9D		                subb    a,r5
 5112: 1  11E2	F9		                mov     r1,a
 5113: 1  11E3	EA		                mov     a,r2
 5114: 1  11E4	9E		                subb    a,r6
 5115: 1  11E5	FA		                mov     r2,a
 5116: 1  11E6	EB		                mov     a,r3
 5117: 1  11E7	9F		                subb    a,r7
 5118: 1  11E8	FB		                mov     r3,a
 5119: 1  11E9	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5120: 1  11EC	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5121: 1  11ED	49		                orl     a,r1
 5122: 1  11EE	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5123: 1  11EF	60 02		                jz      s_cmp323        ;acc0=acc1
 5124: 1  11F1	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5125: 1			;acc0=acc1
 5126: 1  11F3	D0 E0		s_cmp323:       pop     acc
 5127: 1  11F5	FB		                mov     r3,a
 5128: 1  11F6	D0 E0		                pop     acc
 5129: 1  11F8	FA		                mov     r2,a
 5130: 1  11F9	D0 E0		                pop     acc
 5131: 1  11FB	F9		                mov     r1,a
 5132: 1  11FC	D0 E0		                pop     acc
 5133: 1  11FE	F8		                mov     r0,a
 5134: 1  11FF	D0 D0		                pop     psw             ;acc0=acc1
 5135: 1  1201	C3		                clr     c               ;geef dit aan in de outputstatus
 5136: 1  1202	D2 D5		                setb    f0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5137: 1  1204	D0 E0		                pop     acc
 5138: 1  1206	22		                ret
 5139: 1
 5140: 1			;*******************************************************************************
 5141: 1			; cmp32        (27,14us @16.777216MHz)
 5142: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5143: 1			;
 5144: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5145: 1			;
 5146: 1			; input:     r3,r2,r1,r0 = acc0
 5147: 1			;            r7,r6,r5,r4 = acc1
 5148: 1			;
 5149: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5150: 1			;            f0=0,cy=0  als acc0 > acc1
 5151: 1			;            f0=1 cy=0    als acc1 = acc0
 5152: 1			;
 5153: 1			; vernietigt:  niets
 5154: 1			;*******************************************************************************
 5155: 1  1207	C0 E0		cmp32:          push    acc             ;bewaar registers
 5156: 1  1209	C0 F0		                push    b
 5157: 1  120B	C0 D0		                push    psw
 5158: 1
 5159: 1  120D	C3		                clr     c               ;vergelijk acc0 met acc1
 5160: 1  120E	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5161: 1  120F	8F F0		                mov     b,r7            ;test r3-r7
 5162: 1  1211	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5163: 1
 5164: 1  1214	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5165: 1  1215	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5166: 1  1217	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5167: 1
 5168: 1  121A	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5169: 1  121B	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5170: 1  121D	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5171: 1
 5172: 1  1220	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5173: 1  1221	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5174: 1  1223	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5175: 1			;acc0=acc1
 5176: 1  1226	D0 D0		                pop     psw
 5177: 1  1228	D2 D5		                setb    f0
 5178: 1  122A	C3		                clr     c
 5179: 1  122B	D0 F0		                pop     b
 5180: 1  122D	D0 E0		                pop     acc
 5181: 1  122F	22		                ret
 5182: 1  1230	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5183: 1			;acc0>acc1, indien cy=0
 5184: 1  1232	D0 D0		                pop     psw
 5185: 1  1234	C2 D5		                clr     f0
 5186: 1  1236	C3		                clr     c
 5187: 1  1237	D0 F0		                pop     b
 5188: 1  1239	D0 E0		                pop     acc
 5189: 1  123B	22		                ret
 5190: 1			;acc0<acc1
 5191: 1  123C	D0 D0		cmp322:         pop     psw
 5192: 1  123E	D3		                setb    c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5193: 1  123F	C2 D5		                clr     f0
 5194: 1  1241	D0 F0		                pop     b
 5195: 1  1243	D0 E0		                pop     acc
 5196: 1  1245	22		                ret
 5197: 1
 5198: 1
 5199: 1			;*******************************************************************************
 5200: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5201: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5202: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5203: 1			; adres zitten.
 5204: 1			;
 5205: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5206: 1			;
 5207: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5208: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5209: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5210: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5211: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5212: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5213: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5214: 1			;                cy = 0  lookup is ok
 5215: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5216: 1			; vernietigt:  niets
 5217: 1			;*******************************************************************************
 5218: 1  1246	C0 E0		table_lu:       push    acc             ;bewaren registers
 5219: 1  1248	C0 D0		                push    psw
 5220: 1  124A	C0 82		                push    dpl
 5221: 1  124C	C0 83		                push    dph
 5222: 1
 5223: 1  124E	A2 D5		                mov     c,f0            ;byte of word items?
 5224: 1  1250	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5225: 1			;tabel met byte items
 5226: 1  1252	E5 82		                mov     a,dpl           ;datapointer plus index
 5227: 1  1254	28		                add     a,r0
 5228: 1  1255	F5 82		                mov     dpl,a
 5229: 1  1257	E5 83		                mov     a,dph
 5230: 1  1259	39		                addc    a,r1
 5231: 1  125A	F5 83		                mov     dph,a
 5232: 1  125C	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5233: 1  125E	A2 D1		                mov     c,f1            ;code of datageheugen?
 5234: 1  1260	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5235: 1
 5236: 1			;bytetabel in codegeheugen
 5237: 1  1262	74 00		                mov     a,#0
 5238: 1  1264	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5239: 1  1265	F8		                mov     r0,a            ;en stop in acc0
 5240: 1  1266	79 00		                mov     r1,#0
 5241: 1  1268	02 12 C7	                ljmp    table_lu4       ;en klaar
 5242: 1
 5243: 1			;bytetabel in datageheugen
 5244: 1  126B	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5245: 1  126C	F8		                mov     r0,a            ;en stop in acc0
 5246: 1  126D	79 00		                mov     r1,#0
 5247: 1  126F	02 12 C7	                ljmp    table_lu4       ;en klaar
 5248: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5249: 1  1272	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5250: 1  1274	D0 82		                pop     dpl
 5251: 1  1276	D0 D0		                pop     psw
 5252: 1  1278	D3		                setb    c              ;foutstatus teruggeven!
 5253: 1  1279	D0 E0		                pop     acc
 5254: 1  127B	22		                ret
 5255: 1
 5256: 1			;tabel met word items
 5257: 1  127C	E8		table_lu2:      mov     a,r0            ;index op stack
 5258: 1  127D	C0 E0		                push    acc
 5259: 1  127F	E9		                mov     a,r1
 5260: 1  1280	C0 E0		                push    acc
 5261: 1
 5262: 1  1282	C3		                clr      c              ;index maal 2 (word items)
 5263: 1  1283	E8		                mov     a,r0
 5264: 1  1284	33		                rlc     a
 5265: 1  1285	F8		                mov     r0,a
 5266: 1  1286	E9		                mov     a,r1
 5267: 1  1287	33		                rlc     a
 5268: 1  1288	F9		                mov     r1,a
 5269: 1
 5270: 1  1289	E5 82		                mov     a,dpl           ;datapointer plus index
 5271: 1  128B	28		                add     a,r0
 5272: 1  128C	F5 82		                mov     dpl,a
 5273: 1  128E	E5 83		                mov     a,dph
 5274: 1  1290	39		                addc    a,r1
 5275: 1  1291	F5 83		                mov     dph,a
 5276: 1
 5277: 1  1293	D0 E0		                pop     acc             ;index weer van stack
 5278: 1  1295	F9		                mov     r1,a
 5279: 1  1296	D0 E0		                pop     acc
 5280: 1  1298	F8		                mov     r0,a
 5281: 1
 5282: 1  1299	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5283: 1  129B	A2 D1		                mov     c,f1            ;code of datageheugen?
 5284: 1  129D	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5285: 1			;wordtabel in codegeheugen
 5286: 1  129F	74 00		                mov     a,#0
 5287: 1  12A1	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5288: 1  12A2	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5289: 1  12A3	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5290: 1  12A5	24 01		                add     a,#1
 5291: 1  12A7	F5 82		                mov     dpl,a
 5292: 1  12A9	E5 83		                mov     a,dph
 5293: 1  12AB	34 00		                addc    a,#0
 5294: 1  12AD	F5 83		                mov     dph,a
 5295: 1  12AF	74 00		                mov     a,#0
 5296: 1  12B1	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5297: 1  12B2	F9		                mov     r1,a            ;msb in acc0 stoppen
 5298: 1  12B3	80 12		                sjmp    table_lu4        ;en klaar
 5299: 1			;wordtabel    in datageheugen
 5300: 1  12B5	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5301: 1  12B6	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5302: 1  12B7	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5303: 1  12B9	24 01		                add     a,#1
 5304: 1  12BB	F5 82		                mov     dpl,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5305: 1  12BD	E5 83		                mov     a,dph
 5306: 1  12BF	34 00		                addc    a,#0
 5307: 1  12C1	F5 83		                mov     dph,a
 5308: 1  12C3	74 00		                mov     a,#0
 5309: 1  12C5	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5310: 1  12C6	F9		                mov     r1,a            ;msb in acc0 stoppen
 5311: 1			                                        ;en klaar
 5312: 1
 5313: 1  12C7	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5314: 1  12C9	D0 82		                pop     dpl
 5315: 1  12CB	D0 D0		                pop     psw
 5316: 1  12CD	D0 E0		                pop     acc
 5317: 1  12CF	22		                ret
 5318: 1
 5319: 1
 5320: 1
 5321: 1			;*******************************************************************************
 5322: 1			; Cordic        (2,11ms @16.777216MHz)
 5323: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5324: 1			; waarde (2's complement) opgegeven hoek.
 5325: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5326: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5327: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5328: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5329: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5330: 1			; als geschaalde getallen ter beschikking komen.
 5331: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5332: 1			;
 5333: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5334: 1			;
 5335: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5336: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5337: 1			;            cy = 0 : hoek binnen bereik
 5338: 1			;            cy = 1 : error, hoek buiten bereik
 5339: 1			;            nauwkeurigheid: 12 msbits
 5340: 1			; vernietigt:  niets
 5341: 1			;*******************************************************************************
 5342: 1  12D0	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5343: 1  12D2	C0 D0		                push    psw
 5344: 1  12D4	C0 83		                push    dph
 5345: 1  12D6	C0 82		                push    dpl
 5346: 1  12D8	C0 F0		                push    b
 5347: 1
 5348: 1  12DA	EF		                mov     a,r7
 5349: 1  12DB	C0 E0		                push    acc
 5350: 1  12DD	EE		                mov     a,r6
 5351: 1  12DE	C0 E0		                push    acc
 5352: 1  12E0	ED		                mov     a,r5
 5353: 1  12E1	C0 E0		                push    acc
 5354: 1  12E3	EC		                mov     a,r4
 5355: 1  12E4	C0 E0		                push    acc
 5356: 1
 5357: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5358: 1			;en niet groter dan pi/2 radialen (6478h)
 5359: 1  12E6	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5360: 1  12E8	7D 64		                mov     r5,#64h

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5361: 1  12EA	12 11 66	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5362: 1  12ED	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5363: 1  12F0	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5364: 1  12F2	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5365: 1
 5366: 1  12F4	C2 A0		cordic000:      clr     p2.0
 5367: 1  12F6	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5368: 1  12F8	7D 9B		                mov     r5,#9bh
 5369: 1  12FA	12 11 66	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5370: 1  12FD	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5371: 1  1300	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5372: 1  1302	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5373: 1
 5374: 1  1304	C2 A1		cordic_error:   clr     p2.1
 5375: 1  1306	02 13 B8	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5376: 1
 5377: 1			;Hoek is -pi/2 resultaat gekend
 5378: 1  1309	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5379: 1  130B	7A 00		                mov     r2,#000h
 5380: 1  130D	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5381: 1  130F	78 00		                mov     r0,#000h
 5382: 1  1311	C3		                clr     c
 5383: 1  1312	02 13 B8	                ljmp    cordic40        ;en klaar
 5384: 1			;hoek is +pi/2 resultaat gekend
 5385: 1  1315	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5386: 1  1317	7A FF		                mov     r2,#0ffh
 5387: 1  1319	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5388: 1  131B	78 00		                mov     r0,#000h
 5389: 1  131D	C3		                clr     c
 5390: 1  131E	02 13 B8	                ljmp    cordic40        ;en klaar
 5391: 1
 5392: 1  1321	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5393: 1  1323	7D 00		                mov     r5,#00h
 5394: 1  1325	12 11 66	                lcall   cmp16            ;vergelijk de hoeken
 5395: 1  1328	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5396: 1  132B	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5397: 1			;hoek is 0, resultaat gekend
 5398: 1  132D	C2 A7		cordic_nul:     clr     p2.7
 5399: 1  132F	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5400: 1  1331	7A 00		                mov     r2,#000h
 5401: 1  1333	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5402: 1  1335	78 FF		                mov     r0,#0ffh
 5403: 1  1337	C3		                clr     c
 5404: 1  1338	02 13 B8	                ljmp    cordic40        ;en klaar
 5405: 1
 5406: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5407: 1  133B	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5408: 1  133C	C0 E0		                push    acc
 5409: 1  133E	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5410: 1  133F	C0 E0		                push    acc
 5411: 1
 5412: 1  1341	7B 00		                mov     r3,#00h         ;y=0
 5413: 1  1343	7A 00		                mov     r2,#00h
 5414: 1  1345	79 26		                mov     r1,#026h        ;x = K * 2^14
 5415: 1  1347	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5416: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5417: 1  1349	75 F0 00	                mov     b,#00h          ;loopteller=0
 5418: 1
 5419: 1  134C	90 14 10	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5420: 1
 5421: 1  134F	EB		cordic1:        mov     a,r3            ;sry=y
 5422: 1  1350	FF		                mov     r7,a
 5423: 1  1351	EA		                mov     a,r2
 5424: 1  1352	FE		                mov     r6,a
 5425: 1  1353	E9		                mov     a,r1            ;srx=x
 5426: 1  1354	FD		                mov     r5,a
 5427: 1  1355	E8		                mov     a,r0
 5428: 1  1356	FC		                mov     r4,a
 5429: 1
 5430: 1  1357	12 13 D7	                lcall   cordic5          ;srx en sry >> loopteller
 5431: 1
 5432: 1  135A	D0 E0		                pop     acc
 5433: 1  135C	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5434: 1
 5435: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5436: 1  135F	C3		                clr     c
 5437: 1  1360	E8		                mov     a,r0            ;bereken x=x-sry
 5438: 1  1361	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5439: 1  1362	F8		                mov     r0,a
 5440: 1  1363	E9		                mov     a,r1
 5441: 1  1364	9F		                subb    a,r7
 5442: 1  1365	F9		                mov     r1,a
 5443: 1
 5444: 1  1366	EA		                mov     a,r2            ;bereken y=y+srx
 5445: 1  1367	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5446: 1  1368	FA		                mov     r2,a
 5447: 1  1369	EB		                mov     a,r3
 5448: 1  136A	3D		                addc    a,r5
 5449: 1  136B	FB		                mov     r3,a
 5450: 1
 5451: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5452: 1  136C	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5453: 1  136E	93		                movc    a,@a+dptr
 5454: 1  136F	A3		                inc     dptr
 5455: 1  1370	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5456: 1  1371	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5457: 1  1373	C3		                clr     c               ;verklein de hoek
 5458: 1  1374	9C		                subb    a,r4
 5459: 1  1375	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5460: 1  1377	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5461: 1
 5462: 1  1379	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5463: 1  137B	93		                movc    a,@a+dptr
 5464: 1  137C	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5465: 1  137D	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5466: 1  137E	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5467: 1  1380	9D		                subb    a,r5            ;verklein de hoek
 5468: 1  1381	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5469: 1
 5470: 1			;loopteller incrementeren en testen op einde van de iteratie
 5471: 1  1383	05 F0		cordic2:        inc     b               ;loopteller++
 5472: 1  1385	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5473: 1  1387	65 F0		                xrl     a,b             ;test op gelijkheid
 5474: 1  1389	60 28		                jz      cordic4         ;ja klaar!
 5475: 1  138B	02 13 4F	                ljmp    cordic1         ;nee, nog even verder...
 5476: 1
 5477: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5478: 1  138E	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5479: 1  138F	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5480: 1  1390	F8		                mov     r0,a
 5481: 1  1391	E9		                mov     a,r1
 5482: 1  1392	3F		                addc    a,r7
 5483: 1  1393	F9		                mov     r1,a
 5484: 1
 5485: 1  1394	C3		                clr     c
 5486: 1  1395	EA		                mov     a,r2            ;bereken y=y-srx
 5487: 1  1396	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5488: 1  1397	FA		                mov     r2,a
 5489: 1  1398	EB		                mov     a,r3
 5490: 1  1399	9D		                subb    a,r5
 5491: 1  139A	FB		                mov     r3,a
 5492: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5493: 1  139B	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5494: 1  139D	93		                movc    a,@a+dptr
 5495: 1  139E	A3		                inc     dptr
 5496: 1  139F	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5497: 1  13A0	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5498: 1  13A2	2C		                add     a,r4            ;vergroot de hoek
 5499: 1  13A3	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5500: 1  13A5	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5501: 1
 5502: 1  13A7	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5503: 1  13A9	93		                movc    a,@a+dptr
 5504: 1  13AA	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5505: 1  13AB	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5506: 1  13AC	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5507: 1  13AE	3D		                addc    a,r5            ;vergroot de hoek
 5508: 1  13AF	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5509: 1
 5510: 1  13B1	80 D0		                sjmp    cordic2
 5511: 1
 5512: 1  13B3	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5513: 1  13B5	D0 E0		                pop     acc             ;dummy hoek van stack
 5514: 1  13B7	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5515: 1
 5516: 1  13B8	D0 E0		cordic40:       pop     acc
 5517: 1  13BA	FC		                mov     r4,a
 5518: 1  13BB	D0 E0		                pop     acc
 5519: 1  13BD	FD		                mov     r5,a
 5520: 1  13BE	D0 E0		                pop     acc
 5521: 1  13C0	FE		                mov     r6,a
 5522: 1  13C1	D0 E0		                pop     acc
 5523: 1  13C3	FF		                mov     r7,a
 5524: 1  13C4	D0 F0		                pop     b
 5525: 1  13C6	D0 82		                pop     dpl
 5526: 1  13C8	D0 83		                pop     dph
 5527: 1  13CA	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5528: 1  13CC	D0 D0		                pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5529: 1  13CE	D0 E0		                pop     acc
 5530: 1  13D0	22		                ret
 5531: 1
 5532: 1  13D1	D0 D0		cordic41:       pop     psw
 5533: 1  13D3	D3		                setb    c
 5534: 1  13D4	D0 E0		                pop     acc
 5535: 1  13D6	22		                ret
 5536: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5537: 1			;over het aantal posities aangegeven in het B register.
 5538: 1  13D7	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5539: 1  13D9	74 00		                mov     a,#0            ;test of loopteller=0
 5540: 1  13DB	65 F0		                xrl     a,b
 5541: 1  13DD	60 2E		                jz      cordic52        ;klaar
 5542: 1
 5543: 1  13DF	ED		                mov     a,r5            ;test teken van srx
 5544: 1  13E0	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5545: 1  13E3	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5546: 1  13E5	80 02		                sjmp    cordic50
 5547: 1  13E7	D2 D5		cordic5a:       setb    f0
 5548: 1  13E9	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5549: 1  13EB	ED		                mov     a,r5            ;eerst de msb
 5550: 1  13EC	13		                rrc     a
 5551: 1  13ED	FD		                mov     r5,a
 5552: 1  13EE	EC		                mov     a,r4            ;dan de lsb
 5553: 1  13EF	13		                rrc     a
 5554: 1  13F0	FC		                mov     r4,a
 5555: 1  13F1	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5556: 1  13F4	D0 F0		                pop     b               ;haal de loopteller van stack
 5557: 1  13F6	C0 F0		                push    b               ;en bewaar hem weer
 5558: 1  13F8	EF		                mov     a,r7            ;test teken van sry
 5559: 1  13F9	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5560: 1  13FC	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5561: 1  13FE	80 02		                sjmp    cordic51
 5562: 1  1400	D2 D5		cordic5b:       setb    f0
 5563: 1  1402	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5564: 1  1404	EF		                mov     a,r7            ;eerst de msb
 5565: 1  1405	13		                rrc     a
 5566: 1  1406	FF		                mov     r7,a
 5567: 1  1407	EE		                mov     a,r6            ;dan de lsb
 5568: 1  1408	13		                rrc     a
 5569: 1  1409	FE		                mov     r6,a
 5570: 1  140A	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5571: 1
 5572: 1  140D	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5573: 1  140F	22		                ret
 5574: 1
 5575: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5576: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5577: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5578: 1  1410	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5579: 1  1412	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5580: 1  1414	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5581: 1  1416	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5582: 1  1418	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5583: 1  141A	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5584: 1  141C	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5585: 1  141E	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5586: 1  1420	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5587: 1  1422	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5588: 1  1424	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5589: 1  1426	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5590: 1  1428	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5591: 1  142A	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5592: 1  142C	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5593: 1
 5594: 1			endif        ;einde van aduc_math
 5595: 1			;******************************************************************************
 5596: 1
 5597: 1			ifdef        aduc_adc    ;A/D conversie routines
 5598: 1			;*******************************************************************************
 5599: 1			; ADuCADC_mide
 5600: 1			; Geschreven door [dp] op 5/1/2014
 5601: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5602: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5603: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5604: 1			; bron instellen.
 5605: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5606: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5607: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5608: 1			;
 5609: 1			;*******************************************************************************
 5610: 1
 5611: 1			;*******************************************************************************
 5612: 1			; adc_init
 5613: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5614: 1			; -  4 track&hold clockperiodes
 5615: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5616: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5617: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5618: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5619: 1			;
 5620: 1			; input: R0 =  0  : Interne referentiebron
 5621: 1			;        R0 <> 0  : Externe referentiebron
 5622: 1			;
 5623: 1			; Deze routine vernietigt niets
 5624: 1			;*******************************************************************************
 5625: 1  142E	C0 E0		adc_init:       push    acc                 ;registers op stack
 5626: 1  1430	C0 D0		                push    psw
 5627: 1  1432	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5628: 1  1435	E8		                mov     a,r0                ;welke referentiebron?
 5629: 1  1436	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5630: 1  1438	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5631: 1  143B	D0 D0		adc_init1:      pop     psw
 5632: 1  143D	D0 E0		                pop     acc
 5633: 1  143F	22		                ret
 5634: 1
 5635: 1			;*******************************************************************************
 5636: 1			; adc_single
 5637: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5638: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5639: 1			; (2's complement) formaat van de meetwaarde.
 5640: 1			; _____________________________________________________________

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5641: 1			; resolutie  |     unsigned      |           signed            |
 5642: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5643: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5644: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5645: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5646: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5647: 1			; _____________________________________________________________
 5648: 1			;
 5649: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5650: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5651: 1			; De ingangsparameter wordt doorgegeven via R0.
 5652: 1			;
 5653: 1			; input:
 5654: 1			;             7    6    5    4    3    2    1    0
 5655: 1			;           _______________________________________
 5656: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5657: 1			;           ---------------------------------------
 5658: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5659: 1			;                                         1000b = temp.sensor
 5660: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5661: 1			;                                   10b = 12 bits, 11b = 12 bits
 5662: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5663: 1			;
 5664: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5665: 1			;         cy=0  bij conversie ok
 5666: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5667: 1			;
 5668: 1			; Deze routine vernietigt niets
 5669: 1			;*******************************************************************************
 5670: 1  1440	C0 E0		adc_single:     push    acc                 ;registers op stack
 5671: 1  1442	C0 D0		                push    psw
 5672: 1  1444	C0 F0		                push    b
 5673: 1  1446	E8		                mov     a,r0                ;neem inputparameter
 5674: 1  1447	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5675: 1  1449	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5676: 1  144C	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5677: 1  144E	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5678: 1  1450	D2 DC		                setb    sconv               ;start een meting
 5679: 1  1452	E8		                mov     a,r0                ;neem parameter terug
 5680: 1  1453	A2 E6		                mov     c,acc.6
 5681: 1  1455	92 D5		                mov     f0,c                ;bewaar format bit
 5682: 1  1457	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5683: 1  145A	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5684: 1  145D	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5685: 1  1460	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5686: 1			;*******************************************************************************
 5687: 1			;8 bit resultaat gevraagd
 5688: 1			;*******************************************************************************
 5689: 1  1463	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5690: 1  1465	C4		                swap    a                    ;swap nibbles
 5691: 1  1466	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5692: 1  1468	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5693: 1  146A	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5694: 1  146C	C4		                swap    a
 5695: 1  146D	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5696: 1  146F	20 D5 05	                jb      f0,adc_single2       ;check formaat

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5697: 1			;8 bit unsigned formaat
 5698: 1  1472	79 00		                mov     r1,#00h              ;unsigned
 5699: 1  1474	F8		                mov     r0,a
 5700: 1  1475	80 63		                sjmp    adc_single42
 5701: 1			;8 bit signed formaat
 5702: 1  1477	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5703: 1  147A	24 80		                add     a,#80h                ;negatief getal van maken
 5704: 1  147C	F8		                mov     r0,a
 5705: 1  147D	79 FF		                mov     r1,#0ffh
 5706: 1  147F	80 59		                sjmp    adc_single42
 5707: 1  1481	C3		adc_single20:   clr     c
 5708: 1  1482	94 80		                subb    a,#80h                ;positief deel verkleinen
 5709: 1  1484	F8		                mov     r0,a
 5710: 1  1485	79 00		                mov     r1,#00h
 5711: 1  1487	80 51		                sjmp    adc_single42
 5712: 1
 5713: 1  1489	02 14 E2	adc_single21:   ljmp    adc_single43
 5714: 1			;*******************************************************************************
 5715: 1			;10 bit resultaat gevraagd
 5716: 1			;*******************************************************************************
 5717: 1  148C	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5718: 1  148E	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5719: 1  1490	03		                rr     a              ;naar msbits roteren
 5720: 1  1491	03		                rr     a
 5721: 1  1492	F5 F0		                mov    b,a            ;even bewaren
 5722: 1  1494	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5723: 1  1496	03		                rr     a              ;twee plaatsen opschuiven
 5724: 1  1497	03		                rr     a
 5725: 1  1498	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5726: 1  149A	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5727: 1  149C	F5 F0		                mov    b,a            ;low byte even bewaren
 5728: 1  149E	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5729: 1  14A0	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5730: 1  14A2	03		                rr     a               ;en op hun plaats schuiven
 5731: 1  14A3	03		                rr     a
 5732: 1  14A4	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5733: 1			;10 bit unsigned formaat
 5734: 1  14A7	F9		                mov    r1,a            ;unsigned
 5735: 1  14A8	A8 F0		                mov    r0,b
 5736: 1  14AA	80 2E		                sjmp   adc_single42
 5737: 1			;10 bit signed formaat
 5738: 1  14AC	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5739: 1  14AF	24 FE		                add    a,#0feh             ;negatief getal van maken
 5740: 1  14B1	F9		                mov    r1,a
 5741: 1  14B2	A8 F0		                mov    r0,b
 5742: 1  14B4	80 24		                sjmp   adc_single42
 5743: 1  14B6	C3		adc_single31:   clr    c
 5744: 1  14B7	94 02		                subb   a,#02h              ;positief deel verkleinen
 5745: 1  14B9	F9		                mov    r1,a
 5746: 1  14BA	A8 F0		                mov    r0,b
 5747: 1  14BC	80 1C		                sjmp   adc_single42
 5748: 1
 5749: 1			;*******************************************************************************
 5750: 1			;12 bit resultaat gevraagd
 5751: 1			;*******************************************************************************
 5752: 1  14BE	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5753: 1  14C0	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5754: 1  14C2	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5755: 1			;12 bit unsigned formaat
 5756: 1  14C5	A8 D9		                mov    r0,adcdatal           ;unsigned
 5757: 1  14C7	F9		                mov    r1,a
 5758: 1  14C8	80 10		                sjmp   adc_single42
 5759: 1			;12 bit signed formaat
 5760: 1  14CA	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5761: 1  14CD	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5762: 1  14CF	F9		                mov    r1,a
 5763: 1  14D0	A8 D9		                mov    r0,adcdatal
 5764: 1  14D2	80 06		                sjmp   adc_single42
 5765: 1  14D4	C3		adc_single41:   clr    c
 5766: 1  14D5	94 08		                subb   a,#08h                ;positief deel verkleinen
 5767: 1  14D7	F9		                mov    r1,a
 5768: 1  14D8	A8 D9		                mov    r0,adcdatal
 5769: 1  14DA	D0 F0		adc_single42:   pop    b
 5770: 1  14DC	D0 D0		                pop    psw
 5771: 1  14DE	C3		                clr    c
 5772: 1  14DF	D0 E0		                pop    acc
 5773: 1  14E1	22		                ret
 5774: 1
 5775: 1  14E2	D0 F0		adc_single43:   pop    b
 5776: 1  14E4	D0 D0		                pop    psw
 5777: 1  14E6	D3		                setb   c
 5778: 1  14E7	D0 E0		                pop    acc
 5779: 1  14E9	22		                ret
 5780: 1
 5781: 1			endif        ;einde van aduc_adc
 5782: 1			;*******************************************************************************
 5783: 1
 5784: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5785: 1			;******************************************************************************
 5786: 1			; ADuCKEY_mide.inc
 5787: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5788: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5789: 1			;
 5790: 1			;     V2.0      V1.1
 5791: 1			;                           |   |   |   |
 5792: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5793: 1			;                   |       |   |   |   |
 5794: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5795: 1			;                   |       |   |   |   |
 5796: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5797: 1			;                   |       |   |   |   |
 5798: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5799: 1			;                   |       |   |   |   |
 5800: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5801: 1			;                   |           |   |   |
 5802: 1			;     P0.5      P3.5|-K2--------|   |   |
 5803: 1			;                   |               |   |
 5804: 1			;     P0.6      P3.6|-K3------------|   |
 5805: 1			;                   |                   |
 5806: 1			;     P0.7      P3.7|-K4----------------|
 5807: 1			;
 5808: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5809: 1			; gebruikt.
 5810: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5811: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5812: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5813: 1			; en als ingang wordt aangeboden.
 5814: 1			;
 5815: 1			;                                  ___                 ___
 5816: 1			;                     ____________|   |  |------------|   |
 5817: 1			;              ____  |   ____     |   |  |   ____     |   |
 5818: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5819: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5820: 1			; '1'= toets  | cl |    | cl |              | cl |
 5821: 1			;  ingedrukt  |____|    |____|              |____|
 5822: 1			;                |         |                   |
 5823: 1			;      CLOCK     |         |                   |
 5824: 1			;         _______|_________|___________________|
 5825: 1			;
 5826: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 5827: 1			;
 5828: 1			;              MAP0      MAP1                 MAP2         MAP3
 5829: 1			;
 5830: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5831: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5832: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5833: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5834: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 5835: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5836: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 5837: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5838: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5839: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5840: 1			;
 5841: 1			;          MAP0    MAP1          MAP2    MAP3
 5842: 1			;         _______________       _______________
 5843: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 5844: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5845: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5846: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5847: 1			;
 5848: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5849: 1			;         | | | | | | | |       | | | | | | | |
 5850: 1			;        K K K K K K K K       K K K K K K K K
 5851: 1			;         O O O O O O O O       O O O O O O O O
 5852: 1			;         L L L L L L L L       L L L L L L L L
 5853: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5854: 1			;
 5855: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 5856: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 5857: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5858: 1			; van bitmaps van voor naar achter.
 5859: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5860: 1			;
 5861: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5862: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5863: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5864: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5865: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5866: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5867: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5868: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5869: 1			; deze toetswaarde weer.
 5870: 1			;
 5871: 1			;
 5872: 1			;
 5873: 1			;******************************************************************************
 5874: 1
 5875: 1
 5876: 1			;******************************************************************************
 5877: 1			; key_init
 5878: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 5879: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5880: 1			; input: niets
 5881: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 5882: 1			;         (map0,map1,map2,map3 =0)
 5883: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5884: 1			; Deze routine vernietigt niets
 5885: 1			;******************************************************************************
 5886: 1
 5887: 1  14EA	C0 E0		Key_init:       push    acc          ;bewaar registers
 5888: 1  14EC	C0 D0		                push    psw
 5889: 1  14EE	E8		                mov     a,r0
 5890: 1  14EF	C0 E0		                push    acc
 5891: 1  14F1	E9		                mov     a,r1
 5892: 1  14F2	C0 E0		                push    acc
 5893: 1  14F4	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5894: 1  14F6	79 09		                mov     r1,#9        ;9 bytes in de maps
 5895: 1  14F8	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5896: 1  14FA	08		                inc     r0           ;volgende byte nemen
 5897: 1  14FB	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5898: 1  14FD	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5899: 1  14FF	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 5900: 1  1501	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5901: 1  1504	D0 E0		                pop     acc          ;herstel registers
 5902: 1  1506	F9		                mov     r1,a
 5903: 1  1507	D0 E0		                pop     acc
 5904: 1  1509	F8		                mov     r0,a
 5905: 1  150A	D0 D0		                pop     psw
 5906: 1  150C	D0 E0		                pop     acc
 5907: 1  150E	22		                ret                    ;terug naar caller
 5908: 1			;******************************************************************************
 5909: 1
 5910: 1
 5911: 1			;******************************************************************************
 5912: 1			; toets_flank
 5913: 1			; Deze routine detecteert de indrukflank van een toets.
 5914: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5915: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5916: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5917: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5918: 1			; minder dan 20ms duurt.
 5919: 1			; input : niets
 5920: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5921: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5922: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5923: 1			;
 5924: 1			; Deze routine vernietigt geen registers.
 5925: 1			;******************************************************************************
 5926: 1  150F	C0 E0		Toets_flank:    push    acc
 5927: 1  1511	C0 D0		                push    psw
 5928: 1  1513	12 15 2D	                lcall   Keyscan
 5929: 1  1516	12 15 A9	                lcall   Keyedge
 5930: 1  1519	D0 D0		                pop     psw
 5931: 1  151B	D0 E0		                pop     acc
 5932: 1  151D	22		                ret
 5933: 1
 5934: 1			;******************************************************************************
 5935: 1			; toets_ingedrukt
 5936: 1			; Deze routine detecteert een ingedrukte toets.
 5937: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5938: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5939: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5940: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5941: 1			; minder dan 20ms duurt.
 5942: 1			; input : niets
 5943: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5944: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5945: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5946: 1			;
 5947: 1			; Deze routine vernietigt geen registers.
 5948: 1			;******************************************************************************
 5949: 1  151E	C0 E0		Toets_ingedrukt:push    acc
 5950: 1  1520	C0 D0		                push    psw
 5951: 1  1522	12 15 2D	                lcall   Keyscan
 5952: 1  1525	12 15 90	                lcall   Keydown
 5953: 1  1528	D0 D0		                pop     psw
 5954: 1  152A	D0 E0		                pop     acc
 5955: 1  152C	22		                ret
 5956: 1
 5957: 1
 5958: 1			;******************************************************************************
 5959: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5960: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5961: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5962: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5963: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5964: 1			; zoals aangegeven in het blokschema van het algorithme.
 5965: 1			; input : niets
 5966: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5967: 1			;         ervan weergeven
 5968: 1			;
 5969: 1			; Deze routine vernietigt geen registers
 5970: 1			;******************************************************************************
 5971: 1
 5972: 1  152D	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 5973: 1  152F	C0 D0		                push    psw
 5974: 1  1531	C0 F0		                push    b
 5975: 1  1533	E8		                mov     a,r0
 5976: 1  1534	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5977: 1  1536	E9		                mov     a,r1
 5978: 1  1537	C0 E0		                push    acc
 5979: 1  1539	EA		                mov     a,r2
 5980: 1  153A	C0 E0		                push    acc
 5981: 1  153C	EE		                mov     a,r6
 5982: 1  153D	C0 E0		                push    acc
 5983: 1
 5984: 1  153F	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 5985: 1  1541	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 5986: 1  1544	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 5987: 1  1546	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 5988: 1
 5989: 1  1548			Scanloop:
 5990: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 5991: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 5992: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 5993: 1			                mov     p0.0,c
 5994: 1			                mov     c,acc.1
 5995: 1			                mov     p0.1,c
 5996: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 5997: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 5998: 1			endif
 5999: 1
 6000: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 6001: 1  1548	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 6002: 1			                                      ;een rij-lijn
 6003: 1			endif
 6004: 1
 6005: 1			; Eerst de flipflops implementeren.
 6006: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 6007: 1			; te lezen van de kolomlijnen
 6008: 1  154A	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 6009: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 6010: 1  154B	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 6011: 1  154C	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 6012: 1  154D	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 6013: 1  154E	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 6014: 1  1550	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 6015: 1  1551	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 6016: 1  1552	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 6017: 1  1554	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 6018: 1  1555	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 6019: 1  1556	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 6020: 1  1557	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 6021: 1  1558	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 6022: 1  155A	FA		                mov     r2,a          ;even bewaren in register
 6023: 1
 6024: 1
 6025: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 6026: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 6027: 1			                                      ;poort3 kolomlijnen
 6028: 1			endif
 6029: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 6030: 1  155B	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 6031: 1			                                     ;poort0 kolomlijnen
 6032: 1			endif

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6033: 1  155D	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 6034: 1  155E	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 6035: 1  1560	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 6036: 1  1561	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 6037: 1
 6038: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 6039: 1			; Nu volgen de logische functies uit het blokschema
 6040: 1
 6041: 1  1562	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 6042: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 6043: 1  1563	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 6044: 1  1564	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 6045: 1  1565	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 6046: 1  1566	54 0F		                anl     a,#00001111b ;low nibble houden
 6047: 1  1568	FA		                mov     r2,a         ;resultaat bewaren
 6048: 1  1569	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 6049: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 6050: 1  156A	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 6051: 1  156B	C4		                swap    a            ;map2 naar low nibble schuiven
 6052: 1  156C	5A		                anl     a,r2         ;combineren met output vorige and poort
 6053: 1  156D	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 6054: 1  156F	FA		                mov     r2,a         ;even bewaren
 6055: 1  1570	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 6056: 1  1571	54 F0		                anl     a,#11110000b ;map2 overhouden
 6057: 1  1573	4A		                orl     a,r2         ;en combineren met nieuwe map3
 6058: 1  1574	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 6059: 1
 6060: 1			; We gaan nu de volgende lijn scannen
 6061: 1
 6062: 1  1575	EE		                mov     a,r6         ;scanpatroon nemen
 6063: 1  1576	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 6064: 1  1577	FE		                mov     r6,a         ;scanpatroon bewaren
 6065: 1
 6066: 1  1578	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 6067: 1  1579	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 6068: 1  157A	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 6069: 1  157D	D0 E0		                pop     acc          ;herstel registers
 6070: 1  157F	FE		                mov     r6,a
 6071: 1  1580	D0 E0		                pop     acc
 6072: 1  1582	FA		                mov     r2,a
 6073: 1  1583	D0 E0		                pop     acc
 6074: 1  1585	F9		                mov     r1,a
 6075: 1  1586	D0 E0		                pop     acc
 6076: 1  1588	F8		                mov     r0,a
 6077: 1  1589	D0 F0		                pop     b
 6078: 1  158B	D0 D0		                pop     psw
 6079: 1  158D	D0 E0		                pop     acc
 6080: 1  158F	22		                ret                    ;terug naar caller
 6081: 1			;******************************************************************************
 6082: 1
 6083: 1
 6084: 1			;******************************************************************************
 6085: 1			; Keydown, Keyedge (twee entry's)
 6086: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6087: 1			;
 6088: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6089: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6090: 1			; Er zijn twee detectie-modes:
 6091: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6092: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6093: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6094: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6095: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6096: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6097: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6098: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6099: 1			;
 6100: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6101: 1			; (flankdetectie mode).
 6102: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6103: 1			; (toets ingedrukt mode).
 6104: 1			;
 6105: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6106: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6107: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6108: 1			; geldt voor een standaard 4x4 keypad.
 6109: 1			;
 6110: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6111: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6112: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6113: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6114: 1			;
 6115: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6116: 1			; output: key = gedetecteerde toets
 6117: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6118: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6119: 1			;
 6120: 1			; Deze routine vernietigt geen registers
 6121: 1			;******************************************************************************
 6122: 1
 6123: 1			;'Toets ingedrukt mode' enty van de routine
 6124: 1  1590	C0 E0		Keydown:        push    acc            ;registers bewaren
 6125: 1  1592	C0 D0		                push    psw
 6126: 1  1594	C0 F0		                push    b
 6127: 1  1596	C0 82		                push    dpl
 6128: 1  1598	C0 83		                push    dph
 6129: 1  159A	E8		                mov     a,r0
 6130: 1  159B	C0 E0		                push    acc
 6131: 1  159D	E9		                mov     a,r1
 6132: 1  159E	C0 E0		                push    acc
 6133: 1  15A0	EA		                mov     a,r2
 6134: 1  15A1	C0 E0		                push    acc
 6135: 1  15A3	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6136: 1  15A5	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6137: 1  15A7	80 15		                sjmp    Key1           ;continue
 6138: 1
 6139: 1			;'Flankdetectiemode' entry van de routine
 6140: 1  15A9	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6141: 1  15AB	C0 D0		                push    psw
 6142: 1  15AD	C0 F0		                push    b
 6143: 1  15AF	C0 82		                push    dpl
 6144: 1  15B1	C0 83		                push    dph

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6145: 1  15B3	E8		                mov     a,r0
 6146: 1  15B4	C0 E0		                push    acc
 6147: 1  15B6	E9		                mov     a,r1
 6148: 1  15B7	C0 E0		                push    acc
 6149: 1  15B9	EA		                mov     a,r2
 6150: 1  15BA	C0 E0		                push    acc
 6151: 1  15BC	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6152: 1  15BE	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6153: 1  15C0	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6154: 1  15C2	E6		                mov     a,@r0         ;map entry ophalen
 6155: 1  15C3	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6156: 1  15C6	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6157: 1  15C8	C4		                swap    a             ;map1 en map0 omwisselen
 6158: 1  15C9	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6159: 1  15CB	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6160: 1  15CC	33		                rlc     a             ;kolombit testen
 6161: 1  15CD	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6162: 1  15CF	33		                rlc    a              ;nee, dan verder roteren
 6163: 1  15D0	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6164: 1  15D2	08		                inc     r0            ;rijpointer in maps verder zetten
 6165: 1  15D3	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6166: 1  15D5	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6167: 1
 6168: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6169: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6170: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6171: 1
 6172: 1  15D7	1A		toetsin:        dec     r2            ;rij-1
 6173: 1  15D8	19		                dec     r1            ;kolom-1
 6174: 1  15D9	EA		                mov     a,r2          ;neem rij-1
 6175: 1  15DA	23		                rl      a             ;(rij-1)x2
 6176: 1  15DB	23		                rl      a              ;(rij-1)x4
 6177: 1  15DC	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6178: 1  15DD	90 15 FB	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6179: 1  15E0	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6180: 1  15E1	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6181: 1  15E3	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6182: 1  15E5	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6183: 1  15E7	D0 E0		                pop     acc            ;herstellen registers
 6184: 1  15E9	FA		                mov     r2,a
 6185: 1  15EA	D0 E0		                pop     acc
 6186: 1  15EC	F9		                mov     r1,a
 6187: 1  15ED	D0 E0		                pop     acc
 6188: 1  15EF	F8		                mov     r0,a
 6189: 1  15F0	D0 83		                pop     dph
 6190: 1  15F2	D0 82		                pop     dpl
 6191: 1  15F4	D0 F0		                pop     b
 6192: 1  15F6	D0 D0		                pop     psw
 6193: 1  15F8	D0 E0		                pop     acc
 6194: 1  15FA	22		                ret                    ;terug naar caller
 6195: 1			;******************************************************************************
 6196: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6197: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6198: 1
 6199: 1  15FB	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6200: 1  15FC	30		                db    '0'    ;kolom2@rij4 toets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6201: 1  15FD	23		                db    '#'    ;kolom3@rij4 toets
 6202: 1  15FE	44		                db    'D'    ;kolom4@rij4 toets
 6203: 1
 6204: 1  15FF	37		                db    '7'    ;kolom1@rij3 toets
 6205: 1  1600	38		                db    '8'    ;kolom2@rij3 toets
 6206: 1  1601	39		                db    '9'    ;kolom3@rij3 toets
 6207: 1  1602	43		                db    'C'    ;kolom4@rij3 toets
 6208: 1
 6209: 1  1603	34		                db    '4'    ;kolom1@rij2 toets
 6210: 1  1604	35		                db    '5'    ;kolom2@rij2 toets
 6211: 1  1605	36		                db    '6'    ;kolom3@rij2 toets
 6212: 1  1606	42		                db    'B'    ;kolom4@rij2 toets
 6213: 1
 6214: 1  1607	31		                db    '1'    ;kolom1@rij1 toets
 6215: 1  1608	32		                db    '2'    ;kolom2@rij1 toets
 6216: 1  1609	33		                db    '3'    ;kolom3@rij1 toets
 6217: 1  160A	41		                db    'A'    ;kolom4@rij1 toets
 6218: 1
 6219: 1			;******************************************************************************
 6220: 1			; switch_init
 6221: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6222: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6223: 1			; input : niets
 6224: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6225: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6226: 1			;
 6227: 1			; Deze routine vernietigt niets
 6228: 1			;******************************************************************************
 6229: 1
 6230: 1  160B	C0 E0		switch_init:    push    acc
 6231: 1  160D	C0 D0		                push    psw
 6232: 1  160F	C0 F0		                push    b
 6233: 1  1611	E8		                mov     a,r0         ;bewaar registers
 6234: 1  1612	C0 E0		                push    acc
 6235: 1
 6236: 1  1614	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6237: 1  1616	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6238: 1  1619	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6239: 1  161B	08		                inc     r0           ;volgende byte nemen
 6240: 1  161C	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6241: 1  161F	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6242: 1  1621	C2 03		                clr     negvalid
 6243: 1  1623	C2 04		                clr     posvalid
 6244: 1
 6245: 1  1625	D0 E0		                pop     acc
 6246: 1  1627	F8		                mov     r0,a
 6247: 1  1628	D0 F0		                pop     b
 6248: 1  162A	D0 D0		                pop     psw
 6249: 1  162C	D0 E0		                pop     acc
 6250: 1  162E	22		                ret                   ;terug naar caller
 6251: 1
 6252: 1			;******************************************************************************
 6253: 1			; read_switch
 6254: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6255: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6256: 1			; Deze routine werkt volgens onderstaand blokschema.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6257: 1			;
 6258: 1			;                                  ___                    ___
 6259: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6260: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6261: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6262: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6263: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6264: 1			;             |____|    |____|              |____|  ----o| 3 |
 6265: 1			;                |         |                   |      |  |   |
 6266: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6267: 1			;         _______*_________*___________________|       --|___|---- posedge
 6268: 1			;
 6269: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6270: 1			;                              (swvalid-flag)
 6271: 1			;            switch1   switch2    debounce      closed
 6272: 1			;
 6273: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6274: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6275: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6276: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6277: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6278: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6279: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6280: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6281: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6282: 1			; een detector voor positieve flanken (posedge).
 6283: 1			;
 6284: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6285: 1			;         bij aduc832v1.1 :
 6286: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6287: 1			;         bij aduc832v2.0 :
 6288: 1			;         als f0=0 dan: schakelaars op p0
 6289: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6290: 1			;
 6291: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6292: 1			;         geactualiseerd.
 6293: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6294: 1			;                  schakelaars weergeeft
 6295: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6296: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6297: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6298: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6299: 1			;                  werd gedetecteerd op een schakelaar.
 6300: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6301: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6302: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6303: 1			;                  werd gedetecteerd op een schakelaar.
 6304: 1			;
 6305: 1			;
 6306: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6307: 1			; en flags te initialiseren.
 6308: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6309: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6310: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6311: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6312: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111



 Line  I  Addr  Code            Source

 6313: 1			; bijhorende flag resetten.
 6314: 1			;
 6315: 1			; Deze routine vernietigt niets
 6316: 1			;******************************************************************************
 6317: 1  162F	C0 E0		read_switch:    push    acc            ;registers bewaren
 6318: 1  1631	C0 D0		                push    psw
 6319: 1  1633	C0 F0		                push    b
 6320: 1			;Flipflops uitvoeren is bytes doorschuiven
 6321: 1  1635	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6322: 1  1638	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6323: 1
 6324: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6325: 1			                clr      a
 6326: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6327: 1			                mov     acc.0,c
 6328: 1			                mov     c,p0.1
 6329: 1			                mov     acc.1,c
 6330: 1			                mov     b,a            ;even bewaren
 6331: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6332: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6333: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6334: 1			endif        ;einde aduc832_v1_1
 6335: 1
 6336: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6337: 1  163B	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6338: 1  163E	E5 80		                mov     a,p0           ;lees de schakelaars
 6339: 1  1640	80 04		                sjmp    lowlogic
 6340: 1  1642	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6341: 1  1644	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6342: 1			endif        ;einde aduc832_2_0
 6343: 1
 6344: 1  1646	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6345: 1  1647	F5 40		                mov     switch1,a      ;en sample opslaan
 6346: 1
 6347: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6348: 1
 6349: 1  1649	E5 40		                mov     a,switch1      ;neem laatste sample
 6350: 1  164B	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6351: 1  164D	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6352: 1  164F	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6353: 1			;negatieve flankdetectie
 6354: 1  1651	E5 43		                mov     a,closed      ;neem 3de FF
 6355: 1  1653	F4		                cpl     a             ;complementeer
 6356: 1  1654	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6357: 1  1656	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6358: 1  1658	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6359: 1  165A	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6360: 1  165C	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6361: 1			;positieve flankdetectie
 6362: 1  165E	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6363: 1  1660	F4		                cpl     a             ;complementeer
 6364: 1  1661	55 43		                anl     a,closed      ;combineer met 3de FF
 6365: 1  1663	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6366: 1  1665	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6367: 1  1667	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6368: 1  1669	D0 F0		read_switch2:   pop     b            ;registers herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112



 Line  I  Addr  Code            Source

 6369: 1  166B	D0 D0		                pop     psw
 6370: 1  166D	D0 E0		                pop     acc
 6371: 1  166F	22		                ret
 6372: 1
 6373: 1			endif    ;einde van aduc_key
 6374: 1
 6375: 1
 6376:				end





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 150
ACC				  DATA	      E0	  69
ADCBUFFER			  CODE	    002A	 207
ADCCON1				  DATA	      EF	  72
ADCCON2				  DATA	      D8	  65
ADCCON3				  DATA	      F5	  78
ADCDATAH			  DATA	      DA	  67
ADCDATAL			  DATA	      D9	  66
ADCGAINH			  DATA	      F4	  77
ADCGAINL			  DATA	      F3	  76
ADCI				  BIT	      DF	 159
ADCOFSH				  DATA	      F2	  75
ADCOFSL				  DATA	      F1	  74
ADC_INIT			  CODE	    142E	5625
ADC_INIT1			  CODE	    143B	5631
ADC_SINGLE			  CODE	    1440	5670
ADC_SINGLE1			  CODE	    144C	5676
ADC_SINGLE2			  CODE	    1477	5702
ADC_SINGLE20			  CODE	    1481	5707
ADC_SINGLE21			  CODE	    1489	5713
ADC_SINGLE3			  CODE	    148C	5717
ADC_SINGLE30			  CODE	    14AC	5738
ADC_SINGLE31			  CODE	    14B6	5743
ADC_SINGLE4			  CODE	    14BE	5752
ADC_SINGLE40			  CODE	    14CA	5760
ADC_SINGLE41			  CODE	    14D4	5765
ADC_SINGLE42			  CODE	    14DA	5769
ADC_SINGLE43			  CODE	    14E2	5775
ADD16				  CODE	    0985	2977
ADD161				  CODE	    0999	2993
ADD32				  CODE	    09D7	3074
ADD321				  CODE	    09F1	3098
ADUC832_V2_0			  NUMBER    0001	 283
ADUC_ADC			  NUMBER    0001	 304
ADUC_I2C			  NUMBER    0001	 301
ADUC_KEY			  NUMBER    0001	 305
ADUC_LCD			  NUMBER    0001	 298
ADUC_MATH			  NUMBER    0001	 303
ADUC_SIO			  NUMBER    0001	 302
ASCBINTRANS			  CODE	    0635	2030
ASCBINTRANS1			  CODE	    064A	2041
ASCBINTRANS2			  CODE	    0649	2040
ASCBINTRANS3			  CODE	    063D	2034
ASCBINTRANS4			  CODE	    0646	2038
ASCCTR				  CODE	    060C	1976
ASCCTR1				  CODE	    060F	1977
ASCCTR2				  CODE	    0614	1979
ASCCTR3				  CODE	    0618	1982

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII1				  CODE	    064B	2052
ASCII2				  CODE	    0650	2066
ASCII21				  CODE	    0662	2075
ASCII4				  CODE	    0665	2089
ASCII41				  CODE	    0674	2096
B				  DATA	      F0	  73
BACKLIGHT			  BIT	      F6	 450
BACKSP				  NUMBER    0008	1675
BAR				  CODE	    0040	 226
BARCHARS			  CODE	    02F5	1076
BAREINDE			  CODE	    031C	1119
BARLCD				  CODE	    0290	 997
BARLCD1				  CODE	    02CB	1031
BARLCD2				  CODE	    02D2	1036
BARLCD3				  CODE	    02DB	1044
BARLCD4				  CODE	    02E0	1048
BARLCDE				  CODE	    02E8	1053
BARLCD_1			  CODE	    02AB	1013
BATRANS				  CODE	    0627	2012
BATRANS1			  CODE	    062C	2014
BATRANS2			  CODE	    0630	2016
BCDHEX16			  CODE	    06EA	2291
BCDHEX161			  CODE	    06F8	2299
BCDHEX1611			  CODE	    0701	2303
BCDHEX1612			  CODE	    070B	2308
BCDHEX1613			  CODE	    0714	2312
BCDHEX162			  CODE	    075F	2366
BCDHEX8				  CODE	    0675	2182
BCDHEX81			  CODE	    0683	2190
BCDHEX811			  CODE	    068C	2194
BCDHEX82			  CODE	    06AE	2218
BDELETE				  CODE	    05E7	1942
BDELETE1			  CODE	    05F5	1950
BDELETE2			  CODE	    0608	1961
BDELETE3			  CODE	    05F9	1952
BEEP				  NUMBER    0007	1676
BLANK				  NUMBER    0020	1670
BUILD				  CODE	    031D	1151
BUILD1				  CODE	    0335	1193
BUILD2				  CODE	    0344	1200
BUILD3				  CODE	    0338	1194
BUILD_ADR			  CODE	    032B	1188
BUZZER				  BIT	      F7	 451
CAP2				  BIT	      C8	 136
CCONV				  BIT	      DD	 157
CFG832				  DATA	      AF	  38
CGRAM				  NUMBER    0040	 466
CHIPID				  DATA	      C2	  52
CLEARDISP			  NUMBER    0001	 456
CLOSED				  NUMBER    0043	 370
CMP16				  CODE	    1166	5008
CMP161				  CODE	    1183	5027
CMP162				  CODE	    118F	5036
CMP32				  CODE	    1207	5155
CMP321				  CODE	    1230	5182
CMP322				  CODE	    123C	5191

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CNT2				  BIT	      C9	 137
CORDIC				  CODE	    12D0	5342
CORDIC0				  CODE	    133B	5407
CORDIC00			  CODE	    1321	5392
CORDIC000			  CODE	    12F4	5366
CORDIC1				  CODE	    134F	5421
CORDIC2				  CODE	    1383	5471
CORDIC3				  CODE	    138E	5478
CORDIC4				  CODE	    13B3	5512
CORDIC40			  CODE	    13B8	5516
CORDIC41			  CODE	    13D1	5532
CORDIC5				  CODE	    13D7	5538
CORDIC50			  CODE	    13E9	5548
CORDIC51			  CODE	    1402	5563
CORDIC52			  CODE	    140D	5572
CORDIC5A			  CODE	    13E7	5547
CORDIC5B			  CODE	    1400	5562
CORDIC_ATAN			  CODE	    1410	5578
CORDIC_ERROR			  CODE	    1304	5374
CORDIC_MIN90			  CODE	    1309	5378
CORDIC_NUL			  CODE	    132D	5398
CORDIC_PLUS90			  CODE	    1315	5385
CPHA				  BIT	      FA	 174
CPOL				  BIT	      FB	 175
CR				  NUMBER    000D	1673
CS0				  BIT	      D8	 152
CS1				  BIT	      D9	 153
CS2				  BIT	      DA	 154
CS3				  BIT	      DB	 155
CURSATHOM			  NUMBER    0002	 457
CURSOROFF			  NUMBER    000C	 462
CURSORONB			  NUMBER    000F	 463
CURSORONN			  NUMBER    000E	 464
CY				  BIT	      D7	 151
D0				  BIT	      ED	 161
D0EN				  BIT	      EB	 160
D1				  BIT	      EF	 163
D1EN				  BIT	      EE	 162
DAC0H				  DATA	      FA	  82
DAC0L				  DATA	      F9	  81
DAC1H				  DATA	      FC	  84
DAC1L				  DATA	      FB	  83
DACCON				  DATA	      FD	  85
DCON				  DATA	      E8	  70
DDRAM				  NUMBER    0080	 467
DEBOUNCE			  NUMBER    0042	 369
DELAY				  CODE	    0076	 261
DELAY2MS			  CODE	    0352	1217
DELAY2MS1			  CODE	    0358	1220
DELAY60US			  CODE	    0363	1237
DELAY60US1			  CODE	    0375	1251
DELAY60US2			  CODE	    0373	1250
DIPSWITCH			  NUMBER    0001	 323
DISPDPTR			  CODE	    053D	1784
DISPDPTRLCD			  CODE	    0157	 672
DISPLAYOF			  NUMBER    0008	 461

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DISPLAYON			  NUMBER    0001	 460
DIV16				  CODE	    0C4C	3760
DIV160				  CODE	    0C5A	3771
DIV161				  CODE	    0C78	3794
DIV162				  CODE	    0C8B	3810
DIV163				  CODE	    0CA7	3835
DIV164				  CODE	    0CB9	3853
DIV32				  CODE	    0CF6	3924
DIV320				  CODE	    0D06	3937
DIV320A				  CODE	    0D10	3948
DIV320B				  CODE	    0D2E	3976
DIV320C				  CODE	    0D53	4004
DIV322				  CODE	    0D78	4038
DIV323				  CODE	    0DC2	4114
DIV324				  CODE	    0DF4	4164
DIV8				  CODE	    0C09	3687
DIV81				  CODE	    0C21	3703
DMA				  BIT	      DE	 158
DMAH				  DATA	      D3	  62
DMAL				  DATA	      D2	  61
DMAP				  DATA	      D4	  63
DPCON				  DATA	      A7	  34
DPH				  DATA	      83	  11
DPL				  DATA	      82	  10
DPP				  DATA	      84	  12
E				  BIT	      F1	 448
EA				  BIT	      AF	 111
EADC				  BIT	      AE	 110
EADRH				  DATA	      C7	  54
EADRL				  DATA	      C6	  53
ECON				  DATA	      B9	  46
EDATA1				  DATA	      BC	  47
EDATA2				  DATA	      BD	  48
EDATA3				  DATA	      BE	  49
EDATA4				  DATA	      BF	  50
ENDBUF				  NUMBER    007F	1682
ENTRYMODE			  NUMBER    0006	 459
ES				  BIT	      AC	 108
ET0				  BIT	      A9	 105
ET1				  BIT	      AB	 107
ET2				  BIT	      AD	 109
EX0				  BIT	      A8	 104
EX1				  BIT	      AA	 106
EXEN2				  BIT	      CB	 139
EXF2				  BIT	      CE	 142
F0				  BIT	      D5	 149
F1				  BIT	      D1	 145
FF				  NUMBER    000C	1672
FUNCTIONS			  NUMBER    0028	 465
HEXBCD16			  CODE	    0768	2402
HEXBCD161			  CODE	    0776	2409
HEXBCD16_U			  CODE	    076B	2403
HEXBCD8				  CODE	    06B7	2243
HEXBCD81			  CODE	    06C1	2248
HEXBCD82			  CODE	    06C6	2250
HEXBCD83			  CODE	    06D0	2256

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBUF2LCD			  CODE	    0233	 938
HEXBUF2LCD1			  CODE	    0257	 954
HEXBUF2LCDE			  CODE	    026E	 965
HEXBUFTXT			  CODE	    027C	 974
HOUR				  DATA	      A5	  32
HTHSEC				  DATA	      A2	  29
I2CADD				  DATA	      9B	  24
I2CCON				  DATA	      E8	  71
I2CDAT				  DATA	      9A	  23
I2CI				  BIT	      E8	 164
I2CINBYTEA1			  CODE	    03BF	1359
I2CINBYTEACK			  CODE	    03B8	1356
I2CINBYTEN1			  CODE	    03E0	1383
I2CINBYTENACK			  CODE	    03D9	1380
I2CINIT				  CODE	    037D	1301
I2CM				  BIT	      EB	 167
I2COUTBYTE			  CODE	    0398	1333
I2COUTBYTE1			  CODE	    039F	1336
I2CPCF8574			  NUMBER    0040	1292
I2CPCF8574A			  NUMBER    0070	1293
I2CRCVDATA			  CODE	    043A	1485
I2CRCVDATA1			  CODE	    0459	1503
I2CRCVDATA2			  CODE	    0462	1507
I2CRCVDATA3			  CODE	    0469	1512
I2CRCVERROR			  CODE	    0475	1520
I2CRS				  BIT	      EA	 166
I2CSENDDATA			  CODE	    03FA	1423
I2CSENDDATA1			  CODE	    0419	1440
I2CSENDERROR			  CODE	    042F	1453
I2CSTART			  CODE	    0386	1310
I2CSTOP				  CODE	    038F	1319
I2CTX				  BIT	      E9	 165
IE				  DATA	      A8	  35
IE0				  BIT	      89	  87
IE1				  BIT	      8B	  89
IEIP2				  DATA	      A9	  36
INBUFA				  CODE	    05AC	1899
INBUFA1				  CODE	    05C3	1916
INBUFA2				  CODE	    05B2	1902
INBUFA3				  CODE	    05D0	1922
INBUFA4				  CODE	    05C9	1918
INBUFA5				  CODE	    05E3	1930
INBUFA6				  CODE	    05D9	1926
INBUFA7				  CODE	    05CB	1919
INBYTE				  CODE	    058C	1867
INBYTE1				  CODE	    05A9	1879
INCHAR				  CODE	    0584	1851
INFLOOP				  CODE	    001C	 201
INITLCD				  CODE	    0087	 482
INITLCD1			  CODE	    0098	 499
INITSIO				  CODE	    04EA	1696
INITSIO1			  CODE	    04F3	1700
INITSIOE			  CODE	    0509	1717
INT0				  BIT	      B2	 114
INT1				  BIT	      B3	 115
INTVAL				  DATA	      A6	  33

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
IP				  DATA	      B8	  45
ISPI				  BIT	      FF	 179
IT0				  BIT	      88	  86
IT1				  BIT	      8A	  88
KEY				  NUMBER    0038	 356
KEY1				  CODE	    15BE	6152
KEY2				  CODE	    15CB	6159
KEYDOWN				  CODE	    1590	6124
KEYEDGE				  CODE	    15A9	6140
KEYFLAGS			  NUMBER    0020	 331
KEYINIT1			  CODE	    14F8	5895
KEYMAP				  NUMBER    0030	 350
KEYMODE				  BIT	      01	 335
KEYSCAN				  CODE	    152D	5972
KEYVALID			  BIT	      00	 333
KEY_INIT			  CODE	    14EA	5887
KOLOMLOOP			  CODE	    15CD	6161
LCDBUZOFF			  CODE	    04D9	1641
LCDBUZON			  CODE	    04CC	1625
LCDLIGHTOFF			  CODE	    04BF	1609
LCDLIGHTON			  CODE	    04B2	1592
LCDPORT				  NUMBER    00F0	 447
LCDTOPORT			  CODE	    0499	1566
LF				  NUMBER    000A	1674
LOWLOGIC			  CODE	    1646	6344
LOWUPTR				  CODE	    061A	1996
LOWUPTR1			  CODE	    061D	1997
LOWUPTR2			  CODE	    0626	2001
LOWUPTR3			  CODE	    0622	1999
MAGSIG16			  CODE	    07D7	2514
MAGSIG16A			  CODE	    07E8	2523
MAGSIG16ACC1			  CODE	    07F7	2547
MAGSIG16ACC1A			  CODE	    0808	2556
MAGSIG16ACC1B			  CODE	    0803	2553
MAGSIG16ACC1C			  CODE	    0812	2564
MAGSIG16B			  CODE	    07E3	2520
MAGSIG16C			  CODE	    07F2	2531
MAGSIG32			  CODE	    0817	2581
MAGSIG32A			  CODE	    0828	2590
MAGSIG32ACC1			  CODE	    0841	2626
MAGSIG32ACC1A			  CODE	    0852	2635
MAGSIG32ACC1B			  CODE	    084D	2632
MAGSIG32ACC1C			  CODE	    0866	2652
MAGSIG32B			  CODE	    0823	2587
MAGSIG32C			  CODE	    083C	2607
MAGSIG8				  CODE	    07A3	2455
MAGSIG8A			  CODE	    07B4	2464
MAGSIG8ACC1			  CODE	    07BD	2485
MAGSIG8ACC1A			  CODE	    07CE	2494
MAGSIG8ACC1B			  CODE	    07C9	2491
MAGSIG8ACC1C			  CODE	    07D2	2498
MAGSIG8B			  CODE	    07AF	2461
MAGSIG8C			  CODE	    07B8	2468
MAP01PTR			  NUMBER    0030	 352
MAP23PTR			  NUMBER    0034	 355
MATRIX				  NUMBER    0001	 321

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MCO				  BIT	      ED	 169
MDE				  BIT	      EE	 170
MDI				  BIT	      EC	 168
MDO				  BIT	      EF	 171
MIN				  DATA	      A4	  31
MUL16				  CODE	    0AC1	3346
MUL16ACC1			  CODE	    0B26	3435
MUL16_10			  CODE	    0EE5	4422
MUL16_100			  CODE	    0F1A	4470
MUL16_I_PI			  CODE	    0E82	4326
MUL16_I_SQRT2			  CODE	    0EC4	4391
MUL16_PI			  CODE	    0E61	4295
MUL16_SQRT2			  CODE	    0EA3	4358
MUL816				  CODE	    0BAE	3582
MULDIV				  CODE	    0E25	4237
MULDIV1				  CODE	    0E35	4249
NEGEDGE				  NUMBER    0044	 371
NEGVALID			  BIT	      03	 340
NOKEY				  CODE	    15E5	6182
OUTBYTE				  CODE	    0529	1764
OUTBYTELCD			  CODE	    0146	 653
OUTC				  CODE	    01F3	 859
OUTCHAR				  CODE	    050D	1731
OUTCHAR1			  CODE	    050F	1732
OUTCHARLCD			  CODE	    00E5	 568
OUTCHARLCD1			  CODE	    00EC	 571
OUTCHARLCD2			  CODE	    00F6	 575
OUTCHARLCD2_0			  CODE	    00F1	 573
OUTCHARLCD3			  CODE	    00FF	 585
OUTCHARLCD4			  CODE	    0106	 589
OUTCHARLCD5			  CODE	    010D	 593
OUTCHARLCD6			  CODE	    0114	 597
OUTCHARLCD7			  CODE	    011B	 601
OUTCHARLCD8			  CODE	    0122	 609
OUTCHARLCD9			  CODE	    0127	 617
OUTCHARLCDE			  CODE	    012A	 618
OUTD				  CODE	    01B9	 781
OUTHNIBC			  CODE	    0209	 901
OUTHNIBD			  CODE	    01C9	 829
OUTMSGA				  CODE	    0550	1803
OUTMSGA1			  CODE	    0565	1814
OUTMSGA2			  CODE	    0558	1807
OUTMSGALCD			  CODE	    016A	 696
OUTMSGALCD1			  CODE	    0172	 703
OUTMSGALCDE			  CODE	    017D	 713
OUTNIB				  CODE	    0515	1745
OUTNIBLCD			  CODE	    012F	 632
OUTNIBLCD1			  CODE	    013A	 637
OUTNIBLCDE			  CODE	    013E	 639
OV				  BIT	      D2	 146
P				  BIT	      D0	 144
P0				  DATA	      80	   8
P1				  DATA	      90	  20
P2				  DATA	      A0	  27
P3				  DATA	      B0	  39
PADC				  BIT	      BE	 126

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
PCF8574A			  NUMBER    0001	1295
PCON				  DATA	      87	  13
PLLCON				  DATA	      D7	  64
PORTTOLCD			  CODE	    0480	1538
POSEDGE				  NUMBER    0045	 372
POSVALID			  BIT	      04	 342
PRE0				  BIT	      C4	 132
PRE1				  BIT	      C5	 133
PRE2				  BIT	      C6	 134
PRE3				  BIT	      C7	 135
PS				  BIT	      BC	 124
PSI				  BIT	      BF	 127
PSMCON				  DATA	      DF	  68
PSW				  DATA	      D0	  60
PT0				  BIT	      B9	 121
PT1				  BIT	      BB	 123
PT2				  BIT	      BD	 125
PWM0H				  DATA	      B2	  41
PWM0L				  DATA	      B1	  40
PWM1H				  DATA	      B4	  43
PWM1L				  DATA	      B3	  42
PWMCON				  DATA	      AE	  37
PX0				  BIT	      B8	 120
PX1				  BIT	      BA	 122
RB8				  BIT	      9A	  98
RCAP2H				  DATA	      CB	  57
RCAP2L				  DATA	      CA	  56
RCLK				  BIT	      CD	 141
RD				  BIT	      B7	 119
READ_PORT3			  CODE	    1642	6340
READ_SWITCH			  CODE	    162F	6317
READ_SWITCH1			  CODE	    165E	6362
READ_SWITCH2			  CODE	    1669	6368
REGTOLCD			  CODE	    0186	 733
REGTOLCD1			  CODE	    0197	 743
REGTOLCD2			  CODE	    01A5	 753
REN				  BIT	      9C	 100
RI				  BIT	      98	  96
RIJLOOP				  CODE	    15C0	6153
RS				  BIT	      F0	 449
RS0				  BIT	      D3	 147
RS1				  BIT	      D4	 148
RXD				  BIT	      B0	 112
SBUF				  DATA	      99	  22
SCANLOOP			  CODE	    1548	5989
SCON				  DATA	      98	  21
SCONV				  BIT	      DC	 156
SEC				  DATA	      A3	  30
SHIFTLEFT1			  CODE	    1091	4785
SHIFTLEFT2			  CODE	    1099	4791
SHIFTLEFT3			  CODE	    109D	4793
SHIFTLEFT32			  CODE	    1089	4781
SHIFTRIGHT1			  CODE	    1065	4740
SHIFTRIGHT2			  CODE	    106D	4746
SHIFTRIGHT3			  CODE	    1071	4748
SHIFTRIGHT32			  CODE	    105D	4736

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SIGMAG16ACC0			  CODE	    089D	2725
SIGMAG16ACC0A			  CODE	    08AC	2734
SIGMAG16ACC1			  CODE	    08BD	2760
SIGMAG16ACC1A			  CODE	    08CC	2769
SIGMAG16ACC1H			  CODE	    08DD	2795
SIGMAG16ACC1HA			  CODE	    08EC	2804
SIGMAG32ACC0			  CODE	    08FD	2832
SIGMAG32ACC0A			  CODE	    090C	2841
SIGMAG32ACC1			  CODE	    0927	2876
SIGMAG32ACC1A			  CODE	    0936	2885
SIGMAG8ACC0			  CODE	    086B	2669
SIGMAG8ACC0A			  CODE	    087A	2677
SIGMAG8ACC1			  CODE	    0884	2697
SIGMAG8ACC1A			  CODE	    0893	2705
SKIP_ADD			  CODE	    0046	 229
SM0				  BIT	      9F	 103
SM1				  BIT	      9E	 102
SM2				  BIT	      9D	 101
SP				  DATA	      81	   9
SPE				  BIT	      FD	 177
SPH				  DATA	      B7	  44
SPICON				  DATA	      F8	  80
SPIDAT				  DATA	      F7	  79
SPIM				  BIT	      FC	 176
SPR0				  BIT	      F8	 172
SPR1				  BIT	      F9	 173
SQRT32				  CODE	    0F70	4542
SQRT320				  CODE	    0F97	4564
SQRT321				  CODE	    0F9C	4566
SQRT322				  CODE	    0FFF	4648
SQRT323				  CODE	    1005	4652
SQRT324				  CODE	    1028	4676
SQRT3240			  CODE	    1023	4674
SQRT325				  CODE	    102B	4678
STACK_INIT			  NUMBER    0090	 182
START				  CODE	    0003	 189
STARTBUFFER			  NUMBER    0080	 184
STRTBUF				  NUMBER    0054	1681
SUB16				  CODE	    0A37	3184
SUB161				  CODE	    0A4C	3201
SUB32				  CODE	    0A9E	3301
SUB321				  CODE	    0AB9	3326
SWINIT				  CODE	    1619	6238
SWITCH1				  NUMBER    0040	 367
SWITCH2				  NUMBER    0041	 368
SWITCHMAP			  NUMBER    0040	 366
SWITCH_INIT			  CODE	    160B	6230
SWVALID				  BIT	      02	 338
S_ADD16				  CODE	    0951	2922
S_ADD161			  CODE	    0975	2948
S_ADD162			  CODE	    0979	2950
S_ADD163			  CODE	    097F	2955
S_ADD32				  CODE	    09A1	3015
S_ADD321			  CODE	    09C9	3046
S_ADD322			  CODE	    09CB	3047
S_ADD323			  CODE	    09D1	3052

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_CMP16				  CODE	    111A	4934
S_CMP160			  CODE	    112D	4951
S_CMP161			  CODE	    113B	4961
S_CMP162			  CODE	    1149	4971
S_CMP163			  CODE	    1158	4983
S_CMP32				  CODE	    1199	5058
S_CMP320			  CODE	    11B4	5078
S_CMP321			  CODE	    11C8	5092
S_CMP322			  CODE	    11DC	5106
S_CMP323			  CODE	    11F3	5126
S_DIV16				  CODE	    0C29	3725
S_DIV161			  CODE	    0C37	3735
S_DIV32				  CODE	    0CD1	3887
S_DIV321			  CODE	    0CE1	3899
S_DIV8				  CODE	    0BF7	3664
S_DIV81				  CODE	    0C08	3670
S_MAC16				  CODE	    0BD5	3624
S_MAC161			  CODE	    0BF1	3644
S_MUL16				  CODE	    0B87	3526
S_MUL16ACC1			  CODE	    0B94	3544
S_MUL816			  CODE	    0BA1	3563
S_MULDIV			  CODE	    0E00	4193
S_MULDIV1			  CODE	    0E10	4205
S_SHIFTLEFT1			  CODE	    10F4	4887
S_SHIFTLEFT2			  CODE	    10FC	4893
S_SHIFTLEFT3			  CODE	    1100	4898
S_SHIFTLEFT32			  CODE	    10EC	4883
S_SHIFTRIGHT1			  CODE	    10BD	4833
S_SHIFTRIGHT2			  CODE	    10C5	4839
S_SHIFTRIGHT20			  CODE	    10D1	4845
S_SHIFTRIGHT3			  CODE	    10D3	4847
S_SHIFTRIGHT32			  CODE	    10B5	4829
S_SQRT32			  CODE	    1046	4709
S_SQRT321			  CODE	    1054	4717
S_SUB16				  CODE	    09F9	3120
S_SUB161			  CODE	    0A27	3155
S_SUB162			  CODE	    0A2B	3157
S_SUB163			  CODE	    0A31	3162
S_SUB32				  CODE	    0A54	3223
S_SUB321			  CODE	    0A90	3273
S_SUB322			  CODE	    0A92	3274
S_SUB323			  CODE	    0A98	3279
T0				  BIT	      B4	 116
T1				  BIT	      B5	 117
T2				  BIT	      90	  94
T2CON				  DATA	      C8	  55
T2EX				  BIT	      91	  95
T3CON				  DATA	      9E	  25
T3FD				  DATA	      9D	  26
TABLE_LU			  CODE	    1246	5218
TABLE_LU1			  CODE	    126B	5244
TABLE_LU2			  CODE	    127C	5257
TABLE_LU3			  CODE	    12B5	5300
TABLE_LU4			  CODE	    12C7	5313
TABLE_LU_10			  CODE	    1272	5249
TB8				  BIT	      9B	  99

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 123



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TCLK				  BIT	      CC	 140
TCON				  DATA	      88	  14
TF0				  BIT	      8D	  91
TF1				  BIT	      8F	  93
TF2				  BIT	      CF	 143
TH0				  DATA	      8C	  18
TH1				  DATA	      8D	  19
TH2				  DATA	      CD	  59
TI				  BIT	      99	  97
TIJD				  NUMBER    0001	 183
TIMECON				  DATA	      A1	  28
TL0				  DATA	      8A	  16
TL1				  DATA	      8B	  17
TL2				  DATA	      CC	  58
TMOD				  DATA	      89	  15
TOETSIN				  CODE	    15D7	6172
TOETSTABEL			  CODE	    15FB	6199
TOETS_FLANK			  CODE	    150F	5926
TOETS_INGEDRUKT			  CODE	    151E	5949
TR0				  BIT	      8C	  90
TR1				  BIT	      8E	  92
TR2				  BIT	      CA	 138
TXD				  BIT	      B1	 113
WAIT_1MS			  CODE	    0072	 258
WAIT_SEL_MS			  CODE	    0065	 251
WCOL				  BIT	      FE	 178
WDCON				  DATA	      C0	  51
WDE				  BIT	      C1	 129
WDIR				  BIT	      C3	 131
WDS				  BIT	      C2	 130
WDWR				  BIT	      C0	 128
WISSEN				  CODE	    04E6	1678
WR				  BIT	      B6	 118
XOFF				  NUMBER    0013	1671
XONXOFF				  CODE	    056E	1831
XONXOFF1			  CODE	    057A	1837
XONXOFF2			  CODE	    0575	1834
XONXOFF3			  CODE	    057F	1839
