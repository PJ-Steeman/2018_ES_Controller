
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\HartslagmeterTotaal.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\HartslagmeterTotaal.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\HartslagmeterTotaal.lst



 Line  I  Addr  Code            Source

    1:				;Anton Peeters & Pieter-Jan Steeman
    2:
    3:				$nolist
  181:
  182:				;@====================================================================================@
  183:				;@ 										      @
  184:				;@ Initialisatie van de flags en variabelen					      @
  185:				;@ 										      @
  186:				;@====================================================================================@
  187:
  188:		N      0090	stack_init	equ	090h
  189:		N      0080	startbuffer	equ	080h
  190:		N      0071	rammsb		equ	071h
  191:		N      0070	ramlsb		equ	070h
  192:		N      0072	teller		equ	072h
  193:		N      0050	dispcount	equ	050h
  194:		N	 00	dispflag	bit	00h
  195:		N	 01	bpmflag		bit	01h
  196:		N      0051	vorige_samplel	equ	051h
  197:		N      0052	vorige_sampleh	equ	052h
  198:		N      0053	periodcountl	equ	053h
  199:		N      0054	periodcounth	equ	054h
  200:		N      0055	refl		equ	055h
  201:		N      0056	refh		equ	056h
  202:		N      0057	periodl		equ	057h
  203:		N      0058	periodh		equ	058h
  204:		N      0059	bpml		equ	059h
  205:		N      005A	bpmh		equ	05ah
  206:		N      0000			org	0000h
  207:
  208:	  0000	02 00 2E			ljmp	start
  209:		N      002B			org	002bh
  210:	  002B	02 00 CA			ljmp	int_rout
  211:
  212:				;@====================================================================================@
  213:				;@ 										      @
  214:				;@ start routine: de eerste routine die uitgevoerd wordt, die initialiseerd alle      @
  215:				;@		  timers, displaytekens(barchars), ...				      @
  216:				;@ 										      @
  217:				;@====================================================================================@
  218:
  219:	  002E	75 81 90	start:		mov	sp,#stack_init			;init van de stack
  220:	  0031	75 D7 00			mov	pllcon,#0

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  221:	  0034	7E 80				mov	r6,#startbuffer			;locatie van de start van de barrel
  222:	  0036	78 01				mov	r0,#1				;voor lcd init
  223:	  0038	75 50 0A			mov	dispcount,#10
  224:	  003B	C2 01				clr	bpmflag
  225:	  003D	C2 00				clr	dispflag
  226:	  003F	75 53 00			mov	periodcountl,#0
  227:	  0042	75 54 00			mov	periodcounth,#0
  228:	  0045	75 55 66			mov	refl,#66h
  229:	  0048	75 56 06			mov	refh,#06h
  230:	  004B	75 51 00			mov	vorige_samplel,#0
  231:	  004E	75 52 00			mov	vorige_sampleh,#0
  232:	  0051	75 57 00			mov	periodl,#0
  233:	  0054	75 58 00			mov	periodh,#0
  234:	  0057	75 59 00			mov	bpml,#0
  235:	  005A	75 5A 00			mov	bpmh,#0
  236:	  005D	12 01 A2			lcall	initlcd
  237:	  0060	12 05 CD			lcall	lcdlighton
  238:
  239:	  0063	12 15 49			lcall 	adc_init
  240:	  0066	75 FD 1D			mov	daccon,#00011101b
  241:
  242:	  0069	D2 D4				setb	rs1
  243:
  244:	  006B	90 04 10			mov	dptr,#barchars
  245:	  006E	12 04 38			lcall	build
  246:
  247:	  0071	D2 AF				setb	ea
  248:	  0073	D2 AD				setb	et2
  249:
  250:	  0075	75 CC B1			mov	tl2,#0b1h
  251:	  0078	75 CD E4			mov	th2,#0e4h
  252:	  007B	75 CA B1			mov	rcap2l,#0b1h			;wacht 5ms
  253:	  007E	75 CB E4			mov	rcap2h,#0e4h			;wacht 5ms
  254:	  0081	75 C8 04			mov	t2con,#00000100b
  255:
  256:				;@====================================================================================@
  257:				;@ 										      @
  258:				;@ een oneindige lus waarin de BPM wordt berekend, er wordt gekeken of de BAR en de   @
  259:				;@ BPM op het scherm getoond moeten woden	      				      @
  260:				;@ 										      @
  261:				;@====================================================================================@
  262:
  263:	  0084	30 00 05	loop:		jnb	dispflag,skiplcd
  264:	  0087	C2 00				clr	dispflag
  265:	  0089	12 01 4F			lcall	bar				;zet de waardes om naar een barchart
  266:	  008C	30 01 39	skiplcd:	jnb	bpmflag,skipbpm
  267:	  008F	C2 01				clr	bpmflag
  268:	  0091	A8 57				mov	r0,periodl			;zet in de juiste registers voor mul16
  269:	  0093	A9 58				mov	r1,periodh
  270:	  0095	7C 05				mov	r4,#5
  271:	  0097	7D 00				mov	r5,#0
  272:	  0099	12 0B DC			lcall	mul16
  273:	  009C	88 59				mov	bpml,r0				;zet resultaat in bmpl en bpmh
  274:	  009E	89 5A				mov	bpmh,r1
  275:	  00A0	78 60				mov	r0,#060h			;zet in de juiste registers voor div16 --> 6
				0000/bpm

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  276:	  00A2	79 EA				mov	r1,#0eah
  277:	  00A4	AC 59				mov	r4,bpml
  278:	  00A6	AD 5A				mov	r5,bpmh
  279:	  00A8	12 0D 67			lcall	div16
  280:	  00AB	79 00				mov	r1,#0
  281:	  00AD	12 08 83			lcall	hexbcd16
  282:	  00B0	74 80				mov	a,#080h
  283:	  00B2	12 02 00			lcall	outcharlcd
  284:	  00B5	E9				mov	a,r1
  285:	  00B6	12 02 61			lcall	outbytelcd
  286:	  00B9	74 82				mov	a,#082h
  287:	  00BB	12 02 00			lcall	outcharlcd
  288:	  00BE	E8				mov	a,r0
  289:	  00BF	12 02 61			lcall	outbytelcd
  290:	  00C2	90 01 93			mov	dptr,#text
  291:	  00C5	12 02 85			lcall	outmsgalcd
  292:	  00C8	80 BA		skipbpm:	sjmp	loop
  293:
  294:				;@====================================================================================@
  295:				;@ 										      @
  296:				;@ interrupt routine: Deze wordt uitgevoerd om de 5ms via een interrupt van TIMER 2.  @
  297:				;@ 										      @
  298:				;@====================================================================================@
  299:
  300:	  00CA	C0 E0		int_rout:	push	acc
  301:	  00CC	C0 D0				push	psw
  302:	  00CE	D2 A0				setb	p2.0
  303:	  00D0	C2 D4				clr	rs1
  304:	  00D2	C2 CF				clr	tf2
  305:	  00D4	C3				clr	c
  306:	  00D5	12 01 30			lcall	adcbuffer			;adc en buffer toewijzing
  307:	  00D8	12 01 66			lcall	gemiddelde
  308:	  00DB	12 01 46			lcall	todac
  309:	  00DE	A8 53				mov	r0,periodcountl
  310:	  00E0	A9 54				mov	r1,periodcounth
  311:	  00E2	7C 01				mov	r4,#1
  312:	  00E4	7D 00				mov	r5,#0
  313:	  00E6	12 0A A0			lcall	add16
  314:	  00E9	88 53				mov	periodcountl,r0
  315:	  00EB	89 54				mov	periodcounth,r1
  316:	  00ED	15 50				dec	dispcount
  317:	  00EF	E5 50				mov	a,dispcount
  318:	  00F1	B4 00 05			cjne	a,#0,skipdispreset
  319:	  00F4	75 50 0A			mov	dispcount,#10
  320:	  00F7	D2 00				setb	dispflag
  321:
  322:				;@====================================================================================@
  323:				;@ 										      @
  324:				;@ subroutine skipdisreset: slaag de set van de displayflag over en tel het aantal    @
  325:				;@		  	    periodes voor er een hartslag is			      @
  326:				;@ 										      @
  327:				;@====================================================================================@
  328:
  329:	  00F9	AC 55		skipdispreset:	mov	r4,refl				;zet in de juiste registers voor cmp16
  330:	  00FB	AD 56				mov	r5,refh
  331:	  00FD	A8 51				mov	r0,vorige_samplel

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  332:	  00FF	A9 52				mov	r1,vorige_sampleh
  333:	  0101	12 12 81			lcall	cmp16
  334:	  0104	30 D7 1C			jnb	cy,skipref
  335:	  0107	A8 70				mov	r0,ramlsb
  336:	  0109	A9 71				mov	r1,rammsb
  337:	  010B	AC 55				mov	r4,refl
  338:	  010D	AD 56				mov	r5,refh
  339:	  010F	12 12 81			lcall	cmp16
  340:	  0112	20 D7 0E			jb	cy,skipref
  341:	  0115	85 53 57			mov	periodl,periodcountl
  342:	  0118	85 54 58			mov	periodh,periodcounth
  343:	  011B	75 53 00			mov	periodcountl,#0
  344:	  011E	75 54 00			mov	periodcounth,#0
  345:	  0121	D2 01				setb	bpmflag
  346:	  0123	85 70 51	skipref:	mov	vorige_samplel,ramlsb
  347:	  0126	85 71 52			mov	vorige_sampleh,rammsb
  348:	  0129	D0 D0				pop	psw
  349:	  012B	D0 E0				pop	acc
  350:	  012D	C2 A0				clr	p2.0
  351:	  012F	32				reti
  352:
  353:				;@====================================================================================@
  354:				;@ 										      @
  355:				;@ subroutine adcbuffer: Hier wordt het analoge signaal omgezet naar een analoog      @
  356:				;@			 signaal een vervolgens in het barrelregister geplaatst	      @
  357:				;@ 										      @
  358:				;@====================================================================================@
  359:
  360:	  0130	78 20		adcbuffer:	mov	r0,#00100000b			;initialiseer de nodige waardes voor een 12b
				it signaal
  361:	  0132	12 15 5B			lcall	adc_single
  362:	  0135	E8				mov	a,r0				;zet ingelezen waardes in r2 en r3(lsb en ms
				b)
  363:	  0136	FA				mov	r2,a
  364:	  0137	E9				mov	a,r1
  365:	  0138	FB				mov	r3,a
  366:	  0139	EE				mov	a,r6
  367:	  013A	F8				mov	r0,a
  368:	  013B	EA				mov	a,r2
  369:	  013C	F6				mov	@r0,a				;zet lsb in barrel
  370:	  013D	08				inc	r0
  371:	  013E	EB				mov	a,r3
  372:	  013F	F6				mov	@r0,a				;zet msb in barrel
  373:	  0140	08				inc	r0
  374:	  0141	E8				mov	a,r0
  375:	  0142	54 8F				anl	a,#08fh				;indien buiten barrelregister zou gaan --> t
				erug naar onder
  376:	  0144	FE				mov	r6,a
  377:	  0145	22				ret
  378:
  379:				;@====================================================================================@
  380:				;@ 										      @
  381:				;@ subroutine todac: Zet het digitale signaal om naar een analoge sinus		      @
  382:				;@ 										      @
  383:				;@====================================================================================@
  384:

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  385:	  0146	A9 71		todac:		mov	r1,rammsb			;gemiddelde msb in r1
  386:	  0148	89 FA				mov	dac0h,r1			;gemiddelde msb naar DAC
  387:	  014A	A8 70				mov	r0,ramlsb			;gemiddelde lsb in r0
  388:	  014C	88 F9				mov	dac0l,r0			;gemiddelde lsb naar DAC
  389:	  014E	22				ret
  390:
  391:				;@====================================================================================@
  392:				;@ 										      @
  393:				;@ subroutine bar: Hier worden de ramlsb en rammsb omgezet in een barchar.	      @
  394:				;@ 										      @
  395:				;@====================================================================================@
  396:
  397:	  014F	A9 71		bar:		mov	r1,rammsb			;gemiddelde msb in r1
  398:	  0151	A8 70				mov	r0,ramlsb			;gemiddelde lsb in r0
  399:	  0153	7D 00				mov	r5,#0
  400:	  0155	7C 69				mov	r4,#105				;nodig voor div16 (4096/40)
  401:	  0157	12 0D 67			lcall	div16				;quotient terug in r0
  402:	  015A	E8				mov	a,r0
  403:						;lcall	outbytelcd
  404:	  015B	FA				mov	r2,a				;zet de waarde om in bars
  405:	  015C	78 28				mov	r0,#40
  406:	  015E	74 40				mov	a,#40h
  407:	  0160	8A F0				mov	b,r2
  408:	  0162	12 03 AB			lcall	barlcd
  409:	  0165	22				ret
  410:
  411:				;@====================================================================================@
  412:				;@ 										      @
  413:				;@ subroutine gemiddele: Hier wordt het gemiddelde berekend van het circulaire 	      @
  414:				;@ register, deze waardes worden opgeslaan in ramlsb en rammsb.			      @
  415:				;@ 										      @
  416:				;@====================================================================================@
  417:
  418:	  0166	7F 80		gemiddelde:	mov	r7,#startbuffer			;start van de barrel in r7
  419:	  0168	75 72 08			mov	teller,#8			;looptiloop init
  420:	  016B	79 00				mov	r1,#0
  421:	  016D	78 00				mov	r0,#0
  422:	  016F	E9		looptiloop:	mov	a,r1
  423:	  0170	FB				mov	r3,a
  424:	  0171	EF				mov	a,r7
  425:	  0172	F9				mov	r1,a
  426:	  0173	E7				mov	a,@r1
  427:	  0174	FC				mov	r4,a				;lsb in r4
  428:	  0175	09				inc	r1
  429:	  0176	E7				mov	a,@r1				;msb in r5
  430:	  0177	FD				mov	r5,a
  431:	  0178	09				inc	r1
  432:	  0179	E9				mov	a,r1
  433:	  017A	FF				mov	r7,a
  434:	  017B	EB				mov	a,r3
  435:	  017C	F9				mov	r1,a
  436:	  017D	12 0A A0			lcall	add16				;16 bit opteller
  437:	  0180	E5 72				mov	a,teller
  438:	  0182	14				dec	a
  439:	  0183	F5 72				mov	teller,a
  440:	  0185	70 E8				jnz	looptiloop

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  441:	  0187	7D 00				mov	r5,#0
  442:	  0189	7C 08				mov	r4,#8
  443:	  018B	12 0D 67			lcall	div16
  444:	  018E	88 70				mov	ramlsb,r0			;lsb in RAM
  445:	  0190	89 71				mov	rammsb,r1			;msb in RAM
  446:	  0192	22				ret
  447:
  448:				;@====================================================================================@
  449:				;@ 										      @
  450:				;@ database tekst: Deze database bevat de tekst die op het display moet worden gezet. @
  451:				;@										      @
  452:				;@====================================================================================@
  453:
  454:	  0193	13 84		text:		db	013h,84h
  455:	  0195	20 42 50 4D			db	' BPM     APS',0
	  0199	20 20 20 20
	  019D	20 41 50 53
	  01A1	00
  456:
  457:				$include (c:/aduc800_mideA.inc)
  458: 1			;******************************************************************************
  459: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  460: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  461: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  462: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  463: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  464: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  465: 1			;******************************************************************************
  466: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  467: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  468: 1			;******************************************************************************
  469: 1
  470: 1
  471: 1			;******************************************************************************
  472: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  473: 1			; hebben voor onze toepassing. Door een module te definieren via het
  474: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  475: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  476: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  477: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  478: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  479: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  480: 1			; definities.
  481: 1			;******************************************************************************
  482: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  483: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  484: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  485: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  486: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  487: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  488: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  489: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  490: 1
  491: 1			ifdef    aduc_key
  492: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  493: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  494: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  495: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  496: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  497: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  498: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  499: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  500: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  501: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  502: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  503: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  504: 1			;definities wel gemaakt worden.
  505: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  506: 1			                            ;anders commentaar van maken!
  507: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  508: 1			                            ;gelezen, anders commentaar van maken!
  509: 1			;******************************************************************************
  510: 1			;Declaraties van de flags voor de aduc_key driver.
  511: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  512: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  513: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  514: 1			;switch_init en read_switch.
  515: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  516: 1			                                ;bereik = 20h-2fh!
  517: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  518: 1			                                   ;een geldige waarde bevat
  519: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  520: 1			                                   ;die de detectie mode aangeeft
  521: 1			;declaratie van de read_switch flags
  522: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  523: 1			                                   ;ontdenderde schakelaars zijn
  524: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  525: 1			                                   ;flanken zijn
  526: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  527: 1			                                   ;flanken zijn
  528: 1			ifdef    matrix        ;matrix keyboard
  529: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  530: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  531: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  532: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  533: 1			;toepassing.
  534: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  535: 1			                                ;geheugenbuffer
  536: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  537: 1			                                ;debounce en de flankdetectie samples stockeren
  538: 1			                                ;de eerste 4 bytes dienen voor debouncing
  539: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  540: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  541: 1			                                ;toetswaarde aangeeft
  542: 1			                                ;bij een geldige keyvalid flag ('1')
  543: 1			endif    ;einde matrix keyboard
  544: 1
  545: 1			ifdef    dipswitch
  546: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  547: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  548: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  549: 1			;toepassing

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  550: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  551: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  552: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  553: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  554: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  555: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  556: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  557: 1			endif    ;einde dipswitch
  558: 1			;******************************************************************************
  559: 1			endif    ;einde aduc_key
  560: 1
  561: 1
  562: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  563: 1
  564: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  565: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  566: 1			endif                               ;dus doen we dit hier nog eens!
  567: 1			;******************************************************************************
  568: 1
  569: 1			;******************************************************************************
  570: 1			;
  571: 1			; ADuc_lcd.inc
  572: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  573: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  574: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  575: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  576: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  577: 1			; het plaatsen van de cursor op een correcte plaats).
  578: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  579: 1			; display gebruiken.
  580: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  581: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  582: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  583: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  584: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  585: 1			;
  586: 1			; Versie ADuC832v1.1:
  587: 1			; Hier is het LCD verbonden met pinnen van poort0
  588: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  589: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  590: 1			;
  591: 1			; Versie ADuC832v2.2:
  592: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  593: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  594: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  595: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  596: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  597: 1			;
  598: 1			;
  599: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  600: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  601: 1			;  aduclcd0.inc
  602: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  603: 1			;  aduclcd1.inc
  604: 1			;    -00dh en 00ah worden door outchar verwerkt
  605: 1			;    -bij de init wordt het display anders opgestart

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  606: 1			;
  607: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  608: 1			;  van gebruik en uitgebreid  met :
  609: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  610: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  611: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  612: 1			;    debug doeleinden
  613: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  614: 1			;    user codes aan te maken
  615: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  616: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  617: 1			;
  618: 1			; Beschikbare routines:
  619: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  620: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  621: 1			; build_adr, delay2ms, delay60us
  622: 1			;******************************************************************************
  623: 1
  624: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  625: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  626: 1			e             bit    lcdport.2            ;enable
  627: 1			rs            bit    lcdport.3            ;register select
  628: 1			endif    ;einde aduc832_v1_1
  629: 1
  630: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  631: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  632: 1	B	 F1	e             bit    lcdport.1            ;enable
  633: 1	B	 F0	rs            bit    lcdport.0            ;register select
  634: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  635: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  636: 1			endif    ;einde aduc832_v2_0
  637: 1
  638: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  639: 1			;het uitvoeren van de overeenkomstige commando's.
  640: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  641: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  642: 1
  643: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  644: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  645: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  646: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  647: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  648: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  649: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  650: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  651: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  652: 1
  653: 1			;******************************************************************************
  654: 1			;
  655: 1			; initlcd
  656: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  657: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  658: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  659: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  660: 1			; Na initialisering wordt het scherm leeg gemaakt.
  661: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  662: 1			; registergebruik: geen
  663: 1			;
  664: 1			;******************************************************************************
  665: 1
  666: 1  01A2	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  667: 1  01A4	C0 D0		              push   psw
  668: 1  01A6	C0 F0		              push   b
  669: 1			ifdef  aduc832_v1_1
  670: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  671: 1			                                   ;let op:twee laagste bits worden
  672: 1			                                   ;niet gebruikt
  673: 1			endif
  674: 1
  675: 1			ifdef    aduc832_v2_0
  676: 1  01A8	12 04 98	              lcall  i2cinit              ;LCD via een I2C bus
  677: 1  01AB	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  678: 1			                                          ;buzzer en backlight  op 1 gezet
  679: 1  01AE	12 05 9B	              lcall  porttolcd            ;data uit b naar het scherm
  680: 1			endif
  681: 1
  682: 1  01B1	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  683: 1  01B3	12 04 6D	initlcd1:     lcall  delay2ms
  684: 1  01B6	D5 E0 FA	              djnz   acc,initlcd1
  685: 1  01B9	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  686: 1  01BB	12 03 24	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  687: 1  01BE	12 04 6D	              lcall  delay2ms      ;om het display altijd opgestart
  688: 1  01C1	74 30		              mov    a,#00110000b  ;te krijgen.
  689: 1  01C3	12 03 24	              lcall  outhnibc
  690: 1  01C6	12 04 6D	              lcall  delay2ms
  691: 1  01C9	74 30		              mov    a,#00110000b
  692: 1  01CB	12 03 24	              lcall  outhnibc
  693: 1  01CE	12 04 6D	              lcall  delay2ms
  694: 1  01D1	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  695: 1  01D3	12 03 24	              lcall  outhnibc      ;hoge nibble naar het controleregister
  696: 1  01D6	12 04 6D	              lcall  delay2ms      ;niet nodig volgens datasheet
  697: 1  01D9	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  698: 1  01DB	12 03 0E	              lcall  outc          ;naar display
  699: 1  01DE	12 04 6D	              lcall  delay2ms      ;is iets te lang volgens datasheet
  700: 1  01E1	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  701: 1  01E3	12 03 0E	              lcall  outc
  702: 1  01E6	12 04 6D	              lcall  delay2ms      ;ook deze delay is iets te lang
  703: 1  01E9	74 01		              mov    a,#displayon  ;clear display and home cursor
  704: 1  01EB	12 03 0E	              lcall  outc
  705: 1  01EE	12 04 6D	              lcall  delay2ms      ;deze wachttijd is bijna juist
  706: 1  01F1	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  707: 1  01F3	12 03 0E	              lcall  outc
  708: 1  01F6	12 04 6D	              lcall  delay2ms      ;wachten weer veel te lang
  709: 1  01F9	D0 F0		              pop    b
  710: 1  01FB	D0 D0		              pop    psw           ;registers terug in orde zetten
  711: 1  01FD	D0 E0		              pop    acc
  712: 1  01FF	22		              ret                  ;einde van de initialisatie
  713: 1
  714: 1			;******************************************************************************
  715: 1			;
  716: 1			; outcharlcd
  717: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  718: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  719: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  720: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  721: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  722: 1			; De controlekarakters komen overeen met volgende acties:
  723: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  724: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  725: 1			;              (line feed+ carriage return!)
  726: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  727: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  728: 1			;      011h   =cursor on, blink mode
  729: 1			;      012h   =cursor on, no blink mode
  730: 1			;      013h   =cursor off
  731: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  732: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  733: 1			;              van het LCD
  734: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  735: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  736: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  737: 1			; positie 6 (C5H-80H=45H)
  738: 1			;
  739: 1			; Deze routine vernietigt geen registers
  740: 1			;
  741: 1			;******************************************************************************
  742: 1
  743: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  744: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  745: 1			; dataregister van het scherm.
  746: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  747: 1			; controlebyte doorsturen naar het LCD.
  748: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  749: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  750: 1			; naar de LCD sturen.
  751: 1
  752: 1  0200	C0 E0		outcharlcd:   push   acc           ;registers op stack
  753: 1  0202	C0 D0		              push   psw
  754: 1  0204	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  755: 1  0207	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  756: 1  0209	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  757: 1  020C	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  758: 1  020E	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  759: 1  0211	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  760: 1
  761: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  762: 1			; Als het een commando is, moeten we het uitvoeren.
  763: 1			; Indien niet, gewoon terug zonder actie!
  764: 1
  765: 1  0213	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  766: 1  0216	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  767: 1  0218	80 28		              sjmp   outcharlcd9          ;afsluiten
  768: 1
  769: 1  021A	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  770: 1  021D	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  771: 1  021F	80 21		              sjmp   outcharlcd9
  772: 1
  773: 1  0221	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  774: 1  0224	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  775: 1  0226	80 1A		              sjmp   outcharlcd9
  776: 1
  777: 1  0228	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  778: 1  022B	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  779: 1  022D	80 13		              sjmp   outcharlcd9
  780: 1
  781: 1  022F	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  782: 1  0232	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  783: 1  0234	80 0C		              sjmp   outcharlcd9
  784: 1
  785: 1  0236	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  786: 1  0239	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  787: 1  023B	80 05		              sjmp   outcharlcd9
  788: 1
  789: 1
  790: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  791: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  792: 1
  793: 1  023D	12 02 D4	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  794: 1  0240	80 03		              sjmp   outcharlcde   ;einde routine
  795: 1
  796: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  797: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  798: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  799: 1			; op dat adres te zetten.
  800: 1
  801: 1  0242	12 03 0E	outcharlcd9:  lcall  outc          ;klaar
  802: 1  0245	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  803: 1  0247	D0 E0		              pop    acc
  804: 1  0249	22		              ret
  805: 1
  806: 1			;******************************************************************************
  807: 1			;
  808: 1			; outniblcd
  809: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  810: 1			; op het lcd scherm.
  811: 1			;
  812: 1			; de routine vernietigt geen registers
  813: 1			;
  814: 1			;******************************************************************************
  815: 1
  816: 1  024A	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  817: 1  024C	C0 D0		              push   psw
  818: 1  024E	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  819: 1  0250	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  820: 1  0252	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  821: 1  0255	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  822: 1  0257	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  823: 1  0259	12 02 D4	outniblcde:   lcall  outd          ;naar het scherm
  824: 1  025C	D0 D0		              pop    psw
  825: 1  025E	D0 E0		              pop    acc
  826: 1  0260	22		              ret
  827: 1
  828: 1			;******************************************************************************
  829: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  830: 1			; outbytelcd
  831: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  832: 1			;
  833: 1			; de routine vernietigt geen registers
  834: 1			;
  835: 1			;******************************************************************************
  836: 1
  837: 1  0261	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  838: 1  0263	C0 D0		              push   psw
  839: 1  0265	C4		              swap   a             ;bitjes omruilen
  840: 1  0266	12 02 4A	              lcall  outniblcd
  841: 1  0269	C4		              swap   a             ;nog eens
  842: 1  026A	12 02 4A	              lcall  outniblcd
  843: 1  026D	D0 D0		              pop    psw
  844: 1  026F	D0 E0		              pop    acc
  845: 1  0271	22		              ret
  846: 1
  847: 1			;******************************************************************************
  848: 1			;
  849: 1			; dispdptrlcd
  850: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  851: 1			;
  852: 1			; de routine vernietigt geen registers
  853: 1			;
  854: 1			;******************************************************************************
  855: 1
  856: 1  0272	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  857: 1  0274	C0 D0		              push   psw
  858: 1  0276	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  859: 1  0278	12 02 61	              lcall  outbytelcd
  860: 1  027B	E5 82		              mov    a,dpl         ;dan het lage deel
  861: 1  027D	12 02 61	              lcall  outbytelcd
  862: 1  0280	D0 D0		              pop    psw
  863: 1  0282	D0 E0		              pop    acc
  864: 1  0284	22		              ret
  865: 1
  866: 1			;******************************************************************************
  867: 1			;
  868: 1			; outmsgalcd
  869: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  870: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  871: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  872: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  873: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  874: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  875: 1			;
  876: 1			; de routine vernietigt geen registers
  877: 1			;
  878: 1			;******************************************************************************
  879: 1
  880: 1  0285	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  881: 1  0287	C0 D0		              push   psw
  882: 1  0289	C0 83		              push   dph           ;ook de data pointer
  883: 1  028B	C0 82		              push   dpl
  884: 1
  885: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  886: 1
  887: 1  028D	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  888: 1  028E	93		              movc   a,@a+dptr     ;waarde lezen
  889: 1  028F	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  890: 1
  891: 1			; de code is niet 0 dus versturen met outchar
  892: 1
  893: 1  0291	12 02 00	              lcall  outcharlcd    ;weg er mee
  894: 1  0294	A3		              inc    dptr          ;naar volgende ascii code wijzen
  895: 1  0295	02 02 8D	              ljmp   outmsgalcd1   ;lus sluiten
  896: 1
  897: 1  0298	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  898: 1  029A	D0 83		              pop    dph
  899: 1  029C	D0 D0		              pop    psw
  900: 1  029E	D0 E0		              pop    acc
  901: 1  02A0	22		              ret
  902: 1
  903: 1			;******************************************************************************
  904: 1			;
  905: 1			; regtolcd
  906: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  907: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  908: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  909: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  910: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  911: 1			;
  912: 1			; de routine vernietigt geen registers
  913: 1			;
  914: 1			;******************************************************************************
  915: 1
  916: 1
  917: 1  02A1	C0 E0		regtolcd:     push   acc           ;registers op de stack
  918: 1  02A3	C0 D0		              push   psw
  919: 1  02A5	E8		              mov    a,r0
  920: 1  02A6	C0 E0		              push   acc
  921: 1  02A8	E9		              mov    a,r1
  922: 1  02A9	C0 E0		              push   acc
  923: 1  02AB	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  924: 1  02AD	12 02 00	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  925: 1			                                   ;plaats
  926: 1  02B0	79 00		              mov    r1,#000h      ;werkt als loopcounter
  927: 1  02B2	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  928: 1  02B3	12 02 00	              lcall  outcharlcd    ;weg er mee
  929: 1  02B6	08		              inc    r0
  930: 1  02B7	09		              inc    r1
  931: 1  02B8	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  932: 1			                                          ;nieuwe lijn genomen worden
  933: 1  02BB	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  934: 1  02BD	12 02 00	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  935: 1			                                   ;plaats
  936: 1
  937: 1  02C0	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  938: 1  02C1	12 02 00	              lcall  outcharlcd    ;weg er mee
  939: 1  02C4	08		              inc    r0
  940: 1  02C5	09		              inc    r1
  941: 1  02C6	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  942: 1  02C9	D0 E0		              pop    acc
  943: 1  02CB	F9		              mov    r1,a
  944: 1  02CC	D0 E0		              pop    acc
  945: 1  02CE	F8		              mov    r0,a
  946: 1  02CF	D0 D0		              pop    psw           ;registers herstellen
  947: 1  02D1	D0 E0		              pop    acc
  948: 1  02D3	22		              ret
  949: 1
  950: 1			;******************************************************************************
  951: 1			;
  952: 1			; outd
  953: 1			; Is een routine die naar het data register van het display een
  954: 1			; volledige byte stuurt.
  955: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  956: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  957: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  958: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  959: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  960: 1			;
  961: 1			; De routine vernietigt geen registers.
  962: 1			;
  963: 1			;******************************************************************************
  964: 1
  965: 1  02D4	C0 E0		outd:         push   acc           ;registers op stack zetten
  966: 1  02D6	C0 D0		              push   psw
  967: 1  02D8	12 02 E4	              lcall  outhnibd      ;hoogste vier bits verzenden
  968: 1			ifdef     aduc832_v1_1
  969: 1			              lcall  delay60us     ;niet echt nodig
  970: 1			endif
  971: 1  02DB	C4		              swap   a             ;bitjes omruilen
  972: 1  02DC	12 02 E4	              lcall  outhnibd      ;naar het scherm sturen
  973: 1
  974: 1			ifdef    aduc832_v1_1
  975: 1			              lcall  delay60us     ;altijd goed
  976: 1			endif
  977: 1
  978: 1  02DF	D0 D0		              pop    psw           ;registers terug herstellen
  979: 1  02E1	D0 E0		              pop    acc
  980: 1  02E3	22		              ret
  981: 1
  982: 1			;******************************************************************************
  983: 1			;
  984: 1			; outhnibd
  985: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  986: 1			; lcd scherm.
  987: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  988: 1			; de routine vernietigt geen registers.
  989: 1			;
  990: 1			;******************************************************************************
  991: 1			ifdef     aduc832_v1_1
  992: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  993: 1			              push   psw
  994: 1			              setb   rs            ;controle lijn in orde
  995: 1			              clr    e             ;deselectie display
  996: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  997: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

  998: 1			              mov     c,acc.6      ;afblijven!
  999: 1			              mov     lcdport.6,c
 1000: 1			              mov     c,acc.5
 1001: 1			              mov     lcdport.5,c
 1002: 1			              mov     c,acc.4
 1003: 1			              mov     lcdport.4,c
 1004: 1			              setb   e             ;display enabelen
 1005: 1			              nop                  ;450ns is normaal gezien voldoende
 1006: 1			              clr    e             ;display deselecteren
 1007: 1			              pop    psw           ;registers herstellen
 1008: 1			              pop    acc
 1009: 1			              ret
 1010: 1			endif
 1011: 1
 1012: 1			ifdef    aduc832_v2_0
 1013: 1  02E4	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
 1014: 1  02E6	C0 D0		              push   psw
 1015: 1  02E8	C0 F0		              push   b             ;werkregister
 1016: 1  02EA	12 05 B4	              lcall  lcdtoport     ;lees de expander naar b register
 1017: 1  02ED	D2 F0		              setb   rs            ;controle lijn in orde
 1018: 1  02EF	C2 F1		              clr    e             ;deselectie display
 1019: 1  02F1	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
 1020: 1  02F3	03		              rr     a             ;bits op juiste plaats zetten
 1021: 1  02F4	03		              rr     a             ;voor b reg
 1022: 1  02F5	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
 1023: 1  02F8	42 F0		              orl    b,a           ;bij elkaar voegen
 1024: 1  02FA	12 05 9B	              lcall  porttolcd     ;naar expander
 1025: 1  02FD	D2 F1		              setb   e             ;display enabelen
 1026: 1  02FF	12 05 9B	              lcall  porttolcd
 1027: 1  0302	C2 F1		              clr    e             ;display deselecteren
 1028: 1  0304	12 05 9B	              lcall  porttolcd
 1029: 1  0307	D0 F0		              pop    b
 1030: 1  0309	D0 D0		              pop    psw           ;registers herstellen
 1031: 1  030B	D0 E0		              pop    acc
 1032: 1  030D	22		              ret
 1033: 1			endif
 1034: 1			;******************************************************************************
 1035: 1			;
 1036: 1			; outc
 1037: 1			; Is een routine die naar het controleregister van het display een
 1038: 1			; volledige byte (commando) stuurt.
 1039: 1			; De routine vernietigt geen registers.
 1040: 1			;
 1041: 1			;******************************************************************************
 1042: 1
 1043: 1  030E	C0 E0		outc:         push   acc           ;registers op stack zetten
 1044: 1  0310	C0 D0		              push   psw
 1045: 1  0312	12 03 24	              lcall  outhnibc      ;hoogste vier bits verzenden
 1046: 1  0315	12 04 6D	              lcall  delay2ms      ;niet echt nodig
 1047: 1  0318	C4		              swap   a             ;bitjes omruilen
 1048: 1  0319	12 03 24	              lcall  outhnibc      ;naar het scherm sturen
 1049: 1  031C	12 04 6D	              lcall  delay2ms      ;altijd goed voor traagste commando
 1050: 1  031F	D0 D0		              pop    psw           ;registers terug herstellen
 1051: 1  0321	D0 E0		              pop    acc
 1052: 1  0323	22		              ret
 1053: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1054: 1			;******************************************************************************
 1055: 1			;
 1056: 1			; outhnibc
 1057: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
 1058: 1			; het lcd scherm.
 1059: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
 1060: 1			; de routine vernietigt geen registers.
 1061: 1			;
 1062: 1			;******************************************************************************
 1063: 1			ifdef     aduc832_v1_1
 1064: 1			outhnibc:     push   acc           ;registers op stack plaatsen
 1065: 1			              push   psw
 1066: 1			              clr    rs            ;controle lijn in orde
 1067: 1			              clr    e             ;deselectie display
 1068: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
 1069: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
 1070: 1			              mov     c,acc.6      ;afblijven!
 1071: 1			              mov     lcdport.6,c
 1072: 1			              mov     c,acc.5
 1073: 1			              mov     lcdport.5,c
 1074: 1			              mov     c,acc.4
 1075: 1			              mov     lcdport.4,c
 1076: 1			              setb   e             ;display enabelen
 1077: 1			              nop                  ;450ns is normaal gezien voldoende
 1078: 1			              clr    e             ;display deselecteren
 1079: 1			              pop    psw           ;registers herstellen
 1080: 1			              pop    acc
 1081: 1			              ret
 1082: 1			endif
 1083: 1
 1084: 1			ifdef    aduc832_v2_0
 1085: 1  0324	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
 1086: 1  0326	C0 D0		              push   psw
 1087: 1  0328	C0 F0		              push   b             ;werkregister
 1088: 1  032A	12 05 B4	              lcall  lcdtoport     ;lees de expander naar b register
 1089: 1  032D	C2 F0		              clr    rs            ;controle lijn in orde
 1090: 1  032F	C2 F1		              clr    e             ;deselectie display
 1091: 1  0331	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
 1092: 1  0333	03		              rr     a             ;bits op juiste plaats zetten
 1093: 1  0334	03		              rr     a             ;voor b reg
 1094: 1  0335	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
 1095: 1  0338	42 F0		              orl    b,a           ;bij elkaar voegen
 1096: 1  033A	12 05 9B	              lcall  porttolcd     ;naar expnder
 1097: 1  033D	D2 F1		              setb   e             ;display enabelen
 1098: 1  033F	12 05 9B	              lcall  porttolcd
 1099: 1  0342	C2 F1		              clr    e             ;display deselecteren
 1100: 1  0344	12 05 9B	              lcall  porttolcd
 1101: 1  0347	D0 F0		              pop    b
 1102: 1  0349	D0 D0		              pop    psw           ;registers herstellen
 1103: 1  034B	D0 E0		              pop    acc
 1104: 1  034D	22		              ret
 1105: 1			endif
 1106: 1
 1107: 1			;******************************************************************************
 1108: 1			; hexbuf2lcd
 1109: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1110: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
 1111: 1			; Dit is vooral handig in een debug fase van een userprogramma.
 1112: 1			; Het startadres van de buffer wordt doorgegeven via R0.
 1113: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
 1114: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
 1115: 1			;
 1116: 1			; ADR| HEX DATA  |
 1117: 1			; 42 |AF 2D 23 5A|
 1118: 1			;
 1119: 1			; Deze routine vernietigt geen registers
 1120: 1			;******************************************************************************
 1121: 1
 1122: 1  034E	C0 E0		hexbuf2lcd:   push   acc
 1123: 1  0350	C0 F0		              push   b
 1124: 1  0352	C0 D0		              push   psw
 1125: 1  0354	C0 82		              push   dpl
 1126: 1  0356	C0 83		              push   dph
 1127: 1  0358	E8		              mov     a,r0
 1128: 1  0359	C0 E0		              push   acc
 1129: 1  035B	90 03 97	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
 1130: 1  035E	12 02 85	              lcall   outmsgalcd
 1131: 1  0361	E8		              mov    a,r0            ;neem pointerwaarde
 1132: 1  0362	12 02 61	              lcall  outbytelcd      ;byte afdrukken als startadres
 1133: 1  0365	74 20		              mov    a,#' '          ;spatie afdrukken
 1134: 1  0367	12 02 00	              lcall  outcharlcd
 1135: 1  036A	74 7C		              mov    a,#'|'          ;pipe afdrukken
 1136: 1  036C	12 02 00	              lcall  outcharlcd
 1137: 1  036F	75 F0 04	              mov    b,#4            ;bytecounter=4
 1138: 1  0372	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
 1139: 1  0373	12 02 61	              lcall  outbytelcd      ;byte naar buiten
 1140: 1  0376	74 20		              mov    a,#' '          ;neem whitespace char
 1141: 1  0378	12 02 00	              lcall  outcharlcd       ;druk af
 1142: 1  037B	08		              inc    r0              ;volgende byte
 1143: 1  037C	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
 1144: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
 1145: 1  037F	74 CF		              mov    a,#0cfh         ;adres laatste char
 1146: 1  0381	12 02 00	              lcall   outcharlcd
 1147: 1  0384	74 7C		              mov    a,#'|'          ;neem pipe
 1148: 1  0386	12 02 00	              lcall  outcharlcd      ;ascii code afdrukken
 1149: 1  0389	D0 E0		hexbuf2lcde:  pop    acc
 1150: 1  038B	F8		              mov   r0,a
 1151: 1  038C	D0 83		              pop   dph
 1152: 1  038E	D0 82		              pop   dpl
 1153: 1  0390	D0 D0		              pop   psw
 1154: 1  0392	D0 F0		              pop   b
 1155: 1  0394	D0 E0		              pop   acc
 1156: 1  0396	22		              ret
 1157: 1			                        ;'0123456789abcdef'
 1158: 1  0397	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  039B	52 7C 20 48
       1  039F	45 58 20 44
       1  03A3	41 54 41 20
       1  03A7	20 7C C0 00
 1159: 1
 1160: 1
 1161: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1162: 1			; barlcd
 1163: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
 1164: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
 1165: 1			; de inhoud van A
 1166: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
 1167: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
 1168: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
 1169: 1			; aangemaakt in de LCD CGRAM.
 1170: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
 1171: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
 1172: 1			;       lcall build
 1173: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
 1174: 1			;       mov     a, #42h     ;de startlocatie is 42h
 1175: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
 1176: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
 1177: 1			;
 1178: 1			; Deze routine vernietigt geen registers.
 1179: 1			;******************************************************************************
 1180: 1
 1181: 1  03AB	C0 82		barlcd:       push   dpl
 1182: 1  03AD	88 82		              mov     dpl,r0
 1183: 1  03AF	C0 82		              push   dpl
 1184: 1  03B1	C0 E0		              push   acc            ;bewaar startlocatie
 1185: 1  03B3	C0 D0		              push   psw            ;bewaar status
 1186: 1  03B5	C0 F0		              push   b              ;bewaar aantal bar's
 1187: 1  03B7	F5 F0		              mov    b,a            ;bewaar startlocatie
 1188: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
 1189: 1  03B9	E8		              mov    a,r0           ;neem maximum aantal bar's
 1190: 1  03BA	C0 F0		              push   b              ;bewaar startadres
 1191: 1  03BC	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
 1192: 1  03BF	84		              div    ab             ;bereken dus het aantal nodige blokjes
 1193: 1  03C0	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
 1194: 1  03C1	E5 F0		              mov    a,b            ;neem restbars
 1195: 1  03C3	60 01		              jz     barlcd_1       ;als nul dan verder
 1196: 1  03C5	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
 1197: 1  03C6	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
 1198: 1  03C8	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
 1199: 1  03CA	12 02 00	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
 1200: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
 1201: 1  03CD	74 13		              mov    a,#13h         ;cursor off
 1202: 1  03CF	12 02 00	              lcall  outcharlcd     ;stuur naar LCD
 1203: 1  03D2	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
 1204: 1  03D4	C0 F0		              push   b              ;en weer bewaren
 1205: 1  03D6	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
 1206: 1  03D8	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
 1207: 1  03DA	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
 1208: 1  03DD	84		              div    ab             ;A=aantal volle blokjes, B=rest
 1209: 1  03DE	C0 F0		              push   b              ;bewaar rest
 1210: 1  03E0	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
 1211: 1  03E2	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
 1212: 1
 1213: 1			;Druk de volle 5x8 blokjes af van de bargraph
 1214: 1  03E4	74 04		              mov    a,#4           ;neem code voor vol blokje
 1215: 1  03E6	12 02 D4	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
 1216: 1  03E9	18		              dec    r0             ;verminder karaktersteller
 1217: 1  03EA	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1218: 1
 1219: 1			;Druk het onvolledige blokje (rest) af
 1220: 1  03ED	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
 1221: 1  03EF	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
 1222: 1  03F1	14		              dec    a              ;converteer rest naar code voor de
 1223: 1			                                    ;overeenkomende bar's
 1224: 1  03F2	12 02 D4	              lcall  outd           ;druk resterende bar's af
 1225: 1  03F5	18		              dec    r0             ;verminder karakterteller
 1226: 1
 1227: 1			;Test of we aan het einde van de bargraph zitten..
 1228: 1  03F6	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
 1229: 1  03F9	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
 1230: 1
 1231: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
 1232: 1  03FB	74 20		barlcd4:      mov    a,#' '         ;neem spatie
 1233: 1  03FD	12 02 D4	              lcall  outd           ;en druk af
 1234: 1  0400	18		              dec    r0             ;karakterteller verminderen
 1235: 1  0401	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
 1236: 1
 1237: 1  0403	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
 1238: 1  0405	D0 D0		              pop    psw            ;haal status weer
 1239: 1  0407	D0 E0		              pop    acc            ;haal startlocatie weer
 1240: 1  0409	D0 82		              pop    dpl
 1241: 1  040B	A8 82		              mov    r0,dpl
 1242: 1  040D	D0 82		              pop    dpl
 1243: 1  040F	22		              ret
 1244: 1
 1245: 1
 1246: 1
 1247: 1			;******************************************************************************
 1248: 1			; barchars
 1249: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
 1250: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
 1251: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
 1252: 1			; kunnen pas daarna worden gebruikt.
 1253: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
 1254: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
 1255: 1			; (max. 3 extra char's).
 1256: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
 1257: 1			; opgeslagen met MSB=1.
 1258: 1			;******************************************************************************
 1259: 1
 1260: 1  0410	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1261: 1  0411	10		              db 00010000b
 1262: 1  0412	10		              db 00010000b
 1263: 1  0413	10		              db 00010000b
 1264: 1  0414	10		              db 00010000b
 1265: 1  0415	10		              db 00010000b
 1266: 1  0416	10		              db 00010000b
 1267: 1  0417	10		              db 00010000b
 1268: 1
 1269: 1  0418	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1270: 1  0419	18		              db 00011000b
 1271: 1  041A	18		              db 00011000b
 1272: 1  041B	18		              db 00011000b
 1273: 1  041C	18		              db 00011000b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1274: 1  041D	18		              db 00011000b
 1275: 1  041E	18		              db 00011000b
 1276: 1  041F	18		              db 00011000b
 1277: 1
 1278: 1  0420	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1279: 1  0421	1C		              db 00011100b
 1280: 1  0422	1C		              db 00011100b
 1281: 1  0423	1C		              db 00011100b
 1282: 1  0424	1C		              db 00011100b
 1283: 1  0425	1C		              db 00011100b
 1284: 1  0426	1C		              db 00011100b
 1285: 1  0427	1C		              db 00011100b
 1286: 1
 1287: 1  0428	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1288: 1  0429	1E		              db 00011110b
 1289: 1  042A	1E		              db 00011110b
 1290: 1  042B	1E		              db 00011110b
 1291: 1  042C	1E		              db 00011110b
 1292: 1  042D	1E		              db 00011110b
 1293: 1  042E	1E		              db 00011110b
 1294: 1  042F	1E		              db 00011110b
 1295: 1
 1296: 1  0430	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1297: 1  0431	1F		              db 00011111b
 1298: 1  0432	1F		              db 00011111b
 1299: 1  0433	1F		              db 00011111b
 1300: 1  0434	1F		              db 00011111b
 1301: 1  0435	1F		              db 00011111b
 1302: 1  0436	1F		              db 00011111b
 1303: 1  0437	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1304: 1
 1305: 1			;******************************************************************************
 1306: 1			;
 1307: 1			; build
 1308: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1309: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1310: 1			; overeen komen met de ASCII codes 00h-07h.
 1311: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1312: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1313: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1314: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1315: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1316: 1			;
 1317: 1			; De routine vernietigt geen registers.
 1318: 1			;
 1319: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1320: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1321: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1322: 1			;      lcall  outcharlcd         ; druk de karakter af
 1323: 1			;
 1324: 1			;eigenkarakter:
 1325: 1			;      db 00001110b
 1326: 1			;      db 00001010b
 1327: 1			;      db 00001110b
 1328: 1			;      db 00000100b
 1329: 1			;      db 00011111b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1330: 1			;      db 00000100b
 1331: 1			;      db 00001010b
 1332: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1333: 1			;******************************************************************************
 1334: 1
 1335: 1  0438	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1336: 1  043A	C0 D0		              push   psw
 1337: 1  043C	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1338: 1  043E	12 04 46	              lcall  build_adr
 1339: 1  0441	D0 D0		              pop    psw
 1340: 1  0443	D0 E0		              pop    acc
 1341: 1  0445	22		              ret                  ;terug
 1342: 1
 1343: 1			;******************************************************************************
 1344: 1			; build_adr
 1345: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1346: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1347: 1			; die overeen komen met de ASCII codes 00h-07h.
 1348: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1349: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1350: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1351: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1352: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1353: 1			;
 1354: 1			; De routine vernietigt geen registers.
 1355: 1			;
 1356: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1357: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1358: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1359: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1360: 1			;      lcall  outcharlcd        ; druk de karakter af
 1361: 1			;
 1362: 1			;eigenkarakters:
 1363: 1			;      db 00001110b
 1364: 1			;      db 00001010b
 1365: 1			;      db 00001110b
 1366: 1			;       db 00000100b
 1367: 1			;      db 00011111b
 1368: 1			;      db 00000100b
 1369: 1			;      db 00001010b
 1370: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1371: 1			;******************************************************************************
 1372: 1  0446	C0 E0		build_adr:      push   acc
 1373: 1  0448	C0 D0		              push   psw
 1374: 1  044A	C0 83		              push   dph
 1375: 1  044C	C0 82		              push   dpl
 1376: 1  044E	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1377: 1  0450	12 03 0E	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1378: 1  0453	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1379: 1  0455	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1380: 1  0456	12 02 D4	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1381: 1  0459	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1382: 1  045C	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1383: 1  045D	80 F4		              sjmp   build3
 1384: 1  045F	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1385: 1  0461	12 03 0E	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1386: 1  0464	D0 82		              pop    dpl
 1387: 1  0466	D0 83		              pop    dph
 1388: 1  0468	D0 D0		              pop    psw
 1389: 1  046A	D0 E0		              pop    acc
 1390: 1  046C	22		              ret
 1391: 1
 1392: 1			;******************************************************************************
 1393: 1			;
 1394: 1			; delay2ms
 1395: 1			; Is een vertragingsroutine van 2ms.
 1396: 1			;
 1397: 1			; De routine vernietigt geen registers.
 1398: 1			;
 1399: 1			;******************************************************************************
 1400: 1
 1401: 1  046D	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1402: 1  046F	C0 D0		              push   psw
 1403: 1  0471	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1404: 1  0473	12 04 7E	delay2ms1:    lcall  delay60us
 1405: 1  0476	D5 E0 FA	              djnz   acc,delay2ms1
 1406: 1  0479	D0 D0		              pop    psw           ;registers herstellen
 1407: 1  047B	D0 E0		              pop    acc
 1408: 1  047D	22		              ret
 1409: 1
 1410: 1			;******************************************************************************
 1411: 1			;
 1412: 1			; delay60us.
 1413: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1414: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1415: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1416: 1			;
 1417: 1			; de routine vernietigt geen registers.
 1418: 1			;
 1419: 1			;******************************************************************************
 1420: 1
 1421: 1  047E	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1422: 1  0480	C0 D0		              push   psw
 1423: 1  0482	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1424: 1  0484	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1425: 1
 1426: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1427: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1428: 1
 1429: 1  0486	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1430: 1  0489	D0 E0		              pop    acc           ;registers herstellen
 1431: 1  048B	D0 D0		              pop    psw
 1432: 1  048D	22		              ret
 1433: 1
 1434: 1  048E	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1435: 1  0490	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1436: 1  0493	D0 D0		              pop    psw
 1437: 1  0495	D0 E0		              pop    acc
 1438: 1  0497	22		              ret
 1439: 1
 1440: 1			endif        ;einde van aduc_lcd
 1441: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1442: 1
 1443: 1
 1444: 1
 1445: 1			ifdef aduc_i2c
 1446: 1			;******************************************************************************
 1447: 1			;
 1448: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1449: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1450: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1451: 1			;
 1452: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1453: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1454: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1455: 1			;
 1456: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1457: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1458: 1			;
 1459: 1			; Beschikbare routines:
 1460: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1461: 1			; i2cstart     :verzenden van een start conditie
 1462: 1			; i2cstop      :verzenden van een stop conditie
 1463: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1464: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1465: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1466: 1			;               negende klokpuls
 1467: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1468: 1			;               negende klokpuls
 1469: 1			;
 1470: 1			; Toevoeging [dp]
 1471: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1472: 1			;               een slavedevice
 1473: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1474: 1			;               en plaatst deze in een geheugenbuffer
 1475: 1			;******************************************************************************
 1476: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1477: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1478: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1479: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1480: 1
 1481: 1			;******************************************************************************
 1482: 1			; i2cinit
 1483: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1484: 1			;******************************************************************************
 1485: 1  0498	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1486: 1  049A	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1487: 1  049C	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1488: 1  049E	D2 EB		                setb    i2cm            ;master mode inschakelen
 1489: 1  04A0	22		                ret
 1490: 1			;******************************************************************************
 1491: 1			; i2cstart
 1492: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1493: 1			;******************************************************************************
 1494: 1  04A1	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1495: 1  04A3	C2 EF		                clr     mdo             ;data moet laag worden
 1496: 1  04A5	D2 EE		                setb    mde             ;data pin enable
 1497: 1  04A7	C2 ED		                clr     mco             ;klok laag maken
 1498: 1  04A9	22		                ret
 1499: 1			;******************************************************************************
 1500: 1			; i2cstop
 1501: 1			; Dit is een subroutine die de stop conditie opwekt.
 1502: 1			;******************************************************************************
 1503: 1  04AA	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1504: 1  04AC	D2 EE		                setb    mde             ;data mag naar buiten
 1505: 1  04AE	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1506: 1  04B0	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1507: 1  04B2	22		                ret
 1508: 1
 1509: 1			;******************************************************************************
 1510: 1			; i2coutbyte
 1511: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1512: 1			; De routine vernietigt geen registers.
 1513: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1514: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1515: 1			;         uitvoeren van de routine.
 1516: 1			;******************************************************************************
 1517: 1  04B3	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1518: 1  04B5	C0 F0		                push    b
 1519: 1  04B7	75 F0 08	                mov     b,#008h         ;loopcounter
 1520: 1  04BA	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1521: 1  04BB	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1522: 1  04BD	D2 EE		                setb    mde             ;pin als output activeren
 1523: 1  04BF	D2 ED		                setb    mco             ;klokpukls hoog
 1524: 1  04C1	C2 ED		                clr     mco             ;klokpuls laag
 1525: 1  04C3	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1526: 1  04C6	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1527: 1  04C8	D2 ED		                setb    mco             ;klokpuls hoog
 1528: 1  04CA	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1529: 1  04CC	C2 ED		                clr     mco             ;klokpuls terug laag
 1530: 1  04CE	D0 F0		                pop     b
 1531: 1  04D0	D0 E0		                pop     acc             ;registers herstellen
 1532: 1  04D2	22		                ret
 1533: 1
 1534: 1			;******************************************************************************
 1535: 1			; i2cinbyteack
 1536: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1537: 1			; De routine vernietigt geen registers. De routine zal als
 1538: 1			; negende bit een ack verzenden.
 1539: 1			;******************************************************************************
 1540: 1  04D3	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1541: 1  04D5	C0 D0		                push    psw
 1542: 1  04D7	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1543: 1  04DA	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1544: 1  04DC	D2 ED		                setb    mco             ;klokpuls hoog
 1545: 1  04DE	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1546: 1  04E0	C2 ED		                clr     mco             ;klokpuls terug laag
 1547: 1  04E2	33		                rlc     a               ;in accu shiften
 1548: 1  04E3	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1549: 1  04E6	C3		                clr     c               ;ack verzenden
 1550: 1  04E7	92 EF		                mov     mdo,c           ;carry naar de mdo pin

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1551: 1  04E9	D2 EE		                setb    mde             ;pin als output activeren
 1552: 1  04EB	D2 ED		                setb    mco             ;klokpukls hoog
 1553: 1  04ED	C2 ED		                clr     mco             ;klokpuls laag
 1554: 1  04EF	D0 D0		                pop     psw             ;registers herstellen
 1555: 1  04F1	D0 F0		                pop     b
 1556: 1  04F3	22		                ret
 1557: 1
 1558: 1			;******************************************************************************
 1559: 1			; i2cinbytenack
 1560: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1561: 1			; De routine vernietigt geen registers. De routine zal als
 1562: 1			; negende bit een nack verzenden.
 1563: 1			;******************************************************************************
 1564: 1  04F4	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1565: 1  04F6	C0 D0		                push    psw
 1566: 1  04F8	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1567: 1  04FB	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1568: 1  04FD	D2 ED		                setb    mco             ;klokpuls hoog
 1569: 1  04FF	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1570: 1  0501	C2 ED		                clr     mco             ;klokpuls terug laag
 1571: 1  0503	33		                rlc     a               ;in accu shiften
 1572: 1  0504	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1573: 1  0507	D3		                setb    c               ;nack verzenden
 1574: 1  0508	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1575: 1  050A	D2 EE		                setb    mde             ;pin als output activeren
 1576: 1  050C	D2 ED		                setb    mco             ;klokpukls hoog
 1577: 1  050E	C2 ED		                clr     mco             ;klokpuls laag
 1578: 1  0510	D0 D0		                pop     psw             ;registers herstellen
 1579: 1  0512	D0 F0		                pop     b
 1580: 1  0514	22		                ret
 1581: 1
 1582: 1			;******************************************************************************
 1583: 1			; i2csenddata
 1584: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1585: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1586: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1587: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1588: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1589: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1590: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1591: 1			;
 1592: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1593: 1			; pointer naar deze data.  .
 1594: 1
 1595: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1596: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1597: 1			;         B       = aantal te versturen bytes (minimum 1)
 1598: 1			;         R0      = startadres van te versturen datablok
 1599: 1			;
 1600: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1601: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1602: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1603: 1			;               verzonden byte waarvoor er geen ack kwam.
 1604: 1			;
 1605: 1			; Deze routine vernietigt niets...
 1606: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1607: 1  0515	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1608: 1  0517	C0 D0		                    push   psw
 1609: 1  0519	E8		                    mov    a,r0
 1610: 1  051A	C0 E0		                    push   acc           ;r0 op stack
 1611: 1
 1612: 1  051C	12 04 A1	                    lcall  i2cstart      ;genereer startconditie
 1613: 1  051F	E5 83		                    mov    a,dph         ;neem adresbyte
 1614: 1  0521	12 04 B3	                    lcall  i2coutbyte    ;en verstuur naar slave
 1615: 1  0524	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1616: 1  0526	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1617: 1  0528	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1618: 1  052A	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1619: 1			;10 bit adressering!
 1620: 1  052D	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1621: 1  052F	12 04 B3	                    lcall  i2coutbyte    ;en verstuur naar slave
 1622: 1  0532	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1623: 1			;7 bit adressering!
 1624: 1  0534	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1625: 1  0535	12 04 B3	                    lcall  i2coutbyte    ;en verstuur naar slave
 1626: 1  0538	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1627: 1  053A	08		                    inc    r0            ;volgende byte
 1628: 1  053B	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1629: 1  053E	12 04 AA	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1630: 1  0541	D0 E0		                    pop    acc
 1631: 1  0543	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1632: 1  0544	D0 D0		                    pop    psw
 1633: 1  0546	C3		                    clr    c             ;alles is ok!
 1634: 1  0547	D0 E0		                    pop    acc
 1635: 1  0549	22		                    ret
 1636: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1637: 1  054A	12 04 AA	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1638: 1  054D	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1639: 1  054F	D0 D0		                    pop    psw
 1640: 1  0551	D3		                    setb   c            ;terug met foutmelding
 1641: 1  0552	D0 E0		                    pop    acc
 1642: 1  0554	22		                    ret
 1643: 1
 1644: 1			;******************************************************************************
 1645: 1			; i2crcvdata
 1646: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1647: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1648: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1649: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1650: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1651: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1652: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1653: 1			;
 1654: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1655: 1			; is een pointer naar de start van dit ontvangen datablok.
 1656: 1			;
 1657: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1658: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1659: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1660: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1661: 1			;
 1662: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1663: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1664: 1			;               het adres, wordt de CY bit geset bij return.
 1665: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1666: 1			;
 1667: 1			; Deze routine vernietigt verder niets...
 1668: 1			;******************************************************************************
 1669: 1  0555	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1670: 1  0557	C0 D0		                    push    psw
 1671: 1  0559	E8		                    mov     a,r0            ;r0 op stack
 1672: 1  055A	C0 E0		                    push    acc
 1673: 1
 1674: 1  055C	12 04 A1	                    lcall   i2cstart        ;genereer startconditie
 1675: 1  055F	E5 83		                    mov     a,dph           ;neem adresbyte
 1676: 1  0561	12 04 B3	                    lcall   i2coutbyte      ;en verstuur naar slave
 1677: 1  0564	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1678: 1  0566	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1679: 1  0568	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1680: 1  056A	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1681: 1			;10 bit adressering!
 1682: 1  056D	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1683: 1  056F	12 04 B3	                    lcall   i2coutbyte      ;en verstuur naar slave
 1684: 1  0572	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1685: 1			;7 bit adressering!
 1686: 1
 1687: 1  0574	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1688: 1  0577	12 04 F4	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1689: 1  057A	F6		                    mov     @r0,a           ;en deze ook bewaren
 1690: 1  057B	80 07		                    sjmp    i2crcvdata3
 1691: 1  057D	12 04 D3	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1692: 1  0580	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1693: 1  0581	08		                    inc     r0              ;pointer verhogen
 1694: 1  0582	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1695: 1
 1696: 1  0584	12 04 AA	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1697: 1  0587	D0 E0		                    pop     acc
 1698: 1  0589	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1699: 1  058A	D0 D0		                    pop     psw
 1700: 1  058C	C3		                    clr     c               ;alles is ok!
 1701: 1  058D	D0 E0		                    pop     acc
 1702: 1  058F	22		                    ret
 1703: 1			;fout: geen ack gekregen bij het versturen van het adres
 1704: 1  0590	12 04 AA	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1705: 1  0593	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1706: 1  0595	D0 D0		                    pop        psw
 1707: 1  0597	D3		                    setb    c               ;terug met foutmelding
 1708: 1  0598	D0 E0		                    pop        acc
 1709: 1  059A	22		                    ret
 1710: 1
 1711: 1
 1712: 1			;******************************************************************************
 1713: 1			;
 1714: 1			; porttolcd
 1715: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1716: 1			; scherm stuurt via de port expander.
 1717: 1			;
 1718: 1			; Gebruikt geen registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1719: 1			;
 1720: 1			;******************************************************************************
 1721: 1
 1722: 1  059B	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1723: 1  059D	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1724: 1  059F	12 04 A1	              lcall  i2cstart      ;vertrokken
 1725: 1			ifdef    pcf8574
 1726: 1			              mov    a,#01000000b  ;schrijven naar expander
 1727: 1			endif
 1728: 1			ifdef    pcf8574A
 1729: 1  05A2	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1730: 1			endif
 1731: 1  05A4	12 04 B3	              lcall  i2coutbyte    ;weg er mee
 1732: 1  05A7	E5 F0		              mov    a,b           ;data verzenden
 1733: 1  05A9	12 04 B3	              lcall  i2coutbyte
 1734: 1  05AC	12 04 AA	              lcall  i2cstop       ;transactie sluiten
 1735: 1  05AF	D0 D0		              pop    psw
 1736: 1  05B1	D0 E0		              pop    acc
 1737: 1  05B3	22		              ret
 1738: 1
 1739: 1			;******************************************************************************
 1740: 1			;
 1741: 1			; lcdtoport
 1742: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1743: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1744: 1			; aansturen van de buzzer en backlight.
 1745: 1			;
 1746: 1			; output: b register
 1747: 1			;
 1748: 1			;******************************************************************************
 1749: 1
 1750: 1  05B4	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1751: 1  05B6	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1752: 1  05B8	12 04 A1	              lcall  i2cstart      ;vertrokken
 1753: 1			ifdef    pcf8574
 1754: 1			              mov    a,#01000000b  ;schrijven naar expander
 1755: 1			endif
 1756: 1			ifdef    pcf8574A
 1757: 1  05BB	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1758: 1			endif
 1759: 1  05BD	12 04 B3	              lcall  i2coutbyte    ;weg er mee
 1760: 1  05C0	12 04 F4	              lcall  i2cinbytenack ;data inlezen
 1761: 1  05C3	12 04 AA	              lcall  i2cstop
 1762: 1  05C6	F5 F0		              mov    b,a
 1763: 1  05C8	D0 D0		              pop    psw
 1764: 1  05CA	D0 E0		              pop    acc
 1765: 1  05CC	22		              ret
 1766: 1
 1767: 1			;******************************************************************************
 1768: 1			;
 1769: 1			; lcdlighton
 1770: 1			; Dit is een subroutine die de backlight inschakeld
 1771: 1			;
 1772: 1			; Gebruikt geen registers
 1773: 1			;
 1774: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1775: 1
 1776: 1  05CD	C0 F0		lcdlighton:   push   b
 1777: 1  05CF	12 05 B4	              lcall  lcdtoport     ;expander lezen
 1778: 1  05D2	C2 F6		              clr    b.6           ;licht aan doen
 1779: 1  05D4	12 05 9B	              lcall  porttolcd     ;expander schrijven
 1780: 1  05D7	D0 F0		              pop    b
 1781: 1  05D9	22		              ret
 1782: 1
 1783: 1
 1784: 1			;******************************************************************************
 1785: 1			;
 1786: 1			; lcdlightoff
 1787: 1			; Dit is een subroutine die de backlight uitschakeld
 1788: 1			;
 1789: 1			; Gebruikt geen registers
 1790: 1			;
 1791: 1			;******************************************************************************
 1792: 1
 1793: 1  05DA	C0 F0		lcdlightoff:  push   b
 1794: 1  05DC	12 05 B4	              lcall  lcdtoport     ;expander lezen
 1795: 1  05DF	D2 F6		              setb   b.6           ;licht uit doen
 1796: 1  05E1	12 05 9B	              lcall  porttolcd     ;expander schrijven
 1797: 1  05E4	D0 F0		              pop    b
 1798: 1  05E6	22		              ret
 1799: 1
 1800: 1			;******************************************************************************
 1801: 1			;
 1802: 1			; lcdbuzon
 1803: 1			; Dit is een subroutine die de buzzer inschakeld
 1804: 1			;
 1805: 1			; Gebruikt geen registers
 1806: 1			;
 1807: 1			;******************************************************************************
 1808: 1
 1809: 1  05E7	C0 F0		lcdbuzon:     push   b
 1810: 1  05E9	12 05 B4	              lcall  lcdtoport     ;expander lezen
 1811: 1  05EC	C2 F7		              clr    b.7           ;buzzer aan doen
 1812: 1  05EE	12 05 9B	              lcall  porttolcd     ;expander schrijven
 1813: 1  05F1	D0 F0		              pop    b
 1814: 1  05F3	22		              ret
 1815: 1
 1816: 1			;******************************************************************************
 1817: 1			;
 1818: 1			; lcdbuzoff
 1819: 1			; Dit is een subroutine die de buzzer uitschakeld
 1820: 1			;
 1821: 1			; Gebruikt geen registers
 1822: 1			;
 1823: 1			;******************************************************************************
 1824: 1
 1825: 1  05F4	C0 F0		lcdbuzoff:    push   b
 1826: 1  05F6	12 05 B4	              lcall  lcdtoport     ;expander lezen
 1827: 1  05F9	D2 F7		              setb   b.7           ;buzzer aan doen
 1828: 1  05FB	12 05 9B	              lcall  porttolcd     ;expander schrijven
 1829: 1  05FE	D0 F0		              pop    b
 1830: 1  0600	22		              ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1831: 1
 1832: 1			endif    ;einde aduc_i2c
 1833: 1			;******************************************************************************
 1834: 1
 1835: 1
 1836: 1
 1837: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1838: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1839: 1			;
 1840: 1			; ADuCsio.inc
 1841: 1			; Is een include file voor de ADuC832 microcontroller.
 1842: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1843: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1844: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1845: 1			; afwijking van de standaard routines is de initsio subroutine.
 1846: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1847: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1848: 1			; zijn.
 1849: 1			;
 1850: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1851: 1			;
 1852: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1853: 1
 1854: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1855: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1856: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1857: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1858: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1859: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1860: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1861: 1
 1862: 1  0601	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1863: 1			                                                        ;van het scherm
 1864: 1
 1865: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1866: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1867: 1
 1868: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1869: 1			;
 1870: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1871: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1872: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1873: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1874: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1875: 1			;
 1876: 1			; de routine gebruikt de psw
 1877: 1			;
 1878: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1879: 1
 1880: 1  0605	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1881: 1  0607	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1882: 1  0609	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1883: 1  060B	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1884: 1  060E	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1885: 1
 1886: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1887: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1888: 1
 1889: 1  0610	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1890: 1  0613	F4		              cpl    a             ;bitbangen om laten uit te komen
 1891: 1  0614	C3		              clr    c             ;verder doen
 1892: 1  0615	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1893: 1  0617	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1894: 1  0619	24 80		              add    a,#080h       ;nu alles in orde
 1895: 1  061B	F5 9E		              mov    t3con,a       ;baud rate klaar
 1896: 1  061D	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1897: 1  0620	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1898: 1  0621	D0 E0		              pop    acc
 1899: 1  0623	22		              ret
 1900: 1
 1901: 1  0624	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1902: 1  0625	D0 E0		              pop    acc
 1903: 1  0627	22		              ret
 1904: 1
 1905: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1906: 1			;
 1907: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1908: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1909: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1910: 1			;
 1911: 1			; de routine gebruikt geen registers.
 1912: 1			;
 1913: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1914: 1
 1915: 1  0628	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1916: 1  062A	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1917: 1  062D	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1918: 1  062F	22		              RET
 1919: 1
 1920: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1921: 1			;
 1922: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1923: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1924: 1			;
 1925: 1			; de routine gebruikt geen registers.
 1926: 1			;
 1927: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1928: 1
 1929: 1  0630	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1930: 1  0632	C0 D0		              push   psw
 1931: 1  0634	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1932: 1  0636	12 07 42	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1933: 1  0639	12 06 28	              LCALL  OUTCHAR       ;VERSTUREN
 1934: 1  063C	12 06 89	              LCALL  XONXOFF       ;FLOW CONTROL
 1935: 1  063F	D0 D0		              pop    psw           ;registers herstellen
 1936: 1  0641	D0 E0		              pop    acc
 1937: 1  0643	22		              RET
 1938: 1
 1939: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1940: 1			;
 1941: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1942: 1			; WORDT XONXOFF GEBRUIKT.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1943: 1			;
 1944: 1			; de routine gebruikt geen registers.
 1945: 1			;
 1946: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1947: 1
 1948: 1  0644	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1949: 1  0646	C0 D0		              push   psw
 1950: 1  0648	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1951: 1  064A	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1952: 1  064B	12 06 30	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1953: 1  064E	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1954: 1  0650	12 06 30	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1955: 1  0653	D0 D0		              pop    psw           ;registers herstellen
 1956: 1  0655	D0 E0		              pop    acc
 1957: 1  0657	22		              RET
 1958: 1
 1959: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1960: 1			;
 1961: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1962: 1			; VAN DE CURSOR.
 1963: 1			;
 1964: 1			; de routine gebruikt geen registers.
 1965: 1			;
 1966: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1967: 1
 1968: 1  0658	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1969: 1  065A	C0 D0		              push   psw
 1970: 1  065C	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1971: 1  065E	12 06 44	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1972: 1  0661	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1973: 1  0663	12 06 44	              LCALL  OUTBYTE       ;WEG ER MEE
 1974: 1  0666	D0 D0		              pop    psw           ;registers herstellen
 1975: 1  0668	D0 E0		              pop    acc
 1976: 1  066A	22		              RET                  ;EINDE
 1977: 1
 1978: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1979: 1			;
 1980: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1981: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1982: 1			;
 1983: 1			; de routine gebruikt geen registers.
 1984: 1			;
 1985: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1986: 1
 1987: 1  066B	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1988: 1  066D	C0 D0		              push   psw
 1989: 1  066F	C0 82		              push   dpl
 1990: 1  0671	C0 83		              push   dph
 1991: 1  0673	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1992: 1  0674	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1993: 1  0675	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1994: 1  0677	12 06 28	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1995: 1  067A	12 06 89	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1996: 1  067D	A3		              INC    DPTR          ;DPTR AANPASSEN
 1997: 1  067E	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1998: 1  0680	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 1999: 1  0682	D0 82		              pop    dpl
 2000: 1  0684	D0 D0		              pop    psw
 2001: 1  0686	D0 E0		              pop    acc
 2002: 1  0688	22		              RET                  ;EINDE ROUTINE
 2003: 1
 2004: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2005: 1			;
 2006: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 2007: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 2008: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 2009: 1			; VERDER DOORGEGEVEN.
 2010: 1			;
 2011: 1			; de routine gebruikt geen registers.
 2012: 1			;
 2013: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2014: 1
 2015: 1  0689	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 2016: 1  068B	C0 D0		              push   psw
 2017: 1  068D	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 2018: 1  0690	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 2019: 1  0692	D0 E0		              pop    acc
 2020: 1  0694	22		              RET                  ;ANDERS EINDE
 2021: 1  0695	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 2022: 1  0697	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 2023: 1  069A	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 2024: 1  069D	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 2025: 1
 2026: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2027: 1			;
 2028: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 2029: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 2030: 1			;
 2031: 1			; de routine gebruikt de accu.
 2032: 1			;
 2033: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2034: 1
 2035: 1  069F	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 2036: 1  06A2	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 2037: 1  06A4	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 2038: 1  06A6	22		              RET
 2039: 1
 2040: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2041: 1			;
 2042: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 2043: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 2044: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 2045: 1			; DE CARRY OP 1 GEZET WORDEN.
 2046: 1			;
 2047: 1			; De routine gebruikt de accu EN PSW.
 2048: 1			;
 2049: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2050: 1
 2051: 1  06A7	C0 F0		INBYTE:       PUSH     B
 2052: 1  06A9	12 06 9F	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 2053: 1  06AC	12 07 35	              LCALL  LOWUPTR
 2054: 1  06AF	12 07 50	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2055: 1  06B2	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 2056: 1  06B4	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 2057: 1  06B5	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 2058: 1  06B7	12 06 9F	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 2059: 1  06BA	12 07 35	              LCALL  LOWUPTR
 2060: 1  06BD	12 07 50	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 2061: 1  06C0	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 2062: 1  06C2	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 2063: 1  06C4	D0 F0		INBYTE1:      POP     B
 2064: 1  06C6	22		              RET
 2065: 1
 2066: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2067: 1			;
 2068: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 2069: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 2070: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 2071: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 2072: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 2073: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 2074: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 2075: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 2076: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 2077: 1			; bepalen.
 2078: 1			;
 2079: 1			; De routine gebruikt  r0 .
 2080: 1			;
 2081: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2082: 1
 2083: 1  06C7	C0 E0		INBUFA:       push   acc            ;registers bewaren
 2084: 1  06C9	C0 D0		              push   psw
 2085: 1  06CB	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 2086: 1  06CD	12 06 9F	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 2087: 1  06D0	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 2088: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 2089: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 2090: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 2091: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 2092: 1			; GEVOERD.
 2093: 1  06D2	12 07 35	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 2094: 1  06D5	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 2095: 1  06D8	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 2096: 1  06D9	D0 D0		              pop    psw                  ;registers herstellen
 2097: 1  06DB	D0 E0		              pop    acc
 2098: 1  06DD	22		              RET                         ;EINDE VAN DE ROUTINE
 2099: 1
 2100: 1  06DE	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 2101: 1  06E1	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 2102: 1  06E4	74 07		INBUFA4:      MOV    A,#BEEP
 2103: 1  06E6	12 06 28	INBUFA7:      LCALL  OUTCHAR
 2104: 1  06E9	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 2105: 1
 2106: 1  06EB	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 2107: 1  06EC	90 06 01	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 2108: 1  06EF	12 06 6B	              LCALL  OUTMSGA
 2109: 1  06F2	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 2110: 1  06F4	12 07 27	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2111: 1  06F7	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 2112: 1  06F9	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 2113: 1  06FC	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 2114: 1  06FE	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 2115: 1  06FF	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 2116: 1  0700	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 2117: 1
 2118: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2119: 1			;
 2120: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 2121: 1			;
 2122: 1			; De routine gebruikt niets.
 2123: 1			;
 2124: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2125: 1
 2126: 1  0702	C0 E0		BDELETE:      PUSH     ACC
 2127: 1  0704	C0 D0		              PUSH     PSW
 2128: 1  0706	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 2129: 1  0707	C0 E0		              PUSH     ACC
 2130: 1  0709	E9		              MOV     A,R1
 2131: 1  070A	C0 E0		              PUSH     ACC
 2132: 1  070C	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 2133: 1  070E	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 2134: 1  0710	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 2135: 1  0711	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 2136: 1  0714	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 2137: 1  0715	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 2138: 1  0718	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 2139: 1  071A	F9		              MOV     R1,A
 2140: 1  071B	D0 E0		              POP     ACC
 2141: 1  071D	F8		              MOV     R0,A
 2142: 1  071E	D0 D0		              POP     PSW
 2143: 1  0720	D0 E0		              POP     ACC
 2144: 1  0722	22		              RET                         ;EINDE VAN DE ROUTINE
 2145: 1  0723	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 2146: 1  0724	09		              INC    R1
 2147: 1  0725	80 ED		              SJMP   BDELETE3
 2148: 1
 2149: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2150: 1			;
 2151: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 2152: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 2153: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 2154: 1			; AANZIEN.
 2155: 1			;
 2156: 1			; De routine gebruikt de accu en de psw.
 2157: 1			;
 2158: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2159: 1
 2160: 1  0727	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 2161: 1  072A	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 2162: 1  072C	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 2163: 1  072F	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 2164: 1  0731	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 2165: 1  0732	22		              RET
 2166: 1  0733	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2167: 1  0734	22		              RET
 2168: 1
 2169: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2170: 1			;
 2171: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 2172: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 2173: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 2174: 1			; AANGEPAST WORDEN.
 2175: 1			;
 2176: 1			; De routine gebruikt de accu en psw .
 2177: 1			;
 2178: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2179: 1
 2180: 1  0735	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 2181: 1  0738	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 2182: 1  073A	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 2183: 1  073D	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 2184: 1  073F	94 20		              SUBB   A,#020H              ;OMZETTING
 2185: 1  0741	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 2186: 1
 2187: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2188: 1			;
 2189: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 2190: 1			; ASCII CODE.
 2191: 1			;
 2192: 1			; De routine gebruikt de accu .
 2193: 1			;
 2194: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2195: 1
 2196: 1  0742	C0 D0		BATRANS:      PUSH   PSW
 2197: 1  0744	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 2198: 1  0747	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 2199: 1  0749	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 2200: 1  074B	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 2201: 1  074D	D0 D0		              POP     PSW
 2202: 1  074F	22		              RET
 2203: 1
 2204: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2205: 1			;
 2206: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 2207: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 2208: 1			; GEVAL WORDT DE CARRY GEZET.
 2209: 1			;
 2210: 1			; De routine gebruikt de accu en de psw.
 2211: 1			;
 2212: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2213: 1
 2214: 1  0750	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 2215: 1  0751	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 2216: 1  0753	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 2217: 1  0755	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 2218: 1  0758	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 2219: 1  075A	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 2220: 1  075C	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 2221: 1  075E	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 2222: 1  0761	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2223: 1  0762	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 2224: 1  0764	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 2225: 1  0765	22		ASCBINTRANS1: RET
 2226: 1
 2227: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2228: 1			;
 2229: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 2230: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 2231: 1			;
 2232: 1			; De routine gebruikt de accu en de psw.
 2233: 1			;
 2234: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2235: 1
 2236: 1  0766	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 2237: 1  0767	12 07 50	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 2238: 1  076A	22		              RET                         ;EINDE OMZETTING
 2239: 1
 2240: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2241: 1			;
 2242: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 2243: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 2244: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 2245: 1			;
 2246: 1			; De routine gebruikt de accu, r0.
 2247: 1			;
 2248: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2249: 1
 2250: 1  076B	C0 F0		ASCII2:       PUSH   B
 2251: 1  076D	12 07 66	              LCALL  ASCII1               ;OMZETTEN
 2252: 1  0770	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 2253: 1  0772	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 2254: 1  0773	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 2255: 1  0775	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 2256: 1  0776	12 07 66	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 2257: 1  0779	40 02		              JC     ASCII21               ;WEG ALS C=1
 2258: 1  077B	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 2259: 1  077D	D0 F0		ASCII21:      POP     B
 2260: 1  077F	22		              RET
 2261: 1
 2262: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2263: 1			;
 2264: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2265: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2266: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2267: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2268: 1			;
 2269: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2270: 1			;
 2271: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2272: 1
 2273: 1  0780	12 07 6B	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2274: 1  0783	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2275: 1  0785	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2276: 1  0787	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2277: 1  0788	12 07 6B	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2278: 1  078B	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2279: 1  078D	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2280: 1  078F	22		ASCII41:      RET
 2281: 1
 2282: 1			endif        ;einde van aduc_sio
 2283: 1			;*******************************************************************************
 2284: 1
 2285: 1
 2286: 1			ifdef        aduc_math    ;rekenkundige routines
 2287: 1			;*******************************************************************************
 2288: 1			; aduc_math
 2289: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2290: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2291: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2292: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2293: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2294: 1			; zoals aangegeven:
 2295: 1			;
 2296: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2297: 1			;        ---------------------------
 2298: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2299: 1			;        ---------------------------                             statusbit = f0
 2300: 1			;        ---------------------------
 2301: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2302: 1			;        ---------------------------
 2303: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2304: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2305: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2306: 1			; return en moeten hiervoor worden gereserveerd.
 2307: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2308: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2309: 1			; en unsigned getallen.
 2310: 1			;
 2311: 1			; Beschikbare routines:
 2312: 1			;
 2313: 1			; Conversie routines:
 2314: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2315: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2316: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2317: 1			;
 2318: 1			; Som:
 2319: 1			; s_add16, add16, s_add32, add32
 2320: 1			;
 2321: 1			; Verschil:
 2322: 1			; s_sub16, sub16, s_sub32, sub32
 2323: 1			;
 2324: 1			; Vermenigvuldigen:
 2325: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2326: 1			;
 2327: 1			; Delen:
 2328: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2329: 1			;
 2330: 1			; Vemenigvuldig met factor:
 2331: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2332: 1			;
 2333: 1			; Vierkantswortel:
 2334: 1			; sqrt32, s_sqrt32

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2335: 1			;
 2336: 1			; Schuiven:
 2337: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2338: 1			;
 2339: 1			; Vergelijken:
 2340: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2341: 1			;
 2342: 1			; Tabel lookup:
 2343: 1			; table_lu
 2344: 1			;
 2345: 1			; Gonemetrische functies:
 2346: 1			; Cordic = sinus,cosinus
 2347: 1			;
 2348: 1			;*******************************************************************************
 2349: 1
 2350: 1			;*******************************************************************************
 2351: 1			;
 2352: 1			; bcdhex8     (45,77us @16.777216MHz)
 2353: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2354: 1			; naar een 2's complement hex getal.
 2355: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2356: 1			; een waarde 00h tot 63h.
 2357: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2358: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2359: 1			; input:      R0 = waarde tussen 00h en 99h.
 2360: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2361: 1			; output:     R0 = 2's complement waarde
 2362: 1			;             cy=1 bij out of range van r0
 2363: 1			;             cy=0 bij conversie ok
 2364: 1			; vernietigt: niets
 2365: 1			;*******************************************************************************
 2366: 1  0790	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2367: 1  0792	C0 D0		              push   psw
 2368: 1  0794	C0 F0		              push   b
 2369: 1
 2370: 1  0796	E8		              mov    a,r0                 ;neem te converteren waarde
 2371: 1  0797	F5 F0		              mov    b,a
 2372: 1  0799	54 0F		              anl    a,#0fh
 2373: 1  079B	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2374: 1  079E	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2375: 1  07A0	E5 F0		              mov    a,b
 2376: 1  07A2	54 F0		              anl    a,#0f0h
 2377: 1  07A4	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2378: 1  07A7	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2379: 1
 2380: 1  07A9	E8		              mov    a,r0
 2381: 1  07AA	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2382: 1  07AC	C4		              swap   a
 2383: 1  07AD	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2384: 1  07B0	A4		              mul    ab
 2385: 1  07B1	F5 F0		              mov    b,a                  ;bewaar dit product even
 2386: 1  07B3	E8		              mov    a,r0
 2387: 1  07B4	54 0F		              anl    a,#00fh
 2388: 1  07B6	F8		              mov    r0,a
 2389: 1  07B7	E5 F0		              mov    a,b
 2390: 1  07B9	28		              add    a,r0                 ;eenheden er bijtellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2391: 1  07BA	F8		              mov    r0,a
 2392: 1
 2393: 1  07BB	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2394: 1  07BD	12 08 BE	              lcall  magsig8              ;omzetten naar 2's complement
 2395: 1
 2396: 1  07C0	D0 F0		              pop    b
 2397: 1  07C2	D0 D0		              pop    psw
 2398: 1  07C4	C2 D7		              clr    cy                   ;geen fout
 2399: 1  07C6	D0 E0		              pop    acc
 2400: 1  07C8	22		              ret
 2401: 1
 2402: 1  07C9	D0 F0		bcdhex82:     pop    b
 2403: 1  07CB	D0 D0		              pop    psw
 2404: 1  07CD	D2 D7		              setb   cy                   ;fout! r0 out of range
 2405: 1  07CF	D0 E0		              pop    acc
 2406: 1  07D1	22		              ret
 2407: 1
 2408: 1			;*******************************************************************************
 2409: 1			;
 2410: 1			; hexbcd8     (38,4us @16.777216MHz)
 2411: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2412: 1			; naar een 8bit bcd getal.
 2413: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2414: 1			; bcdgetal van 00h tot +99h.
 2415: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2416: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2417: 1			; bcdgetal 00h tot -99h
 2418: 1			;
 2419: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2420: 1			;
 2421: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2422: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2423: 1			;             cy=1 bij out of range van r0
 2424: 1			;             cy=0 bij conversie ok
 2425: 1			; vernietigt: niets
 2426: 1			;*******************************************************************************
 2427: 1  07D2	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2428: 1  07D4	C0 D0		                push    psw
 2429: 1  07D6	C0 F0		                push    b
 2430: 1  07D8	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2431: 1  07D9	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2432: 1  07DC	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2433: 1  07DE	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2434: 1  07E1	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2435: 1  07E3	D0 F0		                pop     b
 2436: 1  07E5	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2437: 1  07E7	D3		                setb    c
 2438: 1  07E8	D0 E0		                pop     acc
 2439: 1  07EA	22		                ret
 2440: 1  07EB	12 09 86	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2441: 1  07EE	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2442: 1  07EF	75 F0 0A	                mov     b,#10
 2443: 1  07F2	84		                div     ab
 2444: 1  07F3	C4		                swap    a
 2445: 1  07F4	25 F0		                add     a,b
 2446: 1  07F6	F8		                mov     r0,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2447: 1  07F7	D0 F0		                pop     b               ;registers herstellen
 2448: 1  07F9	D0 E0		                pop     acc             ;psw van stack halen
 2449: 1  07FB	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2450: 1  07FD	92 E5		                mov     acc.5,c
 2451: 1  07FF	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2452: 1  0801	C3		                clr     c               ;status: conversie ok
 2453: 1  0802	D0 E0		                pop     acc
 2454: 1  0804	22		                ret
 2455: 1
 2456: 1
 2457: 1
 2458: 1			;*******************************************************************************
 2459: 1			;
 2460: 1			; bcdhex16    (86,6us @16.777216MHz)
 2461: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2462: 1			; omzetten naar een 2's complement hex getal.
 2463: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2464: 1			; naareen waarde 0000h tot 270fh.
 2465: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2466: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2467: 1			; van -270fh).
 2468: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2469: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2470: 1			; output:     R1,R0 = 2's complement waarde
 2471: 1			;             cy=1 bij out of range van r1,r0
 2472: 1			;             cy=0 bij conversie ok
 2473: 1			; vernietigt: niets
 2474: 1			;*******************************************************************************
 2475: 1  0805	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2476: 1  0807	C0 D0		              push   psw
 2477: 1  0809	C0 F0		              push   b
 2478: 1
 2479: 1  080B	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2480: 1  080C	F5 F0		              mov    b,a
 2481: 1  080E	54 0F		              anl    a,#0fh
 2482: 1  0810	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2483: 1  0813	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2484: 1  0815	E5 F0		              mov    a,b
 2485: 1  0817	54 F0		              anl    a,#0f0h
 2486: 1  0819	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2487: 1  081C	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2488: 1  081E	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2489: 1  081F	F5 F0		              mov    b,a
 2490: 1  0821	54 0F		              anl    a,#0fh
 2491: 1  0823	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2492: 1  0826	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2493: 1  0828	E5 F0		              mov    a,b
 2494: 1  082A	54 F0		              anl    a,#0f0h
 2495: 1  082C	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2496: 1  082F	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2497: 1
 2498: 1  0831	E8		              mov    a,r0                  ;neem low byte voor conversie
 2499: 1  0832	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2500: 1  0834	C0 E0		              push   acc                   ;en even bewaren
 2501: 1
 2502: 1  0836	E8		              mov    a,r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2503: 1  0837	C4		              swap   a
 2504: 1  0838	54 0F		              anl    a,#00fh              ;tientallen
 2505: 1  083A	75 F0 0A	              mov    b,#00ah              ;maal tien
 2506: 1  083D	A4		              mul    ab                   ;
 2507: 1  083E	D0 F0		              pop    b                    ;neem eenheden
 2508: 1  0840	25 F0		              add    a,b                  ;tel bij tientallen
 2509: 1  0842	C0 E0		              push   acc                  ;weer bewaren
 2510: 1
 2511: 1  0844	E9		              mov    a,r1                 ;neem high byte voor conversie
 2512: 1  0845	54 F0		              anl    a,#0f0h
 2513: 1  0847	C4		              swap   a
 2514: 1  0848	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2515: 1
 2516: 1  084A	E9		              mov    a,r1                  ;neem high byte voor conversie
 2517: 1  084B	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2518: 1  084D	75 F0 64	              mov    b,#100d              ;en maal honderd
 2519: 1  0850	A4		              mul    ab
 2520: 1  0851	A9 F0		              mov    r1,b
 2521: 1  0853	F8		              mov    r0,a
 2522: 1
 2523: 1  0854	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2524: 1  0856	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2525: 1  0859	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2526: 1  085A	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2527: 1  085D	A4		              mul    ab
 2528: 1  085E	28		              add    a,r0                 ;tel honderdtallen bij de
 2529: 1  085F	F8		              mov    r0,a                 ;duizendtallen
 2530: 1  0860	E9		              mov    a,r1
 2531: 1  0861	35 F0		              addc   a,b
 2532: 1  0863	F9		              mov    r1,a
 2533: 1
 2534: 1  0864	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2535: 1  0866	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2536: 1  0867	F8		              mov    r0,a                 ;duizendtallen
 2537: 1  0868	74 00		              mov    a,#000h
 2538: 1  086A	39		              addc   a,r1
 2539: 1  086B	F9		              mov    r1,a                 ;omzetting klaar
 2540: 1
 2541: 1  086C	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2542: 1  086E	12 08 F2	              lcall  magsig16             ;omzetten naar 2's complement
 2543: 1
 2544: 1  0871	D0 F0		              pop    b
 2545: 1  0873	D0 D0		              pop    psw
 2546: 1  0875	C2 D7		              clr    cy                   ;geen fout
 2547: 1  0877	D0 E0		              pop    acc
 2548: 1  0879	22		              ret
 2549: 1
 2550: 1  087A	D0 F0		bcdhex162:    pop    b
 2551: 1  087C	D0 D0		              pop    psw
 2552: 1  087E	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2553: 1  0880	D0 E0		              pop    acc
 2554: 1  0882	22		              ret
 2555: 1
 2556: 1			;*******************************************************************************
 2557: 1			;
 2558: 1			; hexbcd16    (1,415ms @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2559: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2560: 1			; naar een 24bit bcd getal.
 2561: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2562: 1			; bcdgetal van 000000h tot +032767h.
 2563: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2564: 1			; naar een bcdgetal 000000h tot -032768h
 2565: 1			;
 2566: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2567: 1			;
 2568: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2569: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2570: 1			;
 2571: 1			; vernietigt: niets
 2572: 1			;*******************************************************************************
 2573: 1			;
 2574: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2575: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2576: 1			; naar een 24bit bcd getal.
 2577: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2578: 1			; bcdgetal van 000000h tot 065535h.
 2579: 1			;
 2580: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2581: 1			;
 2582: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2583: 1			;
 2584: 1			; vernietigt: niets
 2585: 1			;*******************************************************************************
 2586: 1  0883	12 09 B8	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2587: 1  0886	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2588: 1  0888	C0 D0		                push   psw
 2589: 1  088A	C0 F0		                push   b
 2590: 1  088C	C0 82		                push   dpl
 2591: 1
 2592: 1  088E	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2593: 1  0891	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2594: 1  0893	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2595: 1  0895	12 0D 67	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2596: 1  0898	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2597: 1  0899	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2598: 1			                                        ;dus eerst eenheden, dan tientallen
 2599: 1			                                        ;honderdtallen, duizendtallen en
 2600: 1			                                        ;tienduizendtallen
 2601: 1  089B	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2602: 1
 2603: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2604: 1
 2605: 1  089E	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2606: 1  08A0	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2607: 1  08A1	D0 E0		                pop    acc              ;duizendtallen ophalen
 2608: 1  08A3	C4		                swap   a                ;en combineren met de
 2609: 1  08A4	F5 82		                mov    dpl,a
 2610: 1  08A6	D0 E0		                pop    acc              ;honderdtallen van de stack
 2611: 1  08A8	25 82		                add    a,dpl
 2612: 1  08AA	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2613: 1  08AB	D0 E0		                pop    acc              ;tientallen van de stack halen
 2614: 1  08AD	C4		                swap   a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2615: 1  08AE	F5 82		                mov    dpl,a
 2616: 1  08B0	D0 E0		                pop    acc              ;en combineren met de eenheden
 2617: 1  08B2	25 82		                add    a,dpl
 2618: 1  08B4	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2619: 1
 2620: 1  08B5	D0 82		                pop    dpl              ;registers herstellen
 2621: 1  08B7	D0 F0		                pop    b
 2622: 1  08B9	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2623: 1  08BB	D0 E0		                pop    acc
 2624: 1  08BD	22		                ret
 2625: 1
 2626: 1			;*******************************************************************************
 2627: 1			; magsig8        (13,6us @16.777216MHz)
 2628: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2629: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2630: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2631: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2632: 1			;           (f0 en f1 zijn 1 als negatief)
 2633: 1			;
 2634: 1			; output:   r0 = 2's complement
 2635: 1			;
 2636: 1			; vernietigt: niets
 2637: 1			;*******************************************************************************
 2638: 1
 2639: 1  08BE	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2640: 1  08C0	C0 D0		               push   psw
 2641: 1  08C2	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2642: 1  08C5	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2643: 1  08C8	80 09		               sjmp   magsig8c
 2644: 1
 2645: 1  08CA	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2646: 1  08CD	80 04		               sjmp   magsig8c
 2647: 1
 2648: 1  08CF	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2649: 1  08D0	F4		               cpl    a                  ;complementeer abs waarde
 2650: 1  08D1	04		               inc    a                  ;r0 = complement(r0)+1
 2651: 1  08D2	F8		               mov    r0,a               ;bewaar in 2's complement
 2652: 1  08D3	D0 D0		magsig8c:      pop    psw
 2653: 1  08D5	D0 E0		               pop    acc
 2654: 1  08D7	22		               ret                        ;klaar
 2655: 1
 2656: 1			;*******************************************************************************
 2657: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2658: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2659: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2660: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2661: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2662: 1			;           (f0 en f1 zijn 1 als negatief)
 2663: 1			;
 2664: 1			; output:   r4 = 2's complement
 2665: 1			;
 2666: 1			; vernietigt: niets
 2667: 1			;*******************************************************************************
 2668: 1
 2669: 1  08D8	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2670: 1  08DA	C0 D0		               push    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2671: 1  08DC	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2672: 1  08DF	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2673: 1  08E2	80 EF		               sjmp    magsig8c
 2674: 1
 2675: 1  08E4	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2676: 1  08E7	80 04		               sjmp    magsig8acc1c
 2677: 1
 2678: 1  08E9	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2679: 1  08EA	F4		               cpl     a                 ;complementeer abs waarde
 2680: 1  08EB	04		               inc     a                 ;r4 = complement(r0)+1
 2681: 1  08EC	FC		               mov     r4,a              ;bewaar in 2's complement
 2682: 1  08ED	D0 D0		magsig8acc1c:  pop     psw
 2683: 1  08EF	D0 E0		               pop     acc
 2684: 1  08F1	22		               ret                       ;klaar
 2685: 1
 2686: 1			;*******************************************************************************
 2687: 1			; magsig16        (16,6us @16.777216MHz)
 2688: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2689: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2690: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2691: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2692: 1			;           (f0 en f1 zijn 1 als negatief)
 2693: 1			;
 2694: 1			; output:   r1,r0 = 2's complement
 2695: 1			;
 2696: 1			; vernietigt: niets
 2697: 1			;*******************************************************************************
 2698: 1  08F2	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2699: 1  08F4	C0 D0		               push    psw
 2700: 1  08F6	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2701: 1  08F9	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2702: 1  08FC	80 0F		               sjmp    magsig16c
 2703: 1
 2704: 1  08FE	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2705: 1  0901	80 0A		               sjmp    magsig16c
 2706: 1
 2707: 1  0903	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2708: 1  0904	F4		               cpl     a                ;complementeer het dan
 2709: 1  0905	24 01		               add     a, #1            ;en tel er 1 bij
 2710: 1  0907	F8		               mov     r0,a
 2711: 1  0908	E9		               mov     a,r1             ;neem volgende byte
 2712: 1  0909	F4		               cpl     a                ;complementeer en tel carry erbij
 2713: 1  090A	34 00		               addc    a,#0
 2714: 1  090C	F9		               mov     r1,a
 2715: 1  090D	D0 D0		magsig16c:     pop     psw
 2716: 1  090F	D0 E0		               pop     acc
 2717: 1  0911	22		               ret
 2718: 1
 2719: 1			;*******************************************************************************
 2720: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2721: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2722: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2723: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2724: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2725: 1			;           (f0 en f1 zijn 1 als negatief)
 2726: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2727: 1			; output:   r5,r4 = 2's complement
 2728: 1			;
 2729: 1			; vernietigt: niets
 2730: 1			;*******************************************************************************
 2731: 1  0912	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2732: 1  0914	C0 D0		                push    psw
 2733: 1  0916	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2734: 1  0919	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2735: 1  091C	80 0F		                sjmp    magsig16acc1c
 2736: 1
 2737: 1  091E	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2738: 1  0921	80 0A		                sjmp    magsig16acc1c
 2739: 1
 2740: 1  0923	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2741: 1  0924	F4		                cpl     a                   ;complementeer het dan
 2742: 1  0925	24 01		                add     a,#1                ;en tel er 1 bij
 2743: 1  0927	FC		                mov     r4,a
 2744: 1  0928	ED		                mov     a,r5                ;neem volgende byte
 2745: 1  0929	F4		                cpl     a                   ;complementeer en tel carry erbij
 2746: 1  092A	34 00		                addc    a,#0
 2747: 1  092C	FD		                mov     r5,a
 2748: 1  092D	D0 D0		magsig16acc1c:  pop     psw
 2749: 1  092F	D0 E0		                pop     acc
 2750: 1  0931	22		                ret
 2751: 1
 2752: 1			;*******************************************************************************
 2753: 1			; magsig32        (22,2us @16.777216MHz)
 2754: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2755: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2756: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2757: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2758: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2759: 1			;           (f0 en f1 zijn 1 als negatief)
 2760: 1			;
 2761: 1			; output:   r3,r2,r1,r0 = 2's complement
 2762: 1			;
 2763: 1			; vernietigt: niets
 2764: 1			;*******************************************************************************
 2765: 1  0932	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2766: 1  0934	C0 D0		               push    psw
 2767: 1  0936	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2768: 1  0939	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2769: 1  093C	80 19		               sjmp    magsig32c
 2770: 1
 2771: 1  093E	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2772: 1  0941	80 14		               sjmp    magsig32c
 2773: 1
 2774: 1  0943	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2775: 1  0944	F4		               cpl     a                 ;complementeer het dan
 2776: 1  0945	24 01		               add     a,#1             ;en tel er 1 bij
 2777: 1  0947	F8		               mov     r0,a
 2778: 1  0948	E9		               mov     a,r1             ;neem volgende byte
 2779: 1  0949	F4		               cpl     a                 ;complementeer en tel carry erbij
 2780: 1  094A	34 00		               addc    a,#0
 2781: 1  094C	F9		               mov     r1,a
 2782: 1  094D	EA		               mov     a,r2            ;neem volgende byte

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2783: 1  094E	F4		               cpl     a                ;complementeer en tel carry erbij
 2784: 1  094F	34 00		               addc    a,#0
 2785: 1  0951	FA		               mov     r2,a
 2786: 1  0952	EB		               mov     a,r3            ;neem volgende byte
 2787: 1  0953	F4		               cpl     a                ;complementeer en tel carry erbij
 2788: 1  0954	34 00		               addc    a,#0
 2789: 1  0956	FB		               mov     r3,a
 2790: 1
 2791: 1  0957	D0 D0		magsig32c:     pop     psw
 2792: 1  0959	D0 E0		               pop     acc
 2793: 1  095B	22		               ret
 2794: 1
 2795: 1
 2796: 1
 2797: 1			;*******************************************************************************
 2798: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2799: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2800: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2801: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2802: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2803: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2804: 1			;           (f0 en f1 zijn 1 als negatief)
 2805: 1			;
 2806: 1			; output:   r7,r6,r5,r4 = 2's complement
 2807: 1			;
 2808: 1			; vernietigt: niets
 2809: 1			;*******************************************************************************
 2810: 1  095C	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2811: 1  095E	C0 D0		               push    psw
 2812: 1  0960	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2813: 1  0963	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2814: 1  0966	80 19		               sjmp    magsig32acc1c
 2815: 1
 2816: 1  0968	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2817: 1  096B	80 14		               sjmp    magsig32acc1c
 2818: 1
 2819: 1  096D	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2820: 1  096E	F4		               cpl     a                 ;complementeer het dan
 2821: 1  096F	24 01		               add     a,#1             ;en tel er 1 bij
 2822: 1  0971	FC		               mov     r4,a
 2823: 1  0972	ED		               mov     a,r5             ;neem volgende byte
 2824: 1  0973	F4		               cpl     a                 ;complementeer en tel carry erbij
 2825: 1  0974	34 00		               addc    a,#0
 2826: 1  0976	FD		               mov     r5,a
 2827: 1  0977	EE		               mov     a,r6             ;neem volgende byte
 2828: 1  0978	F4		               cpl     a                 ;complementeer en tel carry erbij
 2829: 1  0979	34 00		               addc    a,#0
 2830: 1  097B	FE		               mov     r6,a
 2831: 1  097C	EF		               mov     a,r7             ;neem volgende byte
 2832: 1  097D	F4		               cpl     a                ;complementeer en tel carry erbij
 2833: 1  097E	34 00		               addc    a,#0
 2834: 1  0980	FF		               mov     r7,a
 2835: 1
 2836: 1  0981	D0 D0		magsig32acc1c: pop     psw
 2837: 1  0983	D0 E0		               pop     acc
 2838: 1  0985	22		               ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2839: 1
 2840: 1
 2841: 1			;*******************************************************************************
 2842: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2843: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2844: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2845: 1			; input:     r0 = 2's complement byte in acc0
 2846: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2847: 1			; output:    r0 = absolute waarde
 2848: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2849: 1			;
 2850: 1			; vernietigt: niets
 2851: 1			;*******************************************************************************
 2852: 1
 2853: 1  0986	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2854: 1  0988	C0 D0		                push    psw
 2855: 1  098A	E8		                mov     a,r0               ;neem lsb van acc0
 2856: 1  098B	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2857: 1  098E	D0 D0		                pop     psw
 2858: 1  0990	C2 D5		                clr     f0                 ;nee, positief...klaar
 2859: 1  0992	D0 E0		                pop     acc
 2860: 1  0994	22		                ret
 2861: 1  0995	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2862: 1  0996	04		                inc     a                   ;een erbij
 2863: 1  0997	F8		                mov     r0,a               ;bewaar
 2864: 1  0998	D0 D0		                pop     psw
 2865: 1  099A	D2 D5		                setb    f0                 ;f0=1 als negatief
 2866: 1  099C	D0 E0		                pop     acc
 2867: 1  099E	22		                ret
 2868: 1
 2869: 1			;*******************************************************************************
 2870: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2871: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2872: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2873: 1			; input:     r4 = 2's complement byte in acc1
 2874: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2875: 1			; output:    r4 = absolute waarde
 2876: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2877: 1			;
 2878: 1			; vernietigt: niets
 2879: 1			;*******************************************************************************
 2880: 1
 2881: 1  099F	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2882: 1  09A1	C0 D0		                push    psw
 2883: 1  09A3	EC		                mov     a,r4               ;neem lsb van acc0
 2884: 1  09A4	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2885: 1  09A7	D0 D0		                pop     psw
 2886: 1  09A9	C2 D1		                clr     f1                 ;nee, positief...klaar
 2887: 1  09AB	D0 E0		                pop     acc
 2888: 1  09AD	22		                ret
 2889: 1  09AE	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2890: 1  09AF	04		                inc     a                   ;een erbij
 2891: 1  09B0	FC		                mov     r4,a               ;bewaar
 2892: 1  09B1	D0 D0		                pop     psw
 2893: 1  09B3	D2 D1		                setb    f1                 ;f0=1 als negatief
 2894: 1  09B5	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2895: 1  09B7	22		                ret
 2896: 1
 2897: 1			;*******************************************************************************
 2898: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2899: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2900: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2901: 1			; input:     r1,r0 = 2's complement word in acc0
 2902: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2903: 1			; output:    r1,r0 = absolute waarde
 2904: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2905: 1			;
 2906: 1			; vernietigt: niets
 2907: 1			;*******************************************************************************
 2908: 1
 2909: 1  09B8	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2910: 1  09BA	C0 D0		                push    psw
 2911: 1  09BC	E9		                mov     a,r1               ; neem msb van acc0
 2912: 1  09BD	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2913: 1  09C0	D0 D0		                pop     psw
 2914: 1  09C2	C2 D5		                clr     f0                 ;f0=0 als positief
 2915: 1  09C4	D0 E0		                pop     acc
 2916: 1  09C6	22		                ret                        ;klaar
 2917: 1
 2918: 1  09C7	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2919: 1  09C8	F4		                cpl     a                  ;complementeren
 2920: 1  09C9	24 01		                add     a,#1               ;en een bijtellen
 2921: 1  09CB	F8		                mov     r0,a
 2922: 1  09CC	E9		                mov     a,r1
 2923: 1  09CD	F4		                cpl     a                  ;complement eer volgende byte
 2924: 1  09CE	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2925: 1  09D0	F9		                mov     r1,a
 2926: 1  09D1	D0 D0		                pop     psw
 2927: 1  09D3	D2 D5		                setb    f0                 ;f0=1 als negatief
 2928: 1  09D5	D0 E0		                pop     acc
 2929: 1  09D7	22		                ret
 2930: 1
 2931: 1
 2932: 1			;*******************************************************************************
 2933: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2934: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2935: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2936: 1			; input:     r5,r4 = 2's complement word in acc1
 2937: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2938: 1			; output:    r5,r4 = absolute waarde
 2939: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2940: 1			;
 2941: 1			; vernietigt: niets
 2942: 1			;*******************************************************************************
 2943: 1
 2944: 1  09D8	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2945: 1  09DA	C0 D0		                push    psw
 2946: 1  09DC	ED		                mov     a,r5               ;neem msb van acc1
 2947: 1  09DD	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2948: 1  09E0	D0 D0		                pop     psw
 2949: 1  09E2	C2 D1		                clr     f1                 ;f1=0 als positief
 2950: 1  09E4	D0 E0		                pop    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2951: 1  09E6	22		                ret                        ;klaar
 2952: 1
 2953: 1  09E7	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2954: 1  09E8	F4		                cpl     a                   ;complementeren
 2955: 1  09E9	24 01		                add     a,#1               ;en een bijtellen
 2956: 1  09EB	FC		                mov     r4,a
 2957: 1  09EC	ED		                mov     a,r5
 2958: 1  09ED	F4		                cpl     a                  ;complementeer volgende byte
 2959: 1  09EE	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2960: 1  09F0	FD		                mov     r5,a
 2961: 1  09F1	D0 D0		                pop     psw
 2962: 1  09F3	D2 D1		                setb    f1                ;f1=1 als negatief
 2963: 1  09F5	D0 E0		                pop     acc
 2964: 1  09F7	22		                ret
 2965: 1
 2966: 1
 2967: 1			;*******************************************************************************
 2968: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2969: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2970: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2971: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2972: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2973: 1			; output:    r7,r6 = absolute waarde
 2974: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2975: 1			;
 2976: 1			; vernietigt: niets
 2977: 1			;*******************************************************************************
 2978: 1
 2979: 1  09F8	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2980: 1  09FA	C0 D0		                push    psw
 2981: 1  09FC	EF		                mov     a,r7                ; neem msb van acc1 high
 2982: 1  09FD	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2983: 1  0A00	D0 D0		                pop     psw
 2984: 1  0A02	C2 D5		                clr     f0                  ;f0=0 als positief
 2985: 1  0A04	D0 E0		                pop     acc
 2986: 1  0A06	22		                ret                         ;klaar
 2987: 1
 2988: 1  0A07	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2989: 1  0A08	F4		                cpl     a                   ;complementeren
 2990: 1  0A09	24 01		                add     a,#1               ;en een bijtellen
 2991: 1  0A0B	FE		                mov     r6,a
 2992: 1  0A0C	EF		                mov     a,r7
 2993: 1  0A0D	F4		                cpl     a                  ;complementeer volgende byte
 2994: 1  0A0E	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2995: 1  0A10	FF		                mov     r7,a
 2996: 1  0A11	D0 D0		                pop     psw
 2997: 1  0A13	D2 D5		                setb    f0                ;f0=1 als negatief
 2998: 1  0A15	D0 E0		                pop     acc
 2999: 1  0A17	22		                ret
 3000: 1
 3001: 1
 3002: 1			;*******************************************************************************
 3003: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 3004: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 3005: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 3006: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3007: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 3008: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 3009: 1			;            (-2147483648 tot +2147483647)
 3010: 1			; output:    r3,r2,r1,r0 = absolute waarde
 3011: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 3012: 1			;
 3013: 1			; vernietigt: niets
 3014: 1			;*******************************************************************************
 3015: 1
 3016: 1  0A18	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 3017: 1  0A1A	C0 D0		                push    psw
 3018: 1  0A1C	EB		                mov     a,r3               ;neem msb van acc0
 3019: 1  0A1D	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 3020: 1  0A20	D0 D0		                pop     psw                ;nee, positief
 3021: 1  0A22	C2 D5		                clr     f0
 3022: 1  0A24	D0 E0		                pop     acc
 3023: 1  0A26	22		                ret                        ;klaar
 3024: 1
 3025: 1  0A27	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 3026: 1  0A28	F4		                cpl     a                  ;complementeren
 3027: 1  0A29	24 01		                add     a,#1               ;en een bijtellen
 3028: 1  0A2B	F8		                mov     r0,a
 3029: 1  0A2C	E9		                mov     a,r1               ;neem volgende byte
 3030: 1  0A2D	F4		                cpl     a                  ;complementeer volgende byte
 3031: 1  0A2E	34 00		                addc    a,#0
 3032: 1  0A30	F9		                mov     r1,a
 3033: 1  0A31	EA		                mov     a,r2               ;neem volgende byte
 3034: 1  0A32	F4		                cpl     a                  ;complementeer volgende byte
 3035: 1  0A33	34 00		                addc    a,#0
 3036: 1  0A35	FA		                mov     r2,a
 3037: 1  0A36	EB		                mov     a,r3               ;neem volgende byte
 3038: 1  0A37	F4		                cpl     a                  ;complementeer volgende byte
 3039: 1  0A38	34 00		                addc    a,#0
 3040: 1  0A3A	FB		                mov     r3,a
 3041: 1  0A3B	D0 D0		                pop     psw
 3042: 1  0A3D	D2 D5		                setb    f0                 ;negatief: f0=1
 3043: 1  0A3F	D0 E0		                pop     acc
 3044: 1  0A41	22		                ret                        ;klaar
 3045: 1
 3046: 1			;*******************************************************************************
 3047: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 3048: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 3049: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 3050: 1			;
 3051: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 3052: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 3053: 1			;            (-2147483648 tot +2147483647)
 3054: 1			; output:    r7,r6,r5,r4 = absolute waarde
 3055: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 3056: 1			;
 3057: 1			; vernietigt: niets
 3058: 1			;*******************************************************************************
 3059: 1
 3060: 1  0A42	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 3061: 1  0A44	C0 D0		                push    psw
 3062: 1  0A46	EF		                mov     a,r7               ;neem msb van acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3063: 1  0A47	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 3064: 1  0A4A	D0 D0		                pop     psw                ;nee, positief
 3065: 1  0A4C	C2 D1		                clr     f1
 3066: 1  0A4E	D0 E0		                pop     acc
 3067: 1  0A50	22		                ret                        ;klaar
 3068: 1
 3069: 1  0A51	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 3070: 1  0A52	F4		                cpl     a                   ;complementeren
 3071: 1  0A53	24 01		                add     a,#1               ;en een bijtellen
 3072: 1  0A55	FC		                mov     r4,a
 3073: 1  0A56	ED		                mov     a,r5               ;neem volgende byte
 3074: 1  0A57	F4		                cpl     a                  ;complementeer volgende byte
 3075: 1  0A58	34 00		                addc    a,#0
 3076: 1  0A5A	FD		                mov     r5,a
 3077: 1  0A5B	EE		                mov     a,r6               ;neem volgende byte
 3078: 1  0A5C	F4		                cpl     a                  ;complementeer volgende byte
 3079: 1  0A5D	34 00		                addc    a,#0
 3080: 1  0A5F	FE		                mov     r6,a
 3081: 1  0A60	EF		                mov     a,r7               ;neem volgende byte
 3082: 1  0A61	F4		                cpl     a                  ;complementeer volgende byte
 3083: 1  0A62	34 00		                addc    a,#0
 3084: 1  0A64	FF		                mov     r7,a
 3085: 1  0A65	D0 D0		                pop     psw
 3086: 1  0A67	D2 D1		                setb    f1                 ;negatief: f0=1
 3087: 1  0A69	D0 E0		                pop     acc
 3088: 1  0A6B	22		                ret                        ;klaar
 3089: 1
 3090: 1
 3091: 1			;*******************************************************************************
 3092: 1			; s_add16        (19,35us @16.777216MHz)
 3093: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 3094: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3095: 1			; input:     r1,r0 = acc0
 3096: 1			;            r5,r4 = acc1
 3097: 1			;
 3098: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 3099: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3100: 1			;                  gebruik van r3,r2 is niet nodig
 3101: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3102: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3103: 1			;
 3104: 1			; vernietigt:  niets
 3105: 1			;*******************************************************************************
 3106: 1  0A6C	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 3107: 1  0A6E	C0 D0		               push    psw
 3108: 1
 3109: 1  0A70	E8		               mov     a,r0           ;tel de soft accumulators op
 3110: 1  0A71	2C		               add     a,r4           ;low byte eerst
 3111: 1  0A72	F8		               mov     r0,a           ;resultaat bewaren
 3112: 1  0A73	E9		               mov     a,r1           ;nu de high bytes
 3113: 1  0A74	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3114: 1  0A75	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3115: 1
 3116: 1  0A76	92 D5		               mov     f0,c
 3117: 1  0A78	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 3118: 1  0A7A	92 D1		               mov     f1,c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3119: 1  0A7C	A2 D5		               mov     c,f0           ;herstel carrybit
 3120: 1
 3121: 1  0A7E	74 00		               mov     a,#00h
 3122: 1  0A80	34 00		               addc    a,#00h
 3123: 1  0A82	FA		               mov     r2,a            ;24bit resultaat klaar
 3124: 1
 3125: 1  0A83	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 3126: 1
 3127: 1  0A86	EA		               mov     a,r2            ;ja, sign extention toepassen!
 3128: 1  0A87	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 3129: 1  0A8A	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3130: 1  0A8C	7B FF		               mov     r3,#0ffh
 3131: 1  0A8E	80 04		               sjmp    s_add162
 3132: 1  0A90	7A 00		s_add161:      mov     r2,#00h
 3133: 1  0A92	7B 00		               mov     r3,#00h
 3134: 1  0A94	D0 D0		s_add162:      pop     psw
 3135: 1  0A96	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3136: 1  0A97	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 3137: 1  0A99	22		               ret
 3138: 1
 3139: 1  0A9A	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 3140: 1  0A9C	C3		               clr     c
 3141: 1  0A9D	D0 E0		               pop     acc
 3142: 1  0A9F	22		               ret
 3143: 1
 3144: 1			;*******************************************************************************
 3145: 1			; add16        (13,6us @16.777216MHz)
 3146: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 3147: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3148: 1			; input:     r1,r0 = acc0
 3149: 1			;            r5,r4 = acc1
 3150: 1			;
 3151: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 3152: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 3153: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3154: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 3155: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 3156: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 3157: 1			;
 3158: 1			; vernietigt:  niets
 3159: 1			;*******************************************************************************
 3160: 1
 3161: 1  0AA0	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 3162: 1  0AA2	C0 D0		               push    psw
 3163: 1  0AA4	E8		               mov     a,r0           ;tel de soft accumulators op
 3164: 1  0AA5	2C		               add     a,r4           ;low byte eerst
 3165: 1  0AA6	F8		               mov     r0,a           ;resultaat bewaren
 3166: 1  0AA7	E9		               mov     a,r1           ;nu de high bytes
 3167: 1  0AA8	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3168: 1  0AA9	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3169: 1  0AAA	50 08		               jnc     add161          ;geen 24 bit resultaat
 3170: 1
 3171: 1  0AAC	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 3172: 1  0AAE	D0 D0		               pop     psw
 3173: 1  0AB0	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3174: 1  0AB1	D0 E0		               pop     acc             ;resultaat 24 bits groot is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3175: 1  0AB3	22		               ret
 3176: 1
 3177: 1  0AB4	7A 00		add161:        mov     r2,#00h
 3178: 1  0AB6	D0 D0		               pop     psw
 3179: 1  0AB8	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3180: 1  0AB9	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 3181: 1  0ABB	22		               ret
 3182: 1
 3183: 1			;*******************************************************************************
 3184: 1			; s_add32        (28,0us @16.777216MHz)
 3185: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 3186: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3187: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3188: 1			; input:     r3,r2,r1,r0 = acc0
 3189: 1			;            r7,r6,r5,r4 = acc1
 3190: 1			;
 3191: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 3192: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3193: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 3194: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3195: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3196: 1			;
 3197: 1			; vernietigt:  niets
 3198: 1			;*******************************************************************************
 3199: 1  0ABC	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 3200: 1  0ABE	C0 D0		               push    psw
 3201: 1
 3202: 1  0AC0	E8		               mov     a,r0           ;tel de soft accumulators op
 3203: 1  0AC1	2C		               add     a,r4           ;low byte eerst
 3204: 1  0AC2	F8		               mov     r0,a           ;resultaat bewaren
 3205: 1  0AC3	E9		               mov     a,r1           ;nu de hogere bytes
 3206: 1  0AC4	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3207: 1  0AC5	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3208: 1
 3209: 1  0AC6	EA		               mov     a,r2           ;derde bytes optellen
 3210: 1  0AC7	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3211: 1  0AC8	FA		               mov     r2,a           ;24bit resultaat is klaar
 3212: 1  0AC9	EB		               mov     a,r3           ;nu de ms bytes
 3213: 1  0ACA	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3214: 1  0ACB	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3215: 1
 3216: 1  0ACC	92 D5		               mov     f0,c
 3217: 1  0ACE	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 3218: 1  0AD0	92 D1		               mov     f1,c
 3219: 1  0AD2	A2 D5		               mov     c,f0           ;herstel carrybit
 3220: 1
 3221: 1  0AD4	74 00		               mov     a,#00h
 3222: 1  0AD6	34 00		               addc    a,#00h
 3223: 1  0AD8	FC		               mov     r4,a            ;40bit resultaat klaar
 3224: 1
 3225: 1  0AD9	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 3226: 1  0ADC	EC		               mov     a,r4            ;ja, sign extention toepassen!
 3227: 1  0ADD	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 3228: 1  0AE0	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3229: 1  0AE2	80 02		               sjmp    s_add322
 3230: 1  0AE4	7C 00		s_add321:      mov     r4,#00h

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3231: 1  0AE6	D0 D0		s_add322:      pop     psw
 3232: 1  0AE8	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3233: 1  0AE9	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 3234: 1  0AEB	22		               ret
 3235: 1
 3236: 1  0AEC	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 3237: 1  0AEE	C3		               clr     c
 3238: 1  0AEF	D0 E0		               pop     acc
 3239: 1  0AF1	22		               ret
 3240: 1
 3241: 1
 3242: 1			;*******************************************************************************
 3243: 1			; add32        (18,0us @16.777216MHz)
 3244: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 3245: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3246: 1			; input:     r3,r2,r1,r0 = acc0
 3247: 1			;            r7,r6,r5,r4 = acc1
 3248: 1			;
 3249: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 3250: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3251: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3252: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 3253: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3254: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3255: 1			;
 3256: 1			; vernietigt:  niets
 3257: 1			;*******************************************************************************
 3258: 1  0AF2	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 3259: 1  0AF4	C0 D0		               push    psw
 3260: 1  0AF6	E8		               mov     a,r0           ;tel de soft accumulators op
 3261: 1  0AF7	2C		               add     a,r4           ;low byte eerst
 3262: 1  0AF8	F8		               mov     r0,a           ;resultaat bewaren
 3263: 1  0AF9	E9		               mov     a,r1           ;nu de hogere bytes
 3264: 1  0AFA	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3265: 1  0AFB	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3266: 1
 3267: 1  0AFC	EA		               mov     a,r2           ;derde bytes optellen
 3268: 1  0AFD	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3269: 1  0AFE	FA		               mov     r2,a           ;24bit resultaat is klaar
 3270: 1  0AFF	EB		               mov     a,r3           ;nu de ms bytes
 3271: 1  0B00	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3272: 1  0B01	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3273: 1
 3274: 1  0B02	50 08		               jnc     add321          ;geen 40 bit resultaat
 3275: 1
 3276: 1  0B04	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3277: 1  0B06	D0 D0		               pop     psw
 3278: 1  0B08	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3279: 1  0B09	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3280: 1  0B0B	22		               ret
 3281: 1
 3282: 1  0B0C	7C 00		add321:        mov     r4,#00h
 3283: 1  0B0E	D0 D0		               pop     psw
 3284: 1  0B10	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3285: 1  0B11	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3286: 1  0B13	22		               ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3287: 1
 3288: 1
 3289: 1			;*******************************************************************************
 3290: 1			; s_sub16        (24,4us @16.777216MHz)
 3291: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3292: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3293: 1			; input:     r1,r0 = acc0
 3294: 1			;            r5,r4 = acc1
 3295: 1			;
 3296: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3297: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3298: 1			;                  gebruik van r3,r2 is niet nodig
 3299: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3300: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3301: 1			;
 3302: 1			; vernietigt:  niets
 3303: 1			;*******************************************************************************
 3304: 1  0B14	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3305: 1  0B16	C0 D0		                push    psw
 3306: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3307: 1
 3308: 1  0B18	EC		                mov   	a,r4            ;verander het teken van acc1
 3309: 1  0B19	F4		                cpl    	a               ;door het 2's complement te nemen
 3310: 1  0B1A	24 01		                add   	a,#1
 3311: 1  0B1C	FC		                mov    	r4,a
 3312: 1  0B1D	ED		                mov    	a,r5
 3313: 1  0B1E	F4		                cpl    	a
 3314: 1  0B1F	34 00		                addc	a,#0
 3315: 1  0B21	FD		                mov    	r5,a
 3316: 1			;acc0+acc1
 3317: 1  0B22	E8						mov		a,r0
 3318: 1  0B23	2C						add		a,r4
 3319: 1  0B24	F8						mov		r0,a
 3320: 1  0B25	E9						mov		a,r1
 3321: 1  0B26	3D						addc	a,r5
 3322: 1  0B27	F9						mov		r1,a
 3323: 1
 3324: 1  0B28	92 D5		                mov    f0,c
 3325: 1  0B2A	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3326: 1  0B2C	92 D1		                mov    f1,c
 3327: 1  0B2E	A2 D5		                mov    c,f0            ;herstel carrybit
 3328: 1
 3329: 1  0B30	74 00		                mov    a,#00h
 3330: 1  0B32	34 00		                addc   a,#00h
 3331: 1  0B34	FA		                mov    r2,a            ;24bit resultaat klaar
 3332: 1
 3333: 1  0B35	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3334: 1  0B38	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3335: 1  0B39	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3336: 1  0B3C	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3337: 1  0B3E	7B FF		                mov    r3,#0ffh
 3338: 1  0B40	80 04		                sjmp   s_sub162
 3339: 1  0B42	7A 00		s_sub161:       mov    r2,#00h
 3340: 1  0B44	7B 00		                mov    r3,#00h
 3341: 1  0B46	D0 D0		s_sub162:       pop    psw
 3342: 1  0B48	D3		                setb   c               ;aangeven aan de gebruiker dat het

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3343: 1  0B49	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3344: 1  0B4B	22		                ret
 3345: 1
 3346: 1  0B4C	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3347: 1  0B4E	C3		                clr    c
 3348: 1  0B4F	D0 E0		                pop    acc
 3349: 1  0B51	22		                ret
 3350: 1
 3351: 1			;*******************************************************************************
 3352: 1			; sub16            (14,4us @16.777216MHz)
 3353: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3354: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3355: 1			; input:     r1,r0 = acc0
 3356: 1			;            r5,r4 = acc1
 3357: 1			;
 3358: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3359: 1			;            bij een underflow r2 op ffh zetten
 3360: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3361: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3362: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3363: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3364: 1			;
 3365: 1			; vernietigt:  niets
 3366: 1			;*******************************************************************************
 3367: 1
 3368: 1  0B52	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3369: 1  0B54	C0 D0		                push    psw
 3370: 1  0B56	C3		                clr     c
 3371: 1  0B57	E8		                mov     a,r0            ;tel de soft accumulators op
 3372: 1  0B58	9C		                subb    a,r4            ;low byte eerst
 3373: 1  0B59	F8		                mov     r0,a            ;resultaat bewaren
 3374: 1  0B5A	E9		                mov     a,r1            ;nu de high bytes
 3375: 1  0B5B	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3376: 1  0B5C	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3377: 1  0B5D	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3378: 1
 3379: 1  0B5F	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3380: 1  0B61	D0 D0		                pop     psw
 3381: 1  0B63	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3382: 1  0B64	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3383: 1  0B66	22		                ret
 3384: 1
 3385: 1  0B67	7A 00		sub161:         mov     r2,#00h
 3386: 1  0B69	D0 D0		                pop     psw
 3387: 1  0B6B	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3388: 1  0B6C	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3389: 1  0B6E	22		                ret
 3390: 1
 3391: 1			;*******************************************************************************
 3392: 1			; s_sub32        (27,2us @16.777216MHz)
 3393: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3394: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3395: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3396: 1			; input:     r3,r2,r1,r0 = acc0
 3397: 1			;            r7,r6,r5,r4 = acc1
 3398: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3399: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3400: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3401: 1			;                  gebruik van r4 is niet nodig
 3402: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3403: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3404: 1			;
 3405: 1			; vernietigt:  niets
 3406: 1			;*******************************************************************************
 3407: 1  0B6F	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3408: 1  0B71	C0 D0		                push   psw
 3409: 1
 3410: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3411: 1
 3412: 1  0B73	EC		                mov    	a,r4            ;verander het teken van acc1
 3413: 1  0B74	F4		                cpl    	a               ;door het 2's complement te nemen
 3414: 1  0B75	24 01		                add    	a,#1
 3415: 1  0B77	FC		                mov    	r4,a
 3416: 1  0B78	ED		                mov    	a,r5
 3417: 1  0B79	F4		                cpl    	a
 3418: 1  0B7A	34 00		                addc	a,#0
 3419: 1  0B7C	FD		                mov    	r5,a
 3420: 1  0B7D	EE		                mov    	a,r6
 3421: 1  0B7E	F4		                cpl    	a
 3422: 1  0B7F	34 00		                addc   	a,#0
 3423: 1  0B81	FE		                mov    	r6,a
 3424: 1  0B82	EF		                mov    	a,r7
 3425: 1  0B83	F4		                cpl    	a
 3426: 1  0B84	34 00		                addc   	a,#0
 3427: 1  0B86	FF		                mov    	r7,a
 3428: 1			;acc0+acc1
 3429: 1  0B87	E8						mov		a,r0
 3430: 1  0B88	2C						add		a,r4
 3431: 1  0B89	F8						mov		r0,a
 3432: 1  0B8A	E9						mov		a,r1
 3433: 1  0B8B	3D						addc	a,r5
 3434: 1  0B8C	F9						mov		r1,a
 3435: 1  0B8D	EA						mov		a,r2
 3436: 1  0B8E	3E						addc	a,r6
 3437: 1  0B8F	FA						mov		r2,a
 3438: 1  0B90	EB						mov		a,r3
 3439: 1  0B91	3F						addc	a,r7
 3440: 1  0B92	FB						mov		r3,a
 3441: 1
 3442: 1  0B93	92 D5		                mov   f0,c
 3443: 1  0B95	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3444: 1  0B97	92 D1		                mov   f1,c
 3445: 1  0B99	A2 D5		                mov   c,f0            ;herstel carrybit
 3446: 1
 3447: 1  0B9B	74 00		                mov   a,#00h
 3448: 1  0B9D	34 00		                addc  a,#00h
 3449: 1  0B9F	FC		                mov   r4,a            ;40bit resultaat klaar
 3450: 1
 3451: 1  0BA0	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3452: 1
 3453: 1  0BA3	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3454: 1  0BA4	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3455: 1  0BA7	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3456: 1  0BA9	80 02		                sjmp   s_sub322
 3457: 1  0BAB	7C 00		s_sub321:       mov   r4,#00h
 3458: 1  0BAD	D0 D0		s_sub322:       pop   psw
 3459: 1  0BAF	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3460: 1  0BB0	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3461: 1  0BB2	22		                ret
 3462: 1
 3463: 1  0BB3	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3464: 1  0BB5	C3		                clr   c
 3465: 1  0BB6	D0 E0		                pop   acc
 3466: 1  0BB8	22		                ret
 3467: 1
 3468: 1
 3469: 1			;*******************************************************************************
 3470: 1			; sub32        (18,7us @16.777216MHz)
 3471: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3472: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3473: 1			; input:     r3,r2,r1,r0 = acc0
 3474: 1			;            r7,r6,r5,r4 = acc1
 3475: 1			;
 3476: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3477: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3478: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3479: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3480: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3481: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3482: 1			;
 3483: 1			; vernietigt:  niets
 3484: 1			;*******************************************************************************
 3485: 1  0BB9	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3486: 1  0BBB	C0 D0		               push    psw
 3487: 1  0BBD	C3		               clr       c
 3488: 1  0BBE	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3489: 1  0BBF	9C		               subb    a,r4           ;low byte eerst
 3490: 1  0BC0	F8		               mov     r0,a           ;resultaat bewaren
 3491: 1  0BC1	E9		               mov     a,r1           ;nu de hogere bytes
 3492: 1  0BC2	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3493: 1  0BC3	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3494: 1
 3495: 1  0BC4	EA		               mov     a,r2           ;derde bytes optellen
 3496: 1  0BC5	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3497: 1  0BC6	FA		               mov     r2,a           ;24bit resultaat is klaar
 3498: 1  0BC7	EB		               mov     a,r3           ;nu de ms bytes
 3499: 1  0BC8	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3500: 1  0BC9	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3501: 1
 3502: 1  0BCA	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3503: 1
 3504: 1  0BCC	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3505: 1  0BCE	D0 D0		               pop     psw
 3506: 1  0BD0	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3507: 1  0BD1	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3508: 1  0BD3	22		               ret
 3509: 1
 3510: 1  0BD4	7C 00		sub321:        mov     r4,#00h

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3511: 1  0BD6	D0 D0		               pop     psw
 3512: 1  0BD8	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3513: 1  0BD9	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3514: 1  0BDB	22		               ret
 3515: 1
 3516: 1
 3517: 1
 3518: 1			;*******************************************************************************
 3519: 1			; mul16        (71,2us @16.777216MHz)
 3520: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3521: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3522: 1			; input:     r1,r0 = acc0
 3523: 1			;            r5,r4 = acc1
 3524: 1			;
 3525: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3526: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3527: 1			;
 3528: 1			; vernietigt:  niets
 3529: 1			;*******************************************************************************
 3530: 1  0BDC	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3531: 1  0BDE	C0 D0		                push    psw
 3532: 1  0BE0	C0 F0		                push    b
 3533: 1  0BE2	C0 82		                push    dpl
 3534: 1  0BE4	C0 83		                push    dph
 3535: 1
 3536: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3537: 1
 3538: 1  0BE6	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3539: 1  0BE8	89 83		                mov     dph,r1
 3540: 1  0BEA	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3541: 1  0BEC	08		                inc     r0              ;pointer naar eerste vrije plaats
 3542: 1  0BED	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3543: 1  0BEF	E5 81		                mov     a,sp            ;plaats alloceren
 3544: 1  0BF1	24 03		                add     a,#3            ;3 bytes nodig
 3545: 1  0BF3	F5 81		                mov     sp,a            ;stackpointer verzetten
 3546: 1
 3547: 1  0BF5	E5 82		                mov     a,dpl            ;acc0 lsb
 3548: 1  0BF7	8C F0		                mov     b,r4            ;acc1 lsb
 3549: 1  0BF9	A4		                mul     ab
 3550: 1  0BFA	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3551: 1  0BFB	08		                inc     r0
 3552: 1  0BFC	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3553: 1
 3554: 1  0BFE	E5 83		                mov     a,dph            ;acc0 msb
 3555: 1  0C00	8C F0		                mov     b,r4            ;acc1 lsb
 3556: 1  0C02	A4		                mul     ab
 3557: 1
 3558: 1  0C03	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3559: 1  0C04	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3560: 1  0C05	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3561: 1  0C07	34 00		                addc    a,#0
 3562: 1  0C09	08		                inc     r0               ;bewaar als tussenresultaat
 3563: 1  0C0A	F6		                mov     @r0,a
 3564: 1
 3565: 1  0C0B	E5 82		                mov     a,dpl            ;acc0 lsb
 3566: 1  0C0D	8D F0		                mov     b,r5             ;acc1 msb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3567: 1  0C0F	A4		                mul     ab
 3568: 1  0C10	18		                dec     r0
 3569: 1  0C11	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3570: 1  0C12	F6		                mov     @r0,a            ;en bewaar weer
 3571: 1  0C13	08		                inc     r0
 3572: 1  0C14	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3573: 1  0C16	36		                addc    a,@r0
 3574: 1  0C17	F6		                mov     @r0,a            ;en bewaar weer
 3575: 1  0C18	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3576: 1
 3577: 1  0C1A	E5 83		                mov     a,dph            ;acc0 msb
 3578: 1  0C1C	8D F0		                mov     b,r5             ;acc1 msb
 3579: 1  0C1E	A4		                mul     AB
 3580: 1  0C1F	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3581: 1  0C20	FA		                mov     r2,a
 3582: 1  0C21	E5 F0		                mov     a,b
 3583: 1  0C23	34 00		                addc    a,#0
 3584: 1
 3585: 1  0C25	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3586: 1  0C27	34 00		                addc    a,#0
 3587: 1
 3588: 1  0C29	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3589: 1  0C2A	18		                dec     r0
 3590: 1  0C2B	86 83		                mov     dph,@r0
 3591: 1  0C2D	18		                dec     r0
 3592: 1  0C2E	86 82		                mov     dpl,@r0
 3593: 1
 3594: 1  0C30	89 81		                mov     sp,r1            ;zet stackpointer terug
 3595: 1  0C32	A9 83		                mov     r1,dph
 3596: 1  0C34	A8 82		                mov     r0,dpl
 3597: 1
 3598: 1  0C36	D0 83		                pop     dph              ;herstel de bewaarde registers
 3599: 1  0C38	D0 82		                pop     dpl
 3600: 1  0C3A	D0 F0		                pop     b
 3601: 1  0C3C	D0 D0		                pop     psw
 3602: 1  0C3E	D0 E0		                pop     acc
 3603: 1  0C40	22		                ret
 3604: 1
 3605: 1
 3606: 1
 3607: 1			;*******************************************************************************
 3608: 1			; mul16acc1        (71,2us @16.777216MHz)
 3609: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3610: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3611: 1			; input:     r5,r4 = acc1 low
 3612: 1			;            r7,r6 = acc1 high
 3613: 1			;
 3614: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3615: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3616: 1			;
 3617: 1			; vernietigt:  niets
 3618: 1			;*******************************************************************************
 3619: 1  0C41	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3620: 1  0C43	C0 D0		                push    psw
 3621: 1  0C45	C0 F0		                push    b
 3622: 1  0C47	C0 82		                push    dpl

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3623: 1  0C49	C0 83		                push    dph
 3624: 1
 3625: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3626: 1
 3627: 1  0C4B	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3628: 1  0C4D	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3629: 1
 3630: 1  0C4F	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3631: 1  0C51	08		                inc     r0               ;pointer naar eerste vrije plaats
 3632: 1  0C52	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3633: 1  0C54	E5 81		                mov     a,sp             ;plaats alloceren
 3634: 1  0C56	24 03		                add     a,#3             ;3 bytes nodig
 3635: 1  0C58	F5 81		                mov     sp,a             ;stackpointer verzetten
 3636: 1
 3637: 1  0C5A	EC		                mov     a,r4             ;acc1 low lsb
 3638: 1  0C5B	8E F0		                mov     b,r6             ;acc1 high lsb
 3639: 1  0C5D	A4		                mul     ab
 3640: 1  0C5E	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3641: 1  0C5F	08		                inc     r0
 3642: 1  0C60	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3643: 1
 3644: 1  0C62	ED		                mov     a,r5             ;acc1 low msb
 3645: 1  0C63	8E F0		                mov     b,r6             ;acc1 high lsb
 3646: 1  0C65	A4		                mul     ab
 3647: 1
 3648: 1  0C66	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3649: 1  0C67	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3650: 1  0C68	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3651: 1  0C6A	34 00		                addc    a,#0
 3652: 1  0C6C	08		                inc     r0               ;bewaar als tussenresultaat
 3653: 1  0C6D	F6		                mov     @r0,a
 3654: 1
 3655: 1  0C6E	EC		                mov     a,r4             ;acc1 low lsb
 3656: 1  0C6F	8F F0		                mov     b,r7             ;acc1 high msb
 3657: 1  0C71	A4		                mul     ab
 3658: 1  0C72	18		                dec     r0
 3659: 1  0C73	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3660: 1  0C74	F6		                mov     @r0,a            ;en bewaar weer
 3661: 1  0C75	08		                inc     r0
 3662: 1  0C76	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3663: 1  0C78	36		                addc    a,@r0
 3664: 1  0C79	F6		                mov     @r0,a            ;en bewaar weer
 3665: 1  0C7A	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3666: 1
 3667: 1  0C7C	ED		                mov     a,r5             ;acc1 low msb
 3668: 1  0C7D	8F F0		                mov     b,r7             ;acc1 high msb
 3669: 1  0C7F	A4		                mul     AB
 3670: 1
 3671: 1  0C80	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3672: 1  0C81	FE		                mov     r6,a             ;deze byte van product is al klaar
 3673: 1  0C82	E5 F0		                mov     a,b
 3674: 1  0C84	34 00		                addc    a,#0
 3675: 1  0C86	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3676: 1  0C88	34 00		                addc    a,#0
 3677: 1
 3678: 1  0C8A	FF		                mov     r7,a          ;product is klaar, outputregisters vullen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3679: 1  0C8B	18		                dec     r0
 3680: 1  0C8C	E6		                mov     a,@r0
 3681: 1  0C8D	FD		                mov     r5,a
 3682: 1  0C8E	18		                dec     r0
 3683: 1  0C8F	E6		                mov     a,@r0
 3684: 1  0C90	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3685: 1
 3686: 1  0C91	89 81		                mov     sp,r1            ;zet stackpointer terug
 3687: 1  0C93	A9 83		                mov     r1,dph
 3688: 1  0C95	A8 82		                mov     r0,dpl
 3689: 1
 3690: 1  0C97	D0 83		                pop     dph              ;herstel de bewaarde registers
 3691: 1  0C99	D0 82		                pop     dpl
 3692: 1  0C9B	D0 F0		                pop     b
 3693: 1  0C9D	D0 D0		                pop     psw
 3694: 1  0C9F	D0 E0		                pop     acc
 3695: 1  0CA1	22		                ret
 3696: 1
 3697: 1			;*******************************************************************************
 3698: 1			; s_mul16        (121,1us @16.777216MHz)
 3699: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3700: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3701: 1			; input:     r1,r0 = acc0
 3702: 1			;            r5,r4 = acc1
 3703: 1			;
 3704: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3705: 1			;                                  -1073709056 tot +1073741824
 3706: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3707: 1			;
 3708: 1			; vernietigt:  niets
 3709: 1			;*******************************************************************************
 3710: 1  0CA2	12 09 B8	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3711: 1  0CA5	12 09 D8	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3712: 1  0CA8	12 0B DC	                lcall    mul16           ;maak product
 3713: 1  0CAB	12 09 32	                lcall    magsig32        ;maak 2's complement formaat
 3714: 1  0CAE	22		                ret                      ;klaar
 3715: 1
 3716: 1			;*******************************************************************************
 3717: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3718: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3719: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3720: 1			; input:     r5,r4 = acc1 low
 3721: 1			;            r7,r6 = acc1 high
 3722: 1			;
 3723: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3724: 1			;                                  -1073709056 tot +1073741824
 3725: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3726: 1			; vernietigt:  niets
 3727: 1			;*******************************************************************************
 3728: 1  0CAF	12 09 D8	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3729: 1  0CB2	12 09 F8	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3730: 1  0CB5	12 0C 41	                lcall    mul16acc1       ;maak product
 3731: 1  0CB8	12 09 5C	                lcall    magsig32acc1    ;maak 2's complement formaat
 3732: 1  0CBB	22		                ret                      ;klaar
 3733: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3734: 1			;*******************************************************************************
 3735: 1			; s_mul816        (83,5us @16.777216MHz)
 3736: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3737: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3738: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3739: 1			; input:     r1,r0 = acc0
 3740: 1			;               r4 = acc1
 3741: 1			;
 3742: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3743: 1			;                                  -4194176 tot +4194304
 3744: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3745: 1			; vernietigt:  niets
 3746: 1			;*******************************************************************************
 3747: 1  0CBC	12 09 B8	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3748: 1  0CBF	12 09 9F	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3749: 1  0CC2	12 0C C9	                lcall    mul816          ;8bit x 16 bit product
 3750: 1  0CC5	12 09 32	                lcall    magsig32        ;abs. waarde naar 2's complement
 3751: 1  0CC8	22		                ret
 3752: 1
 3753: 1			;*******************************************************************************
 3754: 1			; mul816        (29,4us @16.777216MHz)
 3755: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3756: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3757: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3758: 1			; input:     r1,r0 = acc0
 3759: 1			;               r4 = acc1
 3760: 1			;
 3761: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3762: 1			;                           0..16711425 (000000h..feff01h)
 3763: 1			;
 3764: 1			; vernietigt:  niets
 3765: 1			;*******************************************************************************
 3766: 1  0CC9	C0 E0		mul816:         push    acc             ;bewaar registers
 3767: 1  0CCB	C0 F0		                push    b
 3768: 1  0CCD	C0 D0		                push    psw
 3769: 1  0CCF	EC		                mov     a,r4            ;neem acc1
 3770: 1  0CD0	88 F0		                mov     b,r0            ;neem lsb van acc0
 3771: 1  0CD2	A4		                mul     ab              ;maak product
 3772: 1  0CD3	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3773: 1  0CD4	C0 F0		                push    b               ;bewaar lsb van het product
 3774: 1  0CD6	EC		                mov     a,r4            ;neem acc1
 3775: 1  0CD7	89 F0		                mov     b,r1            ;neem msb can acc0
 3776: 1  0CD9	A4		                mul     ab              ;maak product
 3777: 1  0CDA	AA F0		                mov     r2,b            ;bewaar msb van product even
 3778: 1  0CDC	F5 F0		                mov     b,a             ;verplaats lsb van product
 3779: 1  0CDE	D0 E0		                pop     acc             ;neem msb van vorig product
 3780: 1  0CE0	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3781: 1  0CE2	F9		                mov     r1,a            ;de middenste byte is klaar
 3782: 1  0CE3	EA		                mov     a,r2            ;tel nu de eventuele
 3783: 1  0CE4	34 00		                addc    a,#0            ;carry bij de msb
 3784: 1  0CE6	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3785: 1  0CE7	7B 00		                mov     r3,#0
 3786: 1  0CE9	D0 D0		                pop     psw
 3787: 1  0CEB	D0 F0		                pop     b
 3788: 1  0CED	D0 E0		                pop     acc
 3789: 1  0CEF	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3790: 1
 3791: 1			;*******************************************************************************
 3792: 1			; s_mac16        (145,1us @16.777216MHz)
 3793: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3794: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3795: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3796: 1			; input:     r7,r6 = acc1 (high word)
 3797: 1			;            r5,r4 = acc1 (low  word)
 3798: 1			;
 3799: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3800: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3801: 1			;                          -2147483648 tot +2147483647
 3802: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3803: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3804: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3805: 1			;
 3806: 1			; vernietigt:  niets
 3807: 1			;*******************************************************************************
 3808: 1  0CF0	12 0C AF	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3809: 1  0CF3	C0 E0		                push    acc
 3810: 1  0CF5	C0 D0		                push    psw
 3811: 1  0CF7	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3812: 1  0CF8	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3813: 1  0CF9	F8		                mov     r0,a
 3814: 1  0CFA	ED		                mov     a,r5
 3815: 1  0CFB	39		                addc    a,r1
 3816: 1  0CFC	F9		                mov     r1,a
 3817: 1  0CFD	EE		                mov     a,r6
 3818: 1  0CFE	3A		                addc    a,r2
 3819: 1  0CFF	FA		                mov     r2,a
 3820: 1  0D00	EF		                mov     a,r7
 3821: 1  0D01	3B		                addc    a,r3
 3822: 1  0D02	FB		                mov     r3,a
 3823: 1  0D03	20 D2 06	                jb      ov,s_mac161
 3824: 1  0D06	D0 D0		                pop     psw
 3825: 1  0D08	C3		                clr     c                ;ok, 32bit som binnen bereik
 3826: 1  0D09	D0 E0		                pop     acc
 3827: 1  0D0B	22		                ret
 3828: 1  0D0C	D0 D0		s_mac161:       pop     psw
 3829: 1  0D0E	D3		                setb    c                ;fout! 32bit som buiten bereik
 3830: 1  0D0F	D0 E0		                pop     acc
 3831: 1  0D11	22		                ret
 3832: 1
 3833: 1
 3834: 1			;*******************************************************************************
 3835: 1			; s_div8        (78us @16.777216MHz)
 3836: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3837: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3838: 1			; input:    r0 = acc0 deeltal (2's compl)
 3839: 1			;           r4 = acc1 deler   (2's compl)
 3840: 1			;
 3841: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3842: 1			;           r4 = rest (2's compl)
 3843: 1			;           cy=1 bij acc1=0 (deling door nul)
 3844: 1			;            cy=0 in andere gevallen
 3845: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3846: 1			; vernietigt: niets
 3847: 1			;*******************************************************************************
 3848: 1  0D12	12 09 86	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3849: 1  0D15	12 09 9F	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3850: 1  0D18	12 0D 24	                lcall   div8
 3851: 1  0D1B	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3852: 1  0D1D	12 08 BE	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3853: 1  0D20	12 08 D8	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3854: 1  0D23	22		s_div81:        ret
 3855: 1
 3856: 1			;*******************************************************************************
 3857: 1			; div8        (19,4us @16.777216MHz)
 3858: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3859: 1			; absolute waarde
 3860: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3861: 1			; input:    r0 = acc0 deeltal
 3862: 1			;           r4 = acc1 deler
 3863: 1			;
 3864: 1			; output:   r0 = quotient van deling acc0/acc1
 3865: 1			;           r4 = rest
 3866: 1			;           cy=1 bij acc1=0 (deling door nul)
 3867: 1			;            cy=0 in andere gevallen
 3868: 1			;
 3869: 1			; vernietigt: niets
 3870: 1			;*******************************************************************************
 3871: 1  0D24	C0 E0		div8:           push    acc             ;bewaar registers
 3872: 1  0D26	C0 F0		                push    b
 3873: 1  0D28	C0 D0		                push    psw
 3874: 1  0D2A	EC		                mov     a,r4            ;neem deler
 3875: 1  0D2B	60 0F		                jz      div81           ;deling door nul?
 3876: 1  0D2D	E8		                mov     a,r0            ;nee, neem deeltal
 3877: 1  0D2E	8C F0		                mov     b,r4            ;en deler
 3878: 1  0D30	84		                div     ab              ;en maak deling
 3879: 1  0D31	F8		                mov     r0,a            ;bewaar quotient in acc0
 3880: 1  0D32	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3881: 1  0D34	D0 D0		                pop     psw             ;herstel registers
 3882: 1  0D36	D0 F0		                pop     b
 3883: 1  0D38	D0 E0		                pop     acc
 3884: 1  0D3A	C3		                clr     c                ;geen deling door nul
 3885: 1  0D3B	22		                ret
 3886: 1
 3887: 1  0D3C	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3888: 1  0D3E	D0 F0		                pop     b
 3889: 1  0D40	D0 E0		                pop     acc
 3890: 1  0D42	D3		                setb    c
 3891: 1  0D43	22		                ret
 3892: 1
 3893: 1
 3894: 1			;*******************************************************************************
 3895: 1			; s_div16        (469,1us @16.777216MHz)
 3896: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3897: 1			; 2's Complement Format
 3898: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3899: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3900: 1			;           r5, r4 = acc1 deler   (2's compl)
 3901: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3902: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3903: 1			;           r5, r4 = rest
 3904: 1			;           cy=1 bij acc1=0 (deling door nul)
 3905: 1			;            cy=0 in andere gevallen
 3906: 1			;
 3907: 1			; vernietigt: niets
 3908: 1			;*******************************************************************************
 3909: 1  0D44	C0 E0		s_div16:        push    acc
 3910: 1  0D46	C0 D0		                push    psw
 3911: 1  0D48	ED		                mov     a,r5            ;neem msb van deler
 3912: 1  0D49	4C		                orl     a,r4            ;combineer met lsb van deler
 3913: 1  0D4A	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3914: 1  0D4C	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3915: 1  0D4E	D0 E0		                pop     acc
 3916: 1  0D50	D3		                setb    C               ;fout, deling door nul!
 3917: 1  0D51	22		                ret
 3918: 1
 3919: 1  0D52	12 09 B8	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3920: 1  0D55	12 09 D8	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3921: 1  0D58	12 0D 67	                lcall   div16
 3922: 1  0D5B	12 08 F2	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3923: 1  0D5E	12 09 12	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3924: 1  0D61	D0 D0		                pop     psw
 3925: 1  0D63	C3		                clr     C               ;delig ok
 3926: 1  0D64	D0 E0		                pop     acc
 3927: 1  0D66	22		                ret                     ;klaar
 3928: 1
 3929: 1			;*******************************************************************************
 3930: 1			; div16            (405,1us @16.777216MHz)
 3931: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3932: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3933: 1			; input:    r1, r0 = Deeltal (acc0)
 3934: 1			;           r5, r4 = Deler   (acc1)
 3935: 1			;
 3936: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3937: 1			;           r5, r4 = rest van de deling acc0/acc1
 3938: 1			;            cy=1 bij deling door nul (acc1=0)
 3939: 1			;            cy=0 bij normale deling
 3940: 1			;
 3941: 1			; vernietigt: niets
 3942: 1			;*******************************************************************************
 3943: 1
 3944: 1  0D67	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3945: 1  0D69	C0 D0		                push    psw
 3946: 1			;check voor deling door nul
 3947: 1  0D6B	EC		                mov     a,r4           ;neem lsb deler
 3948: 1  0D6C	4D		                orl     a,r5           ;combineer met msb van deler
 3949: 1  0D6D	70 06		                jnz     div160         ;niet nul, dan verder werken
 3950: 1  0D6F	D0 D0		                pop     psw            ;als nul, dikke snul
 3951: 1  0D71	D3		                setb    c              ;terug met errorstatus
 3952: 1  0D72	D0 E0		                pop     acc
 3953: 1  0D74	22		                ret
 3954: 1
 3955: 1  0D75	C0 F0		div160:         push    b              ;registers verder bewaren
 3956: 1  0D77	EF		                mov     a,r7
 3957: 1  0D78	C0 E0		                push    acc            ;push r7 op stack

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3958: 1  0D7A	EE		                mov     a,r6
 3959: 1  0D7B	C0 E0		                push    acc            ;push r6 op stack
 3960: 1  0D7D	EB		                mov     a,r3
 3961: 1  0D7E	C0 E0		                push    acc            ;push r3 op stack
 3962: 1  0D80	EA		                mov     a,r2
 3963: 1  0D81	C0 E0		                push    acc            ;push r2 op stack
 3964: 1  0D83	C0 83		                push    dph
 3965: 1  0D85	C0 82		                push    dpl
 3966: 1
 3967: 1  0D87	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3968: 1  0D89	7B 00		                mov     r3,#0
 3969: 1  0D8B	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3970: 1  0D8D	7E 00		                mov     r6,#0
 3971: 1  0D8F	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3972: 1
 3973: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3974: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3975: 1			;het aantal significante bits af in de lusteller b
 3976: 1
 3977: 1  0D92	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3978: 1  0D93	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3979: 1  0D96	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3980: 1  0D97	E8		                mov     a,r0            ;lsb van deeltal nemen
 3981: 1  0D98	33		                rlc     a                ;en opschuiven
 3982: 1  0D99	F8		                mov     r0,a
 3983: 1  0D9A	E9		                mov     a,r1            ;msb van deeltal nemen
 3984: 1  0D9B	33		                rlc     a
 3985: 1  0D9C	F9		                mov     r1,a
 3986: 1  0D9D	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3987: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3988: 1  0DA0	7C 00		                mov     r4,#0
 3989: 1  0DA2	7D 00		                mov     r5,#0
 3990: 1  0DA4	80 2E		                sjmp    div164          ;klaar!
 3991: 1
 3992: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3993: 1
 3994: 1  0DA6	C3		div162:            clr     C            ;start met carry op nul
 3995: 1  0DA7	E8		                mov     a,r0            ;schuif deeltal naar links
 3996: 1  0DA8	33		                rlc     a
 3997: 1  0DA9	F8		                mov     r0,a
 3998: 1  0DAA	E9		                mov     a,r1
 3999: 1  0DAB	33		                rlc     a
 4000: 1  0DAC	F9		                mov     r1,a
 4001: 1  0DAD	EE		                mov     a,r6            ;schuif carry van deeltal in de
 4002: 1  0DAE	33		                rlc     a               ;gedeeltelijke rest
 4003: 1  0DAF	FE		                mov     r6,a
 4004: 1  0DB0	EF		                mov     a,r7
 4005: 1  0DB1	33		                rlc     a
 4006: 1  0DB2	FF		                mov     r7,a
 4007: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 4008: 1  0DB3	EE		                mov     a,r6
 4009: 1  0DB4	C3		                clr     C
 4010: 1  0DB5	9C		                subb    a,r4
 4011: 1  0DB6	F5 82		                mov     dpl,a
 4012: 1  0DB8	EF		                mov     a,r7
 4013: 1  0DB9	9D		                subb    a,r5

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4014: 1  0DBA	F5 83		                mov     dph,a
 4015: 1  0DBC	40 04		                jc      div163
 4016: 1  0DBE	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 4017: 1  0DC0	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 4018: 1
 4019: 1  0DC2	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 4020: 1  0DC3	EA		                mov     a,r2            ;binnenschuiven
 4021: 1  0DC4	33		                rlc     a
 4022: 1  0DC5	FA		                mov     r2,a
 4023: 1  0DC6	EB		                mov     a,r3
 4024: 1  0DC7	33		                rlc     a
 4025: 1  0DC8	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 4026: 1  0DC9	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 4027: 1
 4028: 1  0DCC	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 4029: 1  0DCD	F9		                mov     r1,a
 4030: 1  0DCE	EA		                mov     a,r2
 4031: 1  0DCF	F8		                mov     r0,a
 4032: 1  0DD0	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 4033: 1  0DD1	FD		                mov     r5,a
 4034: 1  0DD2	EE		                mov     a,r6
 4035: 1  0DD3	FC		                mov     r4,a
 4036: 1
 4037: 1  0DD4	D0 82		div164:         pop     dpl             ;registers herstellen
 4038: 1  0DD6	D0 83		                pop     dph
 4039: 1  0DD8	D0 E0		                pop     acc
 4040: 1  0DDA	FA		                mov     r2,a            ;r2 van stack halen
 4041: 1  0DDB	D0 E0		                pop     acc
 4042: 1  0DDD	FB		                mov     r3,a            ;r3 van stack halen
 4043: 1  0DDE	D0 E0		                pop     acc
 4044: 1  0DE0	FE		                mov     r6,a            ;r6 van stack halen
 4045: 1  0DE1	D0 E0		                pop     acc
 4046: 1  0DE3	FF		                mov     r7,a            ;r7 van stack halen
 4047: 1  0DE4	D0 F0		                pop     b
 4048: 1  0DE6	D0 D0		                pop     psw
 4049: 1  0DE8	C3		                clr     c               ;deling ok
 4050: 1  0DE9	D0 E0		                pop     acc
 4051: 1  0DEB	22		                ret
 4052: 1
 4053: 1
 4054: 1			;*******************************************************************************
 4055: 1			; s_div32        (2,15ms @16.777216MHz)
 4056: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 4057: 1			; 2's Complement Format
 4058: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 4059: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4060: 1			;
 4061: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 4062: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 4063: 1			;
 4064: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 4065: 1			;           r7,r6,r5, r4 = rest
 4066: 1			;           cy=1 bij acc1=0 (deling door nul)
 4067: 1			;            cy=0 in andere gevallen
 4068: 1			;
 4069: 1			; vernietigt: niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4070: 1			;*******************************************************************************
 4071: 1  0DEC	C0 E0		s_div32:        push    acc
 4072: 1  0DEE	C0 D0		                push    psw
 4073: 1  0DF0	EF		                mov     a,r7            ;neem msb van deler
 4074: 1  0DF1	4E		                orl     a,r6            ;combineer met lsb's van deler
 4075: 1  0DF2	4D		                orl     a,r5
 4076: 1  0DF3	4C		                orl     a,r4
 4077: 1  0DF4	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 4078: 1  0DF6	D0 D0		                pop     psw                ;anders fout, deling door nul!
 4079: 1  0DF8	D0 E0		                pop     acc
 4080: 1  0DFA	D3		                setb    C                ;fout, deling door nul!
 4081: 1  0DFB	22		                ret
 4082: 1
 4083: 1  0DFC	12 0A 18	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 4084: 1  0DFF	12 0A 42	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 4085: 1  0E02	12 0E 11	                lcall   div32            ;deel 32bit/32bit
 4086: 1  0E05	12 09 32	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 4087: 1  0E08	12 09 5C	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 4088: 1  0E0B	D0 D0		                pop     psw
 4089: 1  0E0D	C3		                clr     C                ;delig ok
 4090: 1  0E0E	D0 E0		                pop     acc
 4091: 1  0E10	22		                ret                        ;klaar
 4092: 1
 4093: 1
 4094: 1			;*******************************************************************************
 4095: 1			; div32        (2,09ms @16.777216MHz)
 4096: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 4097: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 4098: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 4099: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 4100: 1			;
 4101: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 4102: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 4103: 1			;            cy=1 bij deling door nul (acc1=0)
 4104: 1			;            cy=0 bij normale deling
 4105: 1			;
 4106: 1			; vernietigt: niets
 4107: 1			;*******************************************************************************
 4108: 1  0E11	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 4109: 1  0E13	C0 D0		                push    psw
 4110: 1			;check voor deling door nul
 4111: 1  0E15	EF		                mov     a,r7            ;neem msb van deler
 4112: 1  0E16	4E		                orl     a,r6            ;combineer met lsb's van deler
 4113: 1  0E17	4D		                orl     a,r5
 4114: 1  0E18	4C		                orl     a,r4
 4115: 1  0E19	70 06		                jnz     div320          ;niet nul, dan verder werken
 4116: 1  0E1B	D0 D0		                pop     psw             ;als nul, dikke snul
 4117: 1  0E1D	D3		                setb    c               ;terug met errorstatus
 4118: 1  0E1E	D0 E0		                pop     acc
 4119: 1  0E20	22		                ret
 4120: 1
 4121: 1  0E21	C0 F0		div320:         push    b                ;registers verder bewaren
 4122: 1  0E23	C0 83		                push    dph
 4123: 1  0E25	C0 82		                push    dpl
 4124: 1
 4125: 1  0E27	75 F0 20	                mov     b,#32            ;initiele lusteller op 32

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4126: 1
 4127: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 4128: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 4129: 1			;het aantal significante bits af in de lusteller b
 4130: 1
 4131: 1  0E2A	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 4132: 1  0E2B	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 4133: 1  0E2E	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 4134: 1  0E2F	E8		                mov     a,r0            ;lsb van deeltal nemen
 4135: 1  0E30	33		                rlc     a               ;en opschuiven
 4136: 1  0E31	F8		                mov     r0,a
 4137: 1  0E32	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 4138: 1  0E33	33		                rlc     a
 4139: 1  0E34	F9		                mov     r1,a
 4140: 1  0E35	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 4141: 1  0E36	33		                rlc     a
 4142: 1  0E37	FA		                mov     r2,a
 4143: 1  0E38	EB		                mov     a,r3           ;lsb van deeltal nemen
 4144: 1  0E39	33		                rlc     a
 4145: 1  0E3A	FB		                mov     r3,a
 4146: 1  0E3B	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 4147: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 4148: 1  0E3E	7F 00		                mov     r7,#0           ;rest is dan ook nul
 4149: 1  0E40	7E 00		                mov     r6,#0
 4150: 1  0E42	7D 00		                mov     r5,#0
 4151: 1  0E44	7C 00		                mov     r4,#0
 4152: 1  0E46	02 0F 0F	                ljmp    div324           ;klaar!
 4153: 1
 4154: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 4155: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 4156: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 4157: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 4158: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 4159: 1
 4160: 1  0E49			div320b:
 4161: 1  0E49	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 4162: 1
 4163: 1  0E4C	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 4164: 1  0E4E	24 0C		                add     a,#12           ;met 12 plaatsen
 4165: 1  0E50	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 4166: 1
 4167: 1  0E52	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 4168: 1  0E53	C0 E0		                push    acc
 4169: 1  0E55	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 4170: 1  0E56	C0 E0		                push    acc
 4171: 1
 4172: 1  0E58	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 4173: 1  0E5A	08		                inc     r0              ;de deler
 4174: 1  0E5B	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 4175: 1  0E5D	24 05		                add     a,#5            ;het tijdelijk verschil X
 4176: 1  0E5F	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 4177: 1  0E60	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 4178: 1  0E62	24 09		                add     a,#9            ;quotient
 4179: 1  0E64	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 4180: 1
 4181: 1			;Eenmalig de variabelen op stack initaliseren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4182: 1			;Tijdelijk quotient op nul zetten
 4183: 1
 4184: 1  0E66	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 4185: 1  0E68	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 4186: 1  0E69	C0 F0		                push    b                ;loopteller deling bewaren
 4187: 1  0E6B	75 F0 04	                mov     b,#4
 4188: 1  0E6E	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 4189: 1  0E70	09		                inc     r1
 4190: 1  0E71	D5 F0 FA	                djnz    b,div320c
 4191: 1  0E74	D0 F0		                pop     b                ;loopteller deling ophalen
 4192: 1  0E76	19		                dec     r1
 4193: 1  0E77	19		                dec     r1
 4194: 1  0E78	19		                dec     r1
 4195: 1  0E79	19		                dec     r1               ;pointer weer op startadres quotient
 4196: 1  0E7A	C9		                xch     a,r1             ;weer omwisselen
 4197: 1  0E7B	C5 82		                xch     a,dpl
 4198: 1
 4199: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 4200: 1  0E7D	EC		                mov     a,r4
 4201: 1  0E7E	F6		                mov     @r0,a
 4202: 1  0E7F	08		                inc     r0
 4203: 1  0E80	ED		                mov     a,r5
 4204: 1  0E81	F6		                mov     @r0,a
 4205: 1  0E82	08		                inc     r0
 4206: 1  0E83	EE		                mov     a,r6
 4207: 1  0E84	F6		                mov     @r0,a
 4208: 1  0E85	08		                inc     r0
 4209: 1  0E86	EF		                mov     a,r7
 4210: 1  0E87	F6		                mov     @r0,a
 4211: 1  0E88	18		                dec     r0             ;pointer herstellen naar lsb van deler
 4212: 1  0E89	18		                dec     r0
 4213: 1  0E8A	18		                dec     r0
 4214: 1
 4215: 1  0E8B	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 4216: 1  0E8D	7E 00		                mov     r6,#0
 4217: 1  0E8F	7D 00		                mov     r5,#0
 4218: 1  0E91	7C 00		                mov     r4,#0
 4219: 1
 4220: 1
 4221: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 4222: 1  0E93	C3		div322:         clr     C               ;start met carry op nul
 4223: 1
 4224: 1  0E94	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 4225: 1  0E96	33		                rlc     a
 4226: 1  0E97	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 4227: 1  0E99	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 4228: 1  0E9B	D0 E0		                pop     acc             ;r1 van deeltal van stack
 4229: 1  0E9D	33		                rlc     a
 4230: 1  0E9E	C0 E0		                push    acc             ;en weer bewaren
 4231: 1  0EA0	05 81		                inc     sp              ;stackpointer weer corrigeren
 4232: 1
 4233: 1  0EA2	EA		                mov     a,r2
 4234: 1  0EA3	33		                rlc     a
 4235: 1  0EA4	FA		                mov     r2,a
 4236: 1  0EA5	EB		                mov     a,r3
 4237: 1  0EA6	33		                rlc     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4238: 1  0EA7	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 4239: 1
 4240: 1  0EA8	EC		                mov     a,r4            ;schuif carry van deeltal in de
 4241: 1  0EA9	33		                rlc     a               ;gedeeltelijke rest r7..r4
 4242: 1  0EAA	FC		                mov     r4,a
 4243: 1  0EAB	ED		                mov     a,r5
 4244: 1  0EAC	33		                rlc     a
 4245: 1  0EAD	FD		                mov     r5,a
 4246: 1  0EAE	EE		                mov     a,r6
 4247: 1  0EAF	33		                rlc     a
 4248: 1  0EB0	FE		                mov     r6,a
 4249: 1  0EB1	EF		                mov     a,r7
 4250: 1  0EB2	33		                rlc     a
 4251: 1  0EB3	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 4252: 1
 4253: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 4254: 1
 4255: 1  0EB4	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 4256: 1  0EB5	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 4257: 1  0EB6	96		                subb    a,@r0           ;trek er de lsb deler af
 4258: 1  0EB7	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4259: 1  0EB8	08		                inc     r0              ;pointers aanpassen
 4260: 1  0EB9	09		                inc     r1
 4261: 1  0EBA	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4262: 1  0EBB	96		                subb    a,@r0           ;trek er volgende byte deler af
 4263: 1  0EBC	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4264: 1  0EBD	08		                inc     r0              ;pointers aanpassen
 4265: 1  0EBE	09		                inc     r1
 4266: 1  0EBF	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4267: 1  0EC0	96		                subb    a,@r0           ;trek er volgende byte deler af
 4268: 1  0EC1	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4269: 1  0EC2	08		                inc     r0              ;pointers aanpassen
 4270: 1  0EC3	09		                inc     r1
 4271: 1  0EC4	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4272: 1  0EC5	96		                subb    a,@r0           ;trek er msb deler af
 4273: 1  0EC6	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4274: 1  0EC7	18		                dec     r0              ;pointers herstellen naar lsb's
 4275: 1  0EC8	18		                dec     r0
 4276: 1  0EC9	18		                dec     r0
 4277: 1  0ECA	19		                dec     r1
 4278: 1  0ECB	19		                dec     r1
 4279: 1  0ECC	19		                dec     r1
 4280: 1
 4281: 1  0ECD	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4282: 1  0ECF	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4283: 1  0ED0	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4284: 1  0ED1	09		                inc     r1
 4285: 1  0ED2	E7		                mov     a,@r1
 4286: 1  0ED3	FD		                mov     r5,a
 4287: 1  0ED4	09		                inc     r1
 4288: 1  0ED5	E7		                mov     a,@r1
 4289: 1  0ED6	FE		                mov     r6,a
 4290: 1  0ED7	09		                inc     r1
 4291: 1  0ED8	E7		                mov     a,@r1
 4292: 1  0ED9	FF		                mov     r7,a
 4293: 1  0EDA	19		                dec     r1              ;met pointer weer naar lsb van

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4294: 1  0EDB	19		                dec     r1              ;het tijdelijk verschil wijzen
 4295: 1  0EDC	19		                dec     r1
 4296: 1
 4297: 1
 4298: 1  0EDD	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4299: 1  0EDE	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4300: 1  0EE0	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4301: 1  0EE1	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4302: 1  0EE3	E7		                mov     a,@r1           ;neem lsb van qoutient
 4303: 1  0EE4	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4304: 1  0EE5	F7		                mov     @r1,a
 4305: 1  0EE6	09		                inc     r1              ;volgende byte
 4306: 1  0EE7	E7		                mov     a,@r1
 4307: 1  0EE8	33		                rlc     a
 4308: 1  0EE9	F7		                mov     @r1,a
 4309: 1  0EEA	09		                inc     r1              ;volgende byte
 4310: 1  0EEB	E7		                mov     a,@r1
 4311: 1  0EEC	33		                rlc     a
 4312: 1  0EED	F7		                mov     @r1,a
 4313: 1  0EEE	09		                inc     r1              ;volgende byte
 4314: 1  0EEF	E7		                mov     a,@r1
 4315: 1  0EF0	33		                rlc     a
 4316: 1  0EF1	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4317: 1  0EF2	19		                dec     r1
 4318: 1  0EF3	19		                dec     r1
 4319: 1  0EF4	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4320: 1  0EF5	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4321: 1  0EF7	C9		                xch     a,r1            ;r1=pointer naar verschil
 4322: 1  0EF8	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4323: 1
 4324: 1  0EFA	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4325: 1
 4326: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4327: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4328: 1
 4329: 1  0EFD	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4330: 1  0EFF	18		                dec     r0
 4331: 1  0F00	18		                dec     r0
 4332: 1  0F01	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4333: 1  0F02	FB		                mov     r3,a            ;en verplaatsen
 4334: 1  0F03	18		                dec     r0              ;volgende byte
 4335: 1  0F04	E6		                mov     a,@r0
 4336: 1  0F05	FA		                mov     r2,a
 4337: 1  0F06	18		                dec     r0              ;volgende byte
 4338: 1  0F07	E6		                mov     a,@r0
 4339: 1  0F08	F9		                mov     r1,a
 4340: 1  0F09	18		                dec     r0              ;volgende byte
 4341: 1  0F0A	E6		                mov     a,@r0
 4342: 1  0F0B	F8		                mov     r0,a            ;laatste byte verplaatst!
 4343: 1
 4344: 1  0F0C	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4345: 1			                                         ;weer vrijgeven
 4346: 1
 4347: 1
 4348: 1  0F0F	D0 82		div324:         pop     dpl             ;registers herstellen
 4349: 1  0F11	D0 83		                pop     dph

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4350: 1  0F13	D0 F0		                pop     b
 4351: 1  0F15	D0 D0		                pop     psw
 4352: 1  0F17	C3		                clr     c               ;normale deling
 4353: 1  0F18	D0 E0		                pop     acc
 4354: 1  0F1A	22		                ret
 4355: 1
 4356: 1			;*******************************************************************************
 4357: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4358: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4359: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4360: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4361: 1			;
 4362: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4363: 1			;
 4364: 1			; input:     r5,r4 = acc1 (low word product)
 4365: 1			;            r7,r6 = acc1 (high word product)
 4366: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4367: 1			;
 4368: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4369: 1			;            r7,r6,r5,r4 = acc1 = rest
 4370: 1			;                          -2147483648 tot +2147483647
 4371: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4372: 1			;             cy=1 bij deling door nul (acc0=0)
 4373: 1			;             cy=0 bij normale deling
 4374: 1			;
 4375: 1			; vernietigt:  niets
 4376: 1			;*******************************************************************************
 4377: 1  0F1B	C0 E0		s_muldiv:       push    acc
 4378: 1  0F1D	C0 D0		                push    psw
 4379: 1  0F1F	E8		                mov     a,r0            ;neem msb van deler
 4380: 1  0F20	49		                orl     a,r1            ;combineer met lsb's van deler
 4381: 1  0F21	4A		                orl     a,r2
 4382: 1  0F22	4B		                orl     a,r3
 4383: 1  0F23	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4384: 1  0F25	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4385: 1  0F27	D0 E0		                pop     acc
 4386: 1  0F29	D3		                setb    C               ;fout, deling door nul!
 4387: 1  0F2A	22		                ret
 4388: 1
 4389: 1  0F2B	12 09 D8	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4390: 1  0F2E	12 09 F8	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4391: 1  0F31	12 0F 40	                lcall    muldiv          ;maak product en daarna de deling
 4392: 1  0F34	12 09 32	                lcall    magsig32        ;quotient naar 2's complement
 4393: 1  0F37	12 09 5C	                lcall    magsig32acc1    ;rest naar 2's complement
 4394: 1  0F3A	D0 D0		                pop     psw
 4395: 1  0F3C	C3		                clr     c                ;deling is ok
 4396: 1  0F3D	D0 E0		                pop    acc
 4397: 1  0F3F	22		                ret
 4398: 1
 4399: 1			;*******************************************************************************
 4400: 1			; muldiv        (2,0ms @16.777216MHz)
 4401: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4402: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4403: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4404: 1			; 32bit rest in acc1.
 4405: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4406: 1			;
 4407: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4408: 1			;
 4409: 1			; input:     r5,r4 = acc1 (low word product)
 4410: 1			;            r7,r6 = acc1 (high word product)
 4411: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4412: 1			;
 4413: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4414: 1			;            r7,r6,r5,r4 = acc1 = rest
 4415: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4416: 1			;             cy=1 bij deling door nul (acc0=0)
 4417: 1			;             cy=0 bij normale deling
 4418: 1			;
 4419: 1			; vernietigt:  niets
 4420: 1			;*******************************************************************************
 4421: 1  0F40	C0 E0		muldiv:         push    acc
 4422: 1  0F42	C0 D0		                push    psw
 4423: 1  0F44	E8		                mov     a,r0            ;neem msb van deler
 4424: 1  0F45	49		                orl     a,r1            ;combineer met lsb's van deler
 4425: 1  0F46	4A		                orl     a,r2
 4426: 1  0F47	4B		                orl     a,r3
 4427: 1  0F48	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4428: 1  0F4A	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4429: 1  0F4C	D0 E0		                pop     acc
 4430: 1  0F4E	D3		                setb    C               ;fout, deling door nul!
 4431: 1  0F4F	22		                ret
 4432: 1
 4433: 1  0F50	12 0C 41	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4434: 1  0F53	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4435: 1  0F54	C0 E0		                push    acc
 4436: 1  0F56	ED		                mov     a,r5
 4437: 1  0F57	C0 E0		                push    acc
 4438: 1  0F59	EE		                mov     a,r6
 4439: 1  0F5A	C0 E0		                push    acc
 4440: 1  0F5C	EF		                mov     a,r7
 4441: 1  0F5D	C0 E0		                push    acc             ;product staat nu op stack
 4442: 1
 4443: 1  0F5F	E8		                mov     a,r0            ;deler in acc1 stoppen
 4444: 1  0F60	FC		                mov     r4,a
 4445: 1  0F61	E9		                mov     a,r1
 4446: 1  0F62	FD		                mov     r5,a
 4447: 1  0F63	EA		                mov     a,r2
 4448: 1  0F64	FE		                mov     r6,a
 4449: 1  0F65	EB		                mov     a,r3
 4450: 1  0F66	FF		                mov     r7,a            ;deler zit volledig in acc1
 4451: 1
 4452: 1  0F67	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4453: 1  0F69	FB		                mov     r3,a
 4454: 1  0F6A	D0 E0		                pop     acc
 4455: 1  0F6C	FA		                mov     r2,a
 4456: 1  0F6D	D0 E0		                pop     acc
 4457: 1  0F6F	F9		                mov     r1,a
 4458: 1  0F70	D0 E0		                pop     acc
 4459: 1  0F72	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4460: 1  0F73	12 0E 11	                lcall   div32           ;maak deling
 4461: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4462: 1  0F76	D0 D0		                pop     psw            ;herstel registers
 4463: 1  0F78	D0 E0		                pop     acc
 4464: 1  0F7A	C3		                clr     C              ;resultaat ok!
 4465: 1  0F7B	22		                ret
 4466: 1
 4467: 1			;*******************************************************************************
 4468: 1			; mul16_pi        (257,1us @16.777216MHz)
 4469: 1			; acc0 = acc0 x pi
 4470: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4471: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4472: 1			;
 4473: 1			; input:     r1,r0 = acc0 (low word)
 4474: 1			;
 4475: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4476: 1			;
 4477: 1			; vernietigt:  niets
 4478: 1			;*******************************************************************************
 4479: 1  0F7C	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4480: 1  0F7E	C0 D0		                push    psw
 4481: 1  0F80	EC		                mov     a,r4
 4482: 1  0F81	C0 E0		                push    acc
 4483: 1  0F83	ED		                mov     a,r5
 4484: 1  0F84	C0 E0		                push    acc
 4485: 1  0F86	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4486: 1  0F88	7C 0F		                mov     r4,#0fH
 4487: 1  0F8A	12 0B DC	                lcall   mul16           ;acc0 = acc0 x acc1
 4488: 1  0F8D	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4489: 1  0F8F	12 11 78	                lcall   shiftright32    ;om te delen door 2^14
 4490: 1  0F92	D0 E0		                pop     acc
 4491: 1  0F94	FD		                mov     r5,a
 4492: 1  0F95	D0 E0		                pop     acc
 4493: 1  0F97	FC		                mov     r4,a
 4494: 1  0F98	D0 D0		                pop     psw
 4495: 1  0F9A	D0 E0		                pop     acc
 4496: 1  0F9C	22		                ret
 4497: 1
 4498: 1			;*******************************************************************************
 4499: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4500: 1			; acc0 = acc0 x 1/pi
 4501: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4502: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4503: 1			;
 4504: 1			; input:     r1,r0 = acc0 (low word)
 4505: 1			;
 4506: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4507: 1			;
 4508: 1			; vernietigt:  niets
 4509: 1			;*******************************************************************************
 4510: 1  0F9D	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4511: 1  0F9F	C0 D0		                push    psw
 4512: 1  0FA1	EC		                mov     a,r4
 4513: 1  0FA2	C0 E0		                push    acc
 4514: 1  0FA4	ED		                mov     a,r5
 4515: 1  0FA5	C0 E0		                push    acc
 4516: 1  0FA7	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4517: 1  0FA9	7C 7D		                mov     r4,#07dH

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4518: 1  0FAB	12 0B DC	                lcall    mul16          ;acc0 = acc0 x acc1
 4519: 1  0FAE	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4520: 1  0FB0	12 11 78	                lcall   shiftright32    ;om te delen door 2^16
 4521: 1  0FB3	D0 E0		                pop     acc
 4522: 1  0FB5	FD		                mov     r5,a
 4523: 1  0FB6	D0 E0		                pop     acc
 4524: 1  0FB8	FC		                mov     r4,a
 4525: 1  0FB9	D0 D0		                pop     psw
 4526: 1  0FBB	D0 E0		                pop     acc
 4527: 1  0FBD	22		                ret
 4528: 1
 4529: 1			;*******************************************************************************
 4530: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4531: 1			; acc0 = acc0 x sqrt2
 4532: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4533: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4534: 1			;
 4535: 1			; input:     r1,r0 = acc0 (low word)
 4536: 1			;
 4537: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4538: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4539: 1			;
 4540: 1			; vernietigt:  niets
 4541: 1			;*******************************************************************************
 4542: 1  0FBE	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4543: 1  0FC0	C0 D0		                push    psw
 4544: 1  0FC2	EC		                mov     a,r4
 4545: 1  0FC3	C0 E0		                push    acc
 4546: 1  0FC5	ED		                mov     a,r5
 4547: 1  0FC6	C0 E0		                push    acc
 4548: 1  0FC8	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4549: 1  0FCA	7C 05		                mov     r4,#005H
 4550: 1  0FCC	12 0B DC	                lcall   mul16           ;acc0 = acc0 x acc1
 4551: 1  0FCF	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4552: 1  0FD1	12 11 78	                lcall   shiftright32    ;om te delen door 2^15
 4553: 1  0FD4	D0 E0		                pop     acc
 4554: 1  0FD6	FD		                mov     r5,a
 4555: 1  0FD7	D0 E0		                pop     acc
 4556: 1  0FD9	FC		                mov     r4,a
 4557: 1  0FDA	D0 D0		                pop     psw
 4558: 1  0FDC	D0 E0		                pop     acc
 4559: 1  0FDE	22		                ret
 4560: 1
 4561: 1
 4562: 1
 4563: 1			;*******************************************************************************
 4564: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4565: 1			; acc0 = acc0 x 1/sqrt2
 4566: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4567: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4568: 1			;
 4569: 1			; input:     r1,r0 = acc0 (low word)
 4570: 1			;
 4571: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4572: 1			;
 4573: 1			; vernietigt:  niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4574: 1			;*******************************************************************************
 4575: 1  0FDF	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4576: 1  0FE1	C0 D0		                push    psw
 4577: 1  0FE3	EC		                mov     a,r4
 4578: 1  0FE4	C0 E0		                push    acc
 4579: 1  0FE6	ED		                mov     a,r5
 4580: 1  0FE7	C0 E0		                push    acc
 4581: 1  0FE9	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4582: 1  0FEB	7C 05		                mov     r4,#005H
 4583: 1  0FED	12 0B DC	                lcall   mul16           ;acc0 = acc0 x acc1
 4584: 1  0FF0	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4585: 1  0FF2	12 11 78	                lcall   shiftright32    ;om te delen door 2^16
 4586: 1  0FF5	D0 E0		                pop     acc
 4587: 1  0FF7	FD		                mov     r5,a
 4588: 1  0FF8	D0 E0		                pop     acc
 4589: 1  0FFA	FC		                mov     r4,a
 4590: 1  0FFB	D0 D0		                pop     psw
 4591: 1  0FFD	D0 E0		                pop     acc
 4592: 1  0FFF	22		                ret
 4593: 1
 4594: 1			;*******************************************************************************
 4595: 1			; mul16_10        (98,7us @16.777216MHz)
 4596: 1			; acc0 = acc0 x 10
 4597: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4598: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4599: 1			;
 4600: 1			; input:     r1,r0 = acc0 (low word)
 4601: 1			;
 4602: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4603: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4604: 1			; vernietigt:  niets
 4605: 1			;*******************************************************************************
 4606: 1  1000	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4607: 1  1002	C0 D0		                push    psw
 4608: 1  1004	EC		                mov     a,r4
 4609: 1  1005	C0 E0		                push    acc
 4610: 1  1007	7C 01		                mov     r4,#1           ;acc0 x2
 4611: 1  1009	12 11 A4	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4612: 1  100C	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4613: 1  100D	C0 E0		                push    acc
 4614: 1  100F	EA		                mov     a,r2
 4615: 1  1010	C0 E0		                push    acc
 4616: 1  1012	E9		                mov     a,r1
 4617: 1  1013	C0 E0		                push    acc
 4618: 1  1015	E8		                mov     a,r0
 4619: 1  1016	C0 E0		                push    acc             ;acc0 op stack
 4620: 1  1018	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4621: 1  101A	12 11 A4	                lcall   shiftleft32     ;acc0 =acc0 x4
 4622: 1  101D	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4623: 1  101F	28		                add     a,r0            ;tel bij huidige acc0
 4624: 1  1020	F8		                mov     r0,a
 4625: 1  1021	D0 E0		                pop     acc
 4626: 1  1023	39		                addc    a,r1
 4627: 1  1024	F9		                mov     r1,a
 4628: 1  1025	D0 E0		                pop     acc
 4629: 1  1027	3A		                addc    a,r2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4630: 1  1028	FA		                mov     r2,a
 4631: 1  1029	D0 E0		                pop     acc
 4632: 1  102B	3B		                addc    a,r3
 4633: 1  102C	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4634: 1
 4635: 1
 4636: 1  102D	D0 E0		                pop     acc
 4637: 1  102F	FC		                mov     r4,a
 4638: 1  1030	D0 D0		                pop     psw
 4639: 1  1032	D0 E0		                pop     acc
 4640: 1  1034	22		                ret
 4641: 1
 4642: 1			;*******************************************************************************
 4643: 1			; mul16_100        (169,1us @16.777216MHz)
 4644: 1			; acc0 = acc0 x 100
 4645: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4646: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4647: 1			;
 4648: 1			; input:     r1,r0 = acc0 (low word)
 4649: 1			;
 4650: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4651: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4652: 1			; vernietigt:  niets
 4653: 1			;*******************************************************************************
 4654: 1  1035	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4655: 1  1037	C0 D0		                push    psw
 4656: 1  1039	EC		                mov     a,r4
 4657: 1  103A	C0 E0		                push    acc
 4658: 1  103C	7C 02		                mov     r4,#2           ;acc0 x4
 4659: 1  103E	12 11 A4	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4660: 1  1041	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4661: 1  1042	C0 E0		                push    acc
 4662: 1  1044	EA		                mov     a,r2
 4663: 1  1045	C0 E0		                push    acc
 4664: 1  1047	E9		                mov     a,r1
 4665: 1  1048	C0 E0		                push    acc
 4666: 1  104A	E8		                mov     a,r0
 4667: 1  104B	C0 E0		                push    acc             ;acc0 op stack
 4668: 1
 4669: 1  104D	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4670: 1  104F	12 11 A4	                lcall   shiftleft32     ;acc0 =acc0 x8
 4671: 1  1052	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4672: 1  1053	C0 E0		                push    acc
 4673: 1  1055	EA		                mov     a,r2
 4674: 1  1056	C0 E0		                push    acc
 4675: 1  1058	E9		                mov     a,r1
 4676: 1  1059	C0 E0		                push    acc
 4677: 1  105B	E8		                mov     a,r0
 4678: 1  105C	C0 E0		                push    acc             ;acc0 op stack
 4679: 1
 4680: 1  105E	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4681: 1  1060	12 11 A4	                lcall   shiftleft32     ;acc0 =acc0 x2
 4682: 1  1063	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4683: 1  1065	28		                add     a,r0            ;tel bij huidige acc0
 4684: 1  1066	F8		                mov     r0,a
 4685: 1  1067	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4686: 1  1069	39		                addc    a,r1
 4687: 1  106A	F9		                mov     r1,a
 4688: 1  106B	D0 E0		                pop     acc
 4689: 1  106D	3A		                addc    a,r2
 4690: 1  106E	FA		                mov     r2,a
 4691: 1  106F	D0 E0		                pop     acc
 4692: 1  1071	3B		                addc    a,r3
 4693: 1  1072	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4694: 1
 4695: 1  1073	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4696: 1  1075	28		                add     a,r0            ;tel bij huidige acc0
 4697: 1  1076	F8		                mov     r0,a
 4698: 1  1077	D0 E0		                pop     acc
 4699: 1  1079	39		                addc    a,r1
 4700: 1  107A	F9		                mov     r1,a
 4701: 1  107B	D0 E0		                pop     acc
 4702: 1  107D	3A		                addc    a,r2
 4703: 1  107E	FA		                mov     r2,a
 4704: 1  107F	D0 E0		                pop     acc
 4705: 1  1081	3B		                addc    a,r3
 4706: 1  1082	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4707: 1
 4708: 1  1083	D0 E0		                pop     acc
 4709: 1  1085	FC		                mov     r4,a
 4710: 1  1086	D0 D0		                pop     psw
 4711: 1  1088	D0 E0		                pop     acc
 4712: 1  108A	22		                ret
 4713: 1
 4714: 1			;*******************************************************************************
 4715: 1			; sqrt32        (2,99ms @16.777216MHz)
 4716: 1			; acc0 = acc0 ^(1/2)
 4717: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4718: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4719: 1			;
 4720: 1			; input:     r3,r2,r1,r0 = acc0
 4721: 1			;
 4722: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4723: 1			;
 4724: 1			; vernietigt:  niets
 4725: 1			;*******************************************************************************
 4726: 1  108B	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4727: 1  108D	C0 F0		                push    b
 4728: 1  108F	C0 D0		                push    psw
 4729: 1  1091	C0 82		                push    dpl
 4730: 1  1093	C0 83		                push    dph
 4731: 1  1095	EC		                mov     a,r4
 4732: 1  1096	C0 E0		                push    acc
 4733: 1  1098	ED		                mov     a,r5
 4734: 1  1099	C0 E0		                push    acc
 4735: 1  109B	EE		                mov     a,r6
 4736: 1  109C	C0 E0		                push    acc
 4737: 1  109E	EF		                mov     a,r7
 4738: 1  109F	C0 E0		                push    acc
 4739: 1
 4740: 1  10A1	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4741: 1  10A3	7D 00		                mov     r5,#0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4742: 1  10A5	7E 00		                mov     r6,#0
 4743: 1  10A7	7F 00		                mov     r7,#0
 4744: 1  10A9	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4745: 1  10AC	75 83 00	                mov     dph,#0
 4746: 1  10AF	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4747: 1			;hier start het algorithme voor het berekenen van de wortel
 4748: 1  10B2	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4749: 1  10B4	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4750: 1  10B7	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4751: 1  10B8	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4752: 1  10B9	33		                rlc     a                ;getest worden om een wortelbit te
 4753: 1  10BA	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4754: 1  10BB	E9		                mov     a,r1            ;met nullen!
 4755: 1  10BC	33		                rlc     a
 4756: 1  10BD	F9		                mov     r1,a
 4757: 1  10BE	EA		                mov     a,r2
 4758: 1  10BF	33		                rlc     a
 4759: 1  10C0	FA		                mov     r2,a
 4760: 1  10C1	EB		                mov     a,r3
 4761: 1  10C2	33		                rlc     a
 4762: 1  10C3	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4763: 1
 4764: 1  10C4	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4765: 1  10C5	33		                rlc     a
 4766: 1  10C6	FC		                mov     r4,a
 4767: 1  10C7	ED		                mov     a,r5
 4768: 1  10C8	33		                rlc     a
 4769: 1  10C9	FD		                mov     r5,a
 4770: 1  10CA	EE		                mov     a,r6
 4771: 1  10CB	33		                rlc     a
 4772: 1  10CC	FE		                mov     r6,a
 4773: 1  10CD	EF		                mov     a,r7
 4774: 1  10CE	33		                rlc     a
 4775: 1  10CF	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4776: 1  10D0	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4777: 1
 4778: 1  10D3	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4779: 1
 4780: 1  10D5	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4781: 1  10D6	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4782: 1  10D8	33		                rlc     a
 4783: 1  10D9	F5 82		                mov     dpl,a
 4784: 1  10DB	E5 83		                mov     a,dph
 4785: 1  10DD	33		                rlc     a
 4786: 1  10DE	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4787: 1
 4788: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4789: 1  10E0	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4790: 1  10E1	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4791: 1  10E3	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4792: 1  10E4	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4793: 1  10E6	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4794: 1  10E7	C0 E0		                push    acc             ;van acc1
 4795: 1  10E9	EB		                mov     a,r3
 4796: 1  10EA	C0 E0		                push    acc
 4797: 1  10EC	EC		                mov     a,r4

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4798: 1  10ED	C0 E0		                push    acc
 4799: 1  10EF	ED		                mov     a,r5
 4800: 1  10F0	C0 E0		                push    acc
 4801: 1  10F2	EE		                mov     a,r6
 4802: 1  10F3	C0 E0		                push    acc
 4803: 1  10F5	EF		                mov     a,r7
 4804: 1  10F6	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4805: 1
 4806: 1  10F8	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4807: 1  10FA	AD 83		                mov     r5,dph
 4808: 1  10FC	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4809: 1  10FE	AF 83		                mov     r7,dph
 4810: 1  1100	12 0C 41	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4811: 1
 4812: 1  1103	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4813: 1  1105	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4814: 1  1106	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4815: 1  1108	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4816: 1  1109	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4817: 1  110B	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4818: 1  110C	D0 E0		                pop     acc             ;de stack...
 4819: 1  110E	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4820: 1
 4821: 1  110F	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4822: 1  1110	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4823: 1  1111	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4824: 1  1112	E9		                mov     a,r1            ;in acc1.
 4825: 1  1113	9D		                subb    a,r5            ;We doen dit door de carry van het
 4826: 1  1114	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4827: 1  1115	9E		                subb    a,r6
 4828: 1  1116	EB		                mov     a,r3
 4829: 1  1117	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4830: 1  1118	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4831: 1			                                        ;wortel behouden
 4832: 1  111A	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4833: 1  111C	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4834: 1  111E	F5 82		                mov     dpl,a          ;wortel aanpassen
 4835: 1
 4836: 1  1120	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4837: 1  1122	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4838: 1  1124	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4839: 1
 4840: 1  1126	D0 E0		                pop     acc            ;haal acc1 weer op
 4841: 1  1128	FF		                mov     r7,a
 4842: 1  1129	D0 E0		                pop     acc
 4843: 1  112B	FE		                mov     r6,a
 4844: 1  112C	D0 E0		                pop     acc
 4845: 1  112E	FD		                mov     r5,a
 4846: 1  112F	D0 E0		                pop     acc
 4847: 1  1131	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4848: 1
 4849: 1  1132	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4850: 1  1134	FB		                mov     r3,a
 4851: 1  1135	D0 E0		                pop     acc
 4852: 1  1137	FA		                mov     r2,a
 4853: 1  1138	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4854: 1  113A	F9		                mov     r1,a
 4855: 1  113B	D0 E0		                pop     acc
 4856: 1  113D	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4857: 1
 4858: 1  113E	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4859: 1  1141	80 03		                sjmp    sqrt325
 4860: 1  1143	02 10 B2	sqrt324:        ljmp    sqrt320        ;uit acc0
 4861: 1
 4862: 1  1146	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4863: 1  1148	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4864: 1
 4865: 1  114A	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4866: 1  114C	FF		                mov     r7,a
 4867: 1  114D	D0 E0		                pop     acc
 4868: 1  114F	FE		                mov     r6,a
 4869: 1  1150	D0 E0		                pop     acc
 4870: 1  1152	FD		                mov     r5,a
 4871: 1  1153	D0 E0		                pop     acc
 4872: 1  1155	FC		                mov     r4,a           ;acc1 is hersteld
 4873: 1  1156	D0 83		                pop     dph
 4874: 1  1158	D0 82		                pop     dpl
 4875: 1  115A	D0 D0		                pop     psw
 4876: 1  115C	D0 F0		                pop     b
 4877: 1  115E	D0 E0		                pop     acc
 4878: 1
 4879: 1  1160	22		                ret                    ;eindelijk klaar...
 4880: 1
 4881: 1			;*******************************************************************************
 4882: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4883: 1			; acc0 = acc0 ^(1/2)
 4884: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4885: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4886: 1			;                           (-2147483648 tot +2147483647)
 4887: 1			; input:     r3,r2,r1,r0 = acc0
 4888: 1			;
 4889: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4890: 1			;            CY = 1 als acc0 negatief is
 4891: 1			; vernietigt:  niets
 4892: 1			;*******************************************************************************
 4893: 1  1161	C0 E0		s_sqrt32:       push    acc
 4894: 1  1163	C0 D0		                push    psw
 4895: 1  1165	EB		                mov     a,r3
 4896: 1  1166	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4897: 1  1169	D0 D0		                pop     psw
 4898: 1  116B	D3		                setb    c                ;als negatief dan error
 4899: 1  116C	D0 E0		                pop     acc
 4900: 1  116E	22		                ret
 4901: 1  116F	D0 D0		s_sqrt321:      pop     psw
 4902: 1  1171	D0 E0		                pop     acc
 4903: 1  1173	12 10 8B	                lcall   sqrt32            ;wortel trekken
 4904: 1  1176	C3		                clr     c                 ;wortel ok
 4905: 1  1177	22		                ret                       ;klaar
 4906: 1
 4907: 1			;*******************************************************************************
 4908: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4909: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4910: 1			; (logical shift)
 4911: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4912: 1			;
 4913: 1			; input:     r3,r2,r1,r0 = acc0
 4914: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4915: 1			;
 4916: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4917: 1			;            CY=1 als N>=32
 4918: 1			; vernietigt:  niets
 4919: 1			;*******************************************************************************
 4920: 1  1178	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4921: 1  117A	C0 D0		                push    psw
 4922: 1  117C	EC		                mov     a,r4            ;neem aantal shifts
 4923: 1  117D	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4924: 1  1180	40 06		shiftright1:    jc      shiftright2
 4925: 1  1182	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4926: 1  1184	D3		                setb    c               ;N buiten bereik
 4927: 1  1185	D0 E0		                pop     acc
 4928: 1  1187	22		                ret
 4929: 1
 4930: 1  1188	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4931: 1  118A	8C F0		                mov     b,r4            ;lusteller initialiseren
 4932: 1  118C	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4933: 1  118D	EB		                mov     a,r3            ;start bij msb
 4934: 1  118E	13		                rrc     a
 4935: 1  118F	FB		                mov     r3,a
 4936: 1  1190	EA		                mov     a,r2
 4937: 1  1191	13		                rrc     a
 4938: 1  1192	FA		                mov     r2,a
 4939: 1  1193	E9		                mov     a,r1
 4940: 1  1194	13		                rrc     a
 4941: 1  1195	F9		                mov     r1,a
 4942: 1  1196	E8		                mov     a,r0
 4943: 1  1197	13		                rrc     a
 4944: 1  1198	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4945: 1  1199	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4946: 1  119C	D0 F0		                pop     b               ;registers herstellen
 4947: 1  119E	D0 D0		                pop     psw
 4948: 1  11A0	C3		                clr     c               ;N is binnen bereik
 4949: 1  11A1	D0 E0		                pop     acc
 4950: 1  11A3	22		                ret
 4951: 1
 4952: 1			;*******************************************************************************
 4953: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4954: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4955: 1			; (logical shift)
 4956: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4957: 1			;
 4958: 1			; input:     r3,r2,r1,r0 = acc0
 4959: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4960: 1			;
 4961: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4962: 1			;
 4963: 1			; vernietigt:  niets
 4964: 1			;*******************************************************************************
 4965: 1  11A4	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4966: 1  11A6	C0 D0		                push    psw
 4967: 1  11A8	EC		                mov     a,r4            ;neem aantal shifts
 4968: 1  11A9	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4969: 1  11AC	40 06		shiftleft1:     jc      shiftleft2
 4970: 1  11AE	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4971: 1  11B0	D3		                setb    c               ;N buiten bereik
 4972: 1  11B1	D0 E0		                pop     acc
 4973: 1  11B3	22		                ret
 4974: 1
 4975: 1  11B4	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4976: 1  11B6	8C F0		                mov     b,r4            ;lusteller initialiseren
 4977: 1  11B8	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4978: 1  11B9	E8		                mov     a,r0            ;start bij lsb
 4979: 1  11BA	33		                rlc     a
 4980: 1  11BB	F8		                mov     r0,a
 4981: 1  11BC	E9		                mov     a,r1
 4982: 1  11BD	33		                rlc     a
 4983: 1  11BE	F9		                mov     r1,a
 4984: 1  11BF	EA		                mov     a,r2
 4985: 1  11C0	33		                rlc     a
 4986: 1  11C1	FA		                mov     r2,a
 4987: 1  11C2	EB		                mov     a,r3
 4988: 1  11C3	33		                rlc     a
 4989: 1  11C4	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4990: 1  11C5	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4991: 1  11C8	D0 F0		                pop     b               ;registers herstellen
 4992: 1  11CA	D0 D0		                pop     psw
 4993: 1  11CC	C3		                clr     c               ;N is binnen bereik
 4994: 1  11CD	D0 E0		                pop     acc
 4995: 1  11CF	22		                ret
 4996: 1
 4997: 1			;*******************************************************************************
 4998: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4999: 1			; (arithmetic shift)
 5000: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 5001: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 5002: 1			; niet van teken!
 5003: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 5004: 1			;                       (-2147483648 tot +2147483647)
 5005: 1			;
 5006: 1			; input:     r3,r2,r1,r0 = acc0
 5007: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 5008: 1			;
 5009: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 5010: 1			;            CY=1 als N>=31
 5011: 1			; vernietigt:  niets
 5012: 1			;*******************************************************************************
 5013: 1  11D0	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 5014: 1  11D2	C0 D0		                push    psw
 5015: 1  11D4	EC		                mov     a,r4            ;neem aantal shifts
 5016: 1  11D5	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 5017: 1  11D8	40 06		s_shiftright1:  jc      s_shiftright2
 5018: 1  11DA	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 5019: 1  11DC	D3		                setb    c               ;N buiten bereik
 5020: 1  11DD	D0 E0		                pop     acc
 5021: 1  11DF	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5022: 1
 5023: 1  11E0	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 5024: 1  11E2	8C F0		                mov     b,r4            ;lusteller initialiseren
 5025: 1  11E4	EB		                mov     a,r3
 5026: 1  11E5	20 E7 04	                jb      acc.7,s_shiftright20
 5027: 1  11E8	C2 D5		                clr     f0              ;geef aan dat getal positief is
 5028: 1  11EA	80 02		                sjmp    s_shiftright3
 5029: 1  11EC	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 5030: 1
 5031: 1  11EE	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 5032: 1  11F0	EB		                mov     a,r3            ;start bij msb
 5033: 1  11F1	13		                rrc     a
 5034: 1  11F2	FB		                mov     r3,a
 5035: 1  11F3	EA		                mov     a,r2
 5036: 1  11F4	13		                rrc     a
 5037: 1  11F5	FA		                mov     r2,a
 5038: 1  11F6	E9		                mov     a,r1
 5039: 1  11F7	13		                rrc     a
 5040: 1  11F8	F9		                mov     r1,a
 5041: 1  11F9	E8		                mov     a,r0
 5042: 1  11FA	13		                rrc     a
 5043: 1  11FB	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 5044: 1  11FC	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 5045: 1  11FF	D0 F0		                pop     b               ;registers herstellen
 5046: 1  1201	D0 D0		                pop     psw
 5047: 1  1203	C3		                clr     c               ;N is binnen bereik
 5048: 1  1204	D0 E0		                pop     acc
 5049: 1  1206	22		                ret
 5050: 1
 5051: 1			;*******************************************************************************
 5052: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 5053: 1			; (arithmetic shift)
 5054: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 5055: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 5056: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 5057: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 5058: 1			;                       (-2147483648 tot +2147483647)
 5059: 1			;
 5060: 1			; input:     r3,r2,r1,r0 = acc0
 5061: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 5062: 1			;
 5063: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 5064: 1			;            CY=1 als N>=31
 5065: 1			; vernietigt:  niets
 5066: 1			;*******************************************************************************
 5067: 1  1207	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 5068: 1  1209	C0 D0		                push    psw
 5069: 1  120B	EC		                mov     a,r4            ;neem aantal shifts
 5070: 1  120C	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 5071: 1  120F	40 06		s_shiftleft1:   jc      s_shiftleft2
 5072: 1  1211	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 5073: 1  1213	D3		                setb    c               ;N buiten bereik
 5074: 1  1214	D0 E0		                pop     acc
 5075: 1  1216	22		                ret
 5076: 1
 5077: 1  1217	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5078: 1  1219	8C F0		                mov     b,r4            ;lusteller initialiseren
 5079: 1
 5080: 1
 5081: 1
 5082: 1  121B	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 5083: 1  121C	E8		                mov     a,r0             ;start bij lsb
 5084: 1  121D	33		                rlc     a
 5085: 1  121E	F8		                mov     r0,a
 5086: 1  121F	E9		                mov     a,r1
 5087: 1  1220	33		                rlc     a
 5088: 1  1221	F9		                mov     r1,a
 5089: 1  1222	EA		                mov     a,r2
 5090: 1  1223	33		                rlc     a
 5091: 1  1224	FA		                mov     r2,a
 5092: 1  1225	EB		                mov     a,r3
 5093: 1  1226	33		                rlc     a
 5094: 1  1227	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 5095: 1  1229	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 5096: 1  122A	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 5097: 1  122D	D0 F0		                pop     b                ;registers herstellen
 5098: 1  122F	D0 D0		                pop     psw
 5099: 1  1231	C3		                clr     c                ;N is binnen bereik
 5100: 1  1232	D0 E0		                pop     acc
 5101: 1  1234	22		                ret
 5102: 1
 5103: 1			;*******************************************************************************
 5104: 1			; s_cmp16    (29,5us @16.777216MHz)
 5105: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 5106: 1			;
 5107: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 5108: 1			;
 5109: 1			; input:     r1,r0 = acc0
 5110: 1			;            r5,r4 = acc1
 5111: 1			;
 5112: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5113: 1			;             f0=0,cy=0  als acc0 > acc1
 5114: 1			;             f0=1 cy=0    als acc1 = acc0
 5115: 1			;
 5116: 1			; vernietigt:  niets
 5117: 1			;*******************************************************************************
 5118: 1  1235	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 5119: 1  1237	C0 D0		                push    psw
 5120: 1  1239	E8		                mov     a,r0
 5121: 1  123A	C0 E0		                push    acc
 5122: 1  123C	E9		                mov     a,r1
 5123: 1  123D	C0 E0		                push    acc
 5124: 1
 5125: 1  123F	E9		                mov     a,r1            ;neem msb van acc0
 5126: 1  1240	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 5127: 1  1241	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 5128: 1  1244	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 5129: 1			                                        ;negatief is
 5130: 1  1245	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 5131: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 5132: 1
 5133: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

       1
 5134: 1			;acc0>acc1
 5135: 1  1248	D0 E0		s_cmp160:       pop     acc
 5136: 1  124A	F9		                mov     r1,a
 5137: 1  124B	D0 E0		                pop     acc
 5138: 1  124D	F8		                mov     r0,a
 5139: 1  124E	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5140: 1  1250	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5141: 1  1252	C3		                clr     c               ;geef dit aan in de outputstatus
 5142: 1  1253	D0 E0		                pop     acc
 5143: 1  1255	22		                ret
 5144: 1			;acc0<acc1
 5145: 1  1256	D0 E0		s_cmp161:       pop     acc
 5146: 1  1258	F9		                mov     r1,a
 5147: 1  1259	D0 E0		                pop     acc
 5148: 1  125B	F8		                mov     r0,a
 5149: 1  125C	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5150: 1  125E	D3		                setb    c               ;groter dan acc0
 5151: 1  125F	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5152: 1  1261	D0 E0		                pop     acc
 5153: 1  1263	22		                ret
 5154: 1			;gelijk teken, maak verschil
 5155: 1  1264	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 5156: 1  1265	E8		                mov     a,r0            ;acc0-acc1
 5157: 1  1266	9C		                subb    a,r4
 5158: 1  1267	F8		                mov     r0,a
 5159: 1  1268	E9		                mov     a,r1
 5160: 1  1269	9D		                subb    a,r5
 5161: 1  126A	F9		                mov     r1,a
 5162: 1  126B	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 5163: 1  126E	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5164: 1  126F	60 02		                jz      s_cmp163        ;acc0=acc1
 5165: 1  1271	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 5166: 1			;acc0=acc1
 5167: 1  1273	D0 E0		s_cmp163:       pop     acc
 5168: 1  1275	F9		                mov     r1,a
 5169: 1  1276	D0 E0		                pop     acc
 5170: 1  1278	F8		                mov     r0,a
 5171: 1  1279	D0 D0		                pop     psw             ;acc0=acc1
 5172: 1  127B	C3		                clr     c               ;geef dit aan in de outputstatus
 5173: 1  127C	D2 D5		                setb    f0
 5174: 1  127E	D0 E0		                pop     acc
 5175: 1  1280	22		                ret
 5176: 1
 5177: 1			;*******************************************************************************
 5178: 1			; cmp16            (19,9us @16.777216MHz)
 5179: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 5180: 1			;
 5181: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 5182: 1			;
 5183: 1			; input:     r1,r0 = acc0
 5184: 1			;            r5,r4 = acc1
 5185: 1			;
 5186: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5187: 1			;             f0=0,cy=0  als acc0 > acc1
 5188: 1			;             f0=1 cy=0    als acc1 = acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5189: 1			;
 5190: 1			; vernietigt:  niets
 5191: 1			;*******************************************************************************
 5192: 1  1281	C0 E0		cmp16:          push    acc             ;bewaar registers
 5193: 1  1283	C0 F0		                push    b
 5194: 1  1285	C0 D0		                push    psw
 5195: 1
 5196: 1  1287	C3		                clr     c               ;vergelijk acc0 met acc1
 5197: 1  1288	E9		                mov     a,r1            ;eerst de msb's
 5198: 1  1289	8D F0		                mov     b,r5            ;test r1-r5
 5199: 1  128B	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 5200: 1
 5201: 1  128E	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 5202: 1  128F	8C F0		                mov     b,r4            ;test r0-r4
 5203: 1  1291	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 5204: 1			;acc0=acc1
 5205: 1  1294	D0 D0		                pop     psw
 5206: 1  1296	D2 D5		                setb    f0
 5207: 1  1298	C3		                clr     c
 5208: 1  1299	D0 F0		                pop     b
 5209: 1  129B	D0 E0		                pop     acc
 5210: 1  129D	22		                ret
 5211: 1  129E	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 5212: 1			;acc0>acc1
 5213: 1  12A0	D0 D0		                pop     psw
 5214: 1  12A2	C2 D5		                clr     f0
 5215: 1  12A4	C3		                clr     c
 5216: 1  12A5	D0 F0		                pop     b
 5217: 1  12A7	D0 E0		                pop     acc
 5218: 1  12A9	22		                ret
 5219: 1			;acc0<acc1
 5220: 1  12AA	D0 D0		cmp162:         pop     psw
 5221: 1  12AC	D3		                setb    c
 5222: 1  12AD	C2 D5		                clr     f0
 5223: 1  12AF	D0 F0		                pop     b
 5224: 1  12B1	D0 E0		                pop     acc
 5225: 1  12B3	22		                ret
 5226: 1
 5227: 1			;*******************************************************************************
 5228: 1			; s_cmp32        (44,3us @16.777216MHz)
 5229: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 5230: 1			;
 5231: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 5232: 1			;                         -2147483648 tot +2147483647
 5233: 1			; input:     r1,r0 = acc0
 5234: 1			;            r5,r4 = acc1
 5235: 1			;
 5236: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5237: 1			;             f0=0,cy=0  als acc0 > acc1
 5238: 1			;             f0=1 cy=0    als acc1 = acc0
 5239: 1			;
 5240: 1			; vernietigt:  niets
 5241: 1			;*******************************************************************************
 5242: 1  12B4	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 5243: 1  12B6	C0 D0		                push    psw
 5244: 1  12B8	E8		                mov     a,r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5245: 1  12B9	C0 E0		                push    acc
 5246: 1  12BB	E9		                mov     a,r1
 5247: 1  12BC	C0 E0		                push    acc
 5248: 1  12BE	EA		                mov     a,r2
 5249: 1  12BF	C0 E0		                push    acc
 5250: 1  12C1	EB		                mov     a,r3
 5251: 1  12C2	C0 E0		                push    acc
 5252: 1
 5253: 1  12C4	EB		                mov     a,r3            ;neem msb van acc0
 5254: 1  12C5	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 5255: 1  12C6	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 5256: 1  12C8	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 5257: 1  12CA	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 5258: 1  12CB	A2 E7		                mov     c,acc.7         ;negatief is
 5259: 1  12CD	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 5260: 1			                                        ;acc1 positief. Dus acc1>acc0
 5261: 1			;acc0>acc1
 5262: 1  12CF	D0 E0		s_cmp320:       pop     acc
 5263: 1  12D1	FB		                mov     r3,a
 5264: 1  12D2	D0 E0		                pop     acc
 5265: 1  12D4	FA		                mov     r2,a
 5266: 1  12D5	D0 E0		                pop     acc
 5267: 1  12D7	F9		                mov     r1,a
 5268: 1  12D8	D0 E0		                pop     acc
 5269: 1  12DA	F8		                mov     r0,a
 5270: 1  12DB	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5271: 1  12DD	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5272: 1  12DF	C3		                clr     c               ;geef dit aan in de outputstatus
 5273: 1  12E0	D0 E0		                pop     acc
 5274: 1  12E2	22		                ret
 5275: 1			;acc0<acc1
 5276: 1  12E3	D0 E0		s_cmp321:       pop     acc
 5277: 1  12E5	FB		                mov     r3,a
 5278: 1  12E6	D0 E0		                pop     acc
 5279: 1  12E8	FA		                mov     r2,a
 5280: 1  12E9	D0 E0		                pop     acc
 5281: 1  12EB	F9		                mov     r1,a
 5282: 1  12EC	D0 E0		                pop     acc
 5283: 1  12EE	F8		                mov     r0,a
 5284: 1  12EF	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5285: 1  12F1	D3		                setb    c               ;groter dan acc0
 5286: 1  12F2	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5287: 1  12F4	D0 E0		                pop     acc
 5288: 1  12F6	22		                ret
 5289: 1			;gelijk teken, maak verschil
 5290: 1  12F7	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5291: 1  12F8	E8		                mov     a,r0            ;acc0-acc1
 5292: 1  12F9	9C		                subb    a,r4
 5293: 1  12FA	F8		                mov     r0,a
 5294: 1  12FB	E9		                mov     a,r1
 5295: 1  12FC	9D		                subb    a,r5
 5296: 1  12FD	F9		                mov     r1,a
 5297: 1  12FE	EA		                mov     a,r2
 5298: 1  12FF	9E		                subb    a,r6
 5299: 1  1300	FA		                mov     r2,a
 5300: 1  1301	EB		                mov     a,r3

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5301: 1  1302	9F		                subb    a,r7
 5302: 1  1303	FB		                mov     r3,a
 5303: 1  1304	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5304: 1  1307	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5305: 1  1308	49		                orl     a,r1
 5306: 1  1309	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5307: 1  130A	60 02		                jz      s_cmp323        ;acc0=acc1
 5308: 1  130C	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5309: 1			;acc0=acc1
 5310: 1  130E	D0 E0		s_cmp323:       pop     acc
 5311: 1  1310	FB		                mov     r3,a
 5312: 1  1311	D0 E0		                pop     acc
 5313: 1  1313	FA		                mov     r2,a
 5314: 1  1314	D0 E0		                pop     acc
 5315: 1  1316	F9		                mov     r1,a
 5316: 1  1317	D0 E0		                pop     acc
 5317: 1  1319	F8		                mov     r0,a
 5318: 1  131A	D0 D0		                pop     psw             ;acc0=acc1
 5319: 1  131C	C3		                clr     c               ;geef dit aan in de outputstatus
 5320: 1  131D	D2 D5		                setb    f0
 5321: 1  131F	D0 E0		                pop     acc
 5322: 1  1321	22		                ret
 5323: 1
 5324: 1			;*******************************************************************************
 5325: 1			; cmp32        (27,14us @16.777216MHz)
 5326: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5327: 1			;
 5328: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5329: 1			;
 5330: 1			; input:     r3,r2,r1,r0 = acc0
 5331: 1			;            r7,r6,r5,r4 = acc1
 5332: 1			;
 5333: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5334: 1			;            f0=0,cy=0  als acc0 > acc1
 5335: 1			;            f0=1 cy=0    als acc1 = acc0
 5336: 1			;
 5337: 1			; vernietigt:  niets
 5338: 1			;*******************************************************************************
 5339: 1  1322	C0 E0		cmp32:          push    acc             ;bewaar registers
 5340: 1  1324	C0 F0		                push    b
 5341: 1  1326	C0 D0		                push    psw
 5342: 1
 5343: 1  1328	C3		                clr     c               ;vergelijk acc0 met acc1
 5344: 1  1329	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5345: 1  132A	8F F0		                mov     b,r7            ;test r3-r7
 5346: 1  132C	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5347: 1
 5348: 1  132F	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5349: 1  1330	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5350: 1  1332	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5351: 1
 5352: 1  1335	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5353: 1  1336	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5354: 1  1338	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5355: 1
 5356: 1  133B	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5357: 1  133C	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5358: 1  133E	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5359: 1			;acc0=acc1
 5360: 1  1341	D0 D0		                pop     psw
 5361: 1  1343	D2 D5		                setb    f0
 5362: 1  1345	C3		                clr     c
 5363: 1  1346	D0 F0		                pop     b
 5364: 1  1348	D0 E0		                pop     acc
 5365: 1  134A	22		                ret
 5366: 1  134B	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5367: 1			;acc0>acc1, indien cy=0
 5368: 1  134D	D0 D0		                pop     psw
 5369: 1  134F	C2 D5		                clr     f0
 5370: 1  1351	C3		                clr     c
 5371: 1  1352	D0 F0		                pop     b
 5372: 1  1354	D0 E0		                pop     acc
 5373: 1  1356	22		                ret
 5374: 1			;acc0<acc1
 5375: 1  1357	D0 D0		cmp322:         pop     psw
 5376: 1  1359	D3		                setb    c
 5377: 1  135A	C2 D5		                clr     f0
 5378: 1  135C	D0 F0		                pop     b
 5379: 1  135E	D0 E0		                pop     acc
 5380: 1  1360	22		                ret
 5381: 1
 5382: 1
 5383: 1			;*******************************************************************************
 5384: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5385: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5386: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5387: 1			; adres zitten.
 5388: 1			;
 5389: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5390: 1			;
 5391: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5392: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5393: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5394: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5395: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5396: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5397: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5398: 1			;                cy = 0  lookup is ok
 5399: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5400: 1			; vernietigt:  niets
 5401: 1			;*******************************************************************************
 5402: 1  1361	C0 E0		table_lu:       push    acc             ;bewaren registers
 5403: 1  1363	C0 D0		                push    psw
 5404: 1  1365	C0 82		                push    dpl
 5405: 1  1367	C0 83		                push    dph
 5406: 1
 5407: 1  1369	A2 D5		                mov     c,f0            ;byte of word items?
 5408: 1  136B	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5409: 1			;tabel met byte items
 5410: 1  136D	E5 82		                mov     a,dpl           ;datapointer plus index
 5411: 1  136F	28		                add     a,r0
 5412: 1  1370	F5 82		                mov     dpl,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5413: 1  1372	E5 83		                mov     a,dph
 5414: 1  1374	39		                addc    a,r1
 5415: 1  1375	F5 83		                mov     dph,a
 5416: 1  1377	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5417: 1  1379	A2 D1		                mov     c,f1            ;code of datageheugen?
 5418: 1  137B	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5419: 1
 5420: 1			;bytetabel in codegeheugen
 5421: 1  137D	74 00		                mov     a,#0
 5422: 1  137F	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5423: 1  1380	F8		                mov     r0,a            ;en stop in acc0
 5424: 1  1381	79 00		                mov     r1,#0
 5425: 1  1383	02 13 E2	                ljmp    table_lu4       ;en klaar
 5426: 1
 5427: 1			;bytetabel in datageheugen
 5428: 1  1386	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5429: 1  1387	F8		                mov     r0,a            ;en stop in acc0
 5430: 1  1388	79 00		                mov     r1,#0
 5431: 1  138A	02 13 E2	                ljmp    table_lu4       ;en klaar
 5432: 1
 5433: 1  138D	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5434: 1  138F	D0 82		                pop     dpl
 5435: 1  1391	D0 D0		                pop     psw
 5436: 1  1393	D3		                setb    c              ;foutstatus teruggeven!
 5437: 1  1394	D0 E0		                pop     acc
 5438: 1  1396	22		                ret
 5439: 1
 5440: 1			;tabel met word items
 5441: 1  1397	E8		table_lu2:      mov     a,r0            ;index op stack
 5442: 1  1398	C0 E0		                push    acc
 5443: 1  139A	E9		                mov     a,r1
 5444: 1  139B	C0 E0		                push    acc
 5445: 1
 5446: 1  139D	C3		                clr      c              ;index maal 2 (word items)
 5447: 1  139E	E8		                mov     a,r0
 5448: 1  139F	33		                rlc     a
 5449: 1  13A0	F8		                mov     r0,a
 5450: 1  13A1	E9		                mov     a,r1
 5451: 1  13A2	33		                rlc     a
 5452: 1  13A3	F9		                mov     r1,a
 5453: 1
 5454: 1  13A4	E5 82		                mov     a,dpl           ;datapointer plus index
 5455: 1  13A6	28		                add     a,r0
 5456: 1  13A7	F5 82		                mov     dpl,a
 5457: 1  13A9	E5 83		                mov     a,dph
 5458: 1  13AB	39		                addc    a,r1
 5459: 1  13AC	F5 83		                mov     dph,a
 5460: 1
 5461: 1  13AE	D0 E0		                pop     acc             ;index weer van stack
 5462: 1  13B0	F9		                mov     r1,a
 5463: 1  13B1	D0 E0		                pop     acc
 5464: 1  13B3	F8		                mov     r0,a
 5465: 1
 5466: 1  13B4	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5467: 1  13B6	A2 D1		                mov     c,f1            ;code of datageheugen?
 5468: 1  13B8	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5469: 1			;wordtabel in codegeheugen
 5470: 1  13BA	74 00		                mov     a,#0
 5471: 1  13BC	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5472: 1  13BD	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5473: 1  13BE	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5474: 1  13C0	24 01		                add     a,#1
 5475: 1  13C2	F5 82		                mov     dpl,a
 5476: 1  13C4	E5 83		                mov     a,dph
 5477: 1  13C6	34 00		                addc    a,#0
 5478: 1  13C8	F5 83		                mov     dph,a
 5479: 1  13CA	74 00		                mov     a,#0
 5480: 1  13CC	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5481: 1  13CD	F9		                mov     r1,a            ;msb in acc0 stoppen
 5482: 1  13CE	80 12		                sjmp    table_lu4        ;en klaar
 5483: 1			;wordtabel    in datageheugen
 5484: 1  13D0	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5485: 1  13D1	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5486: 1  13D2	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5487: 1  13D4	24 01		                add     a,#1
 5488: 1  13D6	F5 82		                mov     dpl,a
 5489: 1  13D8	E5 83		                mov     a,dph
 5490: 1  13DA	34 00		                addc    a,#0
 5491: 1  13DC	F5 83		                mov     dph,a
 5492: 1  13DE	74 00		                mov     a,#0
 5493: 1  13E0	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5494: 1  13E1	F9		                mov     r1,a            ;msb in acc0 stoppen
 5495: 1			                                        ;en klaar
 5496: 1
 5497: 1  13E2	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5498: 1  13E4	D0 82		                pop     dpl
 5499: 1  13E6	D0 D0		                pop     psw
 5500: 1  13E8	D0 E0		                pop     acc
 5501: 1  13EA	22		                ret
 5502: 1
 5503: 1
 5504: 1
 5505: 1			;*******************************************************************************
 5506: 1			; Cordic        (2,11ms @16.777216MHz)
 5507: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5508: 1			; waarde (2's complement) opgegeven hoek.
 5509: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5510: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5511: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5512: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5513: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5514: 1			; als geschaalde getallen ter beschikking komen.
 5515: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5516: 1			;
 5517: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5518: 1			;
 5519: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5520: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5521: 1			;            cy = 0 : hoek binnen bereik
 5522: 1			;            cy = 1 : error, hoek buiten bereik
 5523: 1			;            nauwkeurigheid: 12 msbits
 5524: 1			; vernietigt:  niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5525: 1			;*******************************************************************************
 5526: 1  13EB	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5527: 1  13ED	C0 D0		                push    psw
 5528: 1  13EF	C0 83		                push    dph
 5529: 1  13F1	C0 82		                push    dpl
 5530: 1  13F3	C0 F0		                push    b
 5531: 1
 5532: 1  13F5	EF		                mov     a,r7
 5533: 1  13F6	C0 E0		                push    acc
 5534: 1  13F8	EE		                mov     a,r6
 5535: 1  13F9	C0 E0		                push    acc
 5536: 1  13FB	ED		                mov     a,r5
 5537: 1  13FC	C0 E0		                push    acc
 5538: 1  13FE	EC		                mov     a,r4
 5539: 1  13FF	C0 E0		                push    acc
 5540: 1
 5541: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5542: 1			;en niet groter dan pi/2 radialen (6478h)
 5543: 1  1401	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5544: 1  1403	7D 64		                mov     r5,#64h
 5545: 1  1405	12 12 81	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5546: 1  1408	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5547: 1  140B	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5548: 1  140D	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5549: 1
 5550: 1  140F	C2 A0		cordic000:      clr     p2.0
 5551: 1  1411	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5552: 1  1413	7D 9B		                mov     r5,#9bh
 5553: 1  1415	12 12 81	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5554: 1  1418	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5555: 1  141B	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5556: 1  141D	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5557: 1
 5558: 1  141F	C2 A1		cordic_error:   clr     p2.1
 5559: 1  1421	02 14 D3	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5560: 1
 5561: 1			;Hoek is -pi/2 resultaat gekend
 5562: 1  1424	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5563: 1  1426	7A 00		                mov     r2,#000h
 5564: 1  1428	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5565: 1  142A	78 00		                mov     r0,#000h
 5566: 1  142C	C3		                clr     c
 5567: 1  142D	02 14 D3	                ljmp    cordic40        ;en klaar
 5568: 1			;hoek is +pi/2 resultaat gekend
 5569: 1  1430	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5570: 1  1432	7A FF		                mov     r2,#0ffh
 5571: 1  1434	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5572: 1  1436	78 00		                mov     r0,#000h
 5573: 1  1438	C3		                clr     c
 5574: 1  1439	02 14 D3	                ljmp    cordic40        ;en klaar
 5575: 1
 5576: 1  143C	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5577: 1  143E	7D 00		                mov     r5,#00h
 5578: 1  1440	12 12 81	                lcall   cmp16            ;vergelijk de hoeken
 5579: 1  1443	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5580: 1  1446	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5581: 1			;hoek is 0, resultaat gekend
 5582: 1  1448	C2 A7		cordic_nul:     clr     p2.7
 5583: 1  144A	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5584: 1  144C	7A 00		                mov     r2,#000h
 5585: 1  144E	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5586: 1  1450	78 FF		                mov     r0,#0ffh
 5587: 1  1452	C3		                clr     c
 5588: 1  1453	02 14 D3	                ljmp    cordic40        ;en klaar
 5589: 1
 5590: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5591: 1  1456	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5592: 1  1457	C0 E0		                push    acc
 5593: 1  1459	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5594: 1  145A	C0 E0		                push    acc
 5595: 1
 5596: 1  145C	7B 00		                mov     r3,#00h         ;y=0
 5597: 1  145E	7A 00		                mov     r2,#00h
 5598: 1  1460	79 26		                mov     r1,#026h        ;x = K * 2^14
 5599: 1  1462	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5600: 1
 5601: 1  1464	75 F0 00	                mov     b,#00h          ;loopteller=0
 5602: 1
 5603: 1  1467	90 15 2B	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5604: 1
 5605: 1  146A	EB		cordic1:        mov     a,r3            ;sry=y
 5606: 1  146B	FF		                mov     r7,a
 5607: 1  146C	EA		                mov     a,r2
 5608: 1  146D	FE		                mov     r6,a
 5609: 1  146E	E9		                mov     a,r1            ;srx=x
 5610: 1  146F	FD		                mov     r5,a
 5611: 1  1470	E8		                mov     a,r0
 5612: 1  1471	FC		                mov     r4,a
 5613: 1
 5614: 1  1472	12 14 F2	                lcall   cordic5          ;srx en sry >> loopteller
 5615: 1
 5616: 1  1475	D0 E0		                pop     acc
 5617: 1  1477	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5618: 1
 5619: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5620: 1  147A	C3		                clr     c
 5621: 1  147B	E8		                mov     a,r0            ;bereken x=x-sry
 5622: 1  147C	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5623: 1  147D	F8		                mov     r0,a
 5624: 1  147E	E9		                mov     a,r1
 5625: 1  147F	9F		                subb    a,r7
 5626: 1  1480	F9		                mov     r1,a
 5627: 1
 5628: 1  1481	EA		                mov     a,r2            ;bereken y=y+srx
 5629: 1  1482	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5630: 1  1483	FA		                mov     r2,a
 5631: 1  1484	EB		                mov     a,r3
 5632: 1  1485	3D		                addc    a,r5
 5633: 1  1486	FB		                mov     r3,a
 5634: 1
 5635: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5636: 1  1487	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5637: 1  1489	93		                movc    a,@a+dptr
 5638: 1  148A	A3		                inc     dptr
 5639: 1  148B	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5640: 1  148C	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5641: 1  148E	C3		                clr     c               ;verklein de hoek
 5642: 1  148F	9C		                subb    a,r4
 5643: 1  1490	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5644: 1  1492	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5645: 1
 5646: 1  1494	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5647: 1  1496	93		                movc    a,@a+dptr
 5648: 1  1497	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5649: 1  1498	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5650: 1  1499	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5651: 1  149B	9D		                subb    a,r5            ;verklein de hoek
 5652: 1  149C	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5653: 1
 5654: 1			;loopteller incrementeren en testen op einde van de iteratie
 5655: 1  149E	05 F0		cordic2:        inc     b               ;loopteller++
 5656: 1  14A0	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5657: 1  14A2	65 F0		                xrl     a,b             ;test op gelijkheid
 5658: 1  14A4	60 28		                jz      cordic4         ;ja klaar!
 5659: 1  14A6	02 14 6A	                ljmp    cordic1         ;nee, nog even verder...
 5660: 1
 5661: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5662: 1  14A9	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5663: 1  14AA	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5664: 1  14AB	F8		                mov     r0,a
 5665: 1  14AC	E9		                mov     a,r1
 5666: 1  14AD	3F		                addc    a,r7
 5667: 1  14AE	F9		                mov     r1,a
 5668: 1
 5669: 1  14AF	C3		                clr     c
 5670: 1  14B0	EA		                mov     a,r2            ;bereken y=y-srx
 5671: 1  14B1	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5672: 1  14B2	FA		                mov     r2,a
 5673: 1  14B3	EB		                mov     a,r3
 5674: 1  14B4	9D		                subb    a,r5
 5675: 1  14B5	FB		                mov     r3,a
 5676: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5677: 1  14B6	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5678: 1  14B8	93		                movc    a,@a+dptr
 5679: 1  14B9	A3		                inc     dptr
 5680: 1  14BA	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5681: 1  14BB	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5682: 1  14BD	2C		                add     a,r4            ;vergroot de hoek
 5683: 1  14BE	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5684: 1  14C0	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5685: 1
 5686: 1  14C2	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5687: 1  14C4	93		                movc    a,@a+dptr
 5688: 1  14C5	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5689: 1  14C6	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5690: 1  14C7	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5691: 1  14C9	3D		                addc    a,r5            ;vergroot de hoek
 5692: 1  14CA	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5693: 1
 5694: 1  14CC	80 D0		                sjmp    cordic2
 5695: 1
 5696: 1  14CE	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5697: 1  14D0	D0 E0		                pop     acc             ;dummy hoek van stack
 5698: 1  14D2	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5699: 1
 5700: 1  14D3	D0 E0		cordic40:       pop     acc
 5701: 1  14D5	FC		                mov     r4,a
 5702: 1  14D6	D0 E0		                pop     acc
 5703: 1  14D8	FD		                mov     r5,a
 5704: 1  14D9	D0 E0		                pop     acc
 5705: 1  14DB	FE		                mov     r6,a
 5706: 1  14DC	D0 E0		                pop     acc
 5707: 1  14DE	FF		                mov     r7,a
 5708: 1  14DF	D0 F0		                pop     b
 5709: 1  14E1	D0 82		                pop     dpl
 5710: 1  14E3	D0 83		                pop     dph
 5711: 1  14E5	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5712: 1  14E7	D0 D0		                pop     psw
 5713: 1  14E9	D0 E0		                pop     acc
 5714: 1  14EB	22		                ret
 5715: 1
 5716: 1  14EC	D0 D0		cordic41:       pop     psw
 5717: 1  14EE	D3		                setb    c
 5718: 1  14EF	D0 E0		                pop     acc
 5719: 1  14F1	22		                ret
 5720: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5721: 1			;over het aantal posities aangegeven in het B register.
 5722: 1  14F2	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5723: 1  14F4	74 00		                mov     a,#0            ;test of loopteller=0
 5724: 1  14F6	65 F0		                xrl     a,b
 5725: 1  14F8	60 2E		                jz      cordic52        ;klaar
 5726: 1
 5727: 1  14FA	ED		                mov     a,r5            ;test teken van srx
 5728: 1  14FB	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5729: 1  14FE	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5730: 1  1500	80 02		                sjmp    cordic50
 5731: 1  1502	D2 D5		cordic5a:       setb    f0
 5732: 1  1504	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5733: 1  1506	ED		                mov     a,r5            ;eerst de msb
 5734: 1  1507	13		                rrc     a
 5735: 1  1508	FD		                mov     r5,a
 5736: 1  1509	EC		                mov     a,r4            ;dan de lsb
 5737: 1  150A	13		                rrc     a
 5738: 1  150B	FC		                mov     r4,a
 5739: 1  150C	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5740: 1  150F	D0 F0		                pop     b               ;haal de loopteller van stack
 5741: 1  1511	C0 F0		                push    b               ;en bewaar hem weer
 5742: 1  1513	EF		                mov     a,r7            ;test teken van sry
 5743: 1  1514	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5744: 1  1517	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5745: 1  1519	80 02		                sjmp    cordic51
 5746: 1  151B	D2 D5		cordic5b:       setb    f0
 5747: 1  151D	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5748: 1  151F	EF		                mov     a,r7            ;eerst de msb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5749: 1  1520	13		                rrc     a
 5750: 1  1521	FF		                mov     r7,a
 5751: 1  1522	EE		                mov     a,r6            ;dan de lsb
 5752: 1  1523	13		                rrc     a
 5753: 1  1524	FE		                mov     r6,a
 5754: 1  1525	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5755: 1
 5756: 1  1528	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5757: 1  152A	22		                ret
 5758: 1
 5759: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5760: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5761: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5762: 1  152B	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5763: 1  152D	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5764: 1  152F	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5765: 1  1531	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5766: 1  1533	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5767: 1  1535	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5768: 1  1537	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5769: 1  1539	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5770: 1  153B	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5771: 1  153D	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5772: 1  153F	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5773: 1  1541	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5774: 1  1543	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5775: 1  1545	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5776: 1  1547	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5777: 1
 5778: 1			endif        ;einde van aduc_math
 5779: 1			;******************************************************************************
 5780: 1
 5781: 1			ifdef        aduc_adc    ;A/D conversie routines
 5782: 1			;*******************************************************************************
 5783: 1			; ADuCADC_mide
 5784: 1			; Geschreven door [dp] op 5/1/2014
 5785: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5786: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5787: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5788: 1			; bron instellen.
 5789: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5790: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5791: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5792: 1			;
 5793: 1			;*******************************************************************************
 5794: 1
 5795: 1			;*******************************************************************************
 5796: 1			; adc_init
 5797: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5798: 1			; -  4 track&hold clockperiodes
 5799: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5800: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5801: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5802: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5803: 1			;
 5804: 1			; input: R0 =  0  : Interne referentiebron

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5805: 1			;        R0 <> 0  : Externe referentiebron
 5806: 1			;
 5807: 1			; Deze routine vernietigt niets
 5808: 1			;*******************************************************************************
 5809: 1  1549	C0 E0		adc_init:       push    acc                 ;registers op stack
 5810: 1  154B	C0 D0		                push    psw
 5811: 1  154D	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5812: 1  1550	E8		                mov     a,r0                ;welke referentiebron?
 5813: 1  1551	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5814: 1  1553	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5815: 1  1556	D0 D0		adc_init1:      pop     psw
 5816: 1  1558	D0 E0		                pop     acc
 5817: 1  155A	22		                ret
 5818: 1
 5819: 1			;*******************************************************************************
 5820: 1			; adc_single
 5821: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5822: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5823: 1			; (2's complement) formaat van de meetwaarde.
 5824: 1			; _____________________________________________________________
 5825: 1			; resolutie  |     unsigned      |           signed            |
 5826: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5827: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5828: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5829: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5830: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5831: 1			; _____________________________________________________________
 5832: 1			;
 5833: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5834: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5835: 1			; De ingangsparameter wordt doorgegeven via R0.
 5836: 1			;
 5837: 1			; input:
 5838: 1			;             7    6    5    4    3    2    1    0
 5839: 1			;           _______________________________________
 5840: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5841: 1			;           ---------------------------------------
 5842: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5843: 1			;                                         1000b = temp.sensor
 5844: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5845: 1			;                                   10b = 12 bits, 11b = 12 bits
 5846: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5847: 1			;
 5848: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5849: 1			;         cy=0  bij conversie ok
 5850: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5851: 1			;
 5852: 1			; Deze routine vernietigt niets
 5853: 1			;*******************************************************************************
 5854: 1  155B	C0 E0		adc_single:     push    acc                 ;registers op stack
 5855: 1  155D	C0 D0		                push    psw
 5856: 1  155F	C0 F0		                push    b
 5857: 1  1561	E8		                mov     a,r0                ;neem inputparameter
 5858: 1  1562	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5859: 1  1564	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5860: 1  1567	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5861: 1  1569	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5862: 1  156B	D2 DC		                setb    sconv               ;start een meting
 5863: 1  156D	E8		                mov     a,r0                ;neem parameter terug
 5864: 1  156E	A2 E6		                mov     c,acc.6
 5865: 1  1570	92 D5		                mov     f0,c                ;bewaar format bit
 5866: 1  1572	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5867: 1  1575	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5868: 1  1578	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5869: 1  157B	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5870: 1			;*******************************************************************************
 5871: 1			;8 bit resultaat gevraagd
 5872: 1			;*******************************************************************************
 5873: 1  157E	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5874: 1  1580	C4		                swap    a                    ;swap nibbles
 5875: 1  1581	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5876: 1  1583	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5877: 1  1585	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5878: 1  1587	C4		                swap    a
 5879: 1  1588	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5880: 1  158A	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5881: 1			;8 bit unsigned formaat
 5882: 1  158D	79 00		                mov     r1,#00h              ;unsigned
 5883: 1  158F	F8		                mov     r0,a
 5884: 1  1590	80 63		                sjmp    adc_single42
 5885: 1			;8 bit signed formaat
 5886: 1  1592	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5887: 1  1595	24 80		                add     a,#80h                ;negatief getal van maken
 5888: 1  1597	F8		                mov     r0,a
 5889: 1  1598	79 FF		                mov     r1,#0ffh
 5890: 1  159A	80 59		                sjmp    adc_single42
 5891: 1  159C	C3		adc_single20:   clr     c
 5892: 1  159D	94 80		                subb    a,#80h                ;positief deel verkleinen
 5893: 1  159F	F8		                mov     r0,a
 5894: 1  15A0	79 00		                mov     r1,#00h
 5895: 1  15A2	80 51		                sjmp    adc_single42
 5896: 1
 5897: 1  15A4	02 15 FD	adc_single21:   ljmp    adc_single43
 5898: 1			;*******************************************************************************
 5899: 1			;10 bit resultaat gevraagd
 5900: 1			;*******************************************************************************
 5901: 1  15A7	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5902: 1  15A9	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5903: 1  15AB	03		                rr     a              ;naar msbits roteren
 5904: 1  15AC	03		                rr     a
 5905: 1  15AD	F5 F0		                mov    b,a            ;even bewaren
 5906: 1  15AF	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5907: 1  15B1	03		                rr     a              ;twee plaatsen opschuiven
 5908: 1  15B2	03		                rr     a
 5909: 1  15B3	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5910: 1  15B5	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5911: 1  15B7	F5 F0		                mov    b,a            ;low byte even bewaren
 5912: 1  15B9	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5913: 1  15BB	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5914: 1  15BD	03		                rr     a               ;en op hun plaats schuiven
 5915: 1  15BE	03		                rr     a
 5916: 1  15BF	20 D5 05	                jb     f0,adc_single30 ;check formaat

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5917: 1			;10 bit unsigned formaat
 5918: 1  15C2	F9		                mov    r1,a            ;unsigned
 5919: 1  15C3	A8 F0		                mov    r0,b
 5920: 1  15C5	80 2E		                sjmp   adc_single42
 5921: 1			;10 bit signed formaat
 5922: 1  15C7	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5923: 1  15CA	24 FE		                add    a,#0feh             ;negatief getal van maken
 5924: 1  15CC	F9		                mov    r1,a
 5925: 1  15CD	A8 F0		                mov    r0,b
 5926: 1  15CF	80 24		                sjmp   adc_single42
 5927: 1  15D1	C3		adc_single31:   clr    c
 5928: 1  15D2	94 02		                subb   a,#02h              ;positief deel verkleinen
 5929: 1  15D4	F9		                mov    r1,a
 5930: 1  15D5	A8 F0		                mov    r0,b
 5931: 1  15D7	80 1C		                sjmp   adc_single42
 5932: 1
 5933: 1			;*******************************************************************************
 5934: 1			;12 bit resultaat gevraagd
 5935: 1			;*******************************************************************************
 5936: 1  15D9	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5937: 1  15DB	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5938: 1  15DD	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5939: 1			;12 bit unsigned formaat
 5940: 1  15E0	A8 D9		                mov    r0,adcdatal           ;unsigned
 5941: 1  15E2	F9		                mov    r1,a
 5942: 1  15E3	80 10		                sjmp   adc_single42
 5943: 1			;12 bit signed formaat
 5944: 1  15E5	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5945: 1  15E8	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5946: 1  15EA	F9		                mov    r1,a
 5947: 1  15EB	A8 D9		                mov    r0,adcdatal
 5948: 1  15ED	80 06		                sjmp   adc_single42
 5949: 1  15EF	C3		adc_single41:   clr    c
 5950: 1  15F0	94 08		                subb   a,#08h                ;positief deel verkleinen
 5951: 1  15F2	F9		                mov    r1,a
 5952: 1  15F3	A8 D9		                mov    r0,adcdatal
 5953: 1  15F5	D0 F0		adc_single42:   pop    b
 5954: 1  15F7	D0 D0		                pop    psw
 5955: 1  15F9	C3		                clr    c
 5956: 1  15FA	D0 E0		                pop    acc
 5957: 1  15FC	22		                ret
 5958: 1
 5959: 1  15FD	D0 F0		adc_single43:   pop    b
 5960: 1  15FF	D0 D0		                pop    psw
 5961: 1  1601	D3		                setb   c
 5962: 1  1602	D0 E0		                pop    acc
 5963: 1  1604	22		                ret
 5964: 1
 5965: 1			endif        ;einde van aduc_adc
 5966: 1			;*******************************************************************************
 5967: 1
 5968: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5969: 1			;******************************************************************************
 5970: 1			; ADuCKEY_mide.inc
 5971: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5972: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5973: 1			;
 5974: 1			;     V2.0      V1.1
 5975: 1			;                           |   |   |   |
 5976: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5977: 1			;                   |       |   |   |   |
 5978: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5979: 1			;                   |       |   |   |   |
 5980: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5981: 1			;                   |       |   |   |   |
 5982: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5983: 1			;                   |       |   |   |   |
 5984: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5985: 1			;                   |           |   |   |
 5986: 1			;     P0.5      P3.5|-K2--------|   |   |
 5987: 1			;                   |               |   |
 5988: 1			;     P0.6      P3.6|-K3------------|   |
 5989: 1			;                   |                   |
 5990: 1			;     P0.7      P3.7|-K4----------------|
 5991: 1			;
 5992: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5993: 1			; gebruikt.
 5994: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5995: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5996: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5997: 1			; en als ingang wordt aangeboden.
 5998: 1			;
 5999: 1			;                                  ___                 ___
 6000: 1			;                     ____________|   |  |------------|   |
 6001: 1			;              ____  |   ____     |   |  |   ____     |   |
 6002: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 6003: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 6004: 1			; '1'= toets  | cl |    | cl |              | cl |
 6005: 1			;  ingedrukt  |____|    |____|              |____|
 6006: 1			;                |         |                   |
 6007: 1			;      CLOCK     |         |                   |
 6008: 1			;         _______|_________|___________________|
 6009: 1			;
 6010: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 6011: 1			;
 6012: 1			;              MAP0      MAP1                 MAP2         MAP3
 6013: 1			;
 6014: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 6015: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 6016: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 6017: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 6018: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 6019: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 6020: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 6021: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 6022: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 6023: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 6024: 1			;
 6025: 1			;          MAP0    MAP1          MAP2    MAP3
 6026: 1			;         _______________       _______________
 6027: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 6028: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6029: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 6030: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 6031: 1			;
 6032: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 6033: 1			;         | | | | | | | |       | | | | | | | |
 6034: 1			;        K K K K K K K K       K K K K K K K K
 6035: 1			;         O O O O O O O O       O O O O O O O O
 6036: 1			;         L L L L L L L L       L L L L L L L L
 6037: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 6038: 1			;
 6039: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 6040: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 6041: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 6042: 1			; van bitmaps van voor naar achter.
 6043: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 6044: 1			;
 6045: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 6046: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 6047: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 6048: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 6049: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 6050: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 6051: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 6052: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 6053: 1			; deze toetswaarde weer.
 6054: 1			;
 6055: 1			;
 6056: 1			;
 6057: 1			;******************************************************************************
 6058: 1
 6059: 1
 6060: 1			;******************************************************************************
 6061: 1			; key_init
 6062: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 6063: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 6064: 1			; input: niets
 6065: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 6066: 1			;         (map0,map1,map2,map3 =0)
 6067: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 6068: 1			; Deze routine vernietigt niets
 6069: 1			;******************************************************************************
 6070: 1
 6071: 1  1605	C0 E0		Key_init:       push    acc          ;bewaar registers
 6072: 1  1607	C0 D0		                push    psw
 6073: 1  1609	E8		                mov     a,r0
 6074: 1  160A	C0 E0		                push    acc
 6075: 1  160C	E9		                mov     a,r1
 6076: 1  160D	C0 E0		                push    acc
 6077: 1  160F	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 6078: 1  1611	79 09		                mov     r1,#9        ;9 bytes in de maps
 6079: 1  1613	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 6080: 1  1615	08		                inc     r0           ;volgende byte nemen
 6081: 1  1616	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 6082: 1  1618	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 6083: 1  161A	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 6084: 1  161C	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6085: 1  161F	D0 E0		                pop     acc          ;herstel registers
 6086: 1  1621	F9		                mov     r1,a
 6087: 1  1622	D0 E0		                pop     acc
 6088: 1  1624	F8		                mov     r0,a
 6089: 1  1625	D0 D0		                pop     psw
 6090: 1  1627	D0 E0		                pop     acc
 6091: 1  1629	22		                ret                    ;terug naar caller
 6092: 1			;******************************************************************************
 6093: 1
 6094: 1
 6095: 1			;******************************************************************************
 6096: 1			; toets_flank
 6097: 1			; Deze routine detecteert de indrukflank van een toets.
 6098: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 6099: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 6100: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 6101: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 6102: 1			; minder dan 20ms duurt.
 6103: 1			; input : niets
 6104: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 6105: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 6106: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 6107: 1			;
 6108: 1			; Deze routine vernietigt geen registers.
 6109: 1			;******************************************************************************
 6110: 1  162A	C0 E0		Toets_flank:    push    acc
 6111: 1  162C	C0 D0		                push    psw
 6112: 1  162E	12 16 48	                lcall   Keyscan
 6113: 1  1631	12 16 C4	                lcall   Keyedge
 6114: 1  1634	D0 D0		                pop     psw
 6115: 1  1636	D0 E0		                pop     acc
 6116: 1  1638	22		                ret
 6117: 1
 6118: 1			;******************************************************************************
 6119: 1			; toets_ingedrukt
 6120: 1			; Deze routine detecteert een ingedrukte toets.
 6121: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 6122: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 6123: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 6124: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 6125: 1			; minder dan 20ms duurt.
 6126: 1			; input : niets
 6127: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 6128: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 6129: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 6130: 1			;
 6131: 1			; Deze routine vernietigt geen registers.
 6132: 1			;******************************************************************************
 6133: 1  1639	C0 E0		Toets_ingedrukt:push    acc
 6134: 1  163B	C0 D0		                push    psw
 6135: 1  163D	12 16 48	                lcall   Keyscan
 6136: 1  1640	12 16 AB	                lcall   Keydown
 6137: 1  1643	D0 D0		                pop     psw
 6138: 1  1645	D0 E0		                pop     acc
 6139: 1  1647	22		                ret
 6140: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6141: 1
 6142: 1			;******************************************************************************
 6143: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6144: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 6145: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 6146: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 6147: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 6148: 1			; zoals aangegeven in het blokschema van het algorithme.
 6149: 1			; input : niets
 6150: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 6151: 1			;         ervan weergeven
 6152: 1			;
 6153: 1			; Deze routine vernietigt geen registers
 6154: 1			;******************************************************************************
 6155: 1
 6156: 1  1648	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 6157: 1  164A	C0 D0		                push    psw
 6158: 1  164C	C0 F0		                push    b
 6159: 1  164E	E8		                mov     a,r0
 6160: 1  164F	C0 E0		                push    acc
 6161: 1  1651	E9		                mov     a,r1
 6162: 1  1652	C0 E0		                push    acc
 6163: 1  1654	EA		                mov     a,r2
 6164: 1  1655	C0 E0		                push    acc
 6165: 1  1657	EE		                mov     a,r6
 6166: 1  1658	C0 E0		                push    acc
 6167: 1
 6168: 1  165A	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 6169: 1  165C	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 6170: 1  165F	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6171: 1  1661	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 6172: 1
 6173: 1  1663			Scanloop:
 6174: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 6175: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 6176: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 6177: 1			                mov     p0.0,c
 6178: 1			                mov     c,acc.1
 6179: 1			                mov     p0.1,c
 6180: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 6181: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 6182: 1			endif
 6183: 1
 6184: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 6185: 1  1663	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 6186: 1			                                      ;een rij-lijn
 6187: 1			endif
 6188: 1
 6189: 1			; Eerst de flipflops implementeren.
 6190: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 6191: 1			; te lezen van de kolomlijnen
 6192: 1  1665	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 6193: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 6194: 1  1666	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 6195: 1  1667	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 6196: 1  1668	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6197: 1  1669	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 6198: 1  166B	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 6199: 1  166C	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 6200: 1  166D	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 6201: 1  166F	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 6202: 1  1670	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 6203: 1  1671	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 6204: 1  1672	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 6205: 1  1673	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 6206: 1  1675	FA		                mov     r2,a          ;even bewaren in register
 6207: 1
 6208: 1
 6209: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 6210: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 6211: 1			                                      ;poort3 kolomlijnen
 6212: 1			endif
 6213: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 6214: 1  1676	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 6215: 1			                                     ;poort0 kolomlijnen
 6216: 1			endif
 6217: 1  1678	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 6218: 1  1679	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 6219: 1  167B	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 6220: 1  167C	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 6221: 1
 6222: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 6223: 1			; Nu volgen de logische functies uit het blokschema
 6224: 1
 6225: 1  167D	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 6226: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 6227: 1  167E	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 6228: 1  167F	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 6229: 1  1680	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 6230: 1  1681	54 0F		                anl     a,#00001111b ;low nibble houden
 6231: 1  1683	FA		                mov     r2,a         ;resultaat bewaren
 6232: 1  1684	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 6233: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 6234: 1  1685	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 6235: 1  1686	C4		                swap    a            ;map2 naar low nibble schuiven
 6236: 1  1687	5A		                anl     a,r2         ;combineren met output vorige and poort
 6237: 1  1688	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 6238: 1  168A	FA		                mov     r2,a         ;even bewaren
 6239: 1  168B	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 6240: 1  168C	54 F0		                anl     a,#11110000b ;map2 overhouden
 6241: 1  168E	4A		                orl     a,r2         ;en combineren met nieuwe map3
 6242: 1  168F	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 6243: 1
 6244: 1			; We gaan nu de volgende lijn scannen
 6245: 1
 6246: 1  1690	EE		                mov     a,r6         ;scanpatroon nemen
 6247: 1  1691	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 6248: 1  1692	FE		                mov     r6,a         ;scanpatroon bewaren
 6249: 1
 6250: 1  1693	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 6251: 1  1694	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 6252: 1  1695	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6253: 1  1698	D0 E0		                pop     acc          ;herstel registers
 6254: 1  169A	FE		                mov     r6,a
 6255: 1  169B	D0 E0		                pop     acc
 6256: 1  169D	FA		                mov     r2,a
 6257: 1  169E	D0 E0		                pop     acc
 6258: 1  16A0	F9		                mov     r1,a
 6259: 1  16A1	D0 E0		                pop     acc
 6260: 1  16A3	F8		                mov     r0,a
 6261: 1  16A4	D0 F0		                pop     b
 6262: 1  16A6	D0 D0		                pop     psw
 6263: 1  16A8	D0 E0		                pop     acc
 6264: 1  16AA	22		                ret                    ;terug naar caller
 6265: 1			;******************************************************************************
 6266: 1
 6267: 1
 6268: 1			;******************************************************************************
 6269: 1			; Keydown, Keyedge (twee entry's)
 6270: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6271: 1			;
 6272: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6273: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6274: 1			; Er zijn twee detectie-modes:
 6275: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6276: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6277: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6278: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6279: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6280: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6281: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6282: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6283: 1			;
 6284: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6285: 1			; (flankdetectie mode).
 6286: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6287: 1			; (toets ingedrukt mode).
 6288: 1			;
 6289: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6290: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6291: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6292: 1			; geldt voor een standaard 4x4 keypad.
 6293: 1			;
 6294: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6295: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6296: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6297: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6298: 1			;
 6299: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6300: 1			; output: key = gedetecteerde toets
 6301: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6302: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6303: 1			;
 6304: 1			; Deze routine vernietigt geen registers
 6305: 1			;******************************************************************************
 6306: 1
 6307: 1			;'Toets ingedrukt mode' enty van de routine
 6308: 1  16AB	C0 E0		Keydown:        push    acc            ;registers bewaren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111



 Line  I  Addr  Code            Source

 6309: 1  16AD	C0 D0		                push    psw
 6310: 1  16AF	C0 F0		                push    b
 6311: 1  16B1	C0 82		                push    dpl
 6312: 1  16B3	C0 83		                push    dph
 6313: 1  16B5	E8		                mov     a,r0
 6314: 1  16B6	C0 E0		                push    acc
 6315: 1  16B8	E9		                mov     a,r1
 6316: 1  16B9	C0 E0		                push    acc
 6317: 1  16BB	EA		                mov     a,r2
 6318: 1  16BC	C0 E0		                push    acc
 6319: 1  16BE	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6320: 1  16C0	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6321: 1  16C2	80 15		                sjmp    Key1           ;continue
 6322: 1
 6323: 1			;'Flankdetectiemode' entry van de routine
 6324: 1  16C4	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6325: 1  16C6	C0 D0		                push    psw
 6326: 1  16C8	C0 F0		                push    b
 6327: 1  16CA	C0 82		                push    dpl
 6328: 1  16CC	C0 83		                push    dph
 6329: 1  16CE	E8		                mov     a,r0
 6330: 1  16CF	C0 E0		                push    acc
 6331: 1  16D1	E9		                mov     a,r1
 6332: 1  16D2	C0 E0		                push    acc
 6333: 1  16D4	EA		                mov     a,r2
 6334: 1  16D5	C0 E0		                push    acc
 6335: 1  16D7	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6336: 1  16D9	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6337: 1  16DB	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6338: 1  16DD	E6		                mov     a,@r0         ;map entry ophalen
 6339: 1  16DE	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6340: 1  16E1	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6341: 1  16E3	C4		                swap    a             ;map1 en map0 omwisselen
 6342: 1  16E4	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6343: 1  16E6	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6344: 1  16E7	33		                rlc     a             ;kolombit testen
 6345: 1  16E8	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6346: 1  16EA	33		                rlc    a              ;nee, dan verder roteren
 6347: 1  16EB	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6348: 1  16ED	08		                inc     r0            ;rijpointer in maps verder zetten
 6349: 1  16EE	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6350: 1  16F0	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6351: 1
 6352: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6353: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6354: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6355: 1
 6356: 1  16F2	1A		toetsin:        dec     r2            ;rij-1
 6357: 1  16F3	19		                dec     r1            ;kolom-1
 6358: 1  16F4	EA		                mov     a,r2          ;neem rij-1
 6359: 1  16F5	23		                rl      a             ;(rij-1)x2
 6360: 1  16F6	23		                rl      a              ;(rij-1)x4
 6361: 1  16F7	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6362: 1  16F8	90 17 16	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6363: 1  16FB	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6364: 1  16FC	F5 38		                mov     key,a         ;stop toetscode in de variabele key

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112



 Line  I  Addr  Code            Source

 6365: 1  16FE	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6366: 1  1700	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6367: 1  1702	D0 E0		                pop     acc            ;herstellen registers
 6368: 1  1704	FA		                mov     r2,a
 6369: 1  1705	D0 E0		                pop     acc
 6370: 1  1707	F9		                mov     r1,a
 6371: 1  1708	D0 E0		                pop     acc
 6372: 1  170A	F8		                mov     r0,a
 6373: 1  170B	D0 83		                pop     dph
 6374: 1  170D	D0 82		                pop     dpl
 6375: 1  170F	D0 F0		                pop     b
 6376: 1  1711	D0 D0		                pop     psw
 6377: 1  1713	D0 E0		                pop     acc
 6378: 1  1715	22		                ret                    ;terug naar caller
 6379: 1			;******************************************************************************
 6380: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6381: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6382: 1
 6383: 1  1716	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6384: 1  1717	30		                db    '0'    ;kolom2@rij4 toets
 6385: 1  1718	23		                db    '#'    ;kolom3@rij4 toets
 6386: 1  1719	44		                db    'D'    ;kolom4@rij4 toets
 6387: 1
 6388: 1  171A	37		                db    '7'    ;kolom1@rij3 toets
 6389: 1  171B	38		                db    '8'    ;kolom2@rij3 toets
 6390: 1  171C	39		                db    '9'    ;kolom3@rij3 toets
 6391: 1  171D	43		                db    'C'    ;kolom4@rij3 toets
 6392: 1
 6393: 1  171E	34		                db    '4'    ;kolom1@rij2 toets
 6394: 1  171F	35		                db    '5'    ;kolom2@rij2 toets
 6395: 1  1720	36		                db    '6'    ;kolom3@rij2 toets
 6396: 1  1721	42		                db    'B'    ;kolom4@rij2 toets
 6397: 1
 6398: 1  1722	31		                db    '1'    ;kolom1@rij1 toets
 6399: 1  1723	32		                db    '2'    ;kolom2@rij1 toets
 6400: 1  1724	33		                db    '3'    ;kolom3@rij1 toets
 6401: 1  1725	41		                db    'A'    ;kolom4@rij1 toets
 6402: 1
 6403: 1			;******************************************************************************
 6404: 1			; switch_init
 6405: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6406: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6407: 1			; input : niets
 6408: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6409: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6410: 1			;
 6411: 1			; Deze routine vernietigt niets
 6412: 1			;******************************************************************************
 6413: 1
 6414: 1  1726	C0 E0		switch_init:    push    acc
 6415: 1  1728	C0 D0		                push    psw
 6416: 1  172A	C0 F0		                push    b
 6417: 1  172C	E8		                mov     a,r0         ;bewaar registers
 6418: 1  172D	C0 E0		                push    acc
 6419: 1
 6420: 1  172F	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113



 Line  I  Addr  Code            Source

 6421: 1  1731	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6422: 1  1734	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6423: 1  1736	08		                inc     r0           ;volgende byte nemen
 6424: 1  1737	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6425: 1  173A	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6426: 1  173C	C2 03		                clr     negvalid
 6427: 1  173E	C2 04		                clr     posvalid
 6428: 1
 6429: 1  1740	D0 E0		                pop     acc
 6430: 1  1742	F8		                mov     r0,a
 6431: 1  1743	D0 F0		                pop     b
 6432: 1  1745	D0 D0		                pop     psw
 6433: 1  1747	D0 E0		                pop     acc
 6434: 1  1749	22		                ret                   ;terug naar caller
 6435: 1
 6436: 1			;******************************************************************************
 6437: 1			; read_switch
 6438: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6439: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6440: 1			; Deze routine werkt volgens onderstaand blokschema.
 6441: 1			;
 6442: 1			;                                  ___                    ___
 6443: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6444: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6445: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6446: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6447: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6448: 1			;             |____|    |____|              |____|  ----o| 3 |
 6449: 1			;                |         |                   |      |  |   |
 6450: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6451: 1			;         _______*_________*___________________|       --|___|---- posedge
 6452: 1			;
 6453: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6454: 1			;                              (swvalid-flag)
 6455: 1			;            switch1   switch2    debounce      closed
 6456: 1			;
 6457: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6458: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6459: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6460: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6461: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6462: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6463: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6464: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6465: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6466: 1			; een detector voor positieve flanken (posedge).
 6467: 1			;
 6468: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6469: 1			;         bij aduc832v1.1 :
 6470: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6471: 1			;         bij aduc832v2.0 :
 6472: 1			;         als f0=0 dan: schakelaars op p0
 6473: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6474: 1			;
 6475: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6476: 1			;         geactualiseerd.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



 Line  I  Addr  Code            Source

 6477: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6478: 1			;                  schakelaars weergeeft
 6479: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6480: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6481: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6482: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6483: 1			;                  werd gedetecteerd op een schakelaar.
 6484: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6485: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6486: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6487: 1			;                  werd gedetecteerd op een schakelaar.
 6488: 1			;
 6489: 1			;
 6490: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6491: 1			; en flags te initialiseren.
 6492: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6493: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6494: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6495: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6496: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6497: 1			; bijhorende flag resetten.
 6498: 1			;
 6499: 1			; Deze routine vernietigt niets
 6500: 1			;******************************************************************************
 6501: 1  174A	C0 E0		read_switch:    push    acc            ;registers bewaren
 6502: 1  174C	C0 D0		                push    psw
 6503: 1  174E	C0 F0		                push    b
 6504: 1			;Flipflops uitvoeren is bytes doorschuiven
 6505: 1  1750	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6506: 1  1753	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6507: 1
 6508: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6509: 1			                clr      a
 6510: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6511: 1			                mov     acc.0,c
 6512: 1			                mov     c,p0.1
 6513: 1			                mov     acc.1,c
 6514: 1			                mov     b,a            ;even bewaren
 6515: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6516: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6517: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6518: 1			endif        ;einde aduc832_v1_1
 6519: 1
 6520: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6521: 1  1756	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6522: 1  1759	E5 80		                mov     a,p0           ;lees de schakelaars
 6523: 1  175B	80 04		                sjmp    lowlogic
 6524: 1  175D	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6525: 1  175F	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6526: 1			endif        ;einde aduc832_2_0
 6527: 1
 6528: 1  1761	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6529: 1  1762	F5 40		                mov     switch1,a      ;en sample opslaan
 6530: 1
 6531: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6532: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



 Line  I  Addr  Code            Source

 6533: 1  1764	E5 40		                mov     a,switch1      ;neem laatste sample
 6534: 1  1766	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6535: 1  1768	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6536: 1  176A	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6537: 1			;negatieve flankdetectie
 6538: 1  176C	E5 43		                mov     a,closed      ;neem 3de FF
 6539: 1  176E	F4		                cpl     a             ;complementeer
 6540: 1  176F	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6541: 1  1771	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6542: 1  1773	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6543: 1  1775	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6544: 1  1777	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6545: 1			;positieve flankdetectie
 6546: 1  1779	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6547: 1  177B	F4		                cpl     a             ;complementeer
 6548: 1  177C	55 43		                anl     a,closed      ;combineer met 3de FF
 6549: 1  177E	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6550: 1  1780	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6551: 1  1782	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6552: 1  1784	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6553: 1  1786	D0 D0		                pop     psw
 6554: 1  1788	D0 E0		                pop     acc
 6555: 1  178A	22		                ret
 6556: 1
 6557: 1			endif    ;einde van aduc_key
 6558: 1
 6559: 1
 6560:				end





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 150
ACC				  DATA	      E0	  69
ADCBUFFER			  CODE	    0130	 360
ADCCON1				  DATA	      EF	  72
ADCCON2				  DATA	      D8	  65
ADCCON3				  DATA	      F5	  78
ADCDATAH			  DATA	      DA	  67
ADCDATAL			  DATA	      D9	  66
ADCGAINH			  DATA	      F4	  77
ADCGAINL			  DATA	      F3	  76
ADCI				  BIT	      DF	 159
ADCOFSH				  DATA	      F2	  75
ADCOFSL				  DATA	      F1	  74
ADC_INIT			  CODE	    1549	5809
ADC_INIT1			  CODE	    1556	5815
ADC_SINGLE			  CODE	    155B	5854
ADC_SINGLE1			  CODE	    1567	5860
ADC_SINGLE2			  CODE	    1592	5886
ADC_SINGLE20			  CODE	    159C	5891
ADC_SINGLE21			  CODE	    15A4	5897
ADC_SINGLE3			  CODE	    15A7	5901
ADC_SINGLE30			  CODE	    15C7	5922
ADC_SINGLE31			  CODE	    15D1	5927
ADC_SINGLE4			  CODE	    15D9	5936
ADC_SINGLE40			  CODE	    15E5	5944
ADC_SINGLE41			  CODE	    15EF	5949
ADC_SINGLE42			  CODE	    15F5	5953
ADC_SINGLE43			  CODE	    15FD	5959
ADD16				  CODE	    0AA0	3161
ADD161				  CODE	    0AB4	3177
ADD32				  CODE	    0AF2	3258
ADD321				  CODE	    0B0C	3282
ADUC832_V2_0			  NUMBER    0001	 467
ADUC_ADC			  NUMBER    0001	 488
ADUC_I2C			  NUMBER    0001	 485
ADUC_KEY			  NUMBER    0001	 489
ADUC_LCD			  NUMBER    0001	 482
ADUC_MATH			  NUMBER    0001	 487
ADUC_SIO			  NUMBER    0001	 486
ASCBINTRANS			  CODE	    0750	2214
ASCBINTRANS1			  CODE	    0765	2225
ASCBINTRANS2			  CODE	    0764	2224
ASCBINTRANS3			  CODE	    0758	2218
ASCBINTRANS4			  CODE	    0761	2222
ASCCTR				  CODE	    0727	2160
ASCCTR1				  CODE	    072A	2161
ASCCTR2				  CODE	    072F	2163
ASCCTR3				  CODE	    0733	2166

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII1				  CODE	    0766	2236
ASCII2				  CODE	    076B	2250
ASCII21				  CODE	    077D	2259
ASCII4				  CODE	    0780	2273
ASCII41				  CODE	    078F	2280
B				  DATA	      F0	  73
BACKLIGHT			  BIT	      F6	 634
BACKSP				  NUMBER    0008	1859
BAR				  CODE	    014F	 397
BARCHARS			  CODE	    0410	1260
BAREINDE			  CODE	    0437	1303
BARLCD				  CODE	    03AB	1181
BARLCD1				  CODE	    03E6	1215
BARLCD2				  CODE	    03ED	1220
BARLCD3				  CODE	    03F6	1228
BARLCD4				  CODE	    03FB	1232
BARLCDE				  CODE	    0403	1237
BARLCD_1			  CODE	    03C6	1197
BATRANS				  CODE	    0742	2196
BATRANS1			  CODE	    0747	2198
BATRANS2			  CODE	    074B	2200
BCDHEX16			  CODE	    0805	2475
BCDHEX161			  CODE	    0813	2483
BCDHEX1611			  CODE	    081C	2487
BCDHEX1612			  CODE	    0826	2492
BCDHEX1613			  CODE	    082F	2496
BCDHEX162			  CODE	    087A	2550
BCDHEX8				  CODE	    0790	2366
BCDHEX81			  CODE	    079E	2374
BCDHEX811			  CODE	    07A7	2378
BCDHEX82			  CODE	    07C9	2402
BDELETE				  CODE	    0702	2126
BDELETE1			  CODE	    0710	2134
BDELETE2			  CODE	    0723	2145
BDELETE3			  CODE	    0714	2136
BEEP				  NUMBER    0007	1860
BLANK				  NUMBER    0020	1854
BPMFLAG				  BIT	      01	 195
BPMH				  NUMBER    005A	 205
BPML				  NUMBER    0059	 204
BUILD				  CODE	    0438	1335
BUILD1				  CODE	    0450	1377
BUILD2				  CODE	    045F	1384
BUILD3				  CODE	    0453	1378
BUILD_ADR			  CODE	    0446	1372
BUZZER				  BIT	      F7	 635
CAP2				  BIT	      C8	 136
CCONV				  BIT	      DD	 157
CFG832				  DATA	      AF	  38
CGRAM				  NUMBER    0040	 650
CHIPID				  DATA	      C2	  52
CLEARDISP			  NUMBER    0001	 640
CLOSED				  NUMBER    0043	 554
CMP16				  CODE	    1281	5192
CMP161				  CODE	    129E	5211
CMP162				  CODE	    12AA	5220

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CMP32				  CODE	    1322	5339
CMP321				  CODE	    134B	5366
CMP322				  CODE	    1357	5375
CNT2				  BIT	      C9	 137
CORDIC				  CODE	    13EB	5526
CORDIC0				  CODE	    1456	5591
CORDIC00			  CODE	    143C	5576
CORDIC000			  CODE	    140F	5550
CORDIC1				  CODE	    146A	5605
CORDIC2				  CODE	    149E	5655
CORDIC3				  CODE	    14A9	5662
CORDIC4				  CODE	    14CE	5696
CORDIC40			  CODE	    14D3	5700
CORDIC41			  CODE	    14EC	5716
CORDIC5				  CODE	    14F2	5722
CORDIC50			  CODE	    1504	5732
CORDIC51			  CODE	    151D	5747
CORDIC52			  CODE	    1528	5756
CORDIC5A			  CODE	    1502	5731
CORDIC5B			  CODE	    151B	5746
CORDIC_ATAN			  CODE	    152B	5762
CORDIC_ERROR			  CODE	    141F	5558
CORDIC_MIN90			  CODE	    1424	5562
CORDIC_NUL			  CODE	    1448	5582
CORDIC_PLUS90			  CODE	    1430	5569
CPHA				  BIT	      FA	 174
CPOL				  BIT	      FB	 175
CR				  NUMBER    000D	1857
CS0				  BIT	      D8	 152
CS1				  BIT	      D9	 153
CS2				  BIT	      DA	 154
CS3				  BIT	      DB	 155
CURSATHOM			  NUMBER    0002	 641
CURSOROFF			  NUMBER    000C	 646
CURSORONB			  NUMBER    000F	 647
CURSORONN			  NUMBER    000E	 648
CY				  BIT	      D7	 151
D0				  BIT	      ED	 161
D0EN				  BIT	      EB	 160
D1				  BIT	      EF	 163
D1EN				  BIT	      EE	 162
DAC0H				  DATA	      FA	  82
DAC0L				  DATA	      F9	  81
DAC1H				  DATA	      FC	  84
DAC1L				  DATA	      FB	  83
DACCON				  DATA	      FD	  85
DCON				  DATA	      E8	  70
DDRAM				  NUMBER    0080	 651
DEBOUNCE			  NUMBER    0042	 553
DELAY2MS			  CODE	    046D	1401
DELAY2MS1			  CODE	    0473	1404
DELAY60US			  CODE	    047E	1421
DELAY60US1			  CODE	    0490	1435
DELAY60US2			  CODE	    048E	1434
DIPSWITCH			  NUMBER    0001	 507
DISPCOUNT			  NUMBER    0050	 193

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DISPDPTR			  CODE	    0658	1968
DISPDPTRLCD			  CODE	    0272	 856
DISPFLAG			  BIT	      00	 194
DISPLAYOF			  NUMBER    0008	 645
DISPLAYON			  NUMBER    0001	 644
DIV16				  CODE	    0D67	3944
DIV160				  CODE	    0D75	3955
DIV161				  CODE	    0D93	3978
DIV162				  CODE	    0DA6	3994
DIV163				  CODE	    0DC2	4019
DIV164				  CODE	    0DD4	4037
DIV32				  CODE	    0E11	4108
DIV320				  CODE	    0E21	4121
DIV320A				  CODE	    0E2B	4132
DIV320B				  CODE	    0E49	4160
DIV320C				  CODE	    0E6E	4188
DIV322				  CODE	    0E93	4222
DIV323				  CODE	    0EDD	4298
DIV324				  CODE	    0F0F	4348
DIV8				  CODE	    0D24	3871
DIV81				  CODE	    0D3C	3887
DMA				  BIT	      DE	 158
DMAH				  DATA	      D3	  62
DMAL				  DATA	      D2	  61
DMAP				  DATA	      D4	  63
DPCON				  DATA	      A7	  34
DPH				  DATA	      83	  11
DPL				  DATA	      82	  10
DPP				  DATA	      84	  12
E				  BIT	      F1	 632
EA				  BIT	      AF	 111
EADC				  BIT	      AE	 110
EADRH				  DATA	      C7	  54
EADRL				  DATA	      C6	  53
ECON				  DATA	      B9	  46
EDATA1				  DATA	      BC	  47
EDATA2				  DATA	      BD	  48
EDATA3				  DATA	      BE	  49
EDATA4				  DATA	      BF	  50
ENDBUF				  NUMBER    007F	1866
ENTRYMODE			  NUMBER    0006	 643
ES				  BIT	      AC	 108
ET0				  BIT	      A9	 105
ET1				  BIT	      AB	 107
ET2				  BIT	      AD	 109
EX0				  BIT	      A8	 104
EX1				  BIT	      AA	 106
EXEN2				  BIT	      CB	 139
EXF2				  BIT	      CE	 142
F0				  BIT	      D5	 149
F1				  BIT	      D1	 145
FF				  NUMBER    000C	1856
FUNCTIONS			  NUMBER    0028	 649
GEMIDDELDE			  CODE	    0166	 418
HEXBCD16			  CODE	    0883	2586
HEXBCD161			  CODE	    0891	2593

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBCD16_U			  CODE	    0886	2587
HEXBCD8				  CODE	    07D2	2427
HEXBCD81			  CODE	    07DC	2432
HEXBCD82			  CODE	    07E1	2434
HEXBCD83			  CODE	    07EB	2440
HEXBUF2LCD			  CODE	    034E	1122
HEXBUF2LCD1			  CODE	    0372	1138
HEXBUF2LCDE			  CODE	    0389	1149
HEXBUFTXT			  CODE	    0397	1158
HOUR				  DATA	      A5	  32
HTHSEC				  DATA	      A2	  29
I2CADD				  DATA	      9B	  24
I2CCON				  DATA	      E8	  71
I2CDAT				  DATA	      9A	  23
I2CI				  BIT	      E8	 164
I2CINBYTEA1			  CODE	    04DA	1543
I2CINBYTEACK			  CODE	    04D3	1540
I2CINBYTEN1			  CODE	    04FB	1567
I2CINBYTENACK			  CODE	    04F4	1564
I2CINIT				  CODE	    0498	1485
I2CM				  BIT	      EB	 167
I2COUTBYTE			  CODE	    04B3	1517
I2COUTBYTE1			  CODE	    04BA	1520
I2CPCF8574			  NUMBER    0040	1476
I2CPCF8574A			  NUMBER    0070	1477
I2CRCVDATA			  CODE	    0555	1669
I2CRCVDATA1			  CODE	    0574	1687
I2CRCVDATA2			  CODE	    057D	1691
I2CRCVDATA3			  CODE	    0584	1696
I2CRCVERROR			  CODE	    0590	1704
I2CRS				  BIT	      EA	 166
I2CSENDDATA			  CODE	    0515	1607
I2CSENDDATA1			  CODE	    0534	1624
I2CSENDERROR			  CODE	    054A	1637
I2CSTART			  CODE	    04A1	1494
I2CSTOP				  CODE	    04AA	1503
I2CTX				  BIT	      E9	 165
IE				  DATA	      A8	  35
IE0				  BIT	      89	  87
IE1				  BIT	      8B	  89
IEIP2				  DATA	      A9	  36
INBUFA				  CODE	    06C7	2083
INBUFA1				  CODE	    06DE	2100
INBUFA2				  CODE	    06CD	2086
INBUFA3				  CODE	    06EB	2106
INBUFA4				  CODE	    06E4	2102
INBUFA5				  CODE	    06FE	2114
INBUFA6				  CODE	    06F4	2110
INBUFA7				  CODE	    06E6	2103
INBYTE				  CODE	    06A7	2051
INBYTE1				  CODE	    06C4	2063
INCHAR				  CODE	    069F	2035
INITLCD				  CODE	    01A2	 666
INITLCD1			  CODE	    01B3	 683
INITSIO				  CODE	    0605	1880
INITSIO1			  CODE	    060E	1884

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
INITSIOE			  CODE	    0624	1901
INT0				  BIT	      B2	 114
INT1				  BIT	      B3	 115
INTVAL				  DATA	      A6	  33
INT_ROUT			  CODE	    00CA	 300
IP				  DATA	      B8	  45
ISPI				  BIT	      FF	 179
IT0				  BIT	      88	  86
IT1				  BIT	      8A	  88
KEY				  NUMBER    0038	 540
KEY1				  CODE	    16D9	6336
KEY2				  CODE	    16E6	6343
KEYDOWN				  CODE	    16AB	6308
KEYEDGE				  CODE	    16C4	6324
KEYFLAGS			  NUMBER    0020	 515
KEYINIT1			  CODE	    1613	6079
KEYMAP				  NUMBER    0030	 534
KEYMODE				  BIT	      01	 519
KEYSCAN				  CODE	    1648	6156
KEYVALID			  BIT	      00	 517
KEY_INIT			  CODE	    1605	6071
KOLOMLOOP			  CODE	    16E8	6345
LCDBUZOFF			  CODE	    05F4	1825
LCDBUZON			  CODE	    05E7	1809
LCDLIGHTOFF			  CODE	    05DA	1793
LCDLIGHTON			  CODE	    05CD	1776
LCDPORT				  NUMBER    00F0	 631
LCDTOPORT			  CODE	    05B4	1750
LF				  NUMBER    000A	1858
LOOP				  CODE	    0084	 263
LOOPTILOOP			  CODE	    016F	 422
LOWLOGIC			  CODE	    1761	6528
LOWUPTR				  CODE	    0735	2180
LOWUPTR1			  CODE	    0738	2181
LOWUPTR2			  CODE	    0741	2185
LOWUPTR3			  CODE	    073D	2183
MAGSIG16			  CODE	    08F2	2698
MAGSIG16A			  CODE	    0903	2707
MAGSIG16ACC1			  CODE	    0912	2731
MAGSIG16ACC1A			  CODE	    0923	2740
MAGSIG16ACC1B			  CODE	    091E	2737
MAGSIG16ACC1C			  CODE	    092D	2748
MAGSIG16B			  CODE	    08FE	2704
MAGSIG16C			  CODE	    090D	2715
MAGSIG32			  CODE	    0932	2765
MAGSIG32A			  CODE	    0943	2774
MAGSIG32ACC1			  CODE	    095C	2810
MAGSIG32ACC1A			  CODE	    096D	2819
MAGSIG32ACC1B			  CODE	    0968	2816
MAGSIG32ACC1C			  CODE	    0981	2836
MAGSIG32B			  CODE	    093E	2771
MAGSIG32C			  CODE	    0957	2791
MAGSIG8				  CODE	    08BE	2639
MAGSIG8A			  CODE	    08CF	2648
MAGSIG8ACC1			  CODE	    08D8	2669
MAGSIG8ACC1A			  CODE	    08E9	2678

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MAGSIG8ACC1B			  CODE	    08E4	2675
MAGSIG8ACC1C			  CODE	    08ED	2682
MAGSIG8B			  CODE	    08CA	2645
MAGSIG8C			  CODE	    08D3	2652
MAP01PTR			  NUMBER    0030	 536
MAP23PTR			  NUMBER    0034	 539
MATRIX				  NUMBER    0001	 505
MCO				  BIT	      ED	 169
MDE				  BIT	      EE	 170
MDI				  BIT	      EC	 168
MDO				  BIT	      EF	 171
MIN				  DATA	      A4	  31
MUL16				  CODE	    0BDC	3530
MUL16ACC1			  CODE	    0C41	3619
MUL16_10			  CODE	    1000	4606
MUL16_100			  CODE	    1035	4654
MUL16_I_PI			  CODE	    0F9D	4510
MUL16_I_SQRT2			  CODE	    0FDF	4575
MUL16_PI			  CODE	    0F7C	4479
MUL16_SQRT2			  CODE	    0FBE	4542
MUL816				  CODE	    0CC9	3766
MULDIV				  CODE	    0F40	4421
MULDIV1				  CODE	    0F50	4433
NEGEDGE				  NUMBER    0044	 555
NEGVALID			  BIT	      03	 524
NOKEY				  CODE	    1700	6366
OUTBYTE				  CODE	    0644	1948
OUTBYTELCD			  CODE	    0261	 837
OUTC				  CODE	    030E	1043
OUTCHAR				  CODE	    0628	1915
OUTCHAR1			  CODE	    062A	1916
OUTCHARLCD			  CODE	    0200	 752
OUTCHARLCD1			  CODE	    0207	 755
OUTCHARLCD2			  CODE	    0211	 759
OUTCHARLCD2_0			  CODE	    020C	 757
OUTCHARLCD3			  CODE	    021A	 769
OUTCHARLCD4			  CODE	    0221	 773
OUTCHARLCD5			  CODE	    0228	 777
OUTCHARLCD6			  CODE	    022F	 781
OUTCHARLCD7			  CODE	    0236	 785
OUTCHARLCD8			  CODE	    023D	 793
OUTCHARLCD9			  CODE	    0242	 801
OUTCHARLCDE			  CODE	    0245	 802
OUTD				  CODE	    02D4	 965
OUTHNIBC			  CODE	    0324	1085
OUTHNIBD			  CODE	    02E4	1013
OUTMSGA				  CODE	    066B	1987
OUTMSGA1			  CODE	    0680	1998
OUTMSGA2			  CODE	    0673	1991
OUTMSGALCD			  CODE	    0285	 880
OUTMSGALCD1			  CODE	    028D	 887
OUTMSGALCDE			  CODE	    0298	 897
OUTNIB				  CODE	    0630	1929
OUTNIBLCD			  CODE	    024A	 816
OUTNIBLCD1			  CODE	    0255	 821
OUTNIBLCDE			  CODE	    0259	 823

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 123



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
OV				  BIT	      D2	 146
P				  BIT	      D0	 144
P0				  DATA	      80	   8
P1				  DATA	      90	  20
P2				  DATA	      A0	  27
P3				  DATA	      B0	  39
PADC				  BIT	      BE	 126
PCF8574A			  NUMBER    0001	1479
PCON				  DATA	      87	  13
PERIODCOUNTH			  NUMBER    0054	 199
PERIODCOUNTL			  NUMBER    0053	 198
PERIODH				  NUMBER    0058	 203
PERIODL				  NUMBER    0057	 202
PLLCON				  DATA	      D7	  64
PORTTOLCD			  CODE	    059B	1722
POSEDGE				  NUMBER    0045	 556
POSVALID			  BIT	      04	 526
PRE0				  BIT	      C4	 132
PRE1				  BIT	      C5	 133
PRE2				  BIT	      C6	 134
PRE3				  BIT	      C7	 135
PS				  BIT	      BC	 124
PSI				  BIT	      BF	 127
PSMCON				  DATA	      DF	  68
PSW				  DATA	      D0	  60
PT0				  BIT	      B9	 121
PT1				  BIT	      BB	 123
PT2				  BIT	      BD	 125
PWM0H				  DATA	      B2	  41
PWM0L				  DATA	      B1	  40
PWM1H				  DATA	      B4	  43
PWM1L				  DATA	      B3	  42
PWMCON				  DATA	      AE	  37
PX0				  BIT	      B8	 120
PX1				  BIT	      BA	 122
RAMLSB				  NUMBER    0070	 191
RAMMSB				  NUMBER    0071	 190
RB8				  BIT	      9A	  98
RCAP2H				  DATA	      CB	  57
RCAP2L				  DATA	      CA	  56
RCLK				  BIT	      CD	 141
RD				  BIT	      B7	 119
READ_PORT3			  CODE	    175D	6524
READ_SWITCH			  CODE	    174A	6501
READ_SWITCH1			  CODE	    1779	6546
READ_SWITCH2			  CODE	    1784	6552
REFH				  NUMBER    0056	 201
REFL				  NUMBER    0055	 200
REGTOLCD			  CODE	    02A1	 917
REGTOLCD1			  CODE	    02B2	 927
REGTOLCD2			  CODE	    02C0	 937
REN				  BIT	      9C	 100
RI				  BIT	      98	  96
RIJLOOP				  CODE	    16DB	6337
RS				  BIT	      F0	 633
RS0				  BIT	      D3	 147

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 124



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
RS1				  BIT	      D4	 148
RXD				  BIT	      B0	 112
SBUF				  DATA	      99	  22
SCANLOOP			  CODE	    1663	6173
SCON				  DATA	      98	  21
SCONV				  BIT	      DC	 156
SEC				  DATA	      A3	  30
SHIFTLEFT1			  CODE	    11AC	4969
SHIFTLEFT2			  CODE	    11B4	4975
SHIFTLEFT3			  CODE	    11B8	4977
SHIFTLEFT32			  CODE	    11A4	4965
SHIFTRIGHT1			  CODE	    1180	4924
SHIFTRIGHT2			  CODE	    1188	4930
SHIFTRIGHT3			  CODE	    118C	4932
SHIFTRIGHT32			  CODE	    1178	4920
SIGMAG16ACC0			  CODE	    09B8	2909
SIGMAG16ACC0A			  CODE	    09C7	2918
SIGMAG16ACC1			  CODE	    09D8	2944
SIGMAG16ACC1A			  CODE	    09E7	2953
SIGMAG16ACC1H			  CODE	    09F8	2979
SIGMAG16ACC1HA			  CODE	    0A07	2988
SIGMAG32ACC0			  CODE	    0A18	3016
SIGMAG32ACC0A			  CODE	    0A27	3025
SIGMAG32ACC1			  CODE	    0A42	3060
SIGMAG32ACC1A			  CODE	    0A51	3069
SIGMAG8ACC0			  CODE	    0986	2853
SIGMAG8ACC0A			  CODE	    0995	2861
SIGMAG8ACC1			  CODE	    099F	2881
SIGMAG8ACC1A			  CODE	    09AE	2889
SKIPBPM				  CODE	    00C8	 292
SKIPDISPRESET			  CODE	    00F9	 329
SKIPLCD				  CODE	    008C	 266
SKIPREF				  CODE	    0123	 346
SM0				  BIT	      9F	 103
SM1				  BIT	      9E	 102
SM2				  BIT	      9D	 101
SP				  DATA	      81	   9
SPE				  BIT	      FD	 177
SPH				  DATA	      B7	  44
SPICON				  DATA	      F8	  80
SPIDAT				  DATA	      F7	  79
SPIM				  BIT	      FC	 176
SPR0				  BIT	      F8	 172
SPR1				  BIT	      F9	 173
SQRT32				  CODE	    108B	4726
SQRT320				  CODE	    10B2	4748
SQRT321				  CODE	    10B7	4750
SQRT322				  CODE	    111A	4832
SQRT323				  CODE	    1120	4836
SQRT324				  CODE	    1143	4860
SQRT3240			  CODE	    113E	4858
SQRT325				  CODE	    1146	4862
STACK_INIT			  NUMBER    0090	 188
START				  CODE	    002E	 219
STARTBUFFER			  NUMBER    0080	 189
STRTBUF				  NUMBER    0054	1865

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 125



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SUB16				  CODE	    0B52	3368
SUB161				  CODE	    0B67	3385
SUB32				  CODE	    0BB9	3485
SUB321				  CODE	    0BD4	3510
SWINIT				  CODE	    1734	6422
SWITCH1				  NUMBER    0040	 551
SWITCH2				  NUMBER    0041	 552
SWITCHMAP			  NUMBER    0040	 550
SWITCH_INIT			  CODE	    1726	6414
SWVALID				  BIT	      02	 522
S_ADD16				  CODE	    0A6C	3106
S_ADD161			  CODE	    0A90	3132
S_ADD162			  CODE	    0A94	3134
S_ADD163			  CODE	    0A9A	3139
S_ADD32				  CODE	    0ABC	3199
S_ADD321			  CODE	    0AE4	3230
S_ADD322			  CODE	    0AE6	3231
S_ADD323			  CODE	    0AEC	3236
S_CMP16				  CODE	    1235	5118
S_CMP160			  CODE	    1248	5135
S_CMP161			  CODE	    1256	5145
S_CMP162			  CODE	    1264	5155
S_CMP163			  CODE	    1273	5167
S_CMP32				  CODE	    12B4	5242
S_CMP320			  CODE	    12CF	5262
S_CMP321			  CODE	    12E3	5276
S_CMP322			  CODE	    12F7	5290
S_CMP323			  CODE	    130E	5310
S_DIV16				  CODE	    0D44	3909
S_DIV161			  CODE	    0D52	3919
S_DIV32				  CODE	    0DEC	4071
S_DIV321			  CODE	    0DFC	4083
S_DIV8				  CODE	    0D12	3848
S_DIV81				  CODE	    0D23	3854
S_MAC16				  CODE	    0CF0	3808
S_MAC161			  CODE	    0D0C	3828
S_MUL16				  CODE	    0CA2	3710
S_MUL16ACC1			  CODE	    0CAF	3728
S_MUL816			  CODE	    0CBC	3747
S_MULDIV			  CODE	    0F1B	4377
S_MULDIV1			  CODE	    0F2B	4389
S_SHIFTLEFT1			  CODE	    120F	5071
S_SHIFTLEFT2			  CODE	    1217	5077
S_SHIFTLEFT3			  CODE	    121B	5082
S_SHIFTLEFT32			  CODE	    1207	5067
S_SHIFTRIGHT1			  CODE	    11D8	5017
S_SHIFTRIGHT2			  CODE	    11E0	5023
S_SHIFTRIGHT20			  CODE	    11EC	5029
S_SHIFTRIGHT3			  CODE	    11EE	5031
S_SHIFTRIGHT32			  CODE	    11D0	5013
S_SQRT32			  CODE	    1161	4893
S_SQRT321			  CODE	    116F	4901
S_SUB16				  CODE	    0B14	3304
S_SUB161			  CODE	    0B42	3339
S_SUB162			  CODE	    0B46	3341
S_SUB163			  CODE	    0B4C	3346

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 126



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_SUB32				  CODE	    0B6F	3407
S_SUB321			  CODE	    0BAB	3457
S_SUB322			  CODE	    0BAD	3458
S_SUB323			  CODE	    0BB3	3463
T0				  BIT	      B4	 116
T1				  BIT	      B5	 117
T2				  BIT	      90	  94
T2CON				  DATA	      C8	  55
T2EX				  BIT	      91	  95
T3CON				  DATA	      9E	  25
T3FD				  DATA	      9D	  26
TABLE_LU			  CODE	    1361	5402
TABLE_LU1			  CODE	    1386	5428
TABLE_LU2			  CODE	    1397	5441
TABLE_LU3			  CODE	    13D0	5484
TABLE_LU4			  CODE	    13E2	5497
TABLE_LU_10			  CODE	    138D	5433
TB8				  BIT	      9B	  99
TCLK				  BIT	      CC	 140
TCON				  DATA	      88	  14
TELLER				  NUMBER    0072	 192
TEXT				  CODE	    0193	 454
TF0				  BIT	      8D	  91
TF1				  BIT	      8F	  93
TF2				  BIT	      CF	 143
TH0				  DATA	      8C	  18
TH1				  DATA	      8D	  19
TH2				  DATA	      CD	  59
TI				  BIT	      99	  97
TIMECON				  DATA	      A1	  28
TL0				  DATA	      8A	  16
TL1				  DATA	      8B	  17
TL2				  DATA	      CC	  58
TMOD				  DATA	      89	  15
TODAC				  CODE	    0146	 385
TOETSIN				  CODE	    16F2	6356
TOETSTABEL			  CODE	    1716	6383
TOETS_FLANK			  CODE	    162A	6110
TOETS_INGEDRUKT			  CODE	    1639	6133
TR0				  BIT	      8C	  90
TR1				  BIT	      8E	  92
TR2				  BIT	      CA	 138
TXD				  BIT	      B1	 113
VORIGE_SAMPLEH			  NUMBER    0052	 197
VORIGE_SAMPLEL			  NUMBER    0051	 196
WCOL				  BIT	      FE	 178
WDCON				  DATA	      C0	  51
WDE				  BIT	      C1	 129
WDIR				  BIT	      C3	 131
WDS				  BIT	      C2	 130
WDWR				  BIT	      C0	 128
WISSEN				  CODE	    0601	1862
WR				  BIT	      B6	 118
XOFF				  NUMBER    0013	1855
XONXOFF				  CODE	    0689	2015
XONXOFF1			  CODE	    0695	2021

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 127



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
XONXOFF2			  CODE	    0690	2018
XONXOFF3			  CODE	    069A	2023
