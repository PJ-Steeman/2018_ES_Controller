
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\Hartslagmeter Gemiddelde.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\Hartslagmeter Gemiddelde.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Hartslagmeter\Hartslagmeter Gemiddelde.lst



 Line  I  Addr  Code            Source

    1:				;Anton Peeters & Pieter-Jan Steeman
    2:
    3:				$nolist
  181:
  182:		N      0090	stack_init	equ	090h
  183:		N      0001	tijd		equ	1
  184:		N      0080	startbuffer	equ	080h
  185:		N      0000			org	0000h
  186:
  187:	  0000	02 00 03			ljmp	start
  188:
  189:	  0003	75 81 90	start:		mov	sp,#stack_init		;init van de stack
  190:	  0006	7E 80				mov	r6,#startbuffer		;locatie van de start van de barrel
  191:	  0008	78 01				mov	r0,#1			;voor lcd init
  192:	  000A	12 00 AD			lcall	initlcd
  193:	  000D	12 04 D8			lcall	lcdlighton
  194:
  195:	  0010	12 14 54			lcall 	adc_init
  196:	  0013	75 FD 1D			mov	daccon,#00011101b
  197:
  198:	  0016	90 03 1B			mov	dptr,#barchars
  199:	  0019	12 03 43			lcall	build
  200:
  201:	  001C	12 00 2D	infloop:	lcall	adcbuffer		;adc en buffer toewijzing
  202:	  001F	12 00 80			lcall	gemiddelde
  203:	  0022	12 00 43			lcall	bar			;zet de waardes om naar een barchart
  204:	  0025	90 00 01			mov	dptr,#tijd		;zet de gewenste delay in de dptr
  205:	  0028	12 00 5E			lcall	wait_sel_ms		;wacht het gekozen aantal miliseconden
  206:	  002B	80 EF				sjmp	infloop			;oneindige lus
  207:
  208:	  002D	78 27		adcbuffer:	mov	r0,#00100111b		;initialiseer de nodige waardes voor een 12bit signa
				al
  209:	  002F	12 14 66			lcall	adc_single
  210:	  0032	E8				mov	a,r0			;zet ingelezen waardes in r2 en r3(lsb en msb)
  211:	  0033	FA				mov	r2,a
  212:	  0034	E9				mov	a,r1
  213:	  0035	FB				mov	r3,a
  214:	  0036	EE				mov	a,r6
  215:	  0037	F8				mov	r0,a
  216:	  0038	EA				mov	a,r2
  217:	  0039	F6				mov	@r0,a			;zet lsb in barrel
  218:	  003A	08				inc	r0
  219:	  003B	EB				mov	a,r3

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  220:	  003C	F6				mov	@r0,a			;zet msb in barrel
  221:	  003D	08				inc	r0
  222:	  003E	E8				mov	a,r0
  223:	  003F	54 8F				anl	a,#08fh			;indien buiten barrelregister zou gaan -> terug naar
				 onder
  224:	  0041	FE				mov	r6,a
  225:	  0042	22				ret
  226:
  227:	  0043	A9 71		bar:		mov	r1,071h			;gemiddelde msb in r1
  228:	  0045	89 FA				mov	dac0h,r1		;gemiddelde msb naar DAC
  229:	  0047	A8 70				mov	r0,070h			;gemiddelde lsb in r0
  230:	  0049	88 F9				mov	dac0l,r0		;gemiddelde lsb naar DAC
  231:	  004B	7D 00				mov	r5,#0
  232:	  004D	7C 69				mov	r4,#105			;nodig voor div16 (4096/40)
  233:	  004F	12 0C 72			lcall	div16			;quotient terug in r0
  234:	  0052	E8				mov	a,r0
  235:						;lcall	outbytelcd
  236:	  0053	FA				mov	r2,a			;zet de waarde om in bars
  237:	  0054	78 28				mov	r0,#40
  238:	  0056	74 40				mov	a,#40h
  239:	  0058	8A F0				mov	b,r2
  240:	  005A	12 02 B6			lcall	barlcd
  241:	  005D	22				ret
  242:
  243:	  005E	74 00		wait_sel_ms:	mov	a,#0
  244:	  0060	C3				clr 	c
  245:	  0061	95 82				subb 	a,dpl
  246:	  0063	F5 82				mov	dpl,a
  247:	  0065	74 00				mov	a,#0
  248:	  0067	95 83				subb	a,dph
  249:	  0069	F5 83				mov	dph,a
  250:	  006B	E4		wait_1ms:	clr	a
  251:	  006C	A3				inc	dptr
  252:	  006D	74 C7				mov	a,#199
  253:	  006F	F8		delay:		mov	r0,a
  254:	  0070	E8				mov	a,r0
  255:	  0071	F8				mov	r0,a
  256:	  0072	E8				mov	a,r0
  257:	  0073	94 01				subb	a,#1
  258:	  0075	70 F8				jnz	delay
  259:	  0077	E5 82				mov	a,dpl
  260:	  0079	70 F0				jnz	wait_1ms
  261:	  007B	E5 83				mov	a,dph
  262:	  007D	70 EC				jnz	wait_1ms
  263:	  007F	22				ret
  264:
  265:	  0080	7F 80		gemiddelde:	mov	r7,#startbuffer		;start van de barrel in r7
  266:	  0082	75 72 08			mov	072h,#8			;looptiloop init
  267:	  0085	79 00				mov	r1,#0
  268:	  0087	78 00				mov	r0,#0
  269:	  0089	E9		looptiloop:	mov	a,r1
  270:	  008A	FB				mov	r3,a
  271:	  008B	EF				mov	a,r7
  272:	  008C	F9				mov	r1,a
  273:	  008D	E7				mov	a,@r1
  274:	  008E	FC				mov	r4,a			;lsb in r4

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  275:	  008F	09				inc	r1
  276:	  0090	E7				mov	a,@r1			;msb in r5
  277:	  0091	FD				mov	r5,a
  278:	  0092	09				inc	r1
  279:	  0093	E9				mov	a,r1
  280:	  0094	FF				mov	r7,a
  281:	  0095	EB				mov	a,r3
  282:	  0096	F9				mov	r1,a
  283:	  0097	12 09 AB			lcall	add16			;16 bit opteller
  284:	  009A	E5 72				mov	a,072h
  285:	  009C	14				dec	a
  286:	  009D	F5 72				mov	072h,a
  287:	  009F	70 E8				jnz	looptiloop
  288:	  00A1	7D 00				mov	r5,#0
  289:	  00A3	7C 08				mov	r4,#8
  290:	  00A5	12 0C 72			lcall	div16
  291:	  00A8	88 70				mov	070h,r0			;lsb in RAM
  292:	  00AA	89 71				mov	071h,r1			;msb in RAM
  293:	  00AC	22				ret
  294:
  295:				$include (c:/aduc800_mideA.inc)
  296: 1			;******************************************************************************
  297: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  298: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  299: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  300: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  301: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  302: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  303: 1			;******************************************************************************
  304: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  305: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  306: 1			;******************************************************************************
  307: 1
  308: 1
  309: 1			;******************************************************************************
  310: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  311: 1			; hebben voor onze toepassing. Door een module te definieren via het
  312: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige
  313: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  314: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  315: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  316: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  317: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  318: 1			; definities.
  319: 1			;******************************************************************************
  320: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  321: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  322: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  323: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  324: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  325: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  326: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  327: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  328: 1
  329: 1			ifdef    aduc_key
  330: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  331: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  332: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  333: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  334: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  335: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  336: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  337: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  338: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  339: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  340: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  341: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  342: 1			;definities wel gemaakt worden.
  343: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  344: 1			                            ;anders commentaar van maken!
  345: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  346: 1			                            ;gelezen, anders commentaar van maken!
  347: 1			;******************************************************************************
  348: 1			;Declaraties van de flags voor de aduc_key driver.
  349: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  350: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  351: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  352: 1			;switch_init en read_switch.
  353: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  354: 1			                                ;bereik = 20h-2fh!
  355: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  356: 1			                                   ;een geldige waarde bevat
  357: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  358: 1			                                   ;die de detectie mode aangeeft
  359: 1			;declaratie van de read_switch flags
  360: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  361: 1			                                   ;ontdenderde schakelaars zijn
  362: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  363: 1			                                   ;flanken zijn
  364: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  365: 1			                                   ;flanken zijn
  366: 1			ifdef    matrix        ;matrix keyboard
  367: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  368: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord
  369: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  370: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  371: 1			;toepassing.
  372: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  373: 1			                                ;geheugenbuffer
  374: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  375: 1			                                ;debounce en de flankdetectie samples stockeren
  376: 1			                                ;de eerste 4 bytes dienen voor debouncing
  377: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  378: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  379: 1			                                ;toetswaarde aangeeft
  380: 1			                                ;bij een geldige keyvalid flag ('1')
  381: 1			endif    ;einde matrix keyboard
  382: 1
  383: 1			ifdef    dipswitch
  384: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  385: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  386: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  387: 1			;toepassing
  388: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  389: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  390: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  391: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  392: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  393: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  394: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  395: 1			endif    ;einde dipswitch
  396: 1			;******************************************************************************
  397: 1			endif    ;einde aduc_key
  398: 1
  399: 1
  400: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  401: 1
  402: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  403: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  404: 1			endif                               ;dus doen we dit hier nog eens!
  405: 1			;******************************************************************************
  406: 1
  407: 1			;******************************************************************************
  408: 1			;
  409: 1			; ADuc_lcd.inc
  410: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  411: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  412: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  413: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  414: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  415: 1			; het plaatsen van de cursor op een correcte plaats).
  416: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  417: 1			; display gebruiken.
  418: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  419: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  420: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  421: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  422: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  423: 1			;
  424: 1			; Versie ADuC832v1.1:
  425: 1			; Hier is het LCD verbonden met pinnen van poort0
  426: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  427: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  428: 1			;
  429: 1			; Versie ADuC832v2.2:
  430: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  431: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  432: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  433: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  434: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  435: 1			;
  436: 1			;
  437: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  438: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  439: 1			;  aduclcd0.inc
  440: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  441: 1			;  aduclcd1.inc
  442: 1			;    -00dh en 00ah worden door outchar verwerkt

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  443: 1			;    -bij de init wordt het display anders opgestart
  444: 1			;
  445: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  446: 1			;  van gebruik en uitgebreid  met :
  447: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  448: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  449: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  450: 1			;    debug doeleinden
  451: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  452: 1			;    user codes aan te maken
  453: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  454: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  455: 1			;
  456: 1			; Beschikbare routines:
  457: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  458: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  459: 1			; build_adr, delay2ms, delay60us
  460: 1			;******************************************************************************
  461: 1
  462: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  463: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  464: 1			e             bit    lcdport.2            ;enable
  465: 1			rs            bit    lcdport.3            ;register select
  466: 1			endif    ;einde aduc832_v1_1
  467: 1
  468: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  469: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  470: 1	B	 F1	e             bit    lcdport.1            ;enable
  471: 1	B	 F0	rs            bit    lcdport.0            ;register select
  472: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  473: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  474: 1			endif    ;einde aduc832_v2_0
  475: 1
  476: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  477: 1			;het uitvoeren van de overeenkomstige commando's.
  478: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  479: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  480: 1
  481: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  482: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  483: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  484: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  485: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  486: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  487: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  488: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  489: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  490: 1
  491: 1			;******************************************************************************
  492: 1			;
  493: 1			; initlcd
  494: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  495: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  496: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  497: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  498: 1			; Na initialisering wordt het scherm leeg gemaakt.

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  499: 1			;
  500: 1			; registergebruik: geen
  501: 1			;
  502: 1			;******************************************************************************
  503: 1
  504: 1  00AD	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  505: 1  00AF	C0 D0		              push   psw
  506: 1  00B1	C0 F0		              push   b
  507: 1			ifdef  aduc832_v1_1
  508: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  509: 1			                                   ;let op:twee laagste bits worden
  510: 1			                                   ;niet gebruikt
  511: 1			endif
  512: 1
  513: 1			ifdef    aduc832_v2_0
  514: 1  00B3	12 03 A3	              lcall  i2cinit              ;LCD via een I2C bus
  515: 1  00B6	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  516: 1			                                          ;buzzer en backlight  op 1 gezet
  517: 1  00B9	12 04 A6	              lcall  porttolcd            ;data uit b naar het scherm
  518: 1			endif
  519: 1
  520: 1  00BC	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  521: 1  00BE	12 03 78	initlcd1:     lcall  delay2ms
  522: 1  00C1	D5 E0 FA	              djnz   acc,initlcd1
  523: 1  00C4	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  524: 1  00C6	12 02 2F	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  525: 1  00C9	12 03 78	              lcall  delay2ms      ;om het display altijd opgestart
  526: 1  00CC	74 30		              mov    a,#00110000b  ;te krijgen.
  527: 1  00CE	12 02 2F	              lcall  outhnibc
  528: 1  00D1	12 03 78	              lcall  delay2ms
  529: 1  00D4	74 30		              mov    a,#00110000b
  530: 1  00D6	12 02 2F	              lcall  outhnibc
  531: 1  00D9	12 03 78	              lcall  delay2ms
  532: 1  00DC	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  533: 1  00DE	12 02 2F	              lcall  outhnibc      ;hoge nibble naar het controleregister
  534: 1  00E1	12 03 78	              lcall  delay2ms      ;niet nodig volgens datasheet
  535: 1  00E4	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  536: 1  00E6	12 02 19	              lcall  outc          ;naar display
  537: 1  00E9	12 03 78	              lcall  delay2ms      ;is iets te lang volgens datasheet
  538: 1  00EC	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  539: 1  00EE	12 02 19	              lcall  outc
  540: 1  00F1	12 03 78	              lcall  delay2ms      ;ook deze delay is iets te lang
  541: 1  00F4	74 01		              mov    a,#displayon  ;clear display and home cursor
  542: 1  00F6	12 02 19	              lcall  outc
  543: 1  00F9	12 03 78	              lcall  delay2ms      ;deze wachttijd is bijna juist
  544: 1  00FC	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  545: 1  00FE	12 02 19	              lcall  outc
  546: 1  0101	12 03 78	              lcall  delay2ms      ;wachten weer veel te lang
  547: 1  0104	D0 F0		              pop    b
  548: 1  0106	D0 D0		              pop    psw           ;registers terug in orde zetten
  549: 1  0108	D0 E0		              pop    acc
  550: 1  010A	22		              ret                  ;einde van de initialisatie
  551: 1
  552: 1			;******************************************************************************
  553: 1			;
  554: 1			; outcharlcd

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  555: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  556: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  557: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  558: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  559: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  560: 1			; De controlekarakters komen overeen met volgende acties:
  561: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  562: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  563: 1			;              (line feed+ carriage return!)
  564: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  565: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  566: 1			;      011h   =cursor on, blink mode
  567: 1			;      012h   =cursor on, no blink mode
  568: 1			;      013h   =cursor off
  569: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  570: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  571: 1			;              van het LCD
  572: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  573: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  574: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  575: 1			; positie 6 (C5H-80H=45H)
  576: 1			;
  577: 1			; Deze routine vernietigt geen registers
  578: 1			;
  579: 1			;******************************************************************************
  580: 1
  581: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  582: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  583: 1			; dataregister van het scherm.
  584: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  585: 1			; controlebyte doorsturen naar het LCD.
  586: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  587: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  588: 1			; naar de LCD sturen.
  589: 1
  590: 1  010B	C0 E0		outcharlcd:   push   acc           ;registers op stack
  591: 1  010D	C0 D0		              push   psw
  592: 1  010F	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres
  593: 1  0112	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  594: 1  0114	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  595: 1  0117	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  596: 1  0119	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  597: 1  011C	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  598: 1
  599: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  600: 1			; Als het een commando is, moeten we het uitvoeren.
  601: 1			; Indien niet, gewoon terug zonder actie!
  602: 1
  603: 1  011E	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  604: 1  0121	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  605: 1  0123	80 28		              sjmp   outcharlcd9          ;afsluiten
  606: 1
  607: 1  0125	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  608: 1  0128	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  609: 1  012A	80 21		              sjmp   outcharlcd9
  610: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  611: 1  012C	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  612: 1  012F	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  613: 1  0131	80 1A		              sjmp   outcharlcd9
  614: 1
  615: 1  0133	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  616: 1  0136	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  617: 1  0138	80 13		              sjmp   outcharlcd9
  618: 1
  619: 1  013A	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  620: 1  013D	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  621: 1  013F	80 0C		              sjmp   outcharlcd9
  622: 1
  623: 1  0141	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  624: 1  0144	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  625: 1  0146	80 05		              sjmp   outcharlcd9
  626: 1
  627: 1
  628: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  629: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  630: 1
  631: 1  0148	12 01 DF	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  632: 1  014B	80 03		              sjmp   outcharlcde   ;einde routine
  633: 1
  634: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  635: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  636: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  637: 1			; op dat adres te zetten.
  638: 1
  639: 1  014D	12 02 19	outcharlcd9:  lcall  outc          ;klaar
  640: 1  0150	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  641: 1  0152	D0 E0		              pop    acc
  642: 1  0154	22		              ret
  643: 1
  644: 1			;******************************************************************************
  645: 1			;
  646: 1			; outniblcd
  647: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  648: 1			; op het lcd scherm.
  649: 1			;
  650: 1			; de routine vernietigt geen registers
  651: 1			;
  652: 1			;******************************************************************************
  653: 1
  654: 1  0155	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  655: 1  0157	C0 D0		              push   psw
  656: 1  0159	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  657: 1  015B	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  658: 1  015D	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  659: 1  0160	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  660: 1  0162	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  661: 1  0164	12 01 DF	outniblcde:   lcall  outd          ;naar het scherm
  662: 1  0167	D0 D0		              pop    psw
  663: 1  0169	D0 E0		              pop    acc
  664: 1  016B	22		              ret
  665: 1
  666: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  667: 1			;
  668: 1			; outbytelcd
  669: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  670: 1			;
  671: 1			; de routine vernietigt geen registers
  672: 1			;
  673: 1			;******************************************************************************
  674: 1
  675: 1  016C	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  676: 1  016E	C0 D0		              push   psw
  677: 1  0170	C4		              swap   a             ;bitjes omruilen
  678: 1  0171	12 01 55	              lcall  outniblcd
  679: 1  0174	C4		              swap   a             ;nog eens
  680: 1  0175	12 01 55	              lcall  outniblcd
  681: 1  0178	D0 D0		              pop    psw
  682: 1  017A	D0 E0		              pop    acc
  683: 1  017C	22		              ret
  684: 1
  685: 1			;******************************************************************************
  686: 1			;
  687: 1			; dispdptrlcd
  688: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  689: 1			;
  690: 1			; de routine vernietigt geen registers
  691: 1			;
  692: 1			;******************************************************************************
  693: 1
  694: 1  017D	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  695: 1  017F	C0 D0		              push   psw
  696: 1  0181	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  697: 1  0183	12 01 6C	              lcall  outbytelcd
  698: 1  0186	E5 82		              mov    a,dpl         ;dan het lage deel
  699: 1  0188	12 01 6C	              lcall  outbytelcd
  700: 1  018B	D0 D0		              pop    psw
  701: 1  018D	D0 E0		              pop    acc
  702: 1  018F	22		              ret
  703: 1
  704: 1			;******************************************************************************
  705: 1			;
  706: 1			; outmsgalcd
  707: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  708: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  709: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  710: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  711: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  712: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  713: 1			;
  714: 1			; de routine vernietigt geen registers
  715: 1			;
  716: 1			;******************************************************************************
  717: 1
  718: 1  0190	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  719: 1  0192	C0 D0		              push   psw
  720: 1  0194	C0 83		              push   dph           ;ook de data pointer
  721: 1  0196	C0 82		              push   dpl
  722: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  723: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  724: 1
  725: 1  0198	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  726: 1  0199	93		              movc   a,@a+dptr     ;waarde lezen
  727: 1  019A	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  728: 1
  729: 1			; de code is niet 0 dus versturen met outchar
  730: 1
  731: 1  019C	12 01 0B	              lcall  outcharlcd    ;weg er mee
  732: 1  019F	A3		              inc    dptr          ;naar volgende ascii code wijzen
  733: 1  01A0	02 01 98	              ljmp   outmsgalcd1   ;lus sluiten
  734: 1
  735: 1  01A3	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  736: 1  01A5	D0 83		              pop    dph
  737: 1  01A7	D0 D0		              pop    psw
  738: 1  01A9	D0 E0		              pop    acc
  739: 1  01AB	22		              ret
  740: 1
  741: 1			;******************************************************************************
  742: 1			;
  743: 1			; regtolcd
  744: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  745: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  746: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  747: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  748: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  749: 1			;
  750: 1			; de routine vernietigt geen registers
  751: 1			;
  752: 1			;******************************************************************************
  753: 1
  754: 1
  755: 1  01AC	C0 E0		regtolcd:     push   acc           ;registers op de stack
  756: 1  01AE	C0 D0		              push   psw
  757: 1  01B0	E8		              mov    a,r0
  758: 1  01B1	C0 E0		              push   acc
  759: 1  01B3	E9		              mov    a,r1
  760: 1  01B4	C0 E0		              push   acc
  761: 1  01B6	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  762: 1  01B8	12 01 0B	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  763: 1			                                   ;plaats
  764: 1  01BB	79 00		              mov    r1,#000h      ;werkt als loopcounter
  765: 1  01BD	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  766: 1  01BE	12 01 0B	              lcall  outcharlcd    ;weg er mee
  767: 1  01C1	08		              inc    r0
  768: 1  01C2	09		              inc    r1
  769: 1  01C3	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  770: 1			                                          ;nieuwe lijn genomen worden
  771: 1  01C6	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  772: 1  01C8	12 01 0B	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  773: 1			                                   ;plaats
  774: 1
  775: 1  01CB	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  776: 1  01CC	12 01 0B	              lcall  outcharlcd    ;weg er mee
  777: 1  01CF	08		              inc    r0
  778: 1  01D0	09		              inc    r1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  779: 1  01D1	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  780: 1  01D4	D0 E0		              pop    acc
  781: 1  01D6	F9		              mov    r1,a
  782: 1  01D7	D0 E0		              pop    acc
  783: 1  01D9	F8		              mov    r0,a
  784: 1  01DA	D0 D0		              pop    psw           ;registers herstellen
  785: 1  01DC	D0 E0		              pop    acc
  786: 1  01DE	22		              ret
  787: 1
  788: 1			;******************************************************************************
  789: 1			;
  790: 1			; outd
  791: 1			; Is een routine die naar het data register van het display een
  792: 1			; volledige byte stuurt.
  793: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  794: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  795: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  796: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  797: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  798: 1			;
  799: 1			; De routine vernietigt geen registers.
  800: 1			;
  801: 1			;******************************************************************************
  802: 1
  803: 1  01DF	C0 E0		outd:         push   acc           ;registers op stack zetten
  804: 1  01E1	C0 D0		              push   psw
  805: 1  01E3	12 01 EF	              lcall  outhnibd      ;hoogste vier bits verzenden
  806: 1			ifdef     aduc832_v1_1
  807: 1			              lcall  delay60us     ;niet echt nodig
  808: 1			endif
  809: 1  01E6	C4		              swap   a             ;bitjes omruilen
  810: 1  01E7	12 01 EF	              lcall  outhnibd      ;naar het scherm sturen
  811: 1
  812: 1			ifdef    aduc832_v1_1
  813: 1			              lcall  delay60us     ;altijd goed
  814: 1			endif
  815: 1
  816: 1  01EA	D0 D0		              pop    psw           ;registers terug herstellen
  817: 1  01EC	D0 E0		              pop    acc
  818: 1  01EE	22		              ret
  819: 1
  820: 1			;******************************************************************************
  821: 1			;
  822: 1			; outhnibd
  823: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  824: 1			; lcd scherm.
  825: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  826: 1			; de routine vernietigt geen registers.
  827: 1			;
  828: 1			;******************************************************************************
  829: 1			ifdef     aduc832_v1_1
  830: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  831: 1			              push   psw
  832: 1			              setb   rs            ;controle lijn in orde
  833: 1			              clr    e             ;deselectie display
  834: 1			              mov     c,acc.7      ;4 meest beduidende bits naar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  835: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  836: 1			              mov     c,acc.6      ;afblijven!
  837: 1			              mov     lcdport.6,c
  838: 1			              mov     c,acc.5
  839: 1			              mov     lcdport.5,c
  840: 1			              mov     c,acc.4
  841: 1			              mov     lcdport.4,c
  842: 1			              setb   e             ;display enabelen
  843: 1			              nop                  ;450ns is normaal gezien voldoende
  844: 1			              clr    e             ;display deselecteren
  845: 1			              pop    psw           ;registers herstellen
  846: 1			              pop    acc
  847: 1			              ret
  848: 1			endif
  849: 1
  850: 1			ifdef    aduc832_v2_0
  851: 1  01EF	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  852: 1  01F1	C0 D0		              push   psw
  853: 1  01F3	C0 F0		              push   b             ;werkregister
  854: 1  01F5	12 04 BF	              lcall  lcdtoport     ;lees de expander naar b register
  855: 1  01F8	D2 F0		              setb   rs            ;controle lijn in orde
  856: 1  01FA	C2 F1		              clr    e             ;deselectie display
  857: 1  01FC	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  858: 1  01FE	03		              rr     a             ;bits op juiste plaats zetten
  859: 1  01FF	03		              rr     a             ;voor b reg
  860: 1  0200	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  861: 1  0203	42 F0		              orl    b,a           ;bij elkaar voegen
  862: 1  0205	12 04 A6	              lcall  porttolcd     ;naar expander
  863: 1  0208	D2 F1		              setb   e             ;display enabelen
  864: 1  020A	12 04 A6	              lcall  porttolcd
  865: 1  020D	C2 F1		              clr    e             ;display deselecteren
  866: 1  020F	12 04 A6	              lcall  porttolcd
  867: 1  0212	D0 F0		              pop    b
  868: 1  0214	D0 D0		              pop    psw           ;registers herstellen
  869: 1  0216	D0 E0		              pop    acc
  870: 1  0218	22		              ret
  871: 1			endif
  872: 1			;******************************************************************************
  873: 1			;
  874: 1			; outc
  875: 1			; Is een routine die naar het controleregister van het display een
  876: 1			; volledige byte (commando) stuurt.
  877: 1			; De routine vernietigt geen registers.
  878: 1			;
  879: 1			;******************************************************************************
  880: 1
  881: 1  0219	C0 E0		outc:         push   acc           ;registers op stack zetten
  882: 1  021B	C0 D0		              push   psw
  883: 1  021D	12 02 2F	              lcall  outhnibc      ;hoogste vier bits verzenden
  884: 1  0220	12 03 78	              lcall  delay2ms      ;niet echt nodig
  885: 1  0223	C4		              swap   a             ;bitjes omruilen
  886: 1  0224	12 02 2F	              lcall  outhnibc      ;naar het scherm sturen
  887: 1  0227	12 03 78	              lcall  delay2ms      ;altijd goed voor traagste commando
  888: 1  022A	D0 D0		              pop    psw           ;registers terug herstellen
  889: 1  022C	D0 E0		              pop    acc
  890: 1  022E	22		              ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  891: 1
  892: 1			;******************************************************************************
  893: 1			;
  894: 1			; outhnibc
  895: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  896: 1			; het lcd scherm.
  897: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  898: 1			; de routine vernietigt geen registers.
  899: 1			;
  900: 1			;******************************************************************************
  901: 1			ifdef     aduc832_v1_1
  902: 1			outhnibc:     push   acc           ;registers op stack plaatsen
  903: 1			              push   psw
  904: 1			              clr    rs            ;controle lijn in orde
  905: 1			              clr    e             ;deselectie display
  906: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  907: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  908: 1			              mov     c,acc.6      ;afblijven!
  909: 1			              mov     lcdport.6,c
  910: 1			              mov     c,acc.5
  911: 1			              mov     lcdport.5,c
  912: 1			              mov     c,acc.4
  913: 1			              mov     lcdport.4,c
  914: 1			              setb   e             ;display enabelen
  915: 1			              nop                  ;450ns is normaal gezien voldoende
  916: 1			              clr    e             ;display deselecteren
  917: 1			              pop    psw           ;registers herstellen
  918: 1			              pop    acc
  919: 1			              ret
  920: 1			endif
  921: 1
  922: 1			ifdef    aduc832_v2_0
  923: 1  022F	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
  924: 1  0231	C0 D0		              push   psw
  925: 1  0233	C0 F0		              push   b             ;werkregister
  926: 1  0235	12 04 BF	              lcall  lcdtoport     ;lees de expander naar b register
  927: 1  0238	C2 F0		              clr    rs            ;controle lijn in orde
  928: 1  023A	C2 F1		              clr    e             ;deselectie display
  929: 1  023C	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  930: 1  023E	03		              rr     a             ;bits op juiste plaats zetten
  931: 1  023F	03		              rr     a             ;voor b reg
  932: 1  0240	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  933: 1  0243	42 F0		              orl    b,a           ;bij elkaar voegen
  934: 1  0245	12 04 A6	              lcall  porttolcd     ;naar expnder
  935: 1  0248	D2 F1		              setb   e             ;display enabelen
  936: 1  024A	12 04 A6	              lcall  porttolcd
  937: 1  024D	C2 F1		              clr    e             ;display deselecteren
  938: 1  024F	12 04 A6	              lcall  porttolcd
  939: 1  0252	D0 F0		              pop    b
  940: 1  0254	D0 D0		              pop    psw           ;registers herstellen
  941: 1  0256	D0 E0		              pop    acc
  942: 1  0258	22		              ret
  943: 1			endif
  944: 1
  945: 1			;******************************************************************************
  946: 1			; hexbuf2lcd

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  947: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  948: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  949: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  950: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  951: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  952: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  953: 1			;
  954: 1			; ADR| HEX DATA  |
  955: 1			; 42 |AF 2D 23 5A|
  956: 1			;
  957: 1			; Deze routine vernietigt geen registers
  958: 1			;******************************************************************************
  959: 1
  960: 1  0259	C0 E0		hexbuf2lcd:   push   acc
  961: 1  025B	C0 F0		              push   b
  962: 1  025D	C0 D0		              push   psw
  963: 1  025F	C0 82		              push   dpl
  964: 1  0261	C0 83		              push   dph
  965: 1  0263	E8		              mov     a,r0
  966: 1  0264	C0 E0		              push   acc
  967: 1  0266	90 02 A2	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
  968: 1  0269	12 01 90	              lcall   outmsgalcd
  969: 1  026C	E8		              mov    a,r0            ;neem pointerwaarde
  970: 1  026D	12 01 6C	              lcall  outbytelcd      ;byte afdrukken als startadres
  971: 1  0270	74 20		              mov    a,#' '          ;spatie afdrukken
  972: 1  0272	12 01 0B	              lcall  outcharlcd
  973: 1  0275	74 7C		              mov    a,#'|'          ;pipe afdrukken
  974: 1  0277	12 01 0B	              lcall  outcharlcd
  975: 1  027A	75 F0 04	              mov    b,#4            ;bytecounter=4
  976: 1  027D	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  977: 1  027E	12 01 6C	              lcall  outbytelcd      ;byte naar buiten
  978: 1  0281	74 20		              mov    a,#' '          ;neem whitespace char
  979: 1  0283	12 01 0B	              lcall  outcharlcd       ;druk af
  980: 1  0286	08		              inc    r0              ;volgende byte
  981: 1  0287	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
  982: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  983: 1  028A	74 CF		              mov    a,#0cfh         ;adres laatste char
  984: 1  028C	12 01 0B	              lcall   outcharlcd
  985: 1  028F	74 7C		              mov    a,#'|'          ;neem pipe
  986: 1  0291	12 01 0B	              lcall  outcharlcd      ;ascii code afdrukken
  987: 1  0294	D0 E0		hexbuf2lcde:  pop    acc
  988: 1  0296	F8		              mov   r0,a
  989: 1  0297	D0 83		              pop   dph
  990: 1  0299	D0 82		              pop   dpl
  991: 1  029B	D0 D0		              pop   psw
  992: 1  029D	D0 F0		              pop   b
  993: 1  029F	D0 E0		              pop   acc
  994: 1  02A1	22		              ret
  995: 1			                        ;'0123456789abcdef'
  996: 1  02A2	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  02A6	52 7C 20 48
       1  02AA	45 58 20 44
       1  02AE	41 54 41 20
       1  02B2	20 7C C0 00
  997: 1
  998: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

  999: 1			;******************************************************************************
 1000: 1			; barlcd
 1001: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
 1002: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
 1003: 1			; de inhoud van A
 1004: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
 1005: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
 1006: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
 1007: 1			; aangemaakt in de LCD CGRAM.
 1008: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
 1009: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
 1010: 1			;       lcall build
 1011: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
 1012: 1			;       mov     a, #42h     ;de startlocatie is 42h
 1013: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
 1014: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
 1015: 1			;
 1016: 1			; Deze routine vernietigt geen registers.
 1017: 1			;******************************************************************************
 1018: 1
 1019: 1  02B6	C0 82		barlcd:       push   dpl
 1020: 1  02B8	88 82		              mov     dpl,r0
 1021: 1  02BA	C0 82		              push   dpl
 1022: 1  02BC	C0 E0		              push   acc            ;bewaar startlocatie
 1023: 1  02BE	C0 D0		              push   psw            ;bewaar status
 1024: 1  02C0	C0 F0		              push   b              ;bewaar aantal bar's
 1025: 1  02C2	F5 F0		              mov    b,a            ;bewaar startlocatie
 1026: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
 1027: 1  02C4	E8		              mov    a,r0           ;neem maximum aantal bar's
 1028: 1  02C5	C0 F0		              push   b              ;bewaar startadres
 1029: 1  02C7	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
 1030: 1  02CA	84		              div    ab             ;bereken dus het aantal nodige blokjes
 1031: 1  02CB	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
 1032: 1  02CC	E5 F0		              mov    a,b            ;neem restbars
 1033: 1  02CE	60 01		              jz     barlcd_1       ;als nul dan verder
 1034: 1  02D0	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
 1035: 1  02D1	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
 1036: 1  02D3	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van
 1037: 1  02D5	12 01 0B	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
 1038: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
 1039: 1  02D8	74 13		              mov    a,#13h         ;cursor off
 1040: 1  02DA	12 01 0B	              lcall  outcharlcd     ;stuur naar LCD
 1041: 1  02DD	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
 1042: 1  02DF	C0 F0		              push   b              ;en weer bewaren
 1043: 1  02E1	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
 1044: 1  02E3	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
 1045: 1  02E5	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
 1046: 1  02E8	84		              div    ab             ;A=aantal volle blokjes, B=rest
 1047: 1  02E9	C0 F0		              push   b              ;bewaar rest
 1048: 1  02EB	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
 1049: 1  02ED	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
 1050: 1
 1051: 1			;Druk de volle 5x8 blokjes af van de bargraph
 1052: 1  02EF	74 04		              mov    a,#4           ;neem code voor vol blokje
 1053: 1  02F1	12 01 DF	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
 1054: 1  02F4	18		              dec    r0             ;verminder karaktersteller

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1055: 1  02F5	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
 1056: 1
 1057: 1			;Druk het onvolledige blokje (rest) af
 1058: 1  02F8	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
 1059: 1  02FA	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
 1060: 1  02FC	14		              dec    a              ;converteer rest naar code voor de
 1061: 1			                                    ;overeenkomende bar's
 1062: 1  02FD	12 01 DF	              lcall  outd           ;druk resterende bar's af
 1063: 1  0300	18		              dec    r0             ;verminder karakterteller
 1064: 1
 1065: 1			;Test of we aan het einde van de bargraph zitten..
 1066: 1  0301	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
 1067: 1  0304	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
 1068: 1
 1069: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
 1070: 1  0306	74 20		barlcd4:      mov    a,#' '         ;neem spatie
 1071: 1  0308	12 01 DF	              lcall  outd           ;en druk af
 1072: 1  030B	18		              dec    r0             ;karakterteller verminderen
 1073: 1  030C	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
 1074: 1
 1075: 1  030E	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
 1076: 1  0310	D0 D0		              pop    psw            ;haal status weer
 1077: 1  0312	D0 E0		              pop    acc            ;haal startlocatie weer
 1078: 1  0314	D0 82		              pop    dpl
 1079: 1  0316	A8 82		              mov    r0,dpl
 1080: 1  0318	D0 82		              pop    dpl
 1081: 1  031A	22		              ret
 1082: 1
 1083: 1
 1084: 1
 1085: 1			;******************************************************************************
 1086: 1			; barchars
 1087: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
 1088: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
 1089: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
 1090: 1			; kunnen pas daarna worden gebruikt.
 1091: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
 1092: 1			; achter deze 5 char's worden geplaatst via de build_adr routine
 1093: 1			; (max. 3 extra char's).
 1094: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
 1095: 1			; opgeslagen met MSB=1.
 1096: 1			;******************************************************************************
 1097: 1
 1098: 1  031B	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1099: 1  031C	10		              db 00010000b
 1100: 1  031D	10		              db 00010000b
 1101: 1  031E	10		              db 00010000b
 1102: 1  031F	10		              db 00010000b
 1103: 1  0320	10		              db 00010000b
 1104: 1  0321	10		              db 00010000b
 1105: 1  0322	10		              db 00010000b
 1106: 1
 1107: 1  0323	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1108: 1  0324	18		              db 00011000b
 1109: 1  0325	18		              db 00011000b
 1110: 1  0326	18		              db 00011000b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1111: 1  0327	18		              db 00011000b
 1112: 1  0328	18		              db 00011000b
 1113: 1  0329	18		              db 00011000b
 1114: 1  032A	18		              db 00011000b
 1115: 1
 1116: 1  032B	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1117: 1  032C	1C		              db 00011100b
 1118: 1  032D	1C		              db 00011100b
 1119: 1  032E	1C		              db 00011100b
 1120: 1  032F	1C		              db 00011100b
 1121: 1  0330	1C		              db 00011100b
 1122: 1  0331	1C		              db 00011100b
 1123: 1  0332	1C		              db 00011100b
 1124: 1
 1125: 1  0333	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1126: 1  0334	1E		              db 00011110b
 1127: 1  0335	1E		              db 00011110b
 1128: 1  0336	1E		              db 00011110b
 1129: 1  0337	1E		              db 00011110b
 1130: 1  0338	1E		              db 00011110b
 1131: 1  0339	1E		              db 00011110b
 1132: 1  033A	1E		              db 00011110b
 1133: 1
 1134: 1  033B	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1135: 1  033C	1F		              db 00011111b
 1136: 1  033D	1F		              db 00011111b
 1137: 1  033E	1F		              db 00011111b
 1138: 1  033F	1F		              db 00011111b
 1139: 1  0340	1F		              db 00011111b
 1140: 1  0341	1F		              db 00011111b
 1141: 1  0342	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1142: 1
 1143: 1			;******************************************************************************
 1144: 1			;
 1145: 1			; build
 1146: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1147: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1148: 1			; overeen komen met de ASCII codes 00h-07h.
 1149: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1150: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1151: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1152: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1153: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1154: 1			;
 1155: 1			; De routine vernietigt geen registers.
 1156: 1			;
 1157: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1158: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1159: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1160: 1			;      lcall  outcharlcd         ; druk de karakter af
 1161: 1			;
 1162: 1			;eigenkarakter:
 1163: 1			;      db 00001110b
 1164: 1			;      db 00001010b
 1165: 1			;      db 00001110b
 1166: 1			;      db 00000100b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1167: 1			;      db 00011111b
 1168: 1			;      db 00000100b
 1169: 1			;      db 00001010b
 1170: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1171: 1			;******************************************************************************
 1172: 1
 1173: 1  0343	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1174: 1  0345	C0 D0		              push   psw
 1175: 1  0347	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1176: 1  0349	12 03 51	              lcall  build_adr
 1177: 1  034C	D0 D0		              pop    psw
 1178: 1  034E	D0 E0		              pop    acc
 1179: 1  0350	22		              ret                  ;terug
 1180: 1
 1181: 1			;******************************************************************************
 1182: 1			; build_adr
 1183: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1184: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1185: 1			; die overeen komen met de ASCII codes 00h-07h.
 1186: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1187: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1188: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1189: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1190: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1191: 1			;
 1192: 1			; De routine vernietigt geen registers.
 1193: 1			;
 1194: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1195: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1196: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1197: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1198: 1			;      lcall  outcharlcd        ; druk de karakter af
 1199: 1			;
 1200: 1			;eigenkarakters:
 1201: 1			;      db 00001110b
 1202: 1			;      db 00001010b
 1203: 1			;      db 00001110b
 1204: 1			;       db 00000100b
 1205: 1			;      db 00011111b
 1206: 1			;      db 00000100b
 1207: 1			;      db 00001010b
 1208: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1209: 1			;******************************************************************************
 1210: 1  0351	C0 E0		build_adr:      push   acc
 1211: 1  0353	C0 D0		              push   psw
 1212: 1  0355	C0 83		              push   dph
 1213: 1  0357	C0 82		              push   dpl
 1214: 1  0359	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1215: 1  035B	12 02 19	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1216: 1  035E	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1217: 1  0360	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1218: 1  0361	12 01 DF	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1219: 1  0364	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1220: 1  0367	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1221: 1  0368	80 F4		              sjmp   build3
 1222: 1  036A	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1223: 1  036C	12 02 19	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1224: 1  036F	D0 82		              pop    dpl
 1225: 1  0371	D0 83		              pop    dph
 1226: 1  0373	D0 D0		              pop    psw
 1227: 1  0375	D0 E0		              pop    acc
 1228: 1  0377	22		              ret
 1229: 1
 1230: 1			;******************************************************************************
 1231: 1			;
 1232: 1			; delay2ms
 1233: 1			; Is een vertragingsroutine van 2ms.
 1234: 1			;
 1235: 1			; De routine vernietigt geen registers.
 1236: 1			;
 1237: 1			;******************************************************************************
 1238: 1
 1239: 1  0378	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1240: 1  037A	C0 D0		              push   psw
 1241: 1  037C	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1242: 1  037E	12 03 89	delay2ms1:    lcall  delay60us
 1243: 1  0381	D5 E0 FA	              djnz   acc,delay2ms1
 1244: 1  0384	D0 D0		              pop    psw           ;registers herstellen
 1245: 1  0386	D0 E0		              pop    acc
 1246: 1  0388	22		              ret
 1247: 1
 1248: 1			;******************************************************************************
 1249: 1			;
 1250: 1			; delay60us.
 1251: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1252: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1253: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1254: 1			;
 1255: 1			; de routine vernietigt geen registers.
 1256: 1			;
 1257: 1			;******************************************************************************
 1258: 1
 1259: 1  0389	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1260: 1  038B	C0 D0		              push   psw
 1261: 1  038D	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1262: 1  038F	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1263: 1
 1264: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1265: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1266: 1
 1267: 1  0391	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1268: 1  0394	D0 E0		              pop    acc           ;registers herstellen
 1269: 1  0396	D0 D0		              pop    psw
 1270: 1  0398	22		              ret
 1271: 1
 1272: 1  0399	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1273: 1  039B	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1274: 1  039E	D0 D0		              pop    psw
 1275: 1  03A0	D0 E0		              pop    acc
 1276: 1  03A2	22		              ret
 1277: 1
 1278: 1			endif        ;einde van aduc_lcd

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1279: 1
 1280: 1
 1281: 1
 1282: 1
 1283: 1			ifdef aduc_i2c
 1284: 1			;******************************************************************************
 1285: 1			;
 1286: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1287: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1288: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1289: 1			;
 1290: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1291: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1292: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1293: 1			;
 1294: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1295: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1296: 1			;
 1297: 1			; Beschikbare routines:
 1298: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1299: 1			; i2cstart     :verzenden van een start conditie
 1300: 1			; i2cstop      :verzenden van een stop conditie
 1301: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1302: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1303: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1304: 1			;               negende klokpuls
 1305: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1306: 1			;               negende klokpuls
 1307: 1			;
 1308: 1			; Toevoeging [dp]
 1309: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1310: 1			;               een slavedevice
 1311: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1312: 1			;               en plaatst deze in een geheugenbuffer
 1313: 1			;******************************************************************************
 1314: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1315: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie
 1316: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1317: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1318: 1
 1319: 1			;******************************************************************************
 1320: 1			; i2cinit
 1321: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1322: 1			;******************************************************************************
 1323: 1  03A3	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1324: 1  03A5	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1325: 1  03A7	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1326: 1  03A9	D2 EB		                setb    i2cm            ;master mode inschakelen
 1327: 1  03AB	22		                ret
 1328: 1			;******************************************************************************
 1329: 1			; i2cstart
 1330: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1331: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1332: 1  03AC	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1333: 1  03AE	C2 EF		                clr     mdo             ;data moet laag worden
 1334: 1  03B0	D2 EE		                setb    mde             ;data pin enable
 1335: 1  03B2	C2 ED		                clr     mco             ;klok laag maken
 1336: 1  03B4	22		                ret
 1337: 1			;******************************************************************************
 1338: 1			; i2cstop
 1339: 1			; Dit is een subroutine die de stop conditie opwekt.
 1340: 1			;******************************************************************************
 1341: 1  03B5	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1342: 1  03B7	D2 EE		                setb    mde             ;data mag naar buiten
 1343: 1  03B9	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1344: 1  03BB	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1345: 1  03BD	22		                ret
 1346: 1
 1347: 1			;******************************************************************************
 1348: 1			; i2coutbyte
 1349: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1350: 1			; De routine vernietigt geen registers.
 1351: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1352: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1353: 1			;         uitvoeren van de routine.
 1354: 1			;******************************************************************************
 1355: 1  03BE	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1356: 1  03C0	C0 F0		                push    b
 1357: 1  03C2	75 F0 08	                mov     b,#008h         ;loopcounter
 1358: 1  03C5	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1359: 1  03C6	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1360: 1  03C8	D2 EE		                setb    mde             ;pin als output activeren
 1361: 1  03CA	D2 ED		                setb    mco             ;klokpukls hoog
 1362: 1  03CC	C2 ED		                clr     mco             ;klokpuls laag
 1363: 1  03CE	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1364: 1  03D1	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1365: 1  03D3	D2 ED		                setb    mco             ;klokpuls hoog
 1366: 1  03D5	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1367: 1  03D7	C2 ED		                clr     mco             ;klokpuls terug laag
 1368: 1  03D9	D0 F0		                pop     b
 1369: 1  03DB	D0 E0		                pop     acc             ;registers herstellen
 1370: 1  03DD	22		                ret
 1371: 1
 1372: 1			;******************************************************************************
 1373: 1			; i2cinbyteack
 1374: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1375: 1			; De routine vernietigt geen registers. De routine zal als
 1376: 1			; negende bit een ack verzenden.
 1377: 1			;******************************************************************************
 1378: 1  03DE	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1379: 1  03E0	C0 D0		                push    psw
 1380: 1  03E2	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1381: 1  03E5	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1382: 1  03E7	D2 ED		                setb    mco             ;klokpuls hoog
 1383: 1  03E9	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1384: 1  03EB	C2 ED		                clr     mco             ;klokpuls terug laag
 1385: 1  03ED	33		                rlc     a               ;in accu shiften
 1386: 1  03EE	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1387: 1  03F1	C3		                clr     c               ;ack verzenden

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1388: 1  03F2	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1389: 1  03F4	D2 EE		                setb    mde             ;pin als output activeren
 1390: 1  03F6	D2 ED		                setb    mco             ;klokpukls hoog
 1391: 1  03F8	C2 ED		                clr     mco             ;klokpuls laag
 1392: 1  03FA	D0 D0		                pop     psw             ;registers herstellen
 1393: 1  03FC	D0 F0		                pop     b
 1394: 1  03FE	22		                ret
 1395: 1
 1396: 1			;******************************************************************************
 1397: 1			; i2cinbytenack
 1398: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1399: 1			; De routine vernietigt geen registers. De routine zal als
 1400: 1			; negende bit een nack verzenden.
 1401: 1			;******************************************************************************
 1402: 1  03FF	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1403: 1  0401	C0 D0		                push    psw
 1404: 1  0403	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1405: 1  0406	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1406: 1  0408	D2 ED		                setb    mco             ;klokpuls hoog
 1407: 1  040A	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1408: 1  040C	C2 ED		                clr     mco             ;klokpuls terug laag
 1409: 1  040E	33		                rlc     a               ;in accu shiften
 1410: 1  040F	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1411: 1  0412	D3		                setb    c               ;nack verzenden
 1412: 1  0413	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1413: 1  0415	D2 EE		                setb    mde             ;pin als output activeren
 1414: 1  0417	D2 ED		                setb    mco             ;klokpukls hoog
 1415: 1  0419	C2 ED		                clr     mco             ;klokpuls laag
 1416: 1  041B	D0 D0		                pop     psw             ;registers herstellen
 1417: 1  041D	D0 F0		                pop     b
 1418: 1  041F	22		                ret
 1419: 1
 1420: 1			;******************************************************************************
 1421: 1			; i2csenddata
 1422: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1423: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1424: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1425: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1426: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1427: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1428: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1429: 1			;
 1430: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1431: 1			; pointer naar deze data.  .
 1432: 1
 1433: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1434: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1435: 1			;         B       = aantal te versturen bytes (minimum 1)
 1436: 1			;         R0      = startadres van te versturen datablok
 1437: 1			;
 1438: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1439: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1440: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1441: 1			;               verzonden byte waarvoor er geen ack kwam.
 1442: 1			;
 1443: 1			; Deze routine vernietigt niets...

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1444: 1			;******************************************************************************
 1445: 1  0420	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1446: 1  0422	C0 D0		                    push   psw
 1447: 1  0424	E8		                    mov    a,r0
 1448: 1  0425	C0 E0		                    push   acc           ;r0 op stack
 1449: 1
 1450: 1  0427	12 03 AC	                    lcall  i2cstart      ;genereer startconditie
 1451: 1  042A	E5 83		                    mov    a,dph         ;neem adresbyte
 1452: 1  042C	12 03 BE	                    lcall  i2coutbyte    ;en verstuur naar slave
 1453: 1  042F	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1454: 1  0431	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1455: 1  0433	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1456: 1  0435	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1457: 1			;10 bit adressering!
 1458: 1  0438	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1459: 1  043A	12 03 BE	                    lcall  i2coutbyte    ;en verstuur naar slave
 1460: 1  043D	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1461: 1			;7 bit adressering!
 1462: 1  043F	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1463: 1  0440	12 03 BE	                    lcall  i2coutbyte    ;en verstuur naar slave
 1464: 1  0443	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1465: 1  0445	08		                    inc    r0            ;volgende byte
 1466: 1  0446	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1467: 1  0449	12 03 B5	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1468: 1  044C	D0 E0		                    pop    acc
 1469: 1  044E	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1470: 1  044F	D0 D0		                    pop    psw
 1471: 1  0451	C3		                    clr    c             ;alles is ok!
 1472: 1  0452	D0 E0		                    pop    acc
 1473: 1  0454	22		                    ret
 1474: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1475: 1  0455	12 03 B5	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1476: 1  0458	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1477: 1  045A	D0 D0		                    pop    psw
 1478: 1  045C	D3		                    setb   c            ;terug met foutmelding
 1479: 1  045D	D0 E0		                    pop    acc
 1480: 1  045F	22		                    ret
 1481: 1
 1482: 1			;******************************************************************************
 1483: 1			; i2crcvdata
 1484: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1485: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1486: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1487: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1488: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1489: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1490: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1491: 1			;
 1492: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1493: 1			; is een pointer naar de start van dit ontvangen datablok.
 1494: 1			;
 1495: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1496: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1497: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1498: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1499: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1500: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1501: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1502: 1			;               het adres, wordt de CY bit geset bij return.
 1503: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1504: 1			;
 1505: 1			; Deze routine vernietigt verder niets...
 1506: 1			;******************************************************************************
 1507: 1  0460	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1508: 1  0462	C0 D0		                    push    psw
 1509: 1  0464	E8		                    mov     a,r0            ;r0 op stack
 1510: 1  0465	C0 E0		                    push    acc
 1511: 1
 1512: 1  0467	12 03 AC	                    lcall   i2cstart        ;genereer startconditie
 1513: 1  046A	E5 83		                    mov     a,dph           ;neem adresbyte
 1514: 1  046C	12 03 BE	                    lcall   i2coutbyte      ;en verstuur naar slave
 1515: 1  046F	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1516: 1  0471	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1517: 1  0473	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1518: 1  0475	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1519: 1			;10 bit adressering!
 1520: 1  0478	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1521: 1  047A	12 03 BE	                    lcall   i2coutbyte      ;en verstuur naar slave
 1522: 1  047D	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1523: 1			;7 bit adressering!
 1524: 1
 1525: 1  047F	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1526: 1  0482	12 03 FF	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1527: 1  0485	F6		                    mov     @r0,a           ;en deze ook bewaren
 1528: 1  0486	80 07		                    sjmp    i2crcvdata3
 1529: 1  0488	12 03 DE	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1530: 1  048B	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1531: 1  048C	08		                    inc     r0              ;pointer verhogen
 1532: 1  048D	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1533: 1
 1534: 1  048F	12 03 B5	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1535: 1  0492	D0 E0		                    pop     acc
 1536: 1  0494	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1537: 1  0495	D0 D0		                    pop     psw
 1538: 1  0497	C3		                    clr     c               ;alles is ok!
 1539: 1  0498	D0 E0		                    pop     acc
 1540: 1  049A	22		                    ret
 1541: 1			;fout: geen ack gekregen bij het versturen van het adres
 1542: 1  049B	12 03 B5	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1543: 1  049E	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1544: 1  04A0	D0 D0		                    pop        psw
 1545: 1  04A2	D3		                    setb    c               ;terug met foutmelding
 1546: 1  04A3	D0 E0		                    pop        acc
 1547: 1  04A5	22		                    ret
 1548: 1
 1549: 1
 1550: 1			;******************************************************************************
 1551: 1			;
 1552: 1			; porttolcd
 1553: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1554: 1			; scherm stuurt via de port expander.
 1555: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1556: 1			; Gebruikt geen registers
 1557: 1			;
 1558: 1			;******************************************************************************
 1559: 1
 1560: 1  04A6	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1561: 1  04A8	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1562: 1  04AA	12 03 AC	              lcall  i2cstart      ;vertrokken
 1563: 1			ifdef    pcf8574
 1564: 1			              mov    a,#01000000b  ;schrijven naar expander
 1565: 1			endif
 1566: 1			ifdef    pcf8574A
 1567: 1  04AD	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1568: 1			endif
 1569: 1  04AF	12 03 BE	              lcall  i2coutbyte    ;weg er mee
 1570: 1  04B2	E5 F0		              mov    a,b           ;data verzenden
 1571: 1  04B4	12 03 BE	              lcall  i2coutbyte
 1572: 1  04B7	12 03 B5	              lcall  i2cstop       ;transactie sluiten
 1573: 1  04BA	D0 D0		              pop    psw
 1574: 1  04BC	D0 E0		              pop    acc
 1575: 1  04BE	22		              ret
 1576: 1
 1577: 1			;******************************************************************************
 1578: 1			;
 1579: 1			; lcdtoport
 1580: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1581: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1582: 1			; aansturen van de buzzer en backlight.
 1583: 1			;
 1584: 1			; output: b register
 1585: 1			;
 1586: 1			;******************************************************************************
 1587: 1
 1588: 1  04BF	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1589: 1  04C1	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1590: 1  04C3	12 03 AC	              lcall  i2cstart      ;vertrokken
 1591: 1			ifdef    pcf8574
 1592: 1			              mov    a,#01000000b  ;schrijven naar expander
 1593: 1			endif
 1594: 1			ifdef    pcf8574A
 1595: 1  04C6	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1596: 1			endif
 1597: 1  04C8	12 03 BE	              lcall  i2coutbyte    ;weg er mee
 1598: 1  04CB	12 03 FF	              lcall  i2cinbytenack ;data inlezen
 1599: 1  04CE	12 03 B5	              lcall  i2cstop
 1600: 1  04D1	F5 F0		              mov    b,a
 1601: 1  04D3	D0 D0		              pop    psw
 1602: 1  04D5	D0 E0		              pop    acc
 1603: 1  04D7	22		              ret
 1604: 1
 1605: 1			;******************************************************************************
 1606: 1			;
 1607: 1			; lcdlighton
 1608: 1			; Dit is een subroutine die de backlight inschakeld
 1609: 1			;
 1610: 1			; Gebruikt geen registers
 1611: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1612: 1			;******************************************************************************
 1613: 1
 1614: 1  04D8	C0 F0		lcdlighton:   push   b
 1615: 1  04DA	12 04 BF	              lcall  lcdtoport     ;expander lezen
 1616: 1  04DD	C2 F6		              clr    b.6           ;licht aan doen
 1617: 1  04DF	12 04 A6	              lcall  porttolcd     ;expander schrijven
 1618: 1  04E2	D0 F0		              pop    b
 1619: 1  04E4	22		              ret
 1620: 1
 1621: 1
 1622: 1			;******************************************************************************
 1623: 1			;
 1624: 1			; lcdlightoff
 1625: 1			; Dit is een subroutine die de backlight uitschakeld
 1626: 1			;
 1627: 1			; Gebruikt geen registers
 1628: 1			;
 1629: 1			;******************************************************************************
 1630: 1
 1631: 1  04E5	C0 F0		lcdlightoff:  push   b
 1632: 1  04E7	12 04 BF	              lcall  lcdtoport     ;expander lezen
 1633: 1  04EA	D2 F6		              setb   b.6           ;licht uit doen
 1634: 1  04EC	12 04 A6	              lcall  porttolcd     ;expander schrijven
 1635: 1  04EF	D0 F0		              pop    b
 1636: 1  04F1	22		              ret
 1637: 1
 1638: 1			;******************************************************************************
 1639: 1			;
 1640: 1			; lcdbuzon
 1641: 1			; Dit is een subroutine die de buzzer inschakeld
 1642: 1			;
 1643: 1			; Gebruikt geen registers
 1644: 1			;
 1645: 1			;******************************************************************************
 1646: 1
 1647: 1  04F2	C0 F0		lcdbuzon:     push   b
 1648: 1  04F4	12 04 BF	              lcall  lcdtoport     ;expander lezen
 1649: 1  04F7	C2 F7		              clr    b.7           ;buzzer aan doen
 1650: 1  04F9	12 04 A6	              lcall  porttolcd     ;expander schrijven
 1651: 1  04FC	D0 F0		              pop    b
 1652: 1  04FE	22		              ret
 1653: 1
 1654: 1			;******************************************************************************
 1655: 1			;
 1656: 1			; lcdbuzoff
 1657: 1			; Dit is een subroutine die de buzzer uitschakeld
 1658: 1			;
 1659: 1			; Gebruikt geen registers
 1660: 1			;
 1661: 1			;******************************************************************************
 1662: 1
 1663: 1  04FF	C0 F0		lcdbuzoff:    push   b
 1664: 1  0501	12 04 BF	              lcall  lcdtoport     ;expander lezen
 1665: 1  0504	D2 F7		              setb   b.7           ;buzzer aan doen
 1666: 1  0506	12 04 A6	              lcall  porttolcd     ;expander schrijven
 1667: 1  0509	D0 F0		              pop    b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1668: 1  050B	22		              ret
 1669: 1
 1670: 1			endif    ;einde aduc_i2c
 1671: 1			;******************************************************************************
 1672: 1
 1673: 1
 1674: 1
 1675: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1676: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1677: 1			;
 1678: 1			; ADuCsio.inc
 1679: 1			; Is een include file voor de ADuC832 microcontroller.
 1680: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1681: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1682: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1683: 1			; afwijking van de standaard routines is de initsio subroutine.
 1684: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1685: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1686: 1			; zijn.
 1687: 1			;
 1688: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1689: 1			;
 1690: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1691: 1
 1692: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1693: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1694: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1695: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1696: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1697: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1698: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1699: 1
 1700: 1  050C	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1701: 1			                                                        ;van het scherm
 1702: 1
 1703: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1704: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1705: 1
 1706: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1707: 1			;
 1708: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1709: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1710: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1711: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1712: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1713: 1			;
 1714: 1			; de routine gebruikt de psw
 1715: 1			;
 1716: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1717: 1
 1718: 1  0510	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1719: 1  0512	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1720: 1  0514	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1721: 1  0516	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1722: 1  0519	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1723: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1724: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1725: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1726: 1
 1727: 1  051B	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1728: 1  051E	F4		              cpl    a             ;bitbangen om laten uit te komen
 1729: 1  051F	C3		              clr    c             ;verder doen
 1730: 1  0520	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1731: 1  0522	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1732: 1  0524	24 80		              add    a,#080h       ;nu alles in orde
 1733: 1  0526	F5 9E		              mov    t3con,a       ;baud rate klaar
 1734: 1  0528	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1735: 1  052B	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1736: 1  052C	D0 E0		              pop    acc
 1737: 1  052E	22		              ret
 1738: 1
 1739: 1  052F	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1740: 1  0530	D0 E0		              pop    acc
 1741: 1  0532	22		              ret
 1742: 1
 1743: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1744: 1			;
 1745: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1746: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1747: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1748: 1			;
 1749: 1			; de routine gebruikt geen registers.
 1750: 1			;
 1751: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1752: 1
 1753: 1  0533	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1754: 1  0535	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1755: 1  0538	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1756: 1  053A	22		              RET
 1757: 1
 1758: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1759: 1			;
 1760: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1761: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
 1762: 1			;
 1763: 1			; de routine gebruikt geen registers.
 1764: 1			;
 1765: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1766: 1
 1767: 1  053B	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1768: 1  053D	C0 D0		              push   psw
 1769: 1  053F	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1770: 1  0541	12 06 4D	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1771: 1  0544	12 05 33	              LCALL  OUTCHAR       ;VERSTUREN
 1772: 1  0547	12 05 94	              LCALL  XONXOFF       ;FLOW CONTROL
 1773: 1  054A	D0 D0		              pop    psw           ;registers herstellen
 1774: 1  054C	D0 E0		              pop    acc
 1775: 1  054E	22		              RET
 1776: 1
 1777: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1778: 1			;
 1779: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1780: 1			; WORDT XONXOFF GEBRUIKT.
 1781: 1			;
 1782: 1			; de routine gebruikt geen registers.
 1783: 1			;
 1784: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1785: 1
 1786: 1  054F	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1787: 1  0551	C0 D0		              push   psw
 1788: 1  0553	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1789: 1  0555	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1790: 1  0556	12 05 3B	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1791: 1  0559	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1792: 1  055B	12 05 3B	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1793: 1  055E	D0 D0		              pop    psw           ;registers herstellen
 1794: 1  0560	D0 E0		              pop    acc
 1795: 1  0562	22		              RET
 1796: 1
 1797: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1798: 1			;
 1799: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1800: 1			; VAN DE CURSOR.
 1801: 1			;
 1802: 1			; de routine gebruikt geen registers.
 1803: 1			;
 1804: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1805: 1
 1806: 1  0563	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1807: 1  0565	C0 D0		              push   psw
 1808: 1  0567	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1809: 1  0569	12 05 4F	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1810: 1  056C	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1811: 1  056E	12 05 4F	              LCALL  OUTBYTE       ;WEG ER MEE
 1812: 1  0571	D0 D0		              pop    psw           ;registers herstellen
 1813: 1  0573	D0 E0		              pop    acc
 1814: 1  0575	22		              RET                  ;EINDE
 1815: 1
 1816: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1817: 1			;
 1818: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1819: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1820: 1			;
 1821: 1			; de routine gebruikt geen registers.
 1822: 1			;
 1823: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1824: 1
 1825: 1  0576	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1826: 1  0578	C0 D0		              push   psw
 1827: 1  057A	C0 82		              push   dpl
 1828: 1  057C	C0 83		              push   dph
 1829: 1  057E	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1830: 1  057F	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1831: 1  0580	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1832: 1  0582	12 05 33	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1833: 1  0585	12 05 94	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1834: 1  0588	A3		              INC    DPTR          ;DPTR AANPASSEN
 1835: 1  0589	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1836: 1  058B	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1837: 1  058D	D0 82		              pop    dpl
 1838: 1  058F	D0 D0		              pop    psw
 1839: 1  0591	D0 E0		              pop    acc
 1840: 1  0593	22		              RET                  ;EINDE ROUTINE
 1841: 1
 1842: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1843: 1			;
 1844: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1845: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1846: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1847: 1			; VERDER DOORGEGEVEN.
 1848: 1			;
 1849: 1			; de routine gebruikt geen registers.
 1850: 1			;
 1851: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1852: 1
 1853: 1  0594	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1854: 1  0596	C0 D0		              push   psw
 1855: 1  0598	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1856: 1  059B	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 1857: 1  059D	D0 E0		              pop    acc
 1858: 1  059F	22		              RET                  ;ANDERS EINDE
 1859: 1  05A0	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1860: 1  05A2	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1861: 1  05A5	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1862: 1  05A8	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1863: 1
 1864: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1865: 1			;
 1866: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1867: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1868: 1			;
 1869: 1			; de routine gebruikt de accu.
 1870: 1			;
 1871: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1872: 1
 1873: 1  05AA	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER
 1874: 1  05AD	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 1875: 1  05AF	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1876: 1  05B1	22		              RET
 1877: 1
 1878: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1879: 1			;
 1880: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1881: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1882: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 1883: 1			; DE CARRY OP 1 GEZET WORDEN.
 1884: 1			;
 1885: 1			; De routine gebruikt de accu EN PSW.
 1886: 1			;
 1887: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1888: 1
 1889: 1  05B2	C0 F0		INBYTE:       PUSH     B
 1890: 1  05B4	12 05 AA	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1891: 1  05B7	12 06 40	              LCALL  LOWUPTR

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1892: 1  05BA	12 06 5B	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1893: 1  05BD	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1894: 1  05BF	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1895: 1  05C0	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1896: 1  05C2	12 05 AA	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1897: 1  05C5	12 06 40	              LCALL  LOWUPTR
 1898: 1  05C8	12 06 5B	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1899: 1  05CB	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1900: 1  05CD	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1901: 1  05CF	D0 F0		INBYTE1:      POP     B
 1902: 1  05D1	22		              RET
 1903: 1
 1904: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1905: 1			;
 1906: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1907: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1908: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1909: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1910: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1911: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1912: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 1913: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1914: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1915: 1			; bepalen.
 1916: 1			;
 1917: 1			; De routine gebruikt  r0 .
 1918: 1			;
 1919: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1920: 1
 1921: 1  05D2	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1922: 1  05D4	C0 D0		              push   psw
 1923: 1  05D6	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1924: 1  05D8	12 05 AA	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 1925: 1  05DB	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1926: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 1927: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1928: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1929: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
 1930: 1			; GEVOERD.
 1931: 1  05DD	12 06 40	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1932: 1  05E0	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1933: 1  05E3	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1934: 1  05E4	D0 D0		              pop    psw                  ;registers herstellen
 1935: 1  05E6	D0 E0		              pop    acc
 1936: 1  05E8	22		              RET                         ;EINDE VAN DE ROUTINE
 1937: 1
 1938: 1  05E9	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 1939: 1  05EC	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1940: 1  05EF	74 07		INBUFA4:      MOV    A,#BEEP
 1941: 1  05F1	12 05 33	INBUFA7:      LCALL  OUTCHAR
 1942: 1  05F4	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1943: 1
 1944: 1  05F6	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1945: 1  05F7	90 05 0C	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1946: 1  05FA	12 05 76	              LCALL  OUTMSGA
 1947: 1  05FD	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1948: 1  05FF	12 06 32	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1949: 1  0602	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1950: 1  0604	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1951: 1  0607	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1952: 1  0609	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1953: 1  060A	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1954: 1  060B	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1955: 1
 1956: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1957: 1			;
 1958: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1959: 1			;
 1960: 1			; De routine gebruikt niets.
 1961: 1			;
 1962: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1963: 1
 1964: 1  060D	C0 E0		BDELETE:      PUSH     ACC
 1965: 1  060F	C0 D0		              PUSH     PSW
 1966: 1  0611	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1967: 1  0612	C0 E0		              PUSH     ACC
 1968: 1  0614	E9		              MOV     A,R1
 1969: 1  0615	C0 E0		              PUSH     ACC
 1970: 1  0617	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1971: 1  0619	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1972: 1  061B	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1973: 1  061C	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1974: 1  061F	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1975: 1  0620	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1976: 1  0623	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1977: 1  0625	F9		              MOV     R1,A
 1978: 1  0626	D0 E0		              POP     ACC
 1979: 1  0628	F8		              MOV     R0,A
 1980: 1  0629	D0 D0		              POP     PSW
 1981: 1  062B	D0 E0		              POP     ACC
 1982: 1  062D	22		              RET                         ;EINDE VAN DE ROUTINE
 1983: 1  062E	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1984: 1  062F	09		              INC    R1
 1985: 1  0630	80 ED		              SJMP   BDELETE3
 1986: 1
 1987: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1988: 1			;
 1989: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1990: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1991: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1992: 1			; AANZIEN.
 1993: 1			;
 1994: 1			; De routine gebruikt de accu en de psw.
 1995: 1			;
 1996: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1997: 1
 1998: 1  0632	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 1999: 1  0635	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 2000: 1  0637	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 2001: 1  063A	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 2002: 1  063C	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 2003: 1  063D	22		              RET

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2004: 1  063E	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 2005: 1  063F	22		              RET
 2006: 1
 2007: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2008: 1			;
 2009: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 2010: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 2011: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 2012: 1			; AANGEPAST WORDEN.
 2013: 1			;
 2014: 1			; De routine gebruikt de accu en psw .
 2015: 1			;
 2016: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2017: 1
 2018: 1  0640	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 2019: 1  0643	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 2020: 1  0645	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 2021: 1  0648	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 2022: 1  064A	94 20		              SUBB   A,#020H              ;OMZETTING
 2023: 1  064C	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 2024: 1
 2025: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2026: 1			;
 2027: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 2028: 1			; ASCII CODE.
 2029: 1			;
 2030: 1			; De routine gebruikt de accu .
 2031: 1			;
 2032: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2033: 1
 2034: 1  064D	C0 D0		BATRANS:      PUSH   PSW
 2035: 1  064F	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 2036: 1  0652	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 2037: 1  0654	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 2038: 1  0656	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 2039: 1  0658	D0 D0		              POP     PSW
 2040: 1  065A	22		              RET
 2041: 1
 2042: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2043: 1			;
 2044: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 2045: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 2046: 1			; GEVAL WORDT DE CARRY GEZET.
 2047: 1			;
 2048: 1			; De routine gebruikt de accu en de psw.
 2049: 1			;
 2050: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2051: 1
 2052: 1  065B	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 2053: 1  065C	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 2054: 1  065E	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 2055: 1  0660	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 2056: 1  0663	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 2057: 1  0665	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 2058: 1  0667	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 2059: 1  0669	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2060: 1  066C	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 2061: 1  066D	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 2062: 1  066F	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 2063: 1  0670	22		ASCBINTRANS1: RET
 2064: 1
 2065: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2066: 1			;
 2067: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 2068: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 2069: 1			;
 2070: 1			; De routine gebruikt de accu en de psw.
 2071: 1			;
 2072: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2073: 1
 2074: 1  0671	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 2075: 1  0672	12 06 5B	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 2076: 1  0675	22		              RET                         ;EINDE OMZETTING
 2077: 1
 2078: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2079: 1			;
 2080: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 2081: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 2082: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 2083: 1			;
 2084: 1			; De routine gebruikt de accu, r0.
 2085: 1			;
 2086: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2087: 1
 2088: 1  0676	C0 F0		ASCII2:       PUSH   B
 2089: 1  0678	12 06 71	              LCALL  ASCII1               ;OMZETTEN
 2090: 1  067B	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 2091: 1  067D	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 2092: 1  067E	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 2093: 1  0680	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 2094: 1  0681	12 06 71	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 2095: 1  0684	40 02		              JC     ASCII21               ;WEG ALS C=1
 2096: 1  0686	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 2097: 1  0688	D0 F0		ASCII21:      POP     B
 2098: 1  068A	22		              RET
 2099: 1
 2100: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2101: 1			;
 2102: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2103: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2104: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2105: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2106: 1			;
 2107: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2108: 1			;
 2109: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2110: 1
 2111: 1  068B	12 06 76	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2112: 1  068E	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2113: 1  0690	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2114: 1  0692	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2115: 1  0693	12 06 76	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2116: 1  0696	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2117: 1  0698	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2118: 1  069A	22		ASCII41:      RET
 2119: 1
 2120: 1			endif        ;einde van aduc_sio
 2121: 1			;*******************************************************************************
 2122: 1
 2123: 1
 2124: 1			ifdef        aduc_math    ;rekenkundige routines
 2125: 1			;*******************************************************************************
 2126: 1			; aduc_math
 2127: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2128: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2129: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2130: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2131: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2132: 1			; zoals aangegeven:
 2133: 1			;
 2134: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2135: 1			;        ---------------------------
 2136: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2137: 1			;        ---------------------------                             statusbit = f0
 2138: 1			;        ---------------------------
 2139: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2140: 1			;        ---------------------------
 2141: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2142: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2143: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2144: 1			; return en moeten hiervoor worden gereserveerd.
 2145: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2146: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2147: 1			; en unsigned getallen.
 2148: 1			;
 2149: 1			; Beschikbare routines:
 2150: 1			;
 2151: 1			; Conversie routines:
 2152: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2153: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,
 2154: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2155: 1			;
 2156: 1			; Som:
 2157: 1			; s_add16, add16, s_add32, add32
 2158: 1			;
 2159: 1			; Verschil:
 2160: 1			; s_sub16, sub16, s_sub32, sub32
 2161: 1			;
 2162: 1			; Vermenigvuldigen:
 2163: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2164: 1			;
 2165: 1			; Delen:
 2166: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2167: 1			;
 2168: 1			; Vemenigvuldig met factor:
 2169: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2170: 1			;
 2171: 1			; Vierkantswortel:

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2172: 1			; sqrt32, s_sqrt32
 2173: 1			;
 2174: 1			; Schuiven:
 2175: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2176: 1			;
 2177: 1			; Vergelijken:
 2178: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2179: 1			;
 2180: 1			; Tabel lookup:
 2181: 1			; table_lu
 2182: 1			;
 2183: 1			; Gonemetrische functies:
 2184: 1			; Cordic = sinus,cosinus
 2185: 1			;
 2186: 1			;*******************************************************************************
 2187: 1
 2188: 1			;*******************************************************************************
 2189: 1			;
 2190: 1			; bcdhex8     (45,77us @16.777216MHz)
 2191: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2192: 1			; naar een 2's complement hex getal.
 2193: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2194: 1			; een waarde 00h tot 63h.
 2195: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2196: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2197: 1			; input:      R0 = waarde tussen 00h en 99h.
 2198: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2199: 1			; output:     R0 = 2's complement waarde
 2200: 1			;             cy=1 bij out of range van r0
 2201: 1			;             cy=0 bij conversie ok
 2202: 1			; vernietigt: niets
 2203: 1			;*******************************************************************************
 2204: 1  069B	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2205: 1  069D	C0 D0		              push   psw
 2206: 1  069F	C0 F0		              push   b
 2207: 1
 2208: 1  06A1	E8		              mov    a,r0                 ;neem te converteren waarde
 2209: 1  06A2	F5 F0		              mov    b,a
 2210: 1  06A4	54 0F		              anl    a,#0fh
 2211: 1  06A6	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2212: 1  06A9	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2213: 1  06AB	E5 F0		              mov    a,b
 2214: 1  06AD	54 F0		              anl    a,#0f0h
 2215: 1  06AF	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2216: 1  06B2	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2217: 1
 2218: 1  06B4	E8		              mov    a,r0
 2219: 1  06B5	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2220: 1  06B7	C4		              swap   a
 2221: 1  06B8	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2222: 1  06BB	A4		              mul    ab
 2223: 1  06BC	F5 F0		              mov    b,a                  ;bewaar dit product even
 2224: 1  06BE	E8		              mov    a,r0
 2225: 1  06BF	54 0F		              anl    a,#00fh
 2226: 1  06C1	F8		              mov    r0,a
 2227: 1  06C2	E5 F0		              mov    a,b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2228: 1  06C4	28		              add    a,r0                 ;eenheden er bijtellen
 2229: 1  06C5	F8		              mov    r0,a
 2230: 1
 2231: 1  06C6	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2232: 1  06C8	12 07 C9	              lcall  magsig8              ;omzetten naar 2's complement
 2233: 1
 2234: 1  06CB	D0 F0		              pop    b
 2235: 1  06CD	D0 D0		              pop    psw
 2236: 1  06CF	C2 D7		              clr    cy                   ;geen fout
 2237: 1  06D1	D0 E0		              pop    acc
 2238: 1  06D3	22		              ret
 2239: 1
 2240: 1  06D4	D0 F0		bcdhex82:     pop    b
 2241: 1  06D6	D0 D0		              pop    psw
 2242: 1  06D8	D2 D7		              setb   cy                   ;fout! r0 out of range
 2243: 1  06DA	D0 E0		              pop    acc
 2244: 1  06DC	22		              ret
 2245: 1
 2246: 1			;*******************************************************************************
 2247: 1			;
 2248: 1			; hexbcd8     (38,4us @16.777216MHz)
 2249: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2250: 1			; naar een 8bit bcd getal.
 2251: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2252: 1			; bcdgetal van 00h tot +99h.
 2253: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2254: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2255: 1			; bcdgetal 00h tot -99h
 2256: 1			;
 2257: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2258: 1			;
 2259: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2260: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2261: 1			;             cy=1 bij out of range van r0
 2262: 1			;             cy=0 bij conversie ok
 2263: 1			; vernietigt: niets
 2264: 1			;*******************************************************************************
 2265: 1  06DD	C0 E0		hexbcd8:        push    acc             ;registers bewaren
 2266: 1  06DF	C0 D0		                push    psw
 2267: 1  06E1	C0 F0		                push    b
 2268: 1  06E3	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2269: 1  06E4	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2270: 1  06E7	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2271: 1  06E9	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2272: 1  06EC	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2273: 1  06EE	D0 F0		                pop     b
 2274: 1  06F0	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2275: 1  06F2	D3		                setb    c
 2276: 1  06F3	D0 E0		                pop     acc
 2277: 1  06F5	22		                ret
 2278: 1  06F6	12 08 91	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2279: 1  06F9	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2280: 1  06FA	75 F0 0A	                mov     b,#10
 2281: 1  06FD	84		                div     ab
 2282: 1  06FE	C4		                swap    a
 2283: 1  06FF	25 F0		                add     a,b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2284: 1  0701	F8		                mov     r0,a
 2285: 1  0702	D0 F0		                pop     b               ;registers herstellen
 2286: 1  0704	D0 E0		                pop     acc             ;psw van stack halen
 2287: 1  0706	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2288: 1  0708	92 E5		                mov     acc.5,c
 2289: 1  070A	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2290: 1  070C	C3		                clr     c               ;status: conversie ok
 2291: 1  070D	D0 E0		                pop     acc
 2292: 1  070F	22		                ret
 2293: 1
 2294: 1
 2295: 1
 2296: 1			;*******************************************************************************
 2297: 1			;
 2298: 1			; bcdhex16    (86,6us @16.777216MHz)
 2299: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2300: 1			; omzetten naar een 2's complement hex getal.
 2301: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2302: 1			; naareen waarde 0000h tot 270fh.
 2303: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2304: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2305: 1			; van -270fh).
 2306: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2307: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2308: 1			; output:     R1,R0 = 2's complement waarde
 2309: 1			;             cy=1 bij out of range van r1,r0
 2310: 1			;             cy=0 bij conversie ok
 2311: 1			; vernietigt: niets
 2312: 1			;*******************************************************************************
 2313: 1  0710	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2314: 1  0712	C0 D0		              push   psw
 2315: 1  0714	C0 F0		              push   b
 2316: 1
 2317: 1  0716	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2318: 1  0717	F5 F0		              mov    b,a
 2319: 1  0719	54 0F		              anl    a,#0fh
 2320: 1  071B	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2321: 1  071E	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error
 2322: 1  0720	E5 F0		              mov    a,b
 2323: 1  0722	54 F0		              anl    a,#0f0h
 2324: 1  0724	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2325: 1  0727	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2326: 1  0729	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2327: 1  072A	F5 F0		              mov    b,a
 2328: 1  072C	54 0F		              anl    a,#0fh
 2329: 1  072E	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2330: 1  0731	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2331: 1  0733	E5 F0		              mov    a,b
 2332: 1  0735	54 F0		              anl    a,#0f0h
 2333: 1  0737	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2334: 1  073A	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2335: 1
 2336: 1  073C	E8		              mov    a,r0                  ;neem low byte voor conversie
 2337: 1  073D	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2338: 1  073F	C0 E0		              push   acc                   ;en even bewaren
 2339: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2340: 1  0741	E8		              mov    a,r0
 2341: 1  0742	C4		              swap   a
 2342: 1  0743	54 0F		              anl    a,#00fh              ;tientallen
 2343: 1  0745	75 F0 0A	              mov    b,#00ah              ;maal tien
 2344: 1  0748	A4		              mul    ab                   ;
 2345: 1  0749	D0 F0		              pop    b                    ;neem eenheden
 2346: 1  074B	25 F0		              add    a,b                  ;tel bij tientallen
 2347: 1  074D	C0 E0		              push   acc                  ;weer bewaren
 2348: 1
 2349: 1  074F	E9		              mov    a,r1                 ;neem high byte voor conversie
 2350: 1  0750	54 F0		              anl    a,#0f0h
 2351: 1  0752	C4		              swap   a
 2352: 1  0753	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2353: 1
 2354: 1  0755	E9		              mov    a,r1                  ;neem high byte voor conversie
 2355: 1  0756	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2356: 1  0758	75 F0 64	              mov    b,#100d              ;en maal honderd
 2357: 1  075B	A4		              mul    ab
 2358: 1  075C	A9 F0		              mov    r1,b
 2359: 1  075E	F8		              mov    r0,a
 2360: 1
 2361: 1  075F	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2362: 1  0761	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2363: 1  0764	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2364: 1  0765	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2365: 1  0768	A4		              mul    ab
 2366: 1  0769	28		              add    a,r0                 ;tel honderdtallen bij de
 2367: 1  076A	F8		              mov    r0,a                 ;duizendtallen
 2368: 1  076B	E9		              mov    a,r1
 2369: 1  076C	35 F0		              addc   a,b
 2370: 1  076E	F9		              mov    r1,a
 2371: 1
 2372: 1  076F	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2373: 1  0771	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2374: 1  0772	F8		              mov    r0,a                 ;duizendtallen
 2375: 1  0773	74 00		              mov    a,#000h
 2376: 1  0775	39		              addc   a,r1
 2377: 1  0776	F9		              mov    r1,a                 ;omzetting klaar
 2378: 1
 2379: 1  0777	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2380: 1  0779	12 07 FD	              lcall  magsig16             ;omzetten naar 2's complement
 2381: 1
 2382: 1  077C	D0 F0		              pop    b
 2383: 1  077E	D0 D0		              pop    psw
 2384: 1  0780	C2 D7		              clr    cy                   ;geen fout
 2385: 1  0782	D0 E0		              pop    acc
 2386: 1  0784	22		              ret
 2387: 1
 2388: 1  0785	D0 F0		bcdhex162:    pop    b
 2389: 1  0787	D0 D0		              pop    psw
 2390: 1  0789	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2391: 1  078B	D0 E0		              pop    acc
 2392: 1  078D	22		              ret
 2393: 1
 2394: 1			;*******************************************************************************
 2395: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2396: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2397: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2398: 1			; naar een 24bit bcd getal.
 2399: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2400: 1			; bcdgetal van 000000h tot +032767h.
 2401: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2402: 1			; naar een bcdgetal 000000h tot -032768h
 2403: 1			;
 2404: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2405: 1			;
 2406: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2407: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2408: 1			;
 2409: 1			; vernietigt: niets
 2410: 1			;*******************************************************************************
 2411: 1			;
 2412: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2413: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2414: 1			; naar een 24bit bcd getal.
 2415: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2416: 1			; bcdgetal van 000000h tot 065535h.
 2417: 1			;
 2418: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2419: 1			;
 2420: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2421: 1			;
 2422: 1			; vernietigt: niets
 2423: 1			;*******************************************************************************
 2424: 1  078E	12 08 C3	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2425: 1  0791	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2426: 1  0793	C0 D0		                push   psw
 2427: 1  0795	C0 F0		                push   b
 2428: 1  0797	C0 82		                push   dpl
 2429: 1
 2430: 1  0799	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2431: 1  079C	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2432: 1  079E	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2433: 1  07A0	12 0C 72	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4
 2434: 1  07A3	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2435: 1  07A4	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2436: 1			                                        ;dus eerst eenheden, dan tientallen
 2437: 1			                                        ;honderdtallen, duizendtallen en
 2438: 1			                                        ;tienduizendtallen
 2439: 1  07A6	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2440: 1
 2441: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2442: 1
 2443: 1  07A9	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2444: 1  07AB	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2445: 1  07AC	D0 E0		                pop    acc              ;duizendtallen ophalen
 2446: 1  07AE	C4		                swap   a                ;en combineren met de
 2447: 1  07AF	F5 82		                mov    dpl,a
 2448: 1  07B1	D0 E0		                pop    acc              ;honderdtallen van de stack
 2449: 1  07B3	25 82		                add    a,dpl
 2450: 1  07B5	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2451: 1  07B6	D0 E0		                pop    acc              ;tientallen van de stack halen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2452: 1  07B8	C4		                swap   a
 2453: 1  07B9	F5 82		                mov    dpl,a
 2454: 1  07BB	D0 E0		                pop    acc              ;en combineren met de eenheden
 2455: 1  07BD	25 82		                add    a,dpl
 2456: 1  07BF	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2457: 1
 2458: 1  07C0	D0 82		                pop    dpl              ;registers herstellen
 2459: 1  07C2	D0 F0		                pop    b
 2460: 1  07C4	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2461: 1  07C6	D0 E0		                pop    acc
 2462: 1  07C8	22		                ret
 2463: 1
 2464: 1			;*******************************************************************************
 2465: 1			; magsig8        (13,6us @16.777216MHz)
 2466: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2467: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2468: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2469: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2470: 1			;           (f0 en f1 zijn 1 als negatief)
 2471: 1			;
 2472: 1			; output:   r0 = 2's complement
 2473: 1			;
 2474: 1			; vernietigt: niets
 2475: 1			;*******************************************************************************
 2476: 1
 2477: 1  07C9	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2478: 1  07CB	C0 D0		               push   psw
 2479: 1  07CD	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2480: 1  07D0	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2481: 1  07D3	80 09		               sjmp   magsig8c
 2482: 1
 2483: 1  07D5	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2484: 1  07D8	80 04		               sjmp   magsig8c
 2485: 1
 2486: 1  07DA	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2487: 1  07DB	F4		               cpl    a                  ;complementeer abs waarde
 2488: 1  07DC	04		               inc    a                  ;r0 = complement(r0)+1
 2489: 1  07DD	F8		               mov    r0,a               ;bewaar in 2's complement
 2490: 1  07DE	D0 D0		magsig8c:      pop    psw
 2491: 1  07E0	D0 E0		               pop    acc
 2492: 1  07E2	22		               ret                        ;klaar
 2493: 1
 2494: 1			;*******************************************************************************
 2495: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2496: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2497: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2498: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2499: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2500: 1			;           (f0 en f1 zijn 1 als negatief)
 2501: 1			;
 2502: 1			; output:   r4 = 2's complement
 2503: 1			;
 2504: 1			; vernietigt: niets
 2505: 1			;*******************************************************************************
 2506: 1
 2507: 1  07E3	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2508: 1  07E5	C0 D0		               push    psw
 2509: 1  07E7	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2510: 1  07EA	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2511: 1  07ED	80 EF		               sjmp    magsig8c
 2512: 1
 2513: 1  07EF	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2514: 1  07F2	80 04		               sjmp    magsig8acc1c
 2515: 1
 2516: 1  07F4	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2517: 1  07F5	F4		               cpl     a                 ;complementeer abs waarde
 2518: 1  07F6	04		               inc     a                 ;r4 = complement(r0)+1
 2519: 1  07F7	FC		               mov     r4,a              ;bewaar in 2's complement
 2520: 1  07F8	D0 D0		magsig8acc1c:  pop     psw
 2521: 1  07FA	D0 E0		               pop     acc
 2522: 1  07FC	22		               ret                       ;klaar
 2523: 1
 2524: 1			;*******************************************************************************
 2525: 1			; magsig16        (16,6us @16.777216MHz)
 2526: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2527: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2528: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2529: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2530: 1			;           (f0 en f1 zijn 1 als negatief)
 2531: 1			;
 2532: 1			; output:   r1,r0 = 2's complement
 2533: 1			;
 2534: 1			; vernietigt: niets
 2535: 1			;*******************************************************************************
 2536: 1  07FD	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2537: 1  07FF	C0 D0		               push    psw
 2538: 1  0801	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2539: 1  0804	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2540: 1  0807	80 0F		               sjmp    magsig16c
 2541: 1
 2542: 1  0809	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2543: 1  080C	80 0A		               sjmp    magsig16c
 2544: 1
 2545: 1  080E	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is
 2546: 1  080F	F4		               cpl     a                ;complementeer het dan
 2547: 1  0810	24 01		               add     a, #1            ;en tel er 1 bij
 2548: 1  0812	F8		               mov     r0,a
 2549: 1  0813	E9		               mov     a,r1             ;neem volgende byte
 2550: 1  0814	F4		               cpl     a                ;complementeer en tel carry erbij
 2551: 1  0815	34 00		               addc    a,#0
 2552: 1  0817	F9		               mov     r1,a
 2553: 1  0818	D0 D0		magsig16c:     pop     psw
 2554: 1  081A	D0 E0		               pop     acc
 2555: 1  081C	22		               ret
 2556: 1
 2557: 1			;*******************************************************************************
 2558: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2559: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2560: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2561: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2562: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2563: 1			;           (f0 en f1 zijn 1 als negatief)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2564: 1			;
 2565: 1			; output:   r5,r4 = 2's complement
 2566: 1			;
 2567: 1			; vernietigt: niets
 2568: 1			;*******************************************************************************
 2569: 1  081D	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2570: 1  081F	C0 D0		                push    psw
 2571: 1  0821	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2572: 1  0824	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2573: 1  0827	80 0F		                sjmp    magsig16acc1c
 2574: 1
 2575: 1  0829	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2576: 1  082C	80 0A		                sjmp    magsig16acc1c
 2577: 1
 2578: 1  082E	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2579: 1  082F	F4		                cpl     a                   ;complementeer het dan
 2580: 1  0830	24 01		                add     a,#1                ;en tel er 1 bij
 2581: 1  0832	FC		                mov     r4,a
 2582: 1  0833	ED		                mov     a,r5                ;neem volgende byte
 2583: 1  0834	F4		                cpl     a                   ;complementeer en tel carry erbij
 2584: 1  0835	34 00		                addc    a,#0
 2585: 1  0837	FD		                mov     r5,a
 2586: 1  0838	D0 D0		magsig16acc1c:  pop     psw
 2587: 1  083A	D0 E0		                pop     acc
 2588: 1  083C	22		                ret
 2589: 1
 2590: 1			;*******************************************************************************
 2591: 1			; magsig32        (22,2us @16.777216MHz)
 2592: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2593: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2594: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2595: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2596: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2597: 1			;           (f0 en f1 zijn 1 als negatief)
 2598: 1			;
 2599: 1			; output:   r3,r2,r1,r0 = 2's complement
 2600: 1			;
 2601: 1			; vernietigt: niets
 2602: 1			;*******************************************************************************
 2603: 1  083D	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2604: 1  083F	C0 D0		               push    psw
 2605: 1  0841	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2606: 1  0844	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2607: 1  0847	80 19		               sjmp    magsig32c
 2608: 1
 2609: 1  0849	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2610: 1  084C	80 14		               sjmp    magsig32c
 2611: 1
 2612: 1  084E	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2613: 1  084F	F4		               cpl     a                 ;complementeer het dan
 2614: 1  0850	24 01		               add     a,#1             ;en tel er 1 bij
 2615: 1  0852	F8		               mov     r0,a
 2616: 1  0853	E9		               mov     a,r1             ;neem volgende byte
 2617: 1  0854	F4		               cpl     a                 ;complementeer en tel carry erbij
 2618: 1  0855	34 00		               addc    a,#0
 2619: 1  0857	F9		               mov     r1,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2620: 1  0858	EA		               mov     a,r2            ;neem volgende byte
 2621: 1  0859	F4		               cpl     a                ;complementeer en tel carry erbij
 2622: 1  085A	34 00		               addc    a,#0
 2623: 1  085C	FA		               mov     r2,a
 2624: 1  085D	EB		               mov     a,r3            ;neem volgende byte
 2625: 1  085E	F4		               cpl     a                ;complementeer en tel carry erbij
 2626: 1  085F	34 00		               addc    a,#0
 2627: 1  0861	FB		               mov     r3,a
 2628: 1
 2629: 1  0862	D0 D0		magsig32c:     pop     psw
 2630: 1  0864	D0 E0		               pop     acc
 2631: 1  0866	22		               ret
 2632: 1
 2633: 1
 2634: 1
 2635: 1			;*******************************************************************************
 2636: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2637: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2638: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2639: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2640: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2641: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2642: 1			;           (f0 en f1 zijn 1 als negatief)
 2643: 1			;
 2644: 1			; output:   r7,r6,r5,r4 = 2's complement
 2645: 1			;
 2646: 1			; vernietigt: niets
 2647: 1			;*******************************************************************************
 2648: 1  0867	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2649: 1  0869	C0 D0		               push    psw
 2650: 1  086B	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2651: 1  086E	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2652: 1  0871	80 19		               sjmp    magsig32acc1c
 2653: 1
 2654: 1  0873	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2655: 1  0876	80 14		               sjmp    magsig32acc1c
 2656: 1
 2657: 1  0878	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is
 2658: 1  0879	F4		               cpl     a                 ;complementeer het dan
 2659: 1  087A	24 01		               add     a,#1             ;en tel er 1 bij
 2660: 1  087C	FC		               mov     r4,a
 2661: 1  087D	ED		               mov     a,r5             ;neem volgende byte
 2662: 1  087E	F4		               cpl     a                 ;complementeer en tel carry erbij
 2663: 1  087F	34 00		               addc    a,#0
 2664: 1  0881	FD		               mov     r5,a
 2665: 1  0882	EE		               mov     a,r6             ;neem volgende byte
 2666: 1  0883	F4		               cpl     a                 ;complementeer en tel carry erbij
 2667: 1  0884	34 00		               addc    a,#0
 2668: 1  0886	FE		               mov     r6,a
 2669: 1  0887	EF		               mov     a,r7             ;neem volgende byte
 2670: 1  0888	F4		               cpl     a                ;complementeer en tel carry erbij
 2671: 1  0889	34 00		               addc    a,#0
 2672: 1  088B	FF		               mov     r7,a
 2673: 1
 2674: 1  088C	D0 D0		magsig32acc1c: pop     psw
 2675: 1  088E	D0 E0		               pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2676: 1  0890	22		               ret
 2677: 1
 2678: 1
 2679: 1			;*******************************************************************************
 2680: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2681: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2682: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2683: 1			; input:     r0 = 2's complement byte in acc0
 2684: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2685: 1			; output:    r0 = absolute waarde
 2686: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2687: 1			;
 2688: 1			; vernietigt: niets
 2689: 1			;*******************************************************************************
 2690: 1
 2691: 1  0891	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2692: 1  0893	C0 D0		                push    psw
 2693: 1  0895	E8		                mov     a,r0               ;neem lsb van acc0
 2694: 1  0896	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2695: 1  0899	D0 D0		                pop     psw
 2696: 1  089B	C2 D5		                clr     f0                 ;nee, positief...klaar
 2697: 1  089D	D0 E0		                pop     acc
 2698: 1  089F	22		                ret
 2699: 1  08A0	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2700: 1  08A1	04		                inc     a                   ;een erbij
 2701: 1  08A2	F8		                mov     r0,a               ;bewaar
 2702: 1  08A3	D0 D0		                pop     psw
 2703: 1  08A5	D2 D5		                setb    f0                 ;f0=1 als negatief
 2704: 1  08A7	D0 E0		                pop     acc
 2705: 1  08A9	22		                ret
 2706: 1
 2707: 1			;*******************************************************************************
 2708: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2709: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2710: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2711: 1			; input:     r4 = 2's complement byte in acc1
 2712: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2713: 1			; output:    r4 = absolute waarde
 2714: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2715: 1			;
 2716: 1			; vernietigt: niets
 2717: 1			;*******************************************************************************
 2718: 1
 2719: 1  08AA	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2720: 1  08AC	C0 D0		                push    psw
 2721: 1  08AE	EC		                mov     a,r4               ;neem lsb van acc0
 2722: 1  08AF	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2723: 1  08B2	D0 D0		                pop     psw
 2724: 1  08B4	C2 D1		                clr     f1                 ;nee, positief...klaar
 2725: 1  08B6	D0 E0		                pop     acc
 2726: 1  08B8	22		                ret
 2727: 1  08B9	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2728: 1  08BA	04		                inc     a                   ;een erbij
 2729: 1  08BB	FC		                mov     r4,a               ;bewaar
 2730: 1  08BC	D0 D0		                pop     psw
 2731: 1  08BE	D2 D1		                setb    f1                 ;f0=1 als negatief

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2732: 1  08C0	D0 E0		                pop     acc
 2733: 1  08C2	22		                ret
 2734: 1
 2735: 1			;*******************************************************************************
 2736: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2737: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2738: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2739: 1			; input:     r1,r0 = 2's complement word in acc0
 2740: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2741: 1			; output:    r1,r0 = absolute waarde
 2742: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2743: 1			;
 2744: 1			; vernietigt: niets
 2745: 1			;*******************************************************************************
 2746: 1
 2747: 1  08C3	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2748: 1  08C5	C0 D0		                push    psw
 2749: 1  08C7	E9		                mov     a,r1               ; neem msb van acc0
 2750: 1  08C8	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2751: 1  08CB	D0 D0		                pop     psw
 2752: 1  08CD	C2 D5		                clr     f0                 ;f0=0 als positief
 2753: 1  08CF	D0 E0		                pop     acc
 2754: 1  08D1	22		                ret                        ;klaar
 2755: 1
 2756: 1  08D2	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2757: 1  08D3	F4		                cpl     a                  ;complementeren
 2758: 1  08D4	24 01		                add     a,#1               ;en een bijtellen
 2759: 1  08D6	F8		                mov     r0,a
 2760: 1  08D7	E9		                mov     a,r1
 2761: 1  08D8	F4		                cpl     a                  ;complement eer volgende byte
 2762: 1  08D9	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2763: 1  08DB	F9		                mov     r1,a
 2764: 1  08DC	D0 D0		                pop     psw
 2765: 1  08DE	D2 D5		                setb    f0                 ;f0=1 als negatief
 2766: 1  08E0	D0 E0		                pop     acc
 2767: 1  08E2	22		                ret
 2768: 1
 2769: 1
 2770: 1			;*******************************************************************************
 2771: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2772: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2773: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2774: 1			; input:     r5,r4 = 2's complement word in acc1
 2775: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2776: 1			; output:    r5,r4 = absolute waarde
 2777: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2778: 1			;
 2779: 1			; vernietigt: niets
 2780: 1			;*******************************************************************************
 2781: 1
 2782: 1  08E3	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2783: 1  08E5	C0 D0		                push    psw
 2784: 1  08E7	ED		                mov     a,r5               ;neem msb van acc1
 2785: 1  08E8	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2786: 1  08EB	D0 D0		                pop     psw
 2787: 1  08ED	C2 D1		                clr     f1                 ;f1=0 als positief

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2788: 1  08EF	D0 E0		                pop    acc
 2789: 1  08F1	22		                ret                        ;klaar
 2790: 1
 2791: 1  08F2	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2792: 1  08F3	F4		                cpl     a                   ;complementeren
 2793: 1  08F4	24 01		                add     a,#1               ;en een bijtellen
 2794: 1  08F6	FC		                mov     r4,a
 2795: 1  08F7	ED		                mov     a,r5
 2796: 1  08F8	F4		                cpl     a                  ;complementeer volgende byte
 2797: 1  08F9	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2798: 1  08FB	FD		                mov     r5,a
 2799: 1  08FC	D0 D0		                pop     psw
 2800: 1  08FE	D2 D1		                setb    f1                ;f1=1 als negatief
 2801: 1  0900	D0 E0		                pop     acc
 2802: 1  0902	22		                ret
 2803: 1
 2804: 1
 2805: 1			;*******************************************************************************
 2806: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2807: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2808: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2809: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2810: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2811: 1			; output:    r7,r6 = absolute waarde
 2812: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2813: 1			;
 2814: 1			; vernietigt: niets
 2815: 1			;*******************************************************************************
 2816: 1
 2817: 1  0903	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2818: 1  0905	C0 D0		                push    psw
 2819: 1  0907	EF		                mov     a,r7                ; neem msb van acc1 high
 2820: 1  0908	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2821: 1  090B	D0 D0		                pop     psw
 2822: 1  090D	C2 D5		                clr     f0                  ;f0=0 als positief
 2823: 1  090F	D0 E0		                pop     acc
 2824: 1  0911	22		                ret                         ;klaar
 2825: 1
 2826: 1  0912	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2827: 1  0913	F4		                cpl     a                   ;complementeren
 2828: 1  0914	24 01		                add     a,#1               ;en een bijtellen
 2829: 1  0916	FE		                mov     r6,a
 2830: 1  0917	EF		                mov     a,r7
 2831: 1  0918	F4		                cpl     a                  ;complementeer volgende byte
 2832: 1  0919	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2833: 1  091B	FF		                mov     r7,a
 2834: 1  091C	D0 D0		                pop     psw
 2835: 1  091E	D2 D5		                setb    f0                ;f0=1 als negatief
 2836: 1  0920	D0 E0		                pop     acc
 2837: 1  0922	22		                ret
 2838: 1
 2839: 1
 2840: 1			;*******************************************************************************
 2841: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2842: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2843: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2844: 1			;
 2845: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2846: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2847: 1			;            (-2147483648 tot +2147483647)
 2848: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2849: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2850: 1			;
 2851: 1			; vernietigt: niets
 2852: 1			;*******************************************************************************
 2853: 1
 2854: 1  0923	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2855: 1  0925	C0 D0		                push    psw
 2856: 1  0927	EB		                mov     a,r3               ;neem msb van acc0
 2857: 1  0928	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2858: 1  092B	D0 D0		                pop     psw                ;nee, positief
 2859: 1  092D	C2 D5		                clr     f0
 2860: 1  092F	D0 E0		                pop     acc
 2861: 1  0931	22		                ret                        ;klaar
 2862: 1
 2863: 1  0932	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2864: 1  0933	F4		                cpl     a                  ;complementeren
 2865: 1  0934	24 01		                add     a,#1               ;en een bijtellen
 2866: 1  0936	F8		                mov     r0,a
 2867: 1  0937	E9		                mov     a,r1               ;neem volgende byte
 2868: 1  0938	F4		                cpl     a                  ;complementeer volgende byte
 2869: 1  0939	34 00		                addc    a,#0
 2870: 1  093B	F9		                mov     r1,a
 2871: 1  093C	EA		                mov     a,r2               ;neem volgende byte
 2872: 1  093D	F4		                cpl     a                  ;complementeer volgende byte
 2873: 1  093E	34 00		                addc    a,#0
 2874: 1  0940	FA		                mov     r2,a
 2875: 1  0941	EB		                mov     a,r3               ;neem volgende byte
 2876: 1  0942	F4		                cpl     a                  ;complementeer volgende byte
 2877: 1  0943	34 00		                addc    a,#0
 2878: 1  0945	FB		                mov     r3,a
 2879: 1  0946	D0 D0		                pop     psw
 2880: 1  0948	D2 D5		                setb    f0                 ;negatief: f0=1
 2881: 1  094A	D0 E0		                pop     acc
 2882: 1  094C	22		                ret                        ;klaar
 2883: 1
 2884: 1			;*******************************************************************************
 2885: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2886: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2887: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2888: 1			;
 2889: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2890: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2891: 1			;            (-2147483648 tot +2147483647)
 2892: 1			; output:    r7,r6,r5,r4 = absolute waarde
 2893: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2894: 1			;
 2895: 1			; vernietigt: niets
 2896: 1			;*******************************************************************************
 2897: 1
 2898: 1  094D	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2899: 1  094F	C0 D0		                push    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2900: 1  0951	EF		                mov     a,r7               ;neem msb van acc0
 2901: 1  0952	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2902: 1  0955	D0 D0		                pop     psw                ;nee, positief
 2903: 1  0957	C2 D1		                clr     f1
 2904: 1  0959	D0 E0		                pop     acc
 2905: 1  095B	22		                ret                        ;klaar
 2906: 1
 2907: 1  095C	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2908: 1  095D	F4		                cpl     a                   ;complementeren
 2909: 1  095E	24 01		                add     a,#1               ;en een bijtellen
 2910: 1  0960	FC		                mov     r4,a
 2911: 1  0961	ED		                mov     a,r5               ;neem volgende byte
 2912: 1  0962	F4		                cpl     a                  ;complementeer volgende byte
 2913: 1  0963	34 00		                addc    a,#0
 2914: 1  0965	FD		                mov     r5,a
 2915: 1  0966	EE		                mov     a,r6               ;neem volgende byte
 2916: 1  0967	F4		                cpl     a                  ;complementeer volgende byte
 2917: 1  0968	34 00		                addc    a,#0
 2918: 1  096A	FE		                mov     r6,a
 2919: 1  096B	EF		                mov     a,r7               ;neem volgende byte
 2920: 1  096C	F4		                cpl     a                  ;complementeer volgende byte
 2921: 1  096D	34 00		                addc    a,#0
 2922: 1  096F	FF		                mov     r7,a
 2923: 1  0970	D0 D0		                pop     psw
 2924: 1  0972	D2 D1		                setb    f1                 ;negatief: f0=1
 2925: 1  0974	D0 E0		                pop     acc
 2926: 1  0976	22		                ret                        ;klaar
 2927: 1
 2928: 1
 2929: 1			;*******************************************************************************
 2930: 1			; s_add16        (19,35us @16.777216MHz)
 2931: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2932: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2933: 1			; input:     r1,r0 = acc0
 2934: 1			;            r5,r4 = acc1
 2935: 1			;
 2936: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2937: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2938: 1			;                  gebruik van r3,r2 is niet nodig
 2939: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2940: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2941: 1			;
 2942: 1			; vernietigt:  niets
 2943: 1			;*******************************************************************************
 2944: 1  0977	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2945: 1  0979	C0 D0		               push    psw
 2946: 1
 2947: 1  097B	E8		               mov     a,r0           ;tel de soft accumulators op
 2948: 1  097C	2C		               add     a,r4           ;low byte eerst
 2949: 1  097D	F8		               mov     r0,a           ;resultaat bewaren
 2950: 1  097E	E9		               mov     a,r1           ;nu de high bytes
 2951: 1  097F	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2952: 1  0980	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2953: 1
 2954: 1  0981	92 D5		               mov     f0,c
 2955: 1  0983	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2956: 1  0985	92 D1		               mov     f1,c
 2957: 1  0987	A2 D5		               mov     c,f0           ;herstel carrybit
 2958: 1
 2959: 1  0989	74 00		               mov     a,#00h
 2960: 1  098B	34 00		               addc    a,#00h
 2961: 1  098D	FA		               mov     r2,a            ;24bit resultaat klaar
 2962: 1
 2963: 1  098E	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2964: 1
 2965: 1  0991	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2966: 1  0992	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2967: 1  0995	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 2968: 1  0997	7B FF		               mov     r3,#0ffh
 2969: 1  0999	80 04		               sjmp    s_add162
 2970: 1  099B	7A 00		s_add161:      mov     r2,#00h
 2971: 1  099D	7B 00		               mov     r3,#00h
 2972: 1  099F	D0 D0		s_add162:      pop     psw
 2973: 1  09A1	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2974: 1  09A2	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2975: 1  09A4	22		               ret
 2976: 1
 2977: 1  09A5	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2978: 1  09A7	C3		               clr     c
 2979: 1  09A8	D0 E0		               pop     acc
 2980: 1  09AA	22		               ret
 2981: 1
 2982: 1			;*******************************************************************************
 2983: 1			; add16        (13,6us @16.777216MHz)
 2984: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2985: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2986: 1			; input:     r1,r0 = acc0
 2987: 1			;            r5,r4 = acc1
 2988: 1			;
 2989: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2990: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 2991: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2992: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 2993: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de
 2994: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 2995: 1			;
 2996: 1			; vernietigt:  niets
 2997: 1			;*******************************************************************************
 2998: 1
 2999: 1  09AB	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 3000: 1  09AD	C0 D0		               push    psw
 3001: 1  09AF	E8		               mov     a,r0           ;tel de soft accumulators op
 3002: 1  09B0	2C		               add     a,r4           ;low byte eerst
 3003: 1  09B1	F8		               mov     r0,a           ;resultaat bewaren
 3004: 1  09B2	E9		               mov     a,r1           ;nu de high bytes
 3005: 1  09B3	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3006: 1  09B4	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3007: 1  09B5	50 08		               jnc     add161          ;geen 24 bit resultaat
 3008: 1
 3009: 1  09B7	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 3010: 1  09B9	D0 D0		               pop     psw
 3011: 1  09BB	D3		               setb    c               ;aangeven aan de gebruiker dat het

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3012: 1  09BC	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 3013: 1  09BE	22		               ret
 3014: 1
 3015: 1  09BF	7A 00		add161:        mov     r2,#00h
 3016: 1  09C1	D0 D0		               pop     psw
 3017: 1  09C3	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3018: 1  09C4	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 3019: 1  09C6	22		               ret
 3020: 1
 3021: 1			;*******************************************************************************
 3022: 1			; s_add32        (28,0us @16.777216MHz)
 3023: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 3024: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3025: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3026: 1			; input:     r3,r2,r1,r0 = acc0
 3027: 1			;            r7,r6,r5,r4 = acc1
 3028: 1			;
 3029: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 3030: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3031: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 3032: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3033: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3034: 1			;
 3035: 1			; vernietigt:  niets
 3036: 1			;*******************************************************************************
 3037: 1  09C7	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 3038: 1  09C9	C0 D0		               push    psw
 3039: 1
 3040: 1  09CB	E8		               mov     a,r0           ;tel de soft accumulators op
 3041: 1  09CC	2C		               add     a,r4           ;low byte eerst
 3042: 1  09CD	F8		               mov     r0,a           ;resultaat bewaren
 3043: 1  09CE	E9		               mov     a,r1           ;nu de hogere bytes
 3044: 1  09CF	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3045: 1  09D0	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3046: 1
 3047: 1  09D1	EA		               mov     a,r2           ;derde bytes optellen
 3048: 1  09D2	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3049: 1  09D3	FA		               mov     r2,a           ;24bit resultaat is klaar
 3050: 1  09D4	EB		               mov     a,r3           ;nu de ms bytes
 3051: 1  09D5	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3052: 1  09D6	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3053: 1
 3054: 1  09D7	92 D5		               mov     f0,c
 3055: 1  09D9	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 3056: 1  09DB	92 D1		               mov     f1,c
 3057: 1  09DD	A2 D5		               mov     c,f0           ;herstel carrybit
 3058: 1
 3059: 1  09DF	74 00		               mov     a,#00h
 3060: 1  09E1	34 00		               addc    a,#00h
 3061: 1  09E3	FC		               mov     r4,a            ;40bit resultaat klaar
 3062: 1
 3063: 1  09E4	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 3064: 1  09E7	EC		               mov     a,r4            ;ja, sign extention toepassen!
 3065: 1  09E8	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 3066: 1  09EB	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3067: 1  09ED	80 02		               sjmp    s_add322

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3068: 1  09EF	7C 00		s_add321:      mov     r4,#00h
 3069: 1  09F1	D0 D0		s_add322:      pop     psw
 3070: 1  09F3	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3071: 1  09F4	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 3072: 1  09F6	22		               ret
 3073: 1
 3074: 1  09F7	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 3075: 1  09F9	C3		               clr     c
 3076: 1  09FA	D0 E0		               pop     acc
 3077: 1  09FC	22		               ret
 3078: 1
 3079: 1
 3080: 1			;*******************************************************************************
 3081: 1			; add32        (18,0us @16.777216MHz)
 3082: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 3083: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3084: 1			; input:     r3,r2,r1,r0 = acc0
 3085: 1			;            r7,r6,r5,r4 = acc1
 3086: 1			;
 3087: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 3088: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3089: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3090: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 3091: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3092: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3093: 1			;
 3094: 1			; vernietigt:  niets
 3095: 1			;*******************************************************************************
 3096: 1  09FD	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 3097: 1  09FF	C0 D0		               push    psw
 3098: 1  0A01	E8		               mov     a,r0           ;tel de soft accumulators op
 3099: 1  0A02	2C		               add     a,r4           ;low byte eerst
 3100: 1  0A03	F8		               mov     r0,a           ;resultaat bewaren
 3101: 1  0A04	E9		               mov     a,r1           ;nu de hogere bytes
 3102: 1  0A05	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3103: 1  0A06	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3104: 1
 3105: 1  0A07	EA		               mov     a,r2           ;derde bytes optellen
 3106: 1  0A08	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3107: 1  0A09	FA		               mov     r2,a           ;24bit resultaat is klaar
 3108: 1  0A0A	EB		               mov     a,r3           ;nu de ms bytes
 3109: 1  0A0B	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3110: 1  0A0C	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3111: 1
 3112: 1  0A0D	50 08		               jnc     add321          ;geen 40 bit resultaat
 3113: 1
 3114: 1  0A0F	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3115: 1  0A11	D0 D0		               pop     psw
 3116: 1  0A13	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3117: 1  0A14	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3118: 1  0A16	22		               ret
 3119: 1
 3120: 1  0A17	7C 00		add321:        mov     r4,#00h
 3121: 1  0A19	D0 D0		               pop     psw
 3122: 1  0A1B	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3123: 1  0A1C	D0 E0		               pop     acc             ;resultaat 32 bits groot is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3124: 1  0A1E	22		               ret
 3125: 1
 3126: 1
 3127: 1			;*******************************************************************************
 3128: 1			; s_sub16        (24,4us @16.777216MHz)
 3129: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3130: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3131: 1			; input:     r1,r0 = acc0
 3132: 1			;            r5,r4 = acc1
 3133: 1			;
 3134: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3135: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3136: 1			;                  gebruik van r3,r2 is niet nodig
 3137: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3138: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3139: 1			;
 3140: 1			; vernietigt:  niets
 3141: 1			;*******************************************************************************
 3142: 1  0A1F	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3143: 1  0A21	C0 D0		                push    psw
 3144: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3145: 1
 3146: 1  0A23	EC		                mov   	a,r4            ;verander het teken van acc1
 3147: 1  0A24	F4		                cpl    	a               ;door het 2's complement te nemen
 3148: 1  0A25	24 01		                add   	a,#1
 3149: 1  0A27	FC		                mov    	r4,a
 3150: 1  0A28	ED		                mov    	a,r5
 3151: 1  0A29	F4		                cpl    	a
 3152: 1  0A2A	34 00		                addc	a,#0
 3153: 1  0A2C	FD		                mov    	r5,a
 3154: 1			;acc0+acc1
 3155: 1  0A2D	E8						mov		a,r0
 3156: 1  0A2E	2C						add		a,r4
 3157: 1  0A2F	F8						mov		r0,a
 3158: 1  0A30	E9						mov		a,r1
 3159: 1  0A31	3D						addc	a,r5
 3160: 1  0A32	F9						mov		r1,a
 3161: 1
 3162: 1  0A33	92 D5		                mov    f0,c
 3163: 1  0A35	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3164: 1  0A37	92 D1		                mov    f1,c
 3165: 1  0A39	A2 D5		                mov    c,f0            ;herstel carrybit
 3166: 1
 3167: 1  0A3B	74 00		                mov    a,#00h
 3168: 1  0A3D	34 00		                addc   a,#00h
 3169: 1  0A3F	FA		                mov    r2,a            ;24bit resultaat klaar
 3170: 1
 3171: 1  0A40	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3172: 1  0A43	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3173: 1  0A44	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3174: 1  0A47	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3175: 1  0A49	7B FF		                mov    r3,#0ffh
 3176: 1  0A4B	80 04		                sjmp   s_sub162
 3177: 1  0A4D	7A 00		s_sub161:       mov    r2,#00h
 3178: 1  0A4F	7B 00		                mov    r3,#00h
 3179: 1  0A51	D0 D0		s_sub162:       pop    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3180: 1  0A53	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3181: 1  0A54	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3182: 1  0A56	22		                ret
 3183: 1
 3184: 1  0A57	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3185: 1  0A59	C3		                clr    c
 3186: 1  0A5A	D0 E0		                pop    acc
 3187: 1  0A5C	22		                ret
 3188: 1
 3189: 1			;*******************************************************************************
 3190: 1			; sub16            (14,4us @16.777216MHz)
 3191: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3192: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3193: 1			; input:     r1,r0 = acc0
 3194: 1			;            r5,r4 = acc1
 3195: 1			;
 3196: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3197: 1			;            bij een underflow r2 op ffh zetten
 3198: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3199: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3200: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3201: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3202: 1			;
 3203: 1			; vernietigt:  niets
 3204: 1			;*******************************************************************************
 3205: 1
 3206: 1  0A5D	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3207: 1  0A5F	C0 D0		                push    psw
 3208: 1  0A61	C3		                clr     c
 3209: 1  0A62	E8		                mov     a,r0            ;tel de soft accumulators op
 3210: 1  0A63	9C		                subb    a,r4            ;low byte eerst
 3211: 1  0A64	F8		                mov     r0,a            ;resultaat bewaren
 3212: 1  0A65	E9		                mov     a,r1            ;nu de high bytes
 3213: 1  0A66	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3214: 1  0A67	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3215: 1  0A68	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3216: 1
 3217: 1  0A6A	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar
 3218: 1  0A6C	D0 D0		                pop     psw
 3219: 1  0A6E	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3220: 1  0A6F	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3221: 1  0A71	22		                ret
 3222: 1
 3223: 1  0A72	7A 00		sub161:         mov     r2,#00h
 3224: 1  0A74	D0 D0		                pop     psw
 3225: 1  0A76	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3226: 1  0A77	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3227: 1  0A79	22		                ret
 3228: 1
 3229: 1			;*******************************************************************************
 3230: 1			; s_sub32        (27,2us @16.777216MHz)
 3231: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3232: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3233: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3234: 1			; input:     r3,r2,r1,r0 = acc0
 3235: 1			;            r7,r6,r5,r4 = acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3236: 1			;
 3237: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3238: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3239: 1			;                  gebruik van r4 is niet nodig
 3240: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3241: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3242: 1			;
 3243: 1			; vernietigt:  niets
 3244: 1			;*******************************************************************************
 3245: 1  0A7A	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3246: 1  0A7C	C0 D0		                push   psw
 3247: 1
 3248: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3249: 1
 3250: 1  0A7E	EC		                mov    	a,r4            ;verander het teken van acc1
 3251: 1  0A7F	F4		                cpl    	a               ;door het 2's complement te nemen
 3252: 1  0A80	24 01		                add    	a,#1
 3253: 1  0A82	FC		                mov    	r4,a
 3254: 1  0A83	ED		                mov    	a,r5
 3255: 1  0A84	F4		                cpl    	a
 3256: 1  0A85	34 00		                addc	a,#0
 3257: 1  0A87	FD		                mov    	r5,a
 3258: 1  0A88	EE		                mov    	a,r6
 3259: 1  0A89	F4		                cpl    	a
 3260: 1  0A8A	34 00		                addc   	a,#0
 3261: 1  0A8C	FE		                mov    	r6,a
 3262: 1  0A8D	EF		                mov    	a,r7
 3263: 1  0A8E	F4		                cpl    	a
 3264: 1  0A8F	34 00		                addc   	a,#0
 3265: 1  0A91	FF		                mov    	r7,a
 3266: 1			;acc0+acc1
 3267: 1  0A92	E8						mov		a,r0
 3268: 1  0A93	2C						add		a,r4
 3269: 1  0A94	F8						mov		r0,a
 3270: 1  0A95	E9						mov		a,r1
 3271: 1  0A96	3D						addc	a,r5
 3272: 1  0A97	F9						mov		r1,a
 3273: 1  0A98	EA						mov		a,r2
 3274: 1  0A99	3E						addc	a,r6
 3275: 1  0A9A	FA						mov		r2,a
 3276: 1  0A9B	EB						mov		a,r3
 3277: 1  0A9C	3F						addc	a,r7
 3278: 1  0A9D	FB						mov		r3,a
 3279: 1
 3280: 1  0A9E	92 D5		                mov   f0,c
 3281: 1  0AA0	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3282: 1  0AA2	92 D1		                mov   f1,c
 3283: 1  0AA4	A2 D5		                mov   c,f0            ;herstel carrybit
 3284: 1
 3285: 1  0AA6	74 00		                mov   a,#00h
 3286: 1  0AA8	34 00		                addc  a,#00h
 3287: 1  0AAA	FC		                mov   r4,a            ;40bit resultaat klaar
 3288: 1
 3289: 1  0AAB	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3290: 1
 3291: 1  0AAE	EC		                mov   a,r4            ;ja, sign extention toepassen!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3292: 1  0AAF	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3293: 1  0AB2	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3294: 1  0AB4	80 02		                sjmp   s_sub322
 3295: 1  0AB6	7C 00		s_sub321:       mov   r4,#00h
 3296: 1  0AB8	D0 D0		s_sub322:       pop   psw
 3297: 1  0ABA	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3298: 1  0ABB	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3299: 1  0ABD	22		                ret
 3300: 1
 3301: 1  0ABE	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3302: 1  0AC0	C3		                clr   c
 3303: 1  0AC1	D0 E0		                pop   acc
 3304: 1  0AC3	22		                ret
 3305: 1
 3306: 1
 3307: 1			;*******************************************************************************
 3308: 1			; sub32        (18,7us @16.777216MHz)
 3309: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3310: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3311: 1			; input:     r3,r2,r1,r0 = acc0
 3312: 1			;            r7,r6,r5,r4 = acc1
 3313: 1			;
 3314: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3315: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3316: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3317: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3318: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3319: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3320: 1			;
 3321: 1			; vernietigt:  niets
 3322: 1			;*******************************************************************************
 3323: 1  0AC4	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3324: 1  0AC6	C0 D0		               push    psw
 3325: 1  0AC8	C3		               clr       c
 3326: 1  0AC9	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3327: 1  0ACA	9C		               subb    a,r4           ;low byte eerst
 3328: 1  0ACB	F8		               mov     r0,a           ;resultaat bewaren
 3329: 1  0ACC	E9		               mov     a,r1           ;nu de hogere bytes
 3330: 1  0ACD	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3331: 1  0ACE	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3332: 1
 3333: 1  0ACF	EA		               mov     a,r2           ;derde bytes optellen
 3334: 1  0AD0	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3335: 1  0AD1	FA		               mov     r2,a           ;24bit resultaat is klaar
 3336: 1  0AD2	EB		               mov     a,r3           ;nu de ms bytes
 3337: 1  0AD3	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3338: 1  0AD4	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3339: 1
 3340: 1  0AD5	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3341: 1
 3342: 1  0AD7	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3343: 1  0AD9	D0 D0		               pop     psw
 3344: 1  0ADB	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3345: 1  0ADC	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3346: 1  0ADE	22		               ret
 3347: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3348: 1  0ADF	7C 00		sub321:        mov     r4,#00h
 3349: 1  0AE1	D0 D0		               pop     psw
 3350: 1  0AE3	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3351: 1  0AE4	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3352: 1  0AE6	22		               ret
 3353: 1
 3354: 1
 3355: 1
 3356: 1			;*******************************************************************************
 3357: 1			; mul16        (71,2us @16.777216MHz)
 3358: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3359: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3360: 1			; input:     r1,r0 = acc0
 3361: 1			;            r5,r4 = acc1
 3362: 1			;
 3363: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3364: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3365: 1			;
 3366: 1			; vernietigt:  niets
 3367: 1			;*******************************************************************************
 3368: 1  0AE7	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3369: 1  0AE9	C0 D0		                push    psw
 3370: 1  0AEB	C0 F0		                push    b
 3371: 1  0AED	C0 82		                push    dpl
 3372: 1  0AEF	C0 83		                push    dph
 3373: 1
 3374: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3375: 1
 3376: 1  0AF1	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3377: 1  0AF3	89 83		                mov     dph,r1
 3378: 1  0AF5	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3379: 1  0AF7	08		                inc     r0              ;pointer naar eerste vrije plaats
 3380: 1  0AF8	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3381: 1  0AFA	E5 81		                mov     a,sp            ;plaats alloceren
 3382: 1  0AFC	24 03		                add     a,#3            ;3 bytes nodig
 3383: 1  0AFE	F5 81		                mov     sp,a            ;stackpointer verzetten
 3384: 1
 3385: 1  0B00	E5 82		                mov     a,dpl            ;acc0 lsb
 3386: 1  0B02	8C F0		                mov     b,r4            ;acc1 lsb
 3387: 1  0B04	A4		                mul     ab
 3388: 1  0B05	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3389: 1  0B06	08		                inc     r0
 3390: 1  0B07	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3391: 1
 3392: 1  0B09	E5 83		                mov     a,dph            ;acc0 msb
 3393: 1  0B0B	8C F0		                mov     b,r4            ;acc1 lsb
 3394: 1  0B0D	A4		                mul     ab
 3395: 1
 3396: 1  0B0E	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3397: 1  0B0F	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3398: 1  0B10	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3399: 1  0B12	34 00		                addc    a,#0
 3400: 1  0B14	08		                inc     r0               ;bewaar als tussenresultaat
 3401: 1  0B15	F6		                mov     @r0,a
 3402: 1
 3403: 1  0B16	E5 82		                mov     a,dpl            ;acc0 lsb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3404: 1  0B18	8D F0		                mov     b,r5             ;acc1 msb
 3405: 1  0B1A	A4		                mul     ab
 3406: 1  0B1B	18		                dec     r0
 3407: 1  0B1C	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3408: 1  0B1D	F6		                mov     @r0,a            ;en bewaar weer
 3409: 1  0B1E	08		                inc     r0
 3410: 1  0B1F	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3411: 1  0B21	36		                addc    a,@r0
 3412: 1  0B22	F6		                mov     @r0,a            ;en bewaar weer
 3413: 1  0B23	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3414: 1
 3415: 1  0B25	E5 83		                mov     a,dph            ;acc0 msb
 3416: 1  0B27	8D F0		                mov     b,r5             ;acc1 msb
 3417: 1  0B29	A4		                mul     AB
 3418: 1  0B2A	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3419: 1  0B2B	FA		                mov     r2,a
 3420: 1  0B2C	E5 F0		                mov     a,b
 3421: 1  0B2E	34 00		                addc    a,#0
 3422: 1
 3423: 1  0B30	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3424: 1  0B32	34 00		                addc    a,#0
 3425: 1
 3426: 1  0B34	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3427: 1  0B35	18		                dec     r0
 3428: 1  0B36	86 83		                mov     dph,@r0
 3429: 1  0B38	18		                dec     r0
 3430: 1  0B39	86 82		                mov     dpl,@r0
 3431: 1
 3432: 1  0B3B	89 81		                mov     sp,r1            ;zet stackpointer terug
 3433: 1  0B3D	A9 83		                mov     r1,dph
 3434: 1  0B3F	A8 82		                mov     r0,dpl
 3435: 1
 3436: 1  0B41	D0 83		                pop     dph              ;herstel de bewaarde registers
 3437: 1  0B43	D0 82		                pop     dpl
 3438: 1  0B45	D0 F0		                pop     b
 3439: 1  0B47	D0 D0		                pop     psw
 3440: 1  0B49	D0 E0		                pop     acc
 3441: 1  0B4B	22		                ret
 3442: 1
 3443: 1
 3444: 1
 3445: 1			;*******************************************************************************
 3446: 1			; mul16acc1        (71,2us @16.777216MHz)
 3447: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3448: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3449: 1			; input:     r5,r4 = acc1 low
 3450: 1			;            r7,r6 = acc1 high
 3451: 1			;
 3452: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3453: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3454: 1			;
 3455: 1			; vernietigt:  niets
 3456: 1			;*******************************************************************************
 3457: 1  0B4C	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3458: 1  0B4E	C0 D0		                push    psw
 3459: 1  0B50	C0 F0		                push    b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3460: 1  0B52	C0 82		                push    dpl
 3461: 1  0B54	C0 83		                push    dph
 3462: 1
 3463: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3464: 1
 3465: 1  0B56	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3466: 1  0B58	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3467: 1
 3468: 1  0B5A	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3469: 1  0B5C	08		                inc     r0               ;pointer naar eerste vrije plaats
 3470: 1  0B5D	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3471: 1  0B5F	E5 81		                mov     a,sp             ;plaats alloceren
 3472: 1  0B61	24 03		                add     a,#3             ;3 bytes nodig
 3473: 1  0B63	F5 81		                mov     sp,a             ;stackpointer verzetten
 3474: 1
 3475: 1  0B65	EC		                mov     a,r4             ;acc1 low lsb
 3476: 1  0B66	8E F0		                mov     b,r6             ;acc1 high lsb
 3477: 1  0B68	A4		                mul     ab
 3478: 1  0B69	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3479: 1  0B6A	08		                inc     r0
 3480: 1  0B6B	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3481: 1
 3482: 1  0B6D	ED		                mov     a,r5             ;acc1 low msb
 3483: 1  0B6E	8E F0		                mov     b,r6             ;acc1 high lsb
 3484: 1  0B70	A4		                mul     ab
 3485: 1
 3486: 1  0B71	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3487: 1  0B72	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3488: 1  0B73	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3489: 1  0B75	34 00		                addc    a,#0
 3490: 1  0B77	08		                inc     r0               ;bewaar als tussenresultaat
 3491: 1  0B78	F6		                mov     @r0,a
 3492: 1
 3493: 1  0B79	EC		                mov     a,r4             ;acc1 low lsb
 3494: 1  0B7A	8F F0		                mov     b,r7             ;acc1 high msb
 3495: 1  0B7C	A4		                mul     ab
 3496: 1  0B7D	18		                dec     r0
 3497: 1  0B7E	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3498: 1  0B7F	F6		                mov     @r0,a            ;en bewaar weer
 3499: 1  0B80	08		                inc     r0
 3500: 1  0B81	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3501: 1  0B83	36		                addc    a,@r0
 3502: 1  0B84	F6		                mov     @r0,a            ;en bewaar weer
 3503: 1  0B85	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3504: 1
 3505: 1  0B87	ED		                mov     a,r5             ;acc1 low msb
 3506: 1  0B88	8F F0		                mov     b,r7             ;acc1 high msb
 3507: 1  0B8A	A4		                mul     AB
 3508: 1
 3509: 1  0B8B	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3510: 1  0B8C	FE		                mov     r6,a             ;deze byte van product is al klaar
 3511: 1  0B8D	E5 F0		                mov     a,b
 3512: 1  0B8F	34 00		                addc    a,#0
 3513: 1  0B91	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3514: 1  0B93	34 00		                addc    a,#0
 3515: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3516: 1  0B95	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3517: 1  0B96	18		                dec     r0
 3518: 1  0B97	E6		                mov     a,@r0
 3519: 1  0B98	FD		                mov     r5,a
 3520: 1  0B99	18		                dec     r0
 3521: 1  0B9A	E6		                mov     a,@r0
 3522: 1  0B9B	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3523: 1
 3524: 1  0B9C	89 81		                mov     sp,r1            ;zet stackpointer terug
 3525: 1  0B9E	A9 83		                mov     r1,dph
 3526: 1  0BA0	A8 82		                mov     r0,dpl
 3527: 1
 3528: 1  0BA2	D0 83		                pop     dph              ;herstel de bewaarde registers
 3529: 1  0BA4	D0 82		                pop     dpl
 3530: 1  0BA6	D0 F0		                pop     b
 3531: 1  0BA8	D0 D0		                pop     psw
 3532: 1  0BAA	D0 E0		                pop     acc
 3533: 1  0BAC	22		                ret
 3534: 1
 3535: 1			;*******************************************************************************
 3536: 1			; s_mul16        (121,1us @16.777216MHz)
 3537: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3538: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3539: 1			; input:     r1,r0 = acc0
 3540: 1			;            r5,r4 = acc1
 3541: 1			;
 3542: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3543: 1			;                                  -1073709056 tot +1073741824
 3544: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3545: 1			;
 3546: 1			; vernietigt:  niets
 3547: 1			;*******************************************************************************
 3548: 1  0BAD	12 08 C3	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3549: 1  0BB0	12 08 E3	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3550: 1  0BB3	12 0A E7	                lcall    mul16           ;maak product
 3551: 1  0BB6	12 08 3D	                lcall    magsig32        ;maak 2's complement formaat
 3552: 1  0BB9	22		                ret                      ;klaar
 3553: 1
 3554: 1			;*******************************************************************************
 3555: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3556: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3557: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3558: 1			; input:     r5,r4 = acc1 low
 3559: 1			;            r7,r6 = acc1 high
 3560: 1			;
 3561: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3562: 1			;                                  -1073709056 tot +1073741824
 3563: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3564: 1			; vernietigt:  niets
 3565: 1			;*******************************************************************************
 3566: 1  0BBA	12 08 E3	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3567: 1  0BBD	12 09 03	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3568: 1  0BC0	12 0B 4C	                lcall    mul16acc1       ;maak product
 3569: 1  0BC3	12 08 67	                lcall    magsig32acc1    ;maak 2's complement formaat
 3570: 1  0BC6	22		                ret                      ;klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3571: 1
 3572: 1			;*******************************************************************************
 3573: 1			; s_mul816        (83,5us @16.777216MHz)
 3574: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3575: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3576: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3577: 1			; input:     r1,r0 = acc0
 3578: 1			;               r4 = acc1
 3579: 1			;
 3580: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3581: 1			;                                  -4194176 tot +4194304
 3582: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3583: 1			; vernietigt:  niets
 3584: 1			;*******************************************************************************
 3585: 1  0BC7	12 08 C3	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3586: 1  0BCA	12 08 AA	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3587: 1  0BCD	12 0B D4	                lcall    mul816          ;8bit x 16 bit product
 3588: 1  0BD0	12 08 3D	                lcall    magsig32        ;abs. waarde naar 2's complement
 3589: 1  0BD3	22		                ret
 3590: 1
 3591: 1			;*******************************************************************************
 3592: 1			; mul816        (29,4us @16.777216MHz)
 3593: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3594: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3595: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3596: 1			; input:     r1,r0 = acc0
 3597: 1			;               r4 = acc1
 3598: 1			;
 3599: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3600: 1			;                           0..16711425 (000000h..feff01h)
 3601: 1			;
 3602: 1			; vernietigt:  niets
 3603: 1			;*******************************************************************************
 3604: 1  0BD4	C0 E0		mul816:         push    acc             ;bewaar registers
 3605: 1  0BD6	C0 F0		                push    b
 3606: 1  0BD8	C0 D0		                push    psw
 3607: 1  0BDA	EC		                mov     a,r4            ;neem acc1
 3608: 1  0BDB	88 F0		                mov     b,r0            ;neem lsb van acc0
 3609: 1  0BDD	A4		                mul     ab              ;maak product
 3610: 1  0BDE	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3611: 1  0BDF	C0 F0		                push    b               ;bewaar lsb van het product
 3612: 1  0BE1	EC		                mov     a,r4            ;neem acc1
 3613: 1  0BE2	89 F0		                mov     b,r1            ;neem msb can acc0
 3614: 1  0BE4	A4		                mul     ab              ;maak product
 3615: 1  0BE5	AA F0		                mov     r2,b            ;bewaar msb van product even
 3616: 1  0BE7	F5 F0		                mov     b,a             ;verplaats lsb van product
 3617: 1  0BE9	D0 E0		                pop     acc             ;neem msb van vorig product
 3618: 1  0BEB	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3619: 1  0BED	F9		                mov     r1,a            ;de middenste byte is klaar
 3620: 1  0BEE	EA		                mov     a,r2            ;tel nu de eventuele
 3621: 1  0BEF	34 00		                addc    a,#0            ;carry bij de msb
 3622: 1  0BF1	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3623: 1  0BF2	7B 00		                mov     r3,#0
 3624: 1  0BF4	D0 D0		                pop     psw
 3625: 1  0BF6	D0 F0		                pop     b
 3626: 1  0BF8	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3627: 1  0BFA	22		                ret
 3628: 1
 3629: 1			;*******************************************************************************
 3630: 1			; s_mac16        (145,1us @16.777216MHz)
 3631: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3632: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3633: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3634: 1			; input:     r7,r6 = acc1 (high word)
 3635: 1			;            r5,r4 = acc1 (low  word)
 3636: 1			;
 3637: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3638: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3639: 1			;                          -2147483648 tot +2147483647
 3640: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3641: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3642: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3643: 1			;
 3644: 1			; vernietigt:  niets
 3645: 1			;*******************************************************************************
 3646: 1  0BFB	12 0B BA	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3647: 1  0BFE	C0 E0		                push    acc
 3648: 1  0C00	C0 D0		                push    psw
 3649: 1  0C02	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3650: 1  0C03	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3651: 1  0C04	F8		                mov     r0,a
 3652: 1  0C05	ED		                mov     a,r5
 3653: 1  0C06	39		                addc    a,r1
 3654: 1  0C07	F9		                mov     r1,a
 3655: 1  0C08	EE		                mov     a,r6
 3656: 1  0C09	3A		                addc    a,r2
 3657: 1  0C0A	FA		                mov     r2,a
 3658: 1  0C0B	EF		                mov     a,r7
 3659: 1  0C0C	3B		                addc    a,r3
 3660: 1  0C0D	FB		                mov     r3,a
 3661: 1  0C0E	20 D2 06	                jb      ov,s_mac161
 3662: 1  0C11	D0 D0		                pop     psw
 3663: 1  0C13	C3		                clr     c                ;ok, 32bit som binnen bereik
 3664: 1  0C14	D0 E0		                pop     acc
 3665: 1  0C16	22		                ret
 3666: 1  0C17	D0 D0		s_mac161:       pop     psw
 3667: 1  0C19	D3		                setb    c                ;fout! 32bit som buiten bereik
 3668: 1  0C1A	D0 E0		                pop     acc
 3669: 1  0C1C	22		                ret
 3670: 1
 3671: 1
 3672: 1			;*******************************************************************************
 3673: 1			; s_div8        (78us @16.777216MHz)
 3674: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3675: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3676: 1			; input:    r0 = acc0 deeltal (2's compl)
 3677: 1			;           r4 = acc1 deler   (2's compl)
 3678: 1			;
 3679: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3680: 1			;           r4 = rest (2's compl)
 3681: 1			;           cy=1 bij acc1=0 (deling door nul)
 3682: 1			;            cy=0 in andere gevallen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3683: 1			;
 3684: 1			; vernietigt: niets
 3685: 1			;*******************************************************************************
 3686: 1  0C1D	12 08 91	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3687: 1  0C20	12 08 AA	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3688: 1  0C23	12 0C 2F	                lcall   div8
 3689: 1  0C26	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3690: 1  0C28	12 07 C9	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3691: 1  0C2B	12 07 E3	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3692: 1  0C2E	22		s_div81:        ret
 3693: 1
 3694: 1			;*******************************************************************************
 3695: 1			; div8        (19,4us @16.777216MHz)
 3696: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3697: 1			; absolute waarde
 3698: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3699: 1			; input:    r0 = acc0 deeltal
 3700: 1			;           r4 = acc1 deler
 3701: 1			;
 3702: 1			; output:   r0 = quotient van deling acc0/acc1
 3703: 1			;           r4 = rest
 3704: 1			;           cy=1 bij acc1=0 (deling door nul)
 3705: 1			;            cy=0 in andere gevallen
 3706: 1			;
 3707: 1			; vernietigt: niets
 3708: 1			;*******************************************************************************
 3709: 1  0C2F	C0 E0		div8:           push    acc             ;bewaar registers
 3710: 1  0C31	C0 F0		                push    b
 3711: 1  0C33	C0 D0		                push    psw
 3712: 1  0C35	EC		                mov     a,r4            ;neem deler
 3713: 1  0C36	60 0F		                jz      div81           ;deling door nul?
 3714: 1  0C38	E8		                mov     a,r0            ;nee, neem deeltal
 3715: 1  0C39	8C F0		                mov     b,r4            ;en deler
 3716: 1  0C3B	84		                div     ab              ;en maak deling
 3717: 1  0C3C	F8		                mov     r0,a            ;bewaar quotient in acc0
 3718: 1  0C3D	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3719: 1  0C3F	D0 D0		                pop     psw             ;herstel registers
 3720: 1  0C41	D0 F0		                pop     b
 3721: 1  0C43	D0 E0		                pop     acc
 3722: 1  0C45	C3		                clr     c                ;geen deling door nul
 3723: 1  0C46	22		                ret
 3724: 1
 3725: 1  0C47	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3726: 1  0C49	D0 F0		                pop     b
 3727: 1  0C4B	D0 E0		                pop     acc
 3728: 1  0C4D	D3		                setb    c
 3729: 1  0C4E	22		                ret
 3730: 1
 3731: 1
 3732: 1			;*******************************************************************************
 3733: 1			; s_div16        (469,1us @16.777216MHz)
 3734: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3735: 1			; 2's Complement Format
 3736: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3737: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3738: 1			;           r5, r4 = acc1 deler   (2's compl)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3739: 1			;
 3740: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3741: 1			;           r5, r4 = rest
 3742: 1			;           cy=1 bij acc1=0 (deling door nul)
 3743: 1			;            cy=0 in andere gevallen
 3744: 1			;
 3745: 1			; vernietigt: niets
 3746: 1			;*******************************************************************************
 3747: 1  0C4F	C0 E0		s_div16:        push    acc
 3748: 1  0C51	C0 D0		                push    psw
 3749: 1  0C53	ED		                mov     a,r5            ;neem msb van deler
 3750: 1  0C54	4C		                orl     a,r4            ;combineer met lsb van deler
 3751: 1  0C55	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3752: 1  0C57	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3753: 1  0C59	D0 E0		                pop     acc
 3754: 1  0C5B	D3		                setb    C               ;fout, deling door nul!
 3755: 1  0C5C	22		                ret
 3756: 1
 3757: 1  0C5D	12 08 C3	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3758: 1  0C60	12 08 E3	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3759: 1  0C63	12 0C 72	                lcall   div16
 3760: 1  0C66	12 07 FD	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3761: 1  0C69	12 08 1D	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3762: 1  0C6C	D0 D0		                pop     psw
 3763: 1  0C6E	C3		                clr     C               ;delig ok
 3764: 1  0C6F	D0 E0		                pop     acc
 3765: 1  0C71	22		                ret                     ;klaar
 3766: 1
 3767: 1			;*******************************************************************************
 3768: 1			; div16            (405,1us @16.777216MHz)
 3769: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3770: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3771: 1			; input:    r1, r0 = Deeltal (acc0)
 3772: 1			;           r5, r4 = Deler   (acc1)
 3773: 1			;
 3774: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3775: 1			;           r5, r4 = rest van de deling acc0/acc1
 3776: 1			;            cy=1 bij deling door nul (acc1=0)
 3777: 1			;            cy=0 bij normale deling
 3778: 1			;
 3779: 1			; vernietigt: niets
 3780: 1			;*******************************************************************************
 3781: 1
 3782: 1  0C72	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3783: 1  0C74	C0 D0		                push    psw
 3784: 1			;check voor deling door nul
 3785: 1  0C76	EC		                mov     a,r4           ;neem lsb deler
 3786: 1  0C77	4D		                orl     a,r5           ;combineer met msb van deler
 3787: 1  0C78	70 06		                jnz     div160         ;niet nul, dan verder werken
 3788: 1  0C7A	D0 D0		                pop     psw            ;als nul, dikke snul
 3789: 1  0C7C	D3		                setb    c              ;terug met errorstatus
 3790: 1  0C7D	D0 E0		                pop     acc
 3791: 1  0C7F	22		                ret
 3792: 1
 3793: 1  0C80	C0 F0		div160:         push    b              ;registers verder bewaren
 3794: 1  0C82	EF		                mov     a,r7

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3795: 1  0C83	C0 E0		                push    acc            ;push r7 op stack
 3796: 1  0C85	EE		                mov     a,r6
 3797: 1  0C86	C0 E0		                push    acc            ;push r6 op stack
 3798: 1  0C88	EB		                mov     a,r3
 3799: 1  0C89	C0 E0		                push    acc            ;push r3 op stack
 3800: 1  0C8B	EA		                mov     a,r2
 3801: 1  0C8C	C0 E0		                push    acc            ;push r2 op stack
 3802: 1  0C8E	C0 83		                push    dph
 3803: 1  0C90	C0 82		                push    dpl
 3804: 1
 3805: 1  0C92	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3806: 1  0C94	7B 00		                mov     r3,#0
 3807: 1  0C96	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3808: 1  0C98	7E 00		                mov     r6,#0
 3809: 1  0C9A	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3810: 1
 3811: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3812: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3813: 1			;het aantal significante bits af in de lusteller b
 3814: 1
 3815: 1  0C9D	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3816: 1  0C9E	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3817: 1  0CA1	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3818: 1  0CA2	E8		                mov     a,r0            ;lsb van deeltal nemen
 3819: 1  0CA3	33		                rlc     a                ;en opschuiven
 3820: 1  0CA4	F8		                mov     r0,a
 3821: 1  0CA5	E9		                mov     a,r1            ;msb van deeltal nemen
 3822: 1  0CA6	33		                rlc     a
 3823: 1  0CA7	F9		                mov     r1,a
 3824: 1  0CA8	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3825: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3826: 1  0CAB	7C 00		                mov     r4,#0
 3827: 1  0CAD	7D 00		                mov     r5,#0
 3828: 1  0CAF	80 2E		                sjmp    div164          ;klaar!
 3829: 1
 3830: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3831: 1
 3832: 1  0CB1	C3		div162:            clr     C            ;start met carry op nul
 3833: 1  0CB2	E8		                mov     a,r0            ;schuif deeltal naar links
 3834: 1  0CB3	33		                rlc     a
 3835: 1  0CB4	F8		                mov     r0,a
 3836: 1  0CB5	E9		                mov     a,r1
 3837: 1  0CB6	33		                rlc     a
 3838: 1  0CB7	F9		                mov     r1,a
 3839: 1  0CB8	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3840: 1  0CB9	33		                rlc     a               ;gedeeltelijke rest
 3841: 1  0CBA	FE		                mov     r6,a
 3842: 1  0CBB	EF		                mov     a,r7
 3843: 1  0CBC	33		                rlc     a
 3844: 1  0CBD	FF		                mov     r7,a
 3845: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3846: 1  0CBE	EE		                mov     a,r6
 3847: 1  0CBF	C3		                clr     C
 3848: 1  0CC0	9C		                subb    a,r4
 3849: 1  0CC1	F5 82		                mov     dpl,a
 3850: 1  0CC3	EF		                mov     a,r7

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3851: 1  0CC4	9D		                subb    a,r5
 3852: 1  0CC5	F5 83		                mov     dph,a
 3853: 1  0CC7	40 04		                jc      div163
 3854: 1  0CC9	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3855: 1  0CCB	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3856: 1
 3857: 1  0CCD	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3858: 1  0CCE	EA		                mov     a,r2            ;binnenschuiven
 3859: 1  0CCF	33		                rlc     a
 3860: 1  0CD0	FA		                mov     r2,a
 3861: 1  0CD1	EB		                mov     a,r3
 3862: 1  0CD2	33		                rlc     a
 3863: 1  0CD3	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 3864: 1  0CD4	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3865: 1
 3866: 1  0CD7	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3867: 1  0CD8	F9		                mov     r1,a
 3868: 1  0CD9	EA		                mov     a,r2
 3869: 1  0CDA	F8		                mov     r0,a
 3870: 1  0CDB	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3871: 1  0CDC	FD		                mov     r5,a
 3872: 1  0CDD	EE		                mov     a,r6
 3873: 1  0CDE	FC		                mov     r4,a
 3874: 1
 3875: 1  0CDF	D0 82		div164:         pop     dpl             ;registers herstellen
 3876: 1  0CE1	D0 83		                pop     dph
 3877: 1  0CE3	D0 E0		                pop     acc
 3878: 1  0CE5	FA		                mov     r2,a            ;r2 van stack halen
 3879: 1  0CE6	D0 E0		                pop     acc
 3880: 1  0CE8	FB		                mov     r3,a            ;r3 van stack halen
 3881: 1  0CE9	D0 E0		                pop     acc
 3882: 1  0CEB	FE		                mov     r6,a            ;r6 van stack halen
 3883: 1  0CEC	D0 E0		                pop     acc
 3884: 1  0CEE	FF		                mov     r7,a            ;r7 van stack halen
 3885: 1  0CEF	D0 F0		                pop     b
 3886: 1  0CF1	D0 D0		                pop     psw
 3887: 1  0CF3	C3		                clr     c               ;deling ok
 3888: 1  0CF4	D0 E0		                pop     acc
 3889: 1  0CF6	22		                ret
 3890: 1
 3891: 1
 3892: 1			;*******************************************************************************
 3893: 1			; s_div32        (2,15ms @16.777216MHz)
 3894: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3895: 1			; 2's Complement Format
 3896: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3897: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3898: 1			;
 3899: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 3900: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3901: 1			;
 3902: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3903: 1			;           r7,r6,r5, r4 = rest
 3904: 1			;           cy=1 bij acc1=0 (deling door nul)
 3905: 1			;            cy=0 in andere gevallen
 3906: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3907: 1			; vernietigt: niets
 3908: 1			;*******************************************************************************
 3909: 1  0CF7	C0 E0		s_div32:        push    acc
 3910: 1  0CF9	C0 D0		                push    psw
 3911: 1  0CFB	EF		                mov     a,r7            ;neem msb van deler
 3912: 1  0CFC	4E		                orl     a,r6            ;combineer met lsb's van deler
 3913: 1  0CFD	4D		                orl     a,r5
 3914: 1  0CFE	4C		                orl     a,r4
 3915: 1  0CFF	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3916: 1  0D01	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3917: 1  0D03	D0 E0		                pop     acc
 3918: 1  0D05	D3		                setb    C                ;fout, deling door nul!
 3919: 1  0D06	22		                ret
 3920: 1
 3921: 1  0D07	12 09 23	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3922: 1  0D0A	12 09 4D	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3923: 1  0D0D	12 0D 1C	                lcall   div32            ;deel 32bit/32bit
 3924: 1  0D10	12 08 3D	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3925: 1  0D13	12 08 67	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3926: 1  0D16	D0 D0		                pop     psw
 3927: 1  0D18	C3		                clr     C                ;delig ok
 3928: 1  0D19	D0 E0		                pop     acc
 3929: 1  0D1B	22		                ret                        ;klaar
 3930: 1
 3931: 1
 3932: 1			;*******************************************************************************
 3933: 1			; div32        (2,09ms @16.777216MHz)
 3934: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3935: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3936: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3937: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3938: 1			;
 3939: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 3940: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3941: 1			;            cy=1 bij deling door nul (acc1=0)
 3942: 1			;            cy=0 bij normale deling
 3943: 1			;
 3944: 1			; vernietigt: niets
 3945: 1			;*******************************************************************************
 3946: 1  0D1C	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3947: 1  0D1E	C0 D0		                push    psw
 3948: 1			;check voor deling door nul
 3949: 1  0D20	EF		                mov     a,r7            ;neem msb van deler
 3950: 1  0D21	4E		                orl     a,r6            ;combineer met lsb's van deler
 3951: 1  0D22	4D		                orl     a,r5
 3952: 1  0D23	4C		                orl     a,r4
 3953: 1  0D24	70 06		                jnz     div320          ;niet nul, dan verder werken
 3954: 1  0D26	D0 D0		                pop     psw             ;als nul, dikke snul
 3955: 1  0D28	D3		                setb    c               ;terug met errorstatus
 3956: 1  0D29	D0 E0		                pop     acc
 3957: 1  0D2B	22		                ret
 3958: 1
 3959: 1  0D2C	C0 F0		div320:         push    b                ;registers verder bewaren
 3960: 1  0D2E	C0 83		                push    dph
 3961: 1  0D30	C0 82		                push    dpl
 3962: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3963: 1  0D32	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3964: 1
 3965: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3966: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3967: 1			;het aantal significante bits af in de lusteller b
 3968: 1
 3969: 1  0D35	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3970: 1  0D36	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3971: 1  0D39	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3972: 1  0D3A	E8		                mov     a,r0            ;lsb van deeltal nemen
 3973: 1  0D3B	33		                rlc     a               ;en opschuiven
 3974: 1  0D3C	F8		                mov     r0,a
 3975: 1  0D3D	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 3976: 1  0D3E	33		                rlc     a
 3977: 1  0D3F	F9		                mov     r1,a
 3978: 1  0D40	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3979: 1  0D41	33		                rlc     a
 3980: 1  0D42	FA		                mov     r2,a
 3981: 1  0D43	EB		                mov     a,r3           ;lsb van deeltal nemen
 3982: 1  0D44	33		                rlc     a
 3983: 1  0D45	FB		                mov     r3,a
 3984: 1  0D46	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3985: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3986: 1  0D49	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3987: 1  0D4B	7E 00		                mov     r6,#0
 3988: 1  0D4D	7D 00		                mov     r5,#0
 3989: 1  0D4F	7C 00		                mov     r4,#0
 3990: 1  0D51	02 0E 1A	                ljmp    div324           ;klaar!
 3991: 1
 3992: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 3993: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 3994: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 3995: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 3996: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 3997: 1
 3998: 1  0D54			div320b:
 3999: 1  0D54	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 4000: 1
 4001: 1  0D57	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 4002: 1  0D59	24 0C		                add     a,#12           ;met 12 plaatsen
 4003: 1  0D5B	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 4004: 1
 4005: 1  0D5D	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 4006: 1  0D5E	C0 E0		                push    acc
 4007: 1  0D60	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 4008: 1  0D61	C0 E0		                push    acc
 4009: 1
 4010: 1  0D63	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 4011: 1  0D65	08		                inc     r0              ;de deler
 4012: 1  0D66	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 4013: 1  0D68	24 05		                add     a,#5            ;het tijdelijk verschil X
 4014: 1  0D6A	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 4015: 1  0D6B	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 4016: 1  0D6D	24 09		                add     a,#9            ;quotient
 4017: 1  0D6F	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 4018: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4019: 1			;Eenmalig de variabelen op stack initaliseren
 4020: 1			;Tijdelijk quotient op nul zetten
 4021: 1
 4022: 1  0D71	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 4023: 1  0D73	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 4024: 1  0D74	C0 F0		                push    b                ;loopteller deling bewaren
 4025: 1  0D76	75 F0 04	                mov     b,#4
 4026: 1  0D79	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 4027: 1  0D7B	09		                inc     r1
 4028: 1  0D7C	D5 F0 FA	                djnz    b,div320c
 4029: 1  0D7F	D0 F0		                pop     b                ;loopteller deling ophalen
 4030: 1  0D81	19		                dec     r1
 4031: 1  0D82	19		                dec     r1
 4032: 1  0D83	19		                dec     r1
 4033: 1  0D84	19		                dec     r1               ;pointer weer op startadres quotient
 4034: 1  0D85	C9		                xch     a,r1             ;weer omwisselen
 4035: 1  0D86	C5 82		                xch     a,dpl
 4036: 1
 4037: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 4038: 1  0D88	EC		                mov     a,r4
 4039: 1  0D89	F6		                mov     @r0,a
 4040: 1  0D8A	08		                inc     r0
 4041: 1  0D8B	ED		                mov     a,r5
 4042: 1  0D8C	F6		                mov     @r0,a
 4043: 1  0D8D	08		                inc     r0
 4044: 1  0D8E	EE		                mov     a,r6
 4045: 1  0D8F	F6		                mov     @r0,a
 4046: 1  0D90	08		                inc     r0
 4047: 1  0D91	EF		                mov     a,r7
 4048: 1  0D92	F6		                mov     @r0,a
 4049: 1  0D93	18		                dec     r0             ;pointer herstellen naar lsb van deler
 4050: 1  0D94	18		                dec     r0
 4051: 1  0D95	18		                dec     r0
 4052: 1
 4053: 1  0D96	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 4054: 1  0D98	7E 00		                mov     r6,#0
 4055: 1  0D9A	7D 00		                mov     r5,#0
 4056: 1  0D9C	7C 00		                mov     r4,#0
 4057: 1
 4058: 1
 4059: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 4060: 1  0D9E	C3		div322:         clr     C               ;start met carry op nul
 4061: 1
 4062: 1  0D9F	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 4063: 1  0DA1	33		                rlc     a
 4064: 1  0DA2	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 4065: 1  0DA4	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 4066: 1  0DA6	D0 E0		                pop     acc             ;r1 van deeltal van stack
 4067: 1  0DA8	33		                rlc     a
 4068: 1  0DA9	C0 E0		                push    acc             ;en weer bewaren
 4069: 1  0DAB	05 81		                inc     sp              ;stackpointer weer corrigeren
 4070: 1
 4071: 1  0DAD	EA		                mov     a,r2
 4072: 1  0DAE	33		                rlc     a
 4073: 1  0DAF	FA		                mov     r2,a
 4074: 1  0DB0	EB		                mov     a,r3

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4075: 1  0DB1	33		                rlc     a
 4076: 1  0DB2	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 4077: 1
 4078: 1  0DB3	EC		                mov     a,r4            ;schuif carry van deeltal in de
 4079: 1  0DB4	33		                rlc     a               ;gedeeltelijke rest r7..r4
 4080: 1  0DB5	FC		                mov     r4,a
 4081: 1  0DB6	ED		                mov     a,r5
 4082: 1  0DB7	33		                rlc     a
 4083: 1  0DB8	FD		                mov     r5,a
 4084: 1  0DB9	EE		                mov     a,r6
 4085: 1  0DBA	33		                rlc     a
 4086: 1  0DBB	FE		                mov     r6,a
 4087: 1  0DBC	EF		                mov     a,r7
 4088: 1  0DBD	33		                rlc     a
 4089: 1  0DBE	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 4090: 1
 4091: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 4092: 1
 4093: 1  0DBF	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 4094: 1  0DC0	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 4095: 1  0DC1	96		                subb    a,@r0           ;trek er de lsb deler af
 4096: 1  0DC2	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4097: 1  0DC3	08		                inc     r0              ;pointers aanpassen
 4098: 1  0DC4	09		                inc     r1
 4099: 1  0DC5	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4100: 1  0DC6	96		                subb    a,@r0           ;trek er volgende byte deler af
 4101: 1  0DC7	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4102: 1  0DC8	08		                inc     r0              ;pointers aanpassen
 4103: 1  0DC9	09		                inc     r1
 4104: 1  0DCA	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4105: 1  0DCB	96		                subb    a,@r0           ;trek er volgende byte deler af
 4106: 1  0DCC	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4107: 1  0DCD	08		                inc     r0              ;pointers aanpassen
 4108: 1  0DCE	09		                inc     r1
 4109: 1  0DCF	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4110: 1  0DD0	96		                subb    a,@r0           ;trek er msb deler af
 4111: 1  0DD1	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4112: 1  0DD2	18		                dec     r0              ;pointers herstellen naar lsb's
 4113: 1  0DD3	18		                dec     r0
 4114: 1  0DD4	18		                dec     r0
 4115: 1  0DD5	19		                dec     r1
 4116: 1  0DD6	19		                dec     r1
 4117: 1  0DD7	19		                dec     r1
 4118: 1
 4119: 1  0DD8	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4120: 1  0DDA	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4121: 1  0DDB	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4122: 1  0DDC	09		                inc     r1
 4123: 1  0DDD	E7		                mov     a,@r1
 4124: 1  0DDE	FD		                mov     r5,a
 4125: 1  0DDF	09		                inc     r1
 4126: 1  0DE0	E7		                mov     a,@r1
 4127: 1  0DE1	FE		                mov     r6,a
 4128: 1  0DE2	09		                inc     r1
 4129: 1  0DE3	E7		                mov     a,@r1
 4130: 1  0DE4	FF		                mov     r7,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4131: 1  0DE5	19		                dec     r1              ;met pointer weer naar lsb van
 4132: 1  0DE6	19		                dec     r1              ;het tijdelijk verschil wijzen
 4133: 1  0DE7	19		                dec     r1
 4134: 1
 4135: 1
 4136: 1  0DE8	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4137: 1  0DE9	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4138: 1  0DEB	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4139: 1  0DEC	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4140: 1  0DEE	E7		                mov     a,@r1           ;neem lsb van qoutient
 4141: 1  0DEF	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4142: 1  0DF0	F7		                mov     @r1,a
 4143: 1  0DF1	09		                inc     r1              ;volgende byte
 4144: 1  0DF2	E7		                mov     a,@r1
 4145: 1  0DF3	33		                rlc     a
 4146: 1  0DF4	F7		                mov     @r1,a
 4147: 1  0DF5	09		                inc     r1              ;volgende byte
 4148: 1  0DF6	E7		                mov     a,@r1
 4149: 1  0DF7	33		                rlc     a
 4150: 1  0DF8	F7		                mov     @r1,a
 4151: 1  0DF9	09		                inc     r1              ;volgende byte
 4152: 1  0DFA	E7		                mov     a,@r1
 4153: 1  0DFB	33		                rlc     a
 4154: 1  0DFC	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4155: 1  0DFD	19		                dec     r1
 4156: 1  0DFE	19		                dec     r1
 4157: 1  0DFF	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4158: 1  0E00	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4159: 1  0E02	C9		                xch     a,r1            ;r1=pointer naar verschil
 4160: 1  0E03	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4161: 1
 4162: 1  0E05	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4163: 1
 4164: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4165: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4166: 1
 4167: 1  0E08	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4168: 1  0E0A	18		                dec     r0
 4169: 1  0E0B	18		                dec     r0
 4170: 1  0E0C	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4171: 1  0E0D	FB		                mov     r3,a            ;en verplaatsen
 4172: 1  0E0E	18		                dec     r0              ;volgende byte
 4173: 1  0E0F	E6		                mov     a,@r0
 4174: 1  0E10	FA		                mov     r2,a
 4175: 1  0E11	18		                dec     r0              ;volgende byte
 4176: 1  0E12	E6		                mov     a,@r0
 4177: 1  0E13	F9		                mov     r1,a
 4178: 1  0E14	18		                dec     r0              ;volgende byte
 4179: 1  0E15	E6		                mov     a,@r0
 4180: 1  0E16	F8		                mov     r0,a            ;laatste byte verplaatst!
 4181: 1
 4182: 1  0E17	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4183: 1			                                         ;weer vrijgeven
 4184: 1
 4185: 1
 4186: 1  0E1A	D0 82		div324:         pop     dpl             ;registers herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4187: 1  0E1C	D0 83		                pop     dph
 4188: 1  0E1E	D0 F0		                pop     b
 4189: 1  0E20	D0 D0		                pop     psw
 4190: 1  0E22	C3		                clr     c               ;normale deling
 4191: 1  0E23	D0 E0		                pop     acc
 4192: 1  0E25	22		                ret
 4193: 1
 4194: 1			;*******************************************************************************
 4195: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4196: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4197: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4198: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4199: 1			;
 4200: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4201: 1			;
 4202: 1			; input:     r5,r4 = acc1 (low word product)
 4203: 1			;            r7,r6 = acc1 (high word product)
 4204: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4205: 1			;
 4206: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4207: 1			;            r7,r6,r5,r4 = acc1 = rest
 4208: 1			;                          -2147483648 tot +2147483647
 4209: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4210: 1			;             cy=1 bij deling door nul (acc0=0)
 4211: 1			;             cy=0 bij normale deling
 4212: 1			;
 4213: 1			; vernietigt:  niets
 4214: 1			;*******************************************************************************
 4215: 1  0E26	C0 E0		s_muldiv:       push    acc
 4216: 1  0E28	C0 D0		                push    psw
 4217: 1  0E2A	E8		                mov     a,r0            ;neem msb van deler
 4218: 1  0E2B	49		                orl     a,r1            ;combineer met lsb's van deler
 4219: 1  0E2C	4A		                orl     a,r2
 4220: 1  0E2D	4B		                orl     a,r3
 4221: 1  0E2E	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4222: 1  0E30	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4223: 1  0E32	D0 E0		                pop     acc
 4224: 1  0E34	D3		                setb    C               ;fout, deling door nul!
 4225: 1  0E35	22		                ret
 4226: 1
 4227: 1  0E36	12 08 E3	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4228: 1  0E39	12 09 03	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4229: 1  0E3C	12 0E 4B	                lcall    muldiv          ;maak product en daarna de deling
 4230: 1  0E3F	12 08 3D	                lcall    magsig32        ;quotient naar 2's complement
 4231: 1  0E42	12 08 67	                lcall    magsig32acc1    ;rest naar 2's complement
 4232: 1  0E45	D0 D0		                pop     psw
 4233: 1  0E47	C3		                clr     c                ;deling is ok
 4234: 1  0E48	D0 E0		                pop    acc
 4235: 1  0E4A	22		                ret
 4236: 1
 4237: 1			;*******************************************************************************
 4238: 1			; muldiv        (2,0ms @16.777216MHz)
 4239: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4240: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4241: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4242: 1			; 32bit rest in acc1.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4243: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4244: 1			;
 4245: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4246: 1			;
 4247: 1			; input:     r5,r4 = acc1 (low word product)
 4248: 1			;            r7,r6 = acc1 (high word product)
 4249: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4250: 1			;
 4251: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4252: 1			;            r7,r6,r5,r4 = acc1 = rest
 4253: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4254: 1			;             cy=1 bij deling door nul (acc0=0)
 4255: 1			;             cy=0 bij normale deling
 4256: 1			;
 4257: 1			; vernietigt:  niets
 4258: 1			;*******************************************************************************
 4259: 1  0E4B	C0 E0		muldiv:         push    acc
 4260: 1  0E4D	C0 D0		                push    psw
 4261: 1  0E4F	E8		                mov     a,r0            ;neem msb van deler
 4262: 1  0E50	49		                orl     a,r1            ;combineer met lsb's van deler
 4263: 1  0E51	4A		                orl     a,r2
 4264: 1  0E52	4B		                orl     a,r3
 4265: 1  0E53	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4266: 1  0E55	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4267: 1  0E57	D0 E0		                pop     acc
 4268: 1  0E59	D3		                setb    C               ;fout, deling door nul!
 4269: 1  0E5A	22		                ret
 4270: 1
 4271: 1  0E5B	12 0B 4C	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4272: 1  0E5E	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4273: 1  0E5F	C0 E0		                push    acc
 4274: 1  0E61	ED		                mov     a,r5
 4275: 1  0E62	C0 E0		                push    acc
 4276: 1  0E64	EE		                mov     a,r6
 4277: 1  0E65	C0 E0		                push    acc
 4278: 1  0E67	EF		                mov     a,r7
 4279: 1  0E68	C0 E0		                push    acc             ;product staat nu op stack
 4280: 1
 4281: 1  0E6A	E8		                mov     a,r0            ;deler in acc1 stoppen
 4282: 1  0E6B	FC		                mov     r4,a
 4283: 1  0E6C	E9		                mov     a,r1
 4284: 1  0E6D	FD		                mov     r5,a
 4285: 1  0E6E	EA		                mov     a,r2
 4286: 1  0E6F	FE		                mov     r6,a
 4287: 1  0E70	EB		                mov     a,r3
 4288: 1  0E71	FF		                mov     r7,a            ;deler zit volledig in acc1
 4289: 1
 4290: 1  0E72	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4291: 1  0E74	FB		                mov     r3,a
 4292: 1  0E75	D0 E0		                pop     acc
 4293: 1  0E77	FA		                mov     r2,a
 4294: 1  0E78	D0 E0		                pop     acc
 4295: 1  0E7A	F9		                mov     r1,a
 4296: 1  0E7B	D0 E0		                pop     acc
 4297: 1  0E7D	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4298: 1  0E7E	12 0D 1C	                lcall   div32           ;maak deling

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4299: 1
 4300: 1  0E81	D0 D0		                pop     psw            ;herstel registers
 4301: 1  0E83	D0 E0		                pop     acc
 4302: 1  0E85	C3		                clr     C              ;resultaat ok!
 4303: 1  0E86	22		                ret
 4304: 1
 4305: 1			;*******************************************************************************
 4306: 1			; mul16_pi        (257,1us @16.777216MHz)
 4307: 1			; acc0 = acc0 x pi
 4308: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4309: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4310: 1			;
 4311: 1			; input:     r1,r0 = acc0 (low word)
 4312: 1			;
 4313: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4314: 1			;
 4315: 1			; vernietigt:  niets
 4316: 1			;*******************************************************************************
 4317: 1  0E87	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4318: 1  0E89	C0 D0		                push    psw
 4319: 1  0E8B	EC		                mov     a,r4
 4320: 1  0E8C	C0 E0		                push    acc
 4321: 1  0E8E	ED		                mov     a,r5
 4322: 1  0E8F	C0 E0		                push    acc
 4323: 1  0E91	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4324: 1  0E93	7C 0F		                mov     r4,#0fH
 4325: 1  0E95	12 0A E7	                lcall   mul16           ;acc0 = acc0 x acc1
 4326: 1  0E98	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4327: 1  0E9A	12 10 83	                lcall   shiftright32    ;om te delen door 2^14
 4328: 1  0E9D	D0 E0		                pop     acc
 4329: 1  0E9F	FD		                mov     r5,a
 4330: 1  0EA0	D0 E0		                pop     acc
 4331: 1  0EA2	FC		                mov     r4,a
 4332: 1  0EA3	D0 D0		                pop     psw
 4333: 1  0EA5	D0 E0		                pop     acc
 4334: 1  0EA7	22		                ret
 4335: 1
 4336: 1			;*******************************************************************************
 4337: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4338: 1			; acc0 = acc0 x 1/pi
 4339: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4340: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4341: 1			;
 4342: 1			; input:     r1,r0 = acc0 (low word)
 4343: 1			;
 4344: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4345: 1			;
 4346: 1			; vernietigt:  niets
 4347: 1			;*******************************************************************************
 4348: 1  0EA8	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4349: 1  0EAA	C0 D0		                push    psw
 4350: 1  0EAC	EC		                mov     a,r4
 4351: 1  0EAD	C0 E0		                push    acc
 4352: 1  0EAF	ED		                mov     a,r5
 4353: 1  0EB0	C0 E0		                push    acc
 4354: 1  0EB2	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4355: 1  0EB4	7C 7D		                mov     r4,#07dH
 4356: 1  0EB6	12 0A E7	                lcall    mul16          ;acc0 = acc0 x acc1
 4357: 1  0EB9	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4358: 1  0EBB	12 10 83	                lcall   shiftright32    ;om te delen door 2^16
 4359: 1  0EBE	D0 E0		                pop     acc
 4360: 1  0EC0	FD		                mov     r5,a
 4361: 1  0EC1	D0 E0		                pop     acc
 4362: 1  0EC3	FC		                mov     r4,a
 4363: 1  0EC4	D0 D0		                pop     psw
 4364: 1  0EC6	D0 E0		                pop     acc
 4365: 1  0EC8	22		                ret
 4366: 1
 4367: 1			;*******************************************************************************
 4368: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4369: 1			; acc0 = acc0 x sqrt2
 4370: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4371: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4372: 1			;
 4373: 1			; input:     r1,r0 = acc0 (low word)
 4374: 1			;
 4375: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4376: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4377: 1			;
 4378: 1			; vernietigt:  niets
 4379: 1			;*******************************************************************************
 4380: 1  0EC9	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4381: 1  0ECB	C0 D0		                push    psw
 4382: 1  0ECD	EC		                mov     a,r4
 4383: 1  0ECE	C0 E0		                push    acc
 4384: 1  0ED0	ED		                mov     a,r5
 4385: 1  0ED1	C0 E0		                push    acc
 4386: 1  0ED3	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4387: 1  0ED5	7C 05		                mov     r4,#005H
 4388: 1  0ED7	12 0A E7	                lcall   mul16           ;acc0 = acc0 x acc1
 4389: 1  0EDA	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4390: 1  0EDC	12 10 83	                lcall   shiftright32    ;om te delen door 2^15
 4391: 1  0EDF	D0 E0		                pop     acc
 4392: 1  0EE1	FD		                mov     r5,a
 4393: 1  0EE2	D0 E0		                pop     acc
 4394: 1  0EE4	FC		                mov     r4,a
 4395: 1  0EE5	D0 D0		                pop     psw
 4396: 1  0EE7	D0 E0		                pop     acc
 4397: 1  0EE9	22		                ret
 4398: 1
 4399: 1
 4400: 1
 4401: 1			;*******************************************************************************
 4402: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4403: 1			; acc0 = acc0 x 1/sqrt2
 4404: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4405: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4406: 1			;
 4407: 1			; input:     r1,r0 = acc0 (low word)
 4408: 1			;
 4409: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4410: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4411: 1			; vernietigt:  niets
 4412: 1			;*******************************************************************************
 4413: 1  0EEA	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4414: 1  0EEC	C0 D0		                push    psw
 4415: 1  0EEE	EC		                mov     a,r4
 4416: 1  0EEF	C0 E0		                push    acc
 4417: 1  0EF1	ED		                mov     a,r5
 4418: 1  0EF2	C0 E0		                push    acc
 4419: 1  0EF4	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4420: 1  0EF6	7C 05		                mov     r4,#005H
 4421: 1  0EF8	12 0A E7	                lcall   mul16           ;acc0 = acc0 x acc1
 4422: 1  0EFB	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4423: 1  0EFD	12 10 83	                lcall   shiftright32    ;om te delen door 2^16
 4424: 1  0F00	D0 E0		                pop     acc
 4425: 1  0F02	FD		                mov     r5,a
 4426: 1  0F03	D0 E0		                pop     acc
 4427: 1  0F05	FC		                mov     r4,a
 4428: 1  0F06	D0 D0		                pop     psw
 4429: 1  0F08	D0 E0		                pop     acc
 4430: 1  0F0A	22		                ret
 4431: 1
 4432: 1			;*******************************************************************************
 4433: 1			; mul16_10        (98,7us @16.777216MHz)
 4434: 1			; acc0 = acc0 x 10
 4435: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4436: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4437: 1			;
 4438: 1			; input:     r1,r0 = acc0 (low word)
 4439: 1			;
 4440: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4441: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4442: 1			; vernietigt:  niets
 4443: 1			;*******************************************************************************
 4444: 1  0F0B	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4445: 1  0F0D	C0 D0		                push    psw
 4446: 1  0F0F	EC		                mov     a,r4
 4447: 1  0F10	C0 E0		                push    acc
 4448: 1  0F12	7C 01		                mov     r4,#1           ;acc0 x2
 4449: 1  0F14	12 10 AF	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4450: 1  0F17	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4451: 1  0F18	C0 E0		                push    acc
 4452: 1  0F1A	EA		                mov     a,r2
 4453: 1  0F1B	C0 E0		                push    acc
 4454: 1  0F1D	E9		                mov     a,r1
 4455: 1  0F1E	C0 E0		                push    acc
 4456: 1  0F20	E8		                mov     a,r0
 4457: 1  0F21	C0 E0		                push    acc             ;acc0 op stack
 4458: 1  0F23	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4459: 1  0F25	12 10 AF	                lcall   shiftleft32     ;acc0 =acc0 x4
 4460: 1  0F28	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4461: 1  0F2A	28		                add     a,r0            ;tel bij huidige acc0
 4462: 1  0F2B	F8		                mov     r0,a
 4463: 1  0F2C	D0 E0		                pop     acc
 4464: 1  0F2E	39		                addc    a,r1
 4465: 1  0F2F	F9		                mov     r1,a
 4466: 1  0F30	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4467: 1  0F32	3A		                addc    a,r2
 4468: 1  0F33	FA		                mov     r2,a
 4469: 1  0F34	D0 E0		                pop     acc
 4470: 1  0F36	3B		                addc    a,r3
 4471: 1  0F37	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4472: 1
 4473: 1
 4474: 1  0F38	D0 E0		                pop     acc
 4475: 1  0F3A	FC		                mov     r4,a
 4476: 1  0F3B	D0 D0		                pop     psw
 4477: 1  0F3D	D0 E0		                pop     acc
 4478: 1  0F3F	22		                ret
 4479: 1
 4480: 1			;*******************************************************************************
 4481: 1			; mul16_100        (169,1us @16.777216MHz)
 4482: 1			; acc0 = acc0 x 100
 4483: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4484: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4485: 1			;
 4486: 1			; input:     r1,r0 = acc0 (low word)
 4487: 1			;
 4488: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4489: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4490: 1			; vernietigt:  niets
 4491: 1			;*******************************************************************************
 4492: 1  0F40	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4493: 1  0F42	C0 D0		                push    psw
 4494: 1  0F44	EC		                mov     a,r4
 4495: 1  0F45	C0 E0		                push    acc
 4496: 1  0F47	7C 02		                mov     r4,#2           ;acc0 x4
 4497: 1  0F49	12 10 AF	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4498: 1  0F4C	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4499: 1  0F4D	C0 E0		                push    acc
 4500: 1  0F4F	EA		                mov     a,r2
 4501: 1  0F50	C0 E0		                push    acc
 4502: 1  0F52	E9		                mov     a,r1
 4503: 1  0F53	C0 E0		                push    acc
 4504: 1  0F55	E8		                mov     a,r0
 4505: 1  0F56	C0 E0		                push    acc             ;acc0 op stack
 4506: 1
 4507: 1  0F58	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4508: 1  0F5A	12 10 AF	                lcall   shiftleft32     ;acc0 =acc0 x8
 4509: 1  0F5D	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4510: 1  0F5E	C0 E0		                push    acc
 4511: 1  0F60	EA		                mov     a,r2
 4512: 1  0F61	C0 E0		                push    acc
 4513: 1  0F63	E9		                mov     a,r1
 4514: 1  0F64	C0 E0		                push    acc
 4515: 1  0F66	E8		                mov     a,r0
 4516: 1  0F67	C0 E0		                push    acc             ;acc0 op stack
 4517: 1
 4518: 1  0F69	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4519: 1  0F6B	12 10 AF	                lcall   shiftleft32     ;acc0 =acc0 x2
 4520: 1  0F6E	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4521: 1  0F70	28		                add     a,r0            ;tel bij huidige acc0
 4522: 1  0F71	F8		                mov     r0,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4523: 1  0F72	D0 E0		                pop     acc
 4524: 1  0F74	39		                addc    a,r1
 4525: 1  0F75	F9		                mov     r1,a
 4526: 1  0F76	D0 E0		                pop     acc
 4527: 1  0F78	3A		                addc    a,r2
 4528: 1  0F79	FA		                mov     r2,a
 4529: 1  0F7A	D0 E0		                pop     acc
 4530: 1  0F7C	3B		                addc    a,r3
 4531: 1  0F7D	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4532: 1
 4533: 1  0F7E	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4534: 1  0F80	28		                add     a,r0            ;tel bij huidige acc0
 4535: 1  0F81	F8		                mov     r0,a
 4536: 1  0F82	D0 E0		                pop     acc
 4537: 1  0F84	39		                addc    a,r1
 4538: 1  0F85	F9		                mov     r1,a
 4539: 1  0F86	D0 E0		                pop     acc
 4540: 1  0F88	3A		                addc    a,r2
 4541: 1  0F89	FA		                mov     r2,a
 4542: 1  0F8A	D0 E0		                pop     acc
 4543: 1  0F8C	3B		                addc    a,r3
 4544: 1  0F8D	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4545: 1
 4546: 1  0F8E	D0 E0		                pop     acc
 4547: 1  0F90	FC		                mov     r4,a
 4548: 1  0F91	D0 D0		                pop     psw
 4549: 1  0F93	D0 E0		                pop     acc
 4550: 1  0F95	22		                ret
 4551: 1
 4552: 1			;*******************************************************************************
 4553: 1			; sqrt32        (2,99ms @16.777216MHz)
 4554: 1			; acc0 = acc0 ^(1/2)
 4555: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4556: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4557: 1			;
 4558: 1			; input:     r3,r2,r1,r0 = acc0
 4559: 1			;
 4560: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4561: 1			;
 4562: 1			; vernietigt:  niets
 4563: 1			;*******************************************************************************
 4564: 1  0F96	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4565: 1  0F98	C0 F0		                push    b
 4566: 1  0F9A	C0 D0		                push    psw
 4567: 1  0F9C	C0 82		                push    dpl
 4568: 1  0F9E	C0 83		                push    dph
 4569: 1  0FA0	EC		                mov     a,r4
 4570: 1  0FA1	C0 E0		                push    acc
 4571: 1  0FA3	ED		                mov     a,r5
 4572: 1  0FA4	C0 E0		                push    acc
 4573: 1  0FA6	EE		                mov     a,r6
 4574: 1  0FA7	C0 E0		                push    acc
 4575: 1  0FA9	EF		                mov     a,r7
 4576: 1  0FAA	C0 E0		                push    acc
 4577: 1
 4578: 1  0FAC	7C 00		                mov     r4,#0           ;acc1 op nul zetten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4579: 1  0FAE	7D 00		                mov     r5,#0
 4580: 1  0FB0	7E 00		                mov     r6,#0
 4581: 1  0FB2	7F 00		                mov     r7,#0
 4582: 1  0FB4	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4583: 1  0FB7	75 83 00	                mov     dph,#0
 4584: 1  0FBA	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4585: 1			;hier start het algorithme voor het berekenen van de wortel
 4586: 1  0FBD	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4587: 1  0FBF	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4588: 1  0FC2	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4589: 1  0FC3	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4590: 1  0FC4	33		                rlc     a                ;getest worden om een wortelbit te
 4591: 1  0FC5	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4592: 1  0FC6	E9		                mov     a,r1            ;met nullen!
 4593: 1  0FC7	33		                rlc     a
 4594: 1  0FC8	F9		                mov     r1,a
 4595: 1  0FC9	EA		                mov     a,r2
 4596: 1  0FCA	33		                rlc     a
 4597: 1  0FCB	FA		                mov     r2,a
 4598: 1  0FCC	EB		                mov     a,r3
 4599: 1  0FCD	33		                rlc     a
 4600: 1  0FCE	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4601: 1
 4602: 1  0FCF	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4603: 1  0FD0	33		                rlc     a
 4604: 1  0FD1	FC		                mov     r4,a
 4605: 1  0FD2	ED		                mov     a,r5
 4606: 1  0FD3	33		                rlc     a
 4607: 1  0FD4	FD		                mov     r5,a
 4608: 1  0FD5	EE		                mov     a,r6
 4609: 1  0FD6	33		                rlc     a
 4610: 1  0FD7	FE		                mov     r6,a
 4611: 1  0FD8	EF		                mov     a,r7
 4612: 1  0FD9	33		                rlc     a
 4613: 1  0FDA	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4614: 1  0FDB	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4615: 1
 4616: 1  0FDE	D0 F0		                pop     b               ;lusteller wortel weer terugnemen
 4617: 1
 4618: 1  0FE0	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4619: 1  0FE1	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4620: 1  0FE3	33		                rlc     a
 4621: 1  0FE4	F5 82		                mov     dpl,a
 4622: 1  0FE6	E5 83		                mov     a,dph
 4623: 1  0FE8	33		                rlc     a
 4624: 1  0FE9	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4625: 1
 4626: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4627: 1  0FEB	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4628: 1  0FEC	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4629: 1  0FEE	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4630: 1  0FEF	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4631: 1  0FF1	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4632: 1  0FF2	C0 E0		                push    acc             ;van acc1
 4633: 1  0FF4	EB		                mov     a,r3
 4634: 1  0FF5	C0 E0		                push    acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4635: 1  0FF7	EC		                mov     a,r4
 4636: 1  0FF8	C0 E0		                push    acc
 4637: 1  0FFA	ED		                mov     a,r5
 4638: 1  0FFB	C0 E0		                push    acc
 4639: 1  0FFD	EE		                mov     a,r6
 4640: 1  0FFE	C0 E0		                push    acc
 4641: 1  1000	EF		                mov     a,r7
 4642: 1  1001	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4643: 1
 4644: 1  1003	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4645: 1  1005	AD 83		                mov     r5,dph
 4646: 1  1007	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4647: 1  1009	AF 83		                mov     r7,dph
 4648: 1  100B	12 0B 4C	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4649: 1
 4650: 1  100E	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4651: 1  1010	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4652: 1  1011	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4653: 1  1013	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4654: 1  1014	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4655: 1  1016	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4656: 1  1017	D0 E0		                pop     acc             ;de stack...
 4657: 1  1019	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4658: 1
 4659: 1  101A	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4660: 1  101B	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4661: 1  101C	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4662: 1  101D	E9		                mov     a,r1            ;in acc1.
 4663: 1  101E	9D		                subb    a,r5            ;We doen dit door de carry van het
 4664: 1  101F	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4665: 1  1020	9E		                subb    a,r6
 4666: 1  1021	EB		                mov     a,r3
 4667: 1  1022	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4668: 1  1023	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4669: 1			                                        ;wortel behouden
 4670: 1  1025	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4671: 1  1027	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4672: 1  1029	F5 82		                mov     dpl,a          ;wortel aanpassen
 4673: 1
 4674: 1  102B	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4675: 1  102D	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4676: 1  102F	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4677: 1
 4678: 1  1031	D0 E0		                pop     acc            ;haal acc1 weer op
 4679: 1  1033	FF		                mov     r7,a
 4680: 1  1034	D0 E0		                pop     acc
 4681: 1  1036	FE		                mov     r6,a
 4682: 1  1037	D0 E0		                pop     acc
 4683: 1  1039	FD		                mov     r5,a
 4684: 1  103A	D0 E0		                pop     acc
 4685: 1  103C	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4686: 1
 4687: 1  103D	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4688: 1  103F	FB		                mov     r3,a
 4689: 1  1040	D0 E0		                pop     acc
 4690: 1  1042	FA		                mov     r2,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4691: 1  1043	D0 E0		                pop     acc
 4692: 1  1045	F9		                mov     r1,a
 4693: 1  1046	D0 E0		                pop     acc
 4694: 1  1048	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4695: 1
 4696: 1  1049	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4697: 1  104C	80 03		                sjmp    sqrt325
 4698: 1  104E	02 0F BD	sqrt324:        ljmp    sqrt320        ;uit acc0
 4699: 1
 4700: 1  1051	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4701: 1  1053	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4702: 1
 4703: 1  1055	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4704: 1  1057	FF		                mov     r7,a
 4705: 1  1058	D0 E0		                pop     acc
 4706: 1  105A	FE		                mov     r6,a
 4707: 1  105B	D0 E0		                pop     acc
 4708: 1  105D	FD		                mov     r5,a
 4709: 1  105E	D0 E0		                pop     acc
 4710: 1  1060	FC		                mov     r4,a           ;acc1 is hersteld
 4711: 1  1061	D0 83		                pop     dph
 4712: 1  1063	D0 82		                pop     dpl
 4713: 1  1065	D0 D0		                pop     psw
 4714: 1  1067	D0 F0		                pop     b
 4715: 1  1069	D0 E0		                pop     acc
 4716: 1
 4717: 1  106B	22		                ret                    ;eindelijk klaar...
 4718: 1
 4719: 1			;*******************************************************************************
 4720: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4721: 1			; acc0 = acc0 ^(1/2)
 4722: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4723: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4724: 1			;                           (-2147483648 tot +2147483647)
 4725: 1			; input:     r3,r2,r1,r0 = acc0
 4726: 1			;
 4727: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4728: 1			;            CY = 1 als acc0 negatief is
 4729: 1			; vernietigt:  niets
 4730: 1			;*******************************************************************************
 4731: 1  106C	C0 E0		s_sqrt32:       push    acc
 4732: 1  106E	C0 D0		                push    psw
 4733: 1  1070	EB		                mov     a,r3
 4734: 1  1071	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4735: 1  1074	D0 D0		                pop     psw
 4736: 1  1076	D3		                setb    c                ;als negatief dan error
 4737: 1  1077	D0 E0		                pop     acc
 4738: 1  1079	22		                ret
 4739: 1  107A	D0 D0		s_sqrt321:      pop     psw
 4740: 1  107C	D0 E0		                pop     acc
 4741: 1  107E	12 0F 96	                lcall   sqrt32            ;wortel trekken
 4742: 1  1081	C3		                clr     c                 ;wortel ok
 4743: 1  1082	22		                ret                       ;klaar
 4744: 1
 4745: 1			;*******************************************************************************
 4746: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4747: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4748: 1			; (logical shift)
 4749: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4750: 1			;
 4751: 1			; input:     r3,r2,r1,r0 = acc0
 4752: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4753: 1			;
 4754: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4755: 1			;            CY=1 als N>=32
 4756: 1			; vernietigt:  niets
 4757: 1			;*******************************************************************************
 4758: 1  1083	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4759: 1  1085	C0 D0		                push    psw
 4760: 1  1087	EC		                mov     a,r4            ;neem aantal shifts
 4761: 1  1088	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4762: 1  108B	40 06		shiftright1:    jc      shiftright2
 4763: 1  108D	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4764: 1  108F	D3		                setb    c               ;N buiten bereik
 4765: 1  1090	D0 E0		                pop     acc
 4766: 1  1092	22		                ret
 4767: 1
 4768: 1  1093	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4769: 1  1095	8C F0		                mov     b,r4            ;lusteller initialiseren
 4770: 1  1097	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4771: 1  1098	EB		                mov     a,r3            ;start bij msb
 4772: 1  1099	13		                rrc     a
 4773: 1  109A	FB		                mov     r3,a
 4774: 1  109B	EA		                mov     a,r2
 4775: 1  109C	13		                rrc     a
 4776: 1  109D	FA		                mov     r2,a
 4777: 1  109E	E9		                mov     a,r1
 4778: 1  109F	13		                rrc     a
 4779: 1  10A0	F9		                mov     r1,a
 4780: 1  10A1	E8		                mov     a,r0
 4781: 1  10A2	13		                rrc     a
 4782: 1  10A3	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4783: 1  10A4	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4784: 1  10A7	D0 F0		                pop     b               ;registers herstellen
 4785: 1  10A9	D0 D0		                pop     psw
 4786: 1  10AB	C3		                clr     c               ;N is binnen bereik
 4787: 1  10AC	D0 E0		                pop     acc
 4788: 1  10AE	22		                ret
 4789: 1
 4790: 1			;*******************************************************************************
 4791: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4792: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4793: 1			; (logical shift)
 4794: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4795: 1			;
 4796: 1			; input:     r3,r2,r1,r0 = acc0
 4797: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4798: 1			;
 4799: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4800: 1			;
 4801: 1			; vernietigt:  niets
 4802: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4803: 1  10AF	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4804: 1  10B1	C0 D0		                push    psw
 4805: 1  10B3	EC		                mov     a,r4            ;neem aantal shifts
 4806: 1  10B4	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4807: 1  10B7	40 06		shiftleft1:     jc      shiftleft2
 4808: 1  10B9	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4809: 1  10BB	D3		                setb    c               ;N buiten bereik
 4810: 1  10BC	D0 E0		                pop     acc
 4811: 1  10BE	22		                ret
 4812: 1
 4813: 1  10BF	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4814: 1  10C1	8C F0		                mov     b,r4            ;lusteller initialiseren
 4815: 1  10C3	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4816: 1  10C4	E8		                mov     a,r0            ;start bij lsb
 4817: 1  10C5	33		                rlc     a
 4818: 1  10C6	F8		                mov     r0,a
 4819: 1  10C7	E9		                mov     a,r1
 4820: 1  10C8	33		                rlc     a
 4821: 1  10C9	F9		                mov     r1,a
 4822: 1  10CA	EA		                mov     a,r2
 4823: 1  10CB	33		                rlc     a
 4824: 1  10CC	FA		                mov     r2,a
 4825: 1  10CD	EB		                mov     a,r3
 4826: 1  10CE	33		                rlc     a
 4827: 1  10CF	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4828: 1  10D0	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4829: 1  10D3	D0 F0		                pop     b               ;registers herstellen
 4830: 1  10D5	D0 D0		                pop     psw
 4831: 1  10D7	C3		                clr     c               ;N is binnen bereik
 4832: 1  10D8	D0 E0		                pop     acc
 4833: 1  10DA	22		                ret
 4834: 1
 4835: 1			;*******************************************************************************
 4836: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4837: 1			; (arithmetic shift)
 4838: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4839: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4840: 1			; niet van teken!
 4841: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4842: 1			;                       (-2147483648 tot +2147483647)
 4843: 1			;
 4844: 1			; input:     r3,r2,r1,r0 = acc0
 4845: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4846: 1			;
 4847: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4848: 1			;            CY=1 als N>=31
 4849: 1			; vernietigt:  niets
 4850: 1			;*******************************************************************************
 4851: 1  10DB	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 4852: 1  10DD	C0 D0		                push    psw
 4853: 1  10DF	EC		                mov     a,r4            ;neem aantal shifts
 4854: 1  10E0	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4855: 1  10E3	40 06		s_shiftright1:  jc      s_shiftright2
 4856: 1  10E5	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4857: 1  10E7	D3		                setb    c               ;N buiten bereik
 4858: 1  10E8	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4859: 1  10EA	22		                ret
 4860: 1
 4861: 1  10EB	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4862: 1  10ED	8C F0		                mov     b,r4            ;lusteller initialiseren
 4863: 1  10EF	EB		                mov     a,r3
 4864: 1  10F0	20 E7 04	                jb      acc.7,s_shiftright20
 4865: 1  10F3	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4866: 1  10F5	80 02		                sjmp    s_shiftright3
 4867: 1  10F7	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4868: 1
 4869: 1  10F9	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4870: 1  10FB	EB		                mov     a,r3            ;start bij msb
 4871: 1  10FC	13		                rrc     a
 4872: 1  10FD	FB		                mov     r3,a
 4873: 1  10FE	EA		                mov     a,r2
 4874: 1  10FF	13		                rrc     a
 4875: 1  1100	FA		                mov     r2,a
 4876: 1  1101	E9		                mov     a,r1
 4877: 1  1102	13		                rrc     a
 4878: 1  1103	F9		                mov     r1,a
 4879: 1  1104	E8		                mov     a,r0
 4880: 1  1105	13		                rrc     a
 4881: 1  1106	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4882: 1  1107	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4883: 1  110A	D0 F0		                pop     b               ;registers herstellen
 4884: 1  110C	D0 D0		                pop     psw
 4885: 1  110E	C3		                clr     c               ;N is binnen bereik
 4886: 1  110F	D0 E0		                pop     acc
 4887: 1  1111	22		                ret
 4888: 1
 4889: 1			;*******************************************************************************
 4890: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4891: 1			; (arithmetic shift)
 4892: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4893: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 4894: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4895: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4896: 1			;                       (-2147483648 tot +2147483647)
 4897: 1			;
 4898: 1			; input:     r3,r2,r1,r0 = acc0
 4899: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4900: 1			;
 4901: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4902: 1			;            CY=1 als N>=31
 4903: 1			; vernietigt:  niets
 4904: 1			;*******************************************************************************
 4905: 1  1112	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 4906: 1  1114	C0 D0		                push    psw
 4907: 1  1116	EC		                mov     a,r4            ;neem aantal shifts
 4908: 1  1117	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4909: 1  111A	40 06		s_shiftleft1:   jc      s_shiftleft2
 4910: 1  111C	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4911: 1  111E	D3		                setb    c               ;N buiten bereik
 4912: 1  111F	D0 E0		                pop     acc
 4913: 1  1121	22		                ret
 4914: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4915: 1  1122	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4916: 1  1124	8C F0		                mov     b,r4            ;lusteller initialiseren
 4917: 1
 4918: 1
 4919: 1
 4920: 1  1126	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4921: 1  1127	E8		                mov     a,r0             ;start bij lsb
 4922: 1  1128	33		                rlc     a
 4923: 1  1129	F8		                mov     r0,a
 4924: 1  112A	E9		                mov     a,r1
 4925: 1  112B	33		                rlc     a
 4926: 1  112C	F9		                mov     r1,a
 4927: 1  112D	EA		                mov     a,r2
 4928: 1  112E	33		                rlc     a
 4929: 1  112F	FA		                mov     r2,a
 4930: 1  1130	EB		                mov     a,r3
 4931: 1  1131	33		                rlc     a
 4932: 1  1132	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4933: 1  1134	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4934: 1  1135	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4935: 1  1138	D0 F0		                pop     b                ;registers herstellen
 4936: 1  113A	D0 D0		                pop     psw
 4937: 1  113C	C3		                clr     c                ;N is binnen bereik
 4938: 1  113D	D0 E0		                pop     acc
 4939: 1  113F	22		                ret
 4940: 1
 4941: 1			;*******************************************************************************
 4942: 1			; s_cmp16    (29,5us @16.777216MHz)
 4943: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4944: 1			;
 4945: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4946: 1			;
 4947: 1			; input:     r1,r0 = acc0
 4948: 1			;            r5,r4 = acc1
 4949: 1			;
 4950: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4951: 1			;             f0=0,cy=0  als acc0 > acc1
 4952: 1			;             f0=1 cy=0    als acc1 = acc0
 4953: 1			;
 4954: 1			; vernietigt:  niets
 4955: 1			;*******************************************************************************
 4956: 1  1140	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4957: 1  1142	C0 D0		                push    psw
 4958: 1  1144	E8		                mov     a,r0
 4959: 1  1145	C0 E0		                push    acc
 4960: 1  1147	E9		                mov     a,r1
 4961: 1  1148	C0 E0		                push    acc
 4962: 1
 4963: 1  114A	E9		                mov     a,r1            ;neem msb van acc0
 4964: 1  114B	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4965: 1  114C	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4966: 1  114F	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4967: 1			                                        ;negatief is
 4968: 1  1150	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4969: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4970: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4971: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4972: 1			;acc0>acc1
 4973: 1  1153	D0 E0		s_cmp160:       pop     acc
 4974: 1  1155	F9		                mov     r1,a
 4975: 1  1156	D0 E0		                pop     acc
 4976: 1  1158	F8		                mov     r0,a
 4977: 1  1159	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4978: 1  115B	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4979: 1  115D	C3		                clr     c               ;geef dit aan in de outputstatus
 4980: 1  115E	D0 E0		                pop     acc
 4981: 1  1160	22		                ret
 4982: 1			;acc0<acc1
 4983: 1  1161	D0 E0		s_cmp161:       pop     acc
 4984: 1  1163	F9		                mov     r1,a
 4985: 1  1164	D0 E0		                pop     acc
 4986: 1  1166	F8		                mov     r0,a
 4987: 1  1167	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4988: 1  1169	D3		                setb    c               ;groter dan acc0
 4989: 1  116A	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4990: 1  116C	D0 E0		                pop     acc
 4991: 1  116E	22		                ret
 4992: 1			;gelijk teken, maak verschil
 4993: 1  116F	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 4994: 1  1170	E8		                mov     a,r0            ;acc0-acc1
 4995: 1  1171	9C		                subb    a,r4
 4996: 1  1172	F8		                mov     r0,a
 4997: 1  1173	E9		                mov     a,r1
 4998: 1  1174	9D		                subb    a,r5
 4999: 1  1175	F9		                mov     r1,a
 5000: 1  1176	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 5001: 1  1179	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5002: 1  117A	60 02		                jz      s_cmp163        ;acc0=acc1
 5003: 1  117C	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 5004: 1			;acc0=acc1
 5005: 1  117E	D0 E0		s_cmp163:       pop     acc
 5006: 1  1180	F9		                mov     r1,a
 5007: 1  1181	D0 E0		                pop     acc
 5008: 1  1183	F8		                mov     r0,a
 5009: 1  1184	D0 D0		                pop     psw             ;acc0=acc1
 5010: 1  1186	C3		                clr     c               ;geef dit aan in de outputstatus
 5011: 1  1187	D2 D5		                setb    f0
 5012: 1  1189	D0 E0		                pop     acc
 5013: 1  118B	22		                ret
 5014: 1
 5015: 1			;*******************************************************************************
 5016: 1			; cmp16            (19,9us @16.777216MHz)
 5017: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 5018: 1			;
 5019: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 5020: 1			;
 5021: 1			; input:     r1,r0 = acc0
 5022: 1			;            r5,r4 = acc1
 5023: 1			;
 5024: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5025: 1			;             f0=0,cy=0  als acc0 > acc1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5026: 1			;             f0=1 cy=0    als acc1 = acc0
 5027: 1			;
 5028: 1			; vernietigt:  niets
 5029: 1			;*******************************************************************************
 5030: 1  118C	C0 E0		cmp16:          push    acc             ;bewaar registers
 5031: 1  118E	C0 F0		                push    b
 5032: 1  1190	C0 D0		                push    psw
 5033: 1
 5034: 1  1192	C3		                clr     c               ;vergelijk acc0 met acc1
 5035: 1  1193	E9		                mov     a,r1            ;eerst de msb's
 5036: 1  1194	8D F0		                mov     b,r5            ;test r1-r5
 5037: 1  1196	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 5038: 1
 5039: 1  1199	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 5040: 1  119A	8C F0		                mov     b,r4            ;test r0-r4
 5041: 1  119C	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 5042: 1			;acc0=acc1
 5043: 1  119F	D0 D0		                pop     psw
 5044: 1  11A1	D2 D5		                setb    f0
 5045: 1  11A3	C3		                clr     c
 5046: 1  11A4	D0 F0		                pop     b
 5047: 1  11A6	D0 E0		                pop     acc
 5048: 1  11A8	22		                ret
 5049: 1  11A9	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 5050: 1			;acc0>acc1
 5051: 1  11AB	D0 D0		                pop     psw
 5052: 1  11AD	C2 D5		                clr     f0
 5053: 1  11AF	C3		                clr     c
 5054: 1  11B0	D0 F0		                pop     b
 5055: 1  11B2	D0 E0		                pop     acc
 5056: 1  11B4	22		                ret
 5057: 1			;acc0<acc1
 5058: 1  11B5	D0 D0		cmp162:         pop     psw
 5059: 1  11B7	D3		                setb    c
 5060: 1  11B8	C2 D5		                clr     f0
 5061: 1  11BA	D0 F0		                pop     b
 5062: 1  11BC	D0 E0		                pop     acc
 5063: 1  11BE	22		                ret
 5064: 1
 5065: 1			;*******************************************************************************
 5066: 1			; s_cmp32        (44,3us @16.777216MHz)
 5067: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 5068: 1			;
 5069: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 5070: 1			;                         -2147483648 tot +2147483647
 5071: 1			; input:     r1,r0 = acc0
 5072: 1			;            r5,r4 = acc1
 5073: 1			;
 5074: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5075: 1			;             f0=0,cy=0  als acc0 > acc1
 5076: 1			;             f0=1 cy=0    als acc1 = acc0
 5077: 1			;
 5078: 1			; vernietigt:  niets
 5079: 1			;*******************************************************************************
 5080: 1  11BF	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 5081: 1  11C1	C0 D0		                push    psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5082: 1  11C3	E8		                mov     a,r0
 5083: 1  11C4	C0 E0		                push    acc
 5084: 1  11C6	E9		                mov     a,r1
 5085: 1  11C7	C0 E0		                push    acc
 5086: 1  11C9	EA		                mov     a,r2
 5087: 1  11CA	C0 E0		                push    acc
 5088: 1  11CC	EB		                mov     a,r3
 5089: 1  11CD	C0 E0		                push    acc
 5090: 1
 5091: 1  11CF	EB		                mov     a,r3            ;neem msb van acc0
 5092: 1  11D0	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 5093: 1  11D1	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 5094: 1  11D3	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 5095: 1  11D5	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 5096: 1  11D6	A2 E7		                mov     c,acc.7         ;negatief is
 5097: 1  11D8	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 5098: 1			                                        ;acc1 positief. Dus acc1>acc0
 5099: 1			;acc0>acc1
 5100: 1  11DA	D0 E0		s_cmp320:       pop     acc
 5101: 1  11DC	FB		                mov     r3,a
 5102: 1  11DD	D0 E0		                pop     acc
 5103: 1  11DF	FA		                mov     r2,a
 5104: 1  11E0	D0 E0		                pop     acc
 5105: 1  11E2	F9		                mov     r1,a
 5106: 1  11E3	D0 E0		                pop     acc
 5107: 1  11E5	F8		                mov     r0,a
 5108: 1  11E6	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5109: 1  11E8	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5110: 1  11EA	C3		                clr     c               ;geef dit aan in de outputstatus
 5111: 1  11EB	D0 E0		                pop     acc
 5112: 1  11ED	22		                ret
 5113: 1			;acc0<acc1
 5114: 1  11EE	D0 E0		s_cmp321:       pop     acc
 5115: 1  11F0	FB		                mov     r3,a
 5116: 1  11F1	D0 E0		                pop     acc
 5117: 1  11F3	FA		                mov     r2,a
 5118: 1  11F4	D0 E0		                pop     acc
 5119: 1  11F6	F9		                mov     r1,a
 5120: 1  11F7	D0 E0		                pop     acc
 5121: 1  11F9	F8		                mov     r0,a
 5122: 1  11FA	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5123: 1  11FC	D3		                setb    c               ;groter dan acc0
 5124: 1  11FD	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5125: 1  11FF	D0 E0		                pop     acc
 5126: 1  1201	22		                ret
 5127: 1			;gelijk teken, maak verschil
 5128: 1  1202	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5129: 1  1203	E8		                mov     a,r0            ;acc0-acc1
 5130: 1  1204	9C		                subb    a,r4
 5131: 1  1205	F8		                mov     r0,a
 5132: 1  1206	E9		                mov     a,r1
 5133: 1  1207	9D		                subb    a,r5
 5134: 1  1208	F9		                mov     r1,a
 5135: 1  1209	EA		                mov     a,r2
 5136: 1  120A	9E		                subb    a,r6
 5137: 1  120B	FA		                mov     r2,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5138: 1  120C	EB		                mov     a,r3
 5139: 1  120D	9F		                subb    a,r7
 5140: 1  120E	FB		                mov     r3,a
 5141: 1  120F	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5142: 1  1212	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5143: 1  1213	49		                orl     a,r1
 5144: 1  1214	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5145: 1  1215	60 02		                jz      s_cmp323        ;acc0=acc1
 5146: 1  1217	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5147: 1			;acc0=acc1
 5148: 1  1219	D0 E0		s_cmp323:       pop     acc
 5149: 1  121B	FB		                mov     r3,a
 5150: 1  121C	D0 E0		                pop     acc
 5151: 1  121E	FA		                mov     r2,a
 5152: 1  121F	D0 E0		                pop     acc
 5153: 1  1221	F9		                mov     r1,a
 5154: 1  1222	D0 E0		                pop     acc
 5155: 1  1224	F8		                mov     r0,a
 5156: 1  1225	D0 D0		                pop     psw             ;acc0=acc1
 5157: 1  1227	C3		                clr     c               ;geef dit aan in de outputstatus
 5158: 1  1228	D2 D5		                setb    f0
 5159: 1  122A	D0 E0		                pop     acc
 5160: 1  122C	22		                ret
 5161: 1
 5162: 1			;*******************************************************************************
 5163: 1			; cmp32        (27,14us @16.777216MHz)
 5164: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5165: 1			;
 5166: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5167: 1			;
 5168: 1			; input:     r3,r2,r1,r0 = acc0
 5169: 1			;            r7,r6,r5,r4 = acc1
 5170: 1			;
 5171: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5172: 1			;            f0=0,cy=0  als acc0 > acc1
 5173: 1			;            f0=1 cy=0    als acc1 = acc0
 5174: 1			;
 5175: 1			; vernietigt:  niets
 5176: 1			;*******************************************************************************
 5177: 1  122D	C0 E0		cmp32:          push    acc             ;bewaar registers
 5178: 1  122F	C0 F0		                push    b
 5179: 1  1231	C0 D0		                push    psw
 5180: 1
 5181: 1  1233	C3		                clr     c               ;vergelijk acc0 met acc1
 5182: 1  1234	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5183: 1  1235	8F F0		                mov     b,r7            ;test r3-r7
 5184: 1  1237	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5185: 1
 5186: 1  123A	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5187: 1  123B	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5188: 1  123D	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5189: 1
 5190: 1  1240	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5191: 1  1241	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5192: 1  1243	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5193: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5194: 1  1246	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5195: 1  1247	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5196: 1  1249	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5197: 1			;acc0=acc1
 5198: 1  124C	D0 D0		                pop     psw
 5199: 1  124E	D2 D5		                setb    f0
 5200: 1  1250	C3		                clr     c
 5201: 1  1251	D0 F0		                pop     b
 5202: 1  1253	D0 E0		                pop     acc
 5203: 1  1255	22		                ret
 5204: 1  1256	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5205: 1			;acc0>acc1, indien cy=0
 5206: 1  1258	D0 D0		                pop     psw
 5207: 1  125A	C2 D5		                clr     f0
 5208: 1  125C	C3		                clr     c
 5209: 1  125D	D0 F0		                pop     b
 5210: 1  125F	D0 E0		                pop     acc
 5211: 1  1261	22		                ret
 5212: 1			;acc0<acc1
 5213: 1  1262	D0 D0		cmp322:         pop     psw
 5214: 1  1264	D3		                setb    c
 5215: 1  1265	C2 D5		                clr     f0
 5216: 1  1267	D0 F0		                pop     b
 5217: 1  1269	D0 E0		                pop     acc
 5218: 1  126B	22		                ret
 5219: 1
 5220: 1
 5221: 1			;*******************************************************************************
 5222: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5223: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5224: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5225: 1			; adres zitten.
 5226: 1			;
 5227: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5228: 1			;
 5229: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5230: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5231: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis
 5232: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5233: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5234: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5235: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5236: 1			;                cy = 0  lookup is ok
 5237: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5238: 1			; vernietigt:  niets
 5239: 1			;*******************************************************************************
 5240: 1  126C	C0 E0		table_lu:       push    acc             ;bewaren registers
 5241: 1  126E	C0 D0		                push    psw
 5242: 1  1270	C0 82		                push    dpl
 5243: 1  1272	C0 83		                push    dph
 5244: 1
 5245: 1  1274	A2 D5		                mov     c,f0            ;byte of word items?
 5246: 1  1276	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5247: 1			;tabel met byte items
 5248: 1  1278	E5 82		                mov     a,dpl           ;datapointer plus index
 5249: 1  127A	28		                add     a,r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5250: 1  127B	F5 82		                mov     dpl,a
 5251: 1  127D	E5 83		                mov     a,dph
 5252: 1  127F	39		                addc    a,r1
 5253: 1  1280	F5 83		                mov     dph,a
 5254: 1  1282	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5255: 1  1284	A2 D1		                mov     c,f1            ;code of datageheugen?
 5256: 1  1286	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5257: 1
 5258: 1			;bytetabel in codegeheugen
 5259: 1  1288	74 00		                mov     a,#0
 5260: 1  128A	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5261: 1  128B	F8		                mov     r0,a            ;en stop in acc0
 5262: 1  128C	79 00		                mov     r1,#0
 5263: 1  128E	02 12 ED	                ljmp    table_lu4       ;en klaar
 5264: 1
 5265: 1			;bytetabel in datageheugen
 5266: 1  1291	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5267: 1  1292	F8		                mov     r0,a            ;en stop in acc0
 5268: 1  1293	79 00		                mov     r1,#0
 5269: 1  1295	02 12 ED	                ljmp    table_lu4       ;en klaar
 5270: 1
 5271: 1  1298	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5272: 1  129A	D0 82		                pop     dpl
 5273: 1  129C	D0 D0		                pop     psw
 5274: 1  129E	D3		                setb    c              ;foutstatus teruggeven!
 5275: 1  129F	D0 E0		                pop     acc
 5276: 1  12A1	22		                ret
 5277: 1
 5278: 1			;tabel met word items
 5279: 1  12A2	E8		table_lu2:      mov     a,r0            ;index op stack
 5280: 1  12A3	C0 E0		                push    acc
 5281: 1  12A5	E9		                mov     a,r1
 5282: 1  12A6	C0 E0		                push    acc
 5283: 1
 5284: 1  12A8	C3		                clr      c              ;index maal 2 (word items)
 5285: 1  12A9	E8		                mov     a,r0
 5286: 1  12AA	33		                rlc     a
 5287: 1  12AB	F8		                mov     r0,a
 5288: 1  12AC	E9		                mov     a,r1
 5289: 1  12AD	33		                rlc     a
 5290: 1  12AE	F9		                mov     r1,a
 5291: 1
 5292: 1  12AF	E5 82		                mov     a,dpl           ;datapointer plus index
 5293: 1  12B1	28		                add     a,r0
 5294: 1  12B2	F5 82		                mov     dpl,a
 5295: 1  12B4	E5 83		                mov     a,dph
 5296: 1  12B6	39		                addc    a,r1
 5297: 1  12B7	F5 83		                mov     dph,a
 5298: 1
 5299: 1  12B9	D0 E0		                pop     acc             ;index weer van stack
 5300: 1  12BB	F9		                mov     r1,a
 5301: 1  12BC	D0 E0		                pop     acc
 5302: 1  12BE	F8		                mov     r0,a
 5303: 1
 5304: 1  12BF	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5305: 1  12C1	A2 D1		                mov     c,f1            ;code of datageheugen?

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5306: 1  12C3	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5307: 1			;wordtabel in codegeheugen
 5308: 1  12C5	74 00		                mov     a,#0
 5309: 1  12C7	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5310: 1  12C8	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5311: 1  12C9	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5312: 1  12CB	24 01		                add     a,#1
 5313: 1  12CD	F5 82		                mov     dpl,a
 5314: 1  12CF	E5 83		                mov     a,dph
 5315: 1  12D1	34 00		                addc    a,#0
 5316: 1  12D3	F5 83		                mov     dph,a
 5317: 1  12D5	74 00		                mov     a,#0
 5318: 1  12D7	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5319: 1  12D8	F9		                mov     r1,a            ;msb in acc0 stoppen
 5320: 1  12D9	80 12		                sjmp    table_lu4        ;en klaar
 5321: 1			;wordtabel    in datageheugen
 5322: 1  12DB	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5323: 1  12DC	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5324: 1  12DD	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5325: 1  12DF	24 01		                add     a,#1
 5326: 1  12E1	F5 82		                mov     dpl,a
 5327: 1  12E3	E5 83		                mov     a,dph
 5328: 1  12E5	34 00		                addc    a,#0
 5329: 1  12E7	F5 83		                mov     dph,a
 5330: 1  12E9	74 00		                mov     a,#0
 5331: 1  12EB	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5332: 1  12EC	F9		                mov     r1,a            ;msb in acc0 stoppen
 5333: 1			                                        ;en klaar
 5334: 1
 5335: 1  12ED	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5336: 1  12EF	D0 82		                pop     dpl
 5337: 1  12F1	D0 D0		                pop     psw
 5338: 1  12F3	D0 E0		                pop     acc
 5339: 1  12F5	22		                ret
 5340: 1
 5341: 1
 5342: 1
 5343: 1			;*******************************************************************************
 5344: 1			; Cordic        (2,11ms @16.777216MHz)
 5345: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5346: 1			; waarde (2's complement) opgegeven hoek.
 5347: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5348: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5349: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5350: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5351: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5352: 1			; als geschaalde getallen ter beschikking komen.
 5353: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5354: 1			;
 5355: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5356: 1			;
 5357: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5358: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5359: 1			;            cy = 0 : hoek binnen bereik
 5360: 1			;            cy = 1 : error, hoek buiten bereik
 5361: 1			;            nauwkeurigheid: 12 msbits

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5362: 1			; vernietigt:  niets
 5363: 1			;*******************************************************************************
 5364: 1  12F6	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5365: 1  12F8	C0 D0		                push    psw
 5366: 1  12FA	C0 83		                push    dph
 5367: 1  12FC	C0 82		                push    dpl
 5368: 1  12FE	C0 F0		                push    b
 5369: 1
 5370: 1  1300	EF		                mov     a,r7
 5371: 1  1301	C0 E0		                push    acc
 5372: 1  1303	EE		                mov     a,r6
 5373: 1  1304	C0 E0		                push    acc
 5374: 1  1306	ED		                mov     a,r5
 5375: 1  1307	C0 E0		                push    acc
 5376: 1  1309	EC		                mov     a,r4
 5377: 1  130A	C0 E0		                push    acc
 5378: 1
 5379: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5380: 1			;en niet groter dan pi/2 radialen (6478h)
 5381: 1  130C	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5382: 1  130E	7D 64		                mov     r5,#64h
 5383: 1  1310	12 11 8C	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5384: 1  1313	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5385: 1  1316	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5386: 1  1318	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5387: 1
 5388: 1  131A	C2 A0		cordic000:      clr     p2.0
 5389: 1  131C	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5390: 1  131E	7D 9B		                mov     r5,#9bh
 5391: 1  1320	12 11 8C	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5392: 1  1323	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5393: 1  1326	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5394: 1  1328	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5395: 1
 5396: 1  132A	C2 A1		cordic_error:   clr     p2.1
 5397: 1  132C	02 13 DE	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5398: 1
 5399: 1			;Hoek is -pi/2 resultaat gekend
 5400: 1  132F	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5401: 1  1331	7A 00		                mov     r2,#000h
 5402: 1  1333	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5403: 1  1335	78 00		                mov     r0,#000h
 5404: 1  1337	C3		                clr     c
 5405: 1  1338	02 13 DE	                ljmp    cordic40        ;en klaar
 5406: 1			;hoek is +pi/2 resultaat gekend
 5407: 1  133B	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5408: 1  133D	7A FF		                mov     r2,#0ffh
 5409: 1  133F	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5410: 1  1341	78 00		                mov     r0,#000h
 5411: 1  1343	C3		                clr     c
 5412: 1  1344	02 13 DE	                ljmp    cordic40        ;en klaar
 5413: 1
 5414: 1  1347	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5415: 1  1349	7D 00		                mov     r5,#00h
 5416: 1  134B	12 11 8C	                lcall   cmp16            ;vergelijk de hoeken
 5417: 1  134E	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5418: 1  1351	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5419: 1			;hoek is 0, resultaat gekend
 5420: 1  1353	C2 A7		cordic_nul:     clr     p2.7
 5421: 1  1355	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5422: 1  1357	7A 00		                mov     r2,#000h
 5423: 1  1359	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5424: 1  135B	78 FF		                mov     r0,#0ffh
 5425: 1  135D	C3		                clr     c
 5426: 1  135E	02 13 DE	                ljmp    cordic40        ;en klaar
 5427: 1
 5428: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5429: 1  1361	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5430: 1  1362	C0 E0		                push    acc
 5431: 1  1364	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5432: 1  1365	C0 E0		                push    acc
 5433: 1
 5434: 1  1367	7B 00		                mov     r3,#00h         ;y=0
 5435: 1  1369	7A 00		                mov     r2,#00h
 5436: 1  136B	79 26		                mov     r1,#026h        ;x = K * 2^14
 5437: 1  136D	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5438: 1
 5439: 1  136F	75 F0 00	                mov     b,#00h          ;loopteller=0
 5440: 1
 5441: 1  1372	90 14 36	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5442: 1
 5443: 1  1375	EB		cordic1:        mov     a,r3            ;sry=y
 5444: 1  1376	FF		                mov     r7,a
 5445: 1  1377	EA		                mov     a,r2
 5446: 1  1378	FE		                mov     r6,a
 5447: 1  1379	E9		                mov     a,r1            ;srx=x
 5448: 1  137A	FD		                mov     r5,a
 5449: 1  137B	E8		                mov     a,r0
 5450: 1  137C	FC		                mov     r4,a
 5451: 1
 5452: 1  137D	12 13 FD	                lcall   cordic5          ;srx en sry >> loopteller
 5453: 1
 5454: 1  1380	D0 E0		                pop     acc
 5455: 1  1382	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten
 5456: 1
 5457: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5458: 1  1385	C3		                clr     c
 5459: 1  1386	E8		                mov     a,r0            ;bereken x=x-sry
 5460: 1  1387	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5461: 1  1388	F8		                mov     r0,a
 5462: 1  1389	E9		                mov     a,r1
 5463: 1  138A	9F		                subb    a,r7
 5464: 1  138B	F9		                mov     r1,a
 5465: 1
 5466: 1  138C	EA		                mov     a,r2            ;bereken y=y+srx
 5467: 1  138D	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5468: 1  138E	FA		                mov     r2,a
 5469: 1  138F	EB		                mov     a,r3
 5470: 1  1390	3D		                addc    a,r5
 5471: 1  1391	FB		                mov     r3,a
 5472: 1
 5473: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5474: 1  1392	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5475: 1  1394	93		                movc    a,@a+dptr
 5476: 1  1395	A3		                inc     dptr
 5477: 1  1396	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5478: 1  1397	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5479: 1  1399	C3		                clr     c               ;verklein de hoek
 5480: 1  139A	9C		                subb    a,r4
 5481: 1  139B	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5482: 1  139D	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5483: 1
 5484: 1  139F	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5485: 1  13A1	93		                movc    a,@a+dptr
 5486: 1  13A2	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5487: 1  13A3	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5488: 1  13A4	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5489: 1  13A6	9D		                subb    a,r5            ;verklein de hoek
 5490: 1  13A7	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5491: 1
 5492: 1			;loopteller incrementeren en testen op einde van de iteratie
 5493: 1  13A9	05 F0		cordic2:        inc     b               ;loopteller++
 5494: 1  13AB	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5495: 1  13AD	65 F0		                xrl     a,b             ;test op gelijkheid
 5496: 1  13AF	60 28		                jz      cordic4         ;ja klaar!
 5497: 1  13B1	02 13 75	                ljmp    cordic1         ;nee, nog even verder...
 5498: 1
 5499: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5500: 1  13B4	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5501: 1  13B5	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5502: 1  13B6	F8		                mov     r0,a
 5503: 1  13B7	E9		                mov     a,r1
 5504: 1  13B8	3F		                addc    a,r7
 5505: 1  13B9	F9		                mov     r1,a
 5506: 1
 5507: 1  13BA	C3		                clr     c
 5508: 1  13BB	EA		                mov     a,r2            ;bereken y=y-srx
 5509: 1  13BC	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5510: 1  13BD	FA		                mov     r2,a
 5511: 1  13BE	EB		                mov     a,r3
 5512: 1  13BF	9D		                subb    a,r5
 5513: 1  13C0	FB		                mov     r3,a
 5514: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5515: 1  13C1	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5516: 1  13C3	93		                movc    a,@a+dptr
 5517: 1  13C4	A3		                inc     dptr
 5518: 1  13C5	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5519: 1  13C6	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5520: 1  13C8	2C		                add     a,r4            ;vergroot de hoek
 5521: 1  13C9	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5522: 1  13CB	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5523: 1
 5524: 1  13CD	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5525: 1  13CF	93		                movc    a,@a+dptr
 5526: 1  13D0	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5527: 1  13D1	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5528: 1  13D2	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5529: 1  13D4	3D		                addc    a,r5            ;vergroot de hoek

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5530: 1  13D5	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5531: 1
 5532: 1  13D7	80 D0		                sjmp    cordic2
 5533: 1
 5534: 1  13D9	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5535: 1  13DB	D0 E0		                pop     acc             ;dummy hoek van stack
 5536: 1  13DD	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5537: 1
 5538: 1  13DE	D0 E0		cordic40:       pop     acc
 5539: 1  13E0	FC		                mov     r4,a
 5540: 1  13E1	D0 E0		                pop     acc
 5541: 1  13E3	FD		                mov     r5,a
 5542: 1  13E4	D0 E0		                pop     acc
 5543: 1  13E6	FE		                mov     r6,a
 5544: 1  13E7	D0 E0		                pop     acc
 5545: 1  13E9	FF		                mov     r7,a
 5546: 1  13EA	D0 F0		                pop     b
 5547: 1  13EC	D0 82		                pop     dpl
 5548: 1  13EE	D0 83		                pop     dph
 5549: 1  13F0	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5550: 1  13F2	D0 D0		                pop     psw
 5551: 1  13F4	D0 E0		                pop     acc
 5552: 1  13F6	22		                ret
 5553: 1
 5554: 1  13F7	D0 D0		cordic41:       pop     psw
 5555: 1  13F9	D3		                setb    c
 5556: 1  13FA	D0 E0		                pop     acc
 5557: 1  13FC	22		                ret
 5558: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5559: 1			;over het aantal posities aangegeven in het B register.
 5560: 1  13FD	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5561: 1  13FF	74 00		                mov     a,#0            ;test of loopteller=0
 5562: 1  1401	65 F0		                xrl     a,b
 5563: 1  1403	60 2E		                jz      cordic52        ;klaar
 5564: 1
 5565: 1  1405	ED		                mov     a,r5            ;test teken van srx
 5566: 1  1406	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5567: 1  1409	C2 D5		                clr     f0              ;geef aan dat srx positief is
 5568: 1  140B	80 02		                sjmp    cordic50
 5569: 1  140D	D2 D5		cordic5a:       setb    f0
 5570: 1  140F	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5571: 1  1411	ED		                mov     a,r5            ;eerst de msb
 5572: 1  1412	13		                rrc     a
 5573: 1  1413	FD		                mov     r5,a
 5574: 1  1414	EC		                mov     a,r4            ;dan de lsb
 5575: 1  1415	13		                rrc     a
 5576: 1  1416	FC		                mov     r4,a
 5577: 1  1417	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5578: 1  141A	D0 F0		                pop     b               ;haal de loopteller van stack
 5579: 1  141C	C0 F0		                push    b               ;en bewaar hem weer
 5580: 1  141E	EF		                mov     a,r7            ;test teken van sry
 5581: 1  141F	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5582: 1  1422	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5583: 1  1424	80 02		                sjmp    cordic51
 5584: 1  1426	D2 D5		cordic5b:       setb    f0
 5585: 1  1428	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5586: 1  142A	EF		                mov     a,r7            ;eerst de msb
 5587: 1  142B	13		                rrc     a
 5588: 1  142C	FF		                mov     r7,a
 5589: 1  142D	EE		                mov     a,r6            ;dan de lsb
 5590: 1  142E	13		                rrc     a
 5591: 1  142F	FE		                mov     r6,a
 5592: 1  1430	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5593: 1
 5594: 1  1433	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5595: 1  1435	22		                ret
 5596: 1
 5597: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5598: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5599: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5600: 1  1436	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5601: 1  1438	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5602: 1  143A	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5603: 1  143C	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5604: 1  143E	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5605: 1  1440	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5606: 1  1442	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5607: 1  1444	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5608: 1  1446	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5609: 1  1448	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5610: 1  144A	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5611: 1  144C	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5612: 1  144E	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5613: 1  1450	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5614: 1  1452	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5615: 1
 5616: 1			endif        ;einde van aduc_math
 5617: 1			;******************************************************************************
 5618: 1
 5619: 1			ifdef        aduc_adc    ;A/D conversie routines
 5620: 1			;*******************************************************************************
 5621: 1			; ADuCADC_mide
 5622: 1			; Geschreven door [dp] op 5/1/2014
 5623: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.
 5624: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5625: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5626: 1			; bron instellen.
 5627: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5628: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5629: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5630: 1			;
 5631: 1			;*******************************************************************************
 5632: 1
 5633: 1			;*******************************************************************************
 5634: 1			; adc_init
 5635: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5636: 1			; -  4 track&hold clockperiodes
 5637: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5638: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5639: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5640: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5641: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5642: 1			; input: R0 =  0  : Interne referentiebron
 5643: 1			;        R0 <> 0  : Externe referentiebron
 5644: 1			;
 5645: 1			; Deze routine vernietigt niets
 5646: 1			;*******************************************************************************
 5647: 1  1454	C0 E0		adc_init:       push    acc                 ;registers op stack
 5648: 1  1456	C0 D0		                push    psw
 5649: 1  1458	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5650: 1  145B	E8		                mov     a,r0                ;welke referentiebron?
 5651: 1  145C	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5652: 1  145E	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5653: 1  1461	D0 D0		adc_init1:      pop     psw
 5654: 1  1463	D0 E0		                pop     acc
 5655: 1  1465	22		                ret
 5656: 1
 5657: 1			;*******************************************************************************
 5658: 1			; adc_single
 5659: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5660: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5661: 1			; (2's complement) formaat van de meetwaarde.
 5662: 1			; _____________________________________________________________
 5663: 1			; resolutie  |     unsigned      |           signed            |
 5664: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5665: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5666: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5667: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5668: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5669: 1			; _____________________________________________________________
 5670: 1			;
 5671: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5672: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5673: 1			; De ingangsparameter wordt doorgegeven via R0.
 5674: 1			;
 5675: 1			; input:
 5676: 1			;             7    6    5    4    3    2    1    0
 5677: 1			;           _______________________________________
 5678: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5679: 1			;           ---------------------------------------
 5680: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5681: 1			;                                         1000b = temp.sensor
 5682: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5683: 1			;                                   10b = 12 bits, 11b = 12 bits
 5684: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5685: 1			;
 5686: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5687: 1			;         cy=0  bij conversie ok
 5688: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5689: 1			;
 5690: 1			; Deze routine vernietigt niets
 5691: 1			;*******************************************************************************
 5692: 1  1466	C0 E0		adc_single:     push    acc                 ;registers op stack
 5693: 1  1468	C0 D0		                push    psw
 5694: 1  146A	C0 F0		                push    b
 5695: 1  146C	E8		                mov     a,r0                ;neem inputparameter
 5696: 1  146D	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5697: 1  146F	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5698: 1  1472	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5699: 1  1474	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5700: 1  1476	D2 DC		                setb    sconv               ;start een meting
 5701: 1  1478	E8		                mov     a,r0                ;neem parameter terug
 5702: 1  1479	A2 E6		                mov     c,acc.6
 5703: 1  147B	92 D5		                mov     f0,c                ;bewaar format bit
 5704: 1  147D	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5705: 1  1480	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5706: 1  1483	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5707: 1  1486	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5708: 1			;*******************************************************************************
 5709: 1			;8 bit resultaat gevraagd
 5710: 1			;*******************************************************************************
 5711: 1  1489	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5712: 1  148B	C4		                swap    a                    ;swap nibbles
 5713: 1  148C	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5714: 1  148E	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5715: 1  1490	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5716: 1  1492	C4		                swap    a
 5717: 1  1493	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5718: 1  1495	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5719: 1			;8 bit unsigned formaat
 5720: 1  1498	79 00		                mov     r1,#00h              ;unsigned
 5721: 1  149A	F8		                mov     r0,a
 5722: 1  149B	80 63		                sjmp    adc_single42
 5723: 1			;8 bit signed formaat
 5724: 1  149D	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5725: 1  14A0	24 80		                add     a,#80h                ;negatief getal van maken
 5726: 1  14A2	F8		                mov     r0,a
 5727: 1  14A3	79 FF		                mov     r1,#0ffh
 5728: 1  14A5	80 59		                sjmp    adc_single42
 5729: 1  14A7	C3		adc_single20:   clr     c
 5730: 1  14A8	94 80		                subb    a,#80h                ;positief deel verkleinen
 5731: 1  14AA	F8		                mov     r0,a
 5732: 1  14AB	79 00		                mov     r1,#00h
 5733: 1  14AD	80 51		                sjmp    adc_single42
 5734: 1
 5735: 1  14AF	02 15 08	adc_single21:   ljmp    adc_single43
 5736: 1			;*******************************************************************************
 5737: 1			;10 bit resultaat gevraagd
 5738: 1			;*******************************************************************************
 5739: 1  14B2	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5740: 1  14B4	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5741: 1  14B6	03		                rr     a              ;naar msbits roteren
 5742: 1  14B7	03		                rr     a
 5743: 1  14B8	F5 F0		                mov    b,a            ;even bewaren
 5744: 1  14BA	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5745: 1  14BC	03		                rr     a              ;twee plaatsen opschuiven
 5746: 1  14BD	03		                rr     a
 5747: 1  14BE	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5748: 1  14C0	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5749: 1  14C2	F5 F0		                mov    b,a            ;low byte even bewaren
 5750: 1  14C4	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5751: 1  14C6	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5752: 1  14C8	03		                rr     a               ;en op hun plaats schuiven
 5753: 1  14C9	03		                rr     a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5754: 1  14CA	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5755: 1			;10 bit unsigned formaat
 5756: 1  14CD	F9		                mov    r1,a            ;unsigned
 5757: 1  14CE	A8 F0		                mov    r0,b
 5758: 1  14D0	80 2E		                sjmp   adc_single42
 5759: 1			;10 bit signed formaat
 5760: 1  14D2	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5761: 1  14D5	24 FE		                add    a,#0feh             ;negatief getal van maken
 5762: 1  14D7	F9		                mov    r1,a
 5763: 1  14D8	A8 F0		                mov    r0,b
 5764: 1  14DA	80 24		                sjmp   adc_single42
 5765: 1  14DC	C3		adc_single31:   clr    c
 5766: 1  14DD	94 02		                subb   a,#02h              ;positief deel verkleinen
 5767: 1  14DF	F9		                mov    r1,a
 5768: 1  14E0	A8 F0		                mov    r0,b
 5769: 1  14E2	80 1C		                sjmp   adc_single42
 5770: 1
 5771: 1			;*******************************************************************************
 5772: 1			;12 bit resultaat gevraagd
 5773: 1			;*******************************************************************************
 5774: 1  14E4	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5775: 1  14E6	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5776: 1  14E8	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5777: 1			;12 bit unsigned formaat
 5778: 1  14EB	A8 D9		                mov    r0,adcdatal           ;unsigned
 5779: 1  14ED	F9		                mov    r1,a
 5780: 1  14EE	80 10		                sjmp   adc_single42
 5781: 1			;12 bit signed formaat
 5782: 1  14F0	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5783: 1  14F3	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5784: 1  14F5	F9		                mov    r1,a
 5785: 1  14F6	A8 D9		                mov    r0,adcdatal
 5786: 1  14F8	80 06		                sjmp   adc_single42
 5787: 1  14FA	C3		adc_single41:   clr    c
 5788: 1  14FB	94 08		                subb   a,#08h                ;positief deel verkleinen
 5789: 1  14FD	F9		                mov    r1,a
 5790: 1  14FE	A8 D9		                mov    r0,adcdatal
 5791: 1  1500	D0 F0		adc_single42:   pop    b
 5792: 1  1502	D0 D0		                pop    psw
 5793: 1  1504	C3		                clr    c
 5794: 1  1505	D0 E0		                pop    acc
 5795: 1  1507	22		                ret
 5796: 1
 5797: 1  1508	D0 F0		adc_single43:   pop    b
 5798: 1  150A	D0 D0		                pop    psw
 5799: 1  150C	D3		                setb   c
 5800: 1  150D	D0 E0		                pop    acc
 5801: 1  150F	22		                ret
 5802: 1
 5803: 1			endif        ;einde van aduc_adc
 5804: 1			;*******************************************************************************
 5805: 1
 5806: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5807: 1			;******************************************************************************
 5808: 1			; ADuCKEY_mide.inc
 5809: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5810: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5811: 1			;
 5812: 1			;     V2.0      V1.1
 5813: 1			;                           |   |   |   |
 5814: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5815: 1			;                   |       |   |   |   |
 5816: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5817: 1			;                   |       |   |   |   |
 5818: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5819: 1			;                   |       |   |   |   |
 5820: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5821: 1			;                   |       |   |   |   |
 5822: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5823: 1			;                   |           |   |   |
 5824: 1			;     P0.5      P3.5|-K2--------|   |   |
 5825: 1			;                   |               |   |
 5826: 1			;     P0.6      P3.6|-K3------------|   |
 5827: 1			;                   |                   |
 5828: 1			;     P0.7      P3.7|-K4----------------|
 5829: 1			;
 5830: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5831: 1			; gebruikt.
 5832: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5833: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5834: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5835: 1			; en als ingang wordt aangeboden.
 5836: 1			;
 5837: 1			;                                  ___                 ___
 5838: 1			;                     ____________|   |  |------------|   |
 5839: 1			;              ____  |   ____     |   |  |   ____     |   |
 5840: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5841: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5842: 1			; '1'= toets  | cl |    | cl |              | cl |
 5843: 1			;  ingedrukt  |____|    |____|              |____|
 5844: 1			;                |         |                   |
 5845: 1			;      CLOCK     |         |                   |
 5846: 1			;         _______|_________|___________________|
 5847: 1			;
 5848: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 5849: 1			;
 5850: 1			;              MAP0      MAP1                 MAP2         MAP3
 5851: 1			;
 5852: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5853: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5854: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5855: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5856: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 5857: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5858: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 5859: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5860: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5861: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5862: 1			;
 5863: 1			;          MAP0    MAP1          MAP2    MAP3
 5864: 1			;         _______________       _______________
 5865: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5866: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5867: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5868: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5869: 1			;
 5870: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5871: 1			;         | | | | | | | |       | | | | | | | |
 5872: 1			;        K K K K K K K K       K K K K K K K K
 5873: 1			;         O O O O O O O O       O O O O O O O O
 5874: 1			;         L L L L L L L L       L L L L L L L L
 5875: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5876: 1			;
 5877: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 5878: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 5879: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5880: 1			; van bitmaps van voor naar achter.
 5881: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5882: 1			;
 5883: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5884: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5885: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5886: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 5887: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5888: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5889: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5890: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5891: 1			; deze toetswaarde weer.
 5892: 1			;
 5893: 1			;
 5894: 1			;
 5895: 1			;******************************************************************************
 5896: 1
 5897: 1
 5898: 1			;******************************************************************************
 5899: 1			; key_init
 5900: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 5901: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5902: 1			; input: niets
 5903: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet
 5904: 1			;         (map0,map1,map2,map3 =0)
 5905: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5906: 1			; Deze routine vernietigt niets
 5907: 1			;******************************************************************************
 5908: 1
 5909: 1  1510	C0 E0		Key_init:       push    acc          ;bewaar registers
 5910: 1  1512	C0 D0		                push    psw
 5911: 1  1514	E8		                mov     a,r0
 5912: 1  1515	C0 E0		                push    acc
 5913: 1  1517	E9		                mov     a,r1
 5914: 1  1518	C0 E0		                push    acc
 5915: 1  151A	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5916: 1  151C	79 09		                mov     r1,#9        ;9 bytes in de maps
 5917: 1  151E	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5918: 1  1520	08		                inc     r0           ;volgende byte nemen
 5919: 1  1521	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5920: 1  1523	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5921: 1  1525	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5922: 1  1527	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5923: 1  152A	D0 E0		                pop     acc          ;herstel registers
 5924: 1  152C	F9		                mov     r1,a
 5925: 1  152D	D0 E0		                pop     acc
 5926: 1  152F	F8		                mov     r0,a
 5927: 1  1530	D0 D0		                pop     psw
 5928: 1  1532	D0 E0		                pop     acc
 5929: 1  1534	22		                ret                    ;terug naar caller
 5930: 1			;******************************************************************************
 5931: 1
 5932: 1
 5933: 1			;******************************************************************************
 5934: 1			; toets_flank
 5935: 1			; Deze routine detecteert de indrukflank van een toets.
 5936: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5937: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5938: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5939: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5940: 1			; minder dan 20ms duurt.
 5941: 1			; input : niets
 5942: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5943: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5944: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5945: 1			;
 5946: 1			; Deze routine vernietigt geen registers.
 5947: 1			;******************************************************************************
 5948: 1  1535	C0 E0		Toets_flank:    push    acc
 5949: 1  1537	C0 D0		                push    psw
 5950: 1  1539	12 15 53	                lcall   Keyscan
 5951: 1  153C	12 15 CF	                lcall   Keyedge
 5952: 1  153F	D0 D0		                pop     psw
 5953: 1  1541	D0 E0		                pop     acc
 5954: 1  1543	22		                ret
 5955: 1
 5956: 1			;******************************************************************************
 5957: 1			; toets_ingedrukt
 5958: 1			; Deze routine detecteert een ingedrukte toets.
 5959: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5960: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5961: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5962: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5963: 1			; minder dan 20ms duurt.
 5964: 1			; input : niets
 5965: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5966: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5967: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5968: 1			;
 5969: 1			; Deze routine vernietigt geen registers.
 5970: 1			;******************************************************************************
 5971: 1  1544	C0 E0		Toets_ingedrukt:push    acc
 5972: 1  1546	C0 D0		                push    psw
 5973: 1  1548	12 15 53	                lcall   Keyscan
 5974: 1  154B	12 15 B6	                lcall   Keydown
 5975: 1  154E	D0 D0		                pop     psw
 5976: 1  1550	D0 E0		                pop     acc
 5977: 1  1552	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5978: 1
 5979: 1
 5980: 1			;******************************************************************************
 5981: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5982: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5983: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5984: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5985: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5986: 1			; zoals aangegeven in het blokschema van het algorithme.
 5987: 1			; input : niets
 5988: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5989: 1			;         ervan weergeven
 5990: 1			;
 5991: 1			; Deze routine vernietigt geen registers
 5992: 1			;******************************************************************************
 5993: 1
 5994: 1  1553	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 5995: 1  1555	C0 D0		                push    psw
 5996: 1  1557	C0 F0		                push    b
 5997: 1  1559	E8		                mov     a,r0
 5998: 1  155A	C0 E0		                push    acc
 5999: 1  155C	E9		                mov     a,r1
 6000: 1  155D	C0 E0		                push    acc
 6001: 1  155F	EA		                mov     a,r2
 6002: 1  1560	C0 E0		                push    acc
 6003: 1  1562	EE		                mov     a,r6
 6004: 1  1563	C0 E0		                push    acc
 6005: 1
 6006: 1  1565	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 6007: 1  1567	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 6008: 1  156A	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6009: 1  156C	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 6010: 1
 6011: 1  156E			Scanloop:
 6012: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 6013: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 6014: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 6015: 1			                mov     p0.0,c
 6016: 1			                mov     c,acc.1
 6017: 1			                mov     p0.1,c
 6018: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 6019: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 6020: 1			endif
 6021: 1
 6022: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 6023: 1  156E	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 6024: 1			                                      ;een rij-lijn
 6025: 1			endif
 6026: 1
 6027: 1			; Eerst de flipflops implementeren.
 6028: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 6029: 1			; te lezen van de kolomlijnen
 6030: 1  1570	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 6031: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 6032: 1  1571	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 6033: 1  1572	C4		                swap    a             ;MAP0 en MAP1 omwisselen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6034: 1  1573	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 6035: 1  1574	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 6036: 1  1576	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 6037: 1  1577	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 6038: 1  1578	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 6039: 1  157A	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 6040: 1  157B	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 6041: 1  157C	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 6042: 1  157D	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 6043: 1  157E	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 6044: 1  1580	FA		                mov     r2,a          ;even bewaren in register
 6045: 1
 6046: 1
 6047: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 6048: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 6049: 1			                                      ;poort3 kolomlijnen
 6050: 1			endif
 6051: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 6052: 1  1581	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 6053: 1			                                     ;poort0 kolomlijnen
 6054: 1			endif
 6055: 1  1583	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 6056: 1  1584	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 6057: 1  1586	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 6058: 1  1587	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 6059: 1
 6060: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 6061: 1			; Nu volgen de logische functies uit het blokschema
 6062: 1
 6063: 1  1588	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 6064: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 6065: 1  1589	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 6066: 1  158A	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 6067: 1  158B	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 6068: 1  158C	54 0F		                anl     a,#00001111b ;low nibble houden
 6069: 1  158E	FA		                mov     r2,a         ;resultaat bewaren
 6070: 1  158F	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 6071: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)
 6072: 1  1590	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 6073: 1  1591	C4		                swap    a            ;map2 naar low nibble schuiven
 6074: 1  1592	5A		                anl     a,r2         ;combineren met output vorige and poort
 6075: 1  1593	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 6076: 1  1595	FA		                mov     r2,a         ;even bewaren
 6077: 1  1596	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 6078: 1  1597	54 F0		                anl     a,#11110000b ;map2 overhouden
 6079: 1  1599	4A		                orl     a,r2         ;en combineren met nieuwe map3
 6080: 1  159A	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 6081: 1
 6082: 1			; We gaan nu de volgende lijn scannen
 6083: 1
 6084: 1  159B	EE		                mov     a,r6         ;scanpatroon nemen
 6085: 1  159C	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 6086: 1  159D	FE		                mov     r6,a         ;scanpatroon bewaren
 6087: 1
 6088: 1  159E	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 6089: 1  159F	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6090: 1  15A0	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 6091: 1  15A3	D0 E0		                pop     acc          ;herstel registers
 6092: 1  15A5	FE		                mov     r6,a
 6093: 1  15A6	D0 E0		                pop     acc
 6094: 1  15A8	FA		                mov     r2,a
 6095: 1  15A9	D0 E0		                pop     acc
 6096: 1  15AB	F9		                mov     r1,a
 6097: 1  15AC	D0 E0		                pop     acc
 6098: 1  15AE	F8		                mov     r0,a
 6099: 1  15AF	D0 F0		                pop     b
 6100: 1  15B1	D0 D0		                pop     psw
 6101: 1  15B3	D0 E0		                pop     acc
 6102: 1  15B5	22		                ret                    ;terug naar caller
 6103: 1			;******************************************************************************
 6104: 1
 6105: 1
 6106: 1			;******************************************************************************
 6107: 1			; Keydown, Keyedge (twee entry's)
 6108: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6109: 1			;
 6110: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6111: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6112: 1			; Er zijn twee detectie-modes:
 6113: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6114: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6115: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6116: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6117: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6118: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6119: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6120: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6121: 1			;
 6122: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6123: 1			; (flankdetectie mode).
 6124: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6125: 1			; (toets ingedrukt mode).
 6126: 1			;
 6127: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel
 6128: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6129: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6130: 1			; geldt voor een standaard 4x4 keypad.
 6131: 1			;
 6132: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6133: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6134: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6135: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6136: 1			;
 6137: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6138: 1			; output: key = gedetecteerde toets
 6139: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6140: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6141: 1			;
 6142: 1			; Deze routine vernietigt geen registers
 6143: 1			;******************************************************************************
 6144: 1
 6145: 1			;'Toets ingedrukt mode' enty van de routine

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6146: 1  15B6	C0 E0		Keydown:        push    acc            ;registers bewaren
 6147: 1  15B8	C0 D0		                push    psw
 6148: 1  15BA	C0 F0		                push    b
 6149: 1  15BC	C0 82		                push    dpl
 6150: 1  15BE	C0 83		                push    dph
 6151: 1  15C0	E8		                mov     a,r0
 6152: 1  15C1	C0 E0		                push    acc
 6153: 1  15C3	E9		                mov     a,r1
 6154: 1  15C4	C0 E0		                push    acc
 6155: 1  15C6	EA		                mov     a,r2
 6156: 1  15C7	C0 E0		                push    acc
 6157: 1  15C9	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6158: 1  15CB	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6159: 1  15CD	80 15		                sjmp    Key1           ;continue
 6160: 1
 6161: 1			;'Flankdetectiemode' entry van de routine
 6162: 1  15CF	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6163: 1  15D1	C0 D0		                push    psw
 6164: 1  15D3	C0 F0		                push    b
 6165: 1  15D5	C0 82		                push    dpl
 6166: 1  15D7	C0 83		                push    dph
 6167: 1  15D9	E8		                mov     a,r0
 6168: 1  15DA	C0 E0		                push    acc
 6169: 1  15DC	E9		                mov     a,r1
 6170: 1  15DD	C0 E0		                push    acc
 6171: 1  15DF	EA		                mov     a,r2
 6172: 1  15E0	C0 E0		                push    acc
 6173: 1  15E2	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6174: 1  15E4	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6175: 1  15E6	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6176: 1  15E8	E6		                mov     a,@r0         ;map entry ophalen
 6177: 1  15E9	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6178: 1  15EC	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6179: 1  15EE	C4		                swap    a             ;map1 en map0 omwisselen
 6180: 1  15EF	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6181: 1  15F1	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6182: 1  15F2	33		                rlc     a             ;kolombit testen
 6183: 1  15F3	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt
 6184: 1  15F5	33		                rlc    a              ;nee, dan verder roteren
 6185: 1  15F6	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6186: 1  15F8	08		                inc     r0            ;rijpointer in maps verder zetten
 6187: 1  15F9	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6188: 1  15FB	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6189: 1
 6190: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6191: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6192: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6193: 1
 6194: 1  15FD	1A		toetsin:        dec     r2            ;rij-1
 6195: 1  15FE	19		                dec     r1            ;kolom-1
 6196: 1  15FF	EA		                mov     a,r2          ;neem rij-1
 6197: 1  1600	23		                rl      a             ;(rij-1)x2
 6198: 1  1601	23		                rl      a              ;(rij-1)x4
 6199: 1  1602	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6200: 1  1603	90 16 21	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6201: 1  1606	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6202: 1  1607	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6203: 1  1609	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6204: 1  160B	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6205: 1  160D	D0 E0		                pop     acc            ;herstellen registers
 6206: 1  160F	FA		                mov     r2,a
 6207: 1  1610	D0 E0		                pop     acc
 6208: 1  1612	F9		                mov     r1,a
 6209: 1  1613	D0 E0		                pop     acc
 6210: 1  1615	F8		                mov     r0,a
 6211: 1  1616	D0 83		                pop     dph
 6212: 1  1618	D0 82		                pop     dpl
 6213: 1  161A	D0 F0		                pop     b
 6214: 1  161C	D0 D0		                pop     psw
 6215: 1  161E	D0 E0		                pop     acc
 6216: 1  1620	22		                ret                    ;terug naar caller
 6217: 1			;******************************************************************************
 6218: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6219: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6220: 1
 6221: 1  1621	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6222: 1  1622	30		                db    '0'    ;kolom2@rij4 toets
 6223: 1  1623	23		                db    '#'    ;kolom3@rij4 toets
 6224: 1  1624	44		                db    'D'    ;kolom4@rij4 toets
 6225: 1
 6226: 1  1625	37		                db    '7'    ;kolom1@rij3 toets
 6227: 1  1626	38		                db    '8'    ;kolom2@rij3 toets
 6228: 1  1627	39		                db    '9'    ;kolom3@rij3 toets
 6229: 1  1628	43		                db    'C'    ;kolom4@rij3 toets
 6230: 1
 6231: 1  1629	34		                db    '4'    ;kolom1@rij2 toets
 6232: 1  162A	35		                db    '5'    ;kolom2@rij2 toets
 6233: 1  162B	36		                db    '6'    ;kolom3@rij2 toets
 6234: 1  162C	42		                db    'B'    ;kolom4@rij2 toets
 6235: 1
 6236: 1  162D	31		                db    '1'    ;kolom1@rij1 toets
 6237: 1  162E	32		                db    '2'    ;kolom2@rij1 toets
 6238: 1  162F	33		                db    '3'    ;kolom3@rij1 toets
 6239: 1  1630	41		                db    'A'    ;kolom4@rij1 toets
 6240: 1
 6241: 1			;******************************************************************************
 6242: 1			; switch_init
 6243: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6244: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6245: 1			; input : niets
 6246: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6247: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6248: 1			;
 6249: 1			; Deze routine vernietigt niets
 6250: 1			;******************************************************************************
 6251: 1
 6252: 1  1631	C0 E0		switch_init:    push    acc
 6253: 1  1633	C0 D0		                push    psw
 6254: 1  1635	C0 F0		                push    b
 6255: 1  1637	E8		                mov     a,r0         ;bewaar registers
 6256: 1  1638	C0 E0		                push    acc
 6257: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6258: 1  163A	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6259: 1  163C	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6260: 1  163F	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6261: 1  1641	08		                inc     r0           ;volgende byte nemen
 6262: 1  1642	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6263: 1  1645	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6264: 1  1647	C2 03		                clr     negvalid
 6265: 1  1649	C2 04		                clr     posvalid
 6266: 1
 6267: 1  164B	D0 E0		                pop     acc
 6268: 1  164D	F8		                mov     r0,a
 6269: 1  164E	D0 F0		                pop     b
 6270: 1  1650	D0 D0		                pop     psw
 6271: 1  1652	D0 E0		                pop     acc
 6272: 1  1654	22		                ret                   ;terug naar caller
 6273: 1
 6274: 1			;******************************************************************************
 6275: 1			; read_switch
 6276: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6277: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6278: 1			; Deze routine werkt volgens onderstaand blokschema.
 6279: 1			;
 6280: 1			;                                  ___                    ___
 6281: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6282: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6283: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6284: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6285: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6286: 1			;             |____|    |____|              |____|  ----o| 3 |
 6287: 1			;                |         |                   |      |  |   |
 6288: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6289: 1			;         _______*_________*___________________|       --|___|---- posedge
 6290: 1			;
 6291: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6292: 1			;                              (swvalid-flag)
 6293: 1			;            switch1   switch2    debounce      closed
 6294: 1			;
 6295: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits
 6296: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6297: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6298: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6299: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6300: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6301: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6302: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6303: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6304: 1			; een detector voor positieve flanken (posedge).
 6305: 1			;
 6306: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6307: 1			;         bij aduc832v1.1 :
 6308: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6309: 1			;         bij aduc832v2.0 :
 6310: 1			;         als f0=0 dan: schakelaars op p0
 6311: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6312: 1			;
 6313: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111



 Line  I  Addr  Code            Source

 6314: 1			;         geactualiseerd.
 6315: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6316: 1			;                  schakelaars weergeeft
 6317: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6318: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6319: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6320: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6321: 1			;                  werd gedetecteerd op een schakelaar.
 6322: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6323: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6324: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6325: 1			;                  werd gedetecteerd op een schakelaar.
 6326: 1			;
 6327: 1			;
 6328: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6329: 1			; en flags te initialiseren.
 6330: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6331: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6332: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6333: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6334: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6335: 1			; bijhorende flag resetten.
 6336: 1			;
 6337: 1			; Deze routine vernietigt niets
 6338: 1			;******************************************************************************
 6339: 1  1655	C0 E0		read_switch:    push    acc            ;registers bewaren
 6340: 1  1657	C0 D0		                push    psw
 6341: 1  1659	C0 F0		                push    b
 6342: 1			;Flipflops uitvoeren is bytes doorschuiven
 6343: 1  165B	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6344: 1  165E	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6345: 1
 6346: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6347: 1			                clr      a
 6348: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6349: 1			                mov     acc.0,c
 6350: 1			                mov     c,p0.1
 6351: 1			                mov     acc.1,c
 6352: 1			                mov     b,a            ;even bewaren
 6353: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6354: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6355: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6356: 1			endif        ;einde aduc832_v1_1
 6357: 1
 6358: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6359: 1  1661	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6360: 1  1664	E5 80		                mov     a,p0           ;lees de schakelaars
 6361: 1  1666	80 04		                sjmp    lowlogic
 6362: 1  1668	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6363: 1  166A	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6364: 1			endif        ;einde aduc832_2_0
 6365: 1
 6366: 1  166C	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6367: 1  166D	F5 40		                mov     switch1,a      ;en sample opslaan
 6368: 1
 6369: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112



 Line  I  Addr  Code            Source

 6370: 1
 6371: 1  166F	E5 40		                mov     a,switch1      ;neem laatste sample
 6372: 1  1671	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6373: 1  1673	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6374: 1  1675	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6375: 1			;negatieve flankdetectie
 6376: 1  1677	E5 43		                mov     a,closed      ;neem 3de FF
 6377: 1  1679	F4		                cpl     a             ;complementeer
 6378: 1  167A	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6379: 1  167C	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6380: 1  167E	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6381: 1  1680	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6382: 1  1682	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6383: 1			;positieve flankdetectie
 6384: 1  1684	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6385: 1  1686	F4		                cpl     a             ;complementeer
 6386: 1  1687	55 43		                anl     a,closed      ;combineer met 3de FF
 6387: 1  1689	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6388: 1  168B	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6389: 1  168D	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6390: 1  168F	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6391: 1  1691	D0 D0		                pop     psw
 6392: 1  1693	D0 E0		                pop     acc
 6393: 1  1695	22		                ret
 6394: 1
 6395: 1			endif    ;einde van aduc_key
 6396: 1
 6397: 1
 6398:				end





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 150
ACC				  DATA	      E0	  69
ADCBUFFER			  CODE	    002D	 208
ADCCON1				  DATA	      EF	  72
ADCCON2				  DATA	      D8	  65
ADCCON3				  DATA	      F5	  78
ADCDATAH			  DATA	      DA	  67
ADCDATAL			  DATA	      D9	  66
ADCGAINH			  DATA	      F4	  77
ADCGAINL			  DATA	      F3	  76
ADCI				  BIT	      DF	 159
ADCOFSH				  DATA	      F2	  75
ADCOFSL				  DATA	      F1	  74
ADC_INIT			  CODE	    1454	5647
ADC_INIT1			  CODE	    1461	5653
ADC_SINGLE			  CODE	    1466	5692
ADC_SINGLE1			  CODE	    1472	5698
ADC_SINGLE2			  CODE	    149D	5724
ADC_SINGLE20			  CODE	    14A7	5729
ADC_SINGLE21			  CODE	    14AF	5735
ADC_SINGLE3			  CODE	    14B2	5739
ADC_SINGLE30			  CODE	    14D2	5760
ADC_SINGLE31			  CODE	    14DC	5765
ADC_SINGLE4			  CODE	    14E4	5774
ADC_SINGLE40			  CODE	    14F0	5782
ADC_SINGLE41			  CODE	    14FA	5787
ADC_SINGLE42			  CODE	    1500	5791
ADC_SINGLE43			  CODE	    1508	5797
ADD16				  CODE	    09AB	2999
ADD161				  CODE	    09BF	3015
ADD32				  CODE	    09FD	3096
ADD321				  CODE	    0A17	3120
ADUC832_V2_0			  NUMBER    0001	 305
ADUC_ADC			  NUMBER    0001	 326
ADUC_I2C			  NUMBER    0001	 323
ADUC_KEY			  NUMBER    0001	 327
ADUC_LCD			  NUMBER    0001	 320
ADUC_MATH			  NUMBER    0001	 325
ADUC_SIO			  NUMBER    0001	 324
ASCBINTRANS			  CODE	    065B	2052
ASCBINTRANS1			  CODE	    0670	2063
ASCBINTRANS2			  CODE	    066F	2062
ASCBINTRANS3			  CODE	    0663	2056
ASCBINTRANS4			  CODE	    066C	2060
ASCCTR				  CODE	    0632	1998
ASCCTR1				  CODE	    0635	1999
ASCCTR2				  CODE	    063A	2001
ASCCTR3				  CODE	    063E	2004

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII1				  CODE	    0671	2074
ASCII2				  CODE	    0676	2088
ASCII21				  CODE	    0688	2097
ASCII4				  CODE	    068B	2111
ASCII41				  CODE	    069A	2118
B				  DATA	      F0	  73
BACKLIGHT			  BIT	      F6	 472
BACKSP				  NUMBER    0008	1697
BAR				  CODE	    0043	 227
BARCHARS			  CODE	    031B	1098
BAREINDE			  CODE	    0342	1141
BARLCD				  CODE	    02B6	1019
BARLCD1				  CODE	    02F1	1053
BARLCD2				  CODE	    02F8	1058
BARLCD3				  CODE	    0301	1066
BARLCD4				  CODE	    0306	1070
BARLCDE				  CODE	    030E	1075
BARLCD_1			  CODE	    02D1	1035
BATRANS				  CODE	    064D	2034
BATRANS1			  CODE	    0652	2036
BATRANS2			  CODE	    0656	2038
BCDHEX16			  CODE	    0710	2313
BCDHEX161			  CODE	    071E	2321
BCDHEX1611			  CODE	    0727	2325
BCDHEX1612			  CODE	    0731	2330
BCDHEX1613			  CODE	    073A	2334
BCDHEX162			  CODE	    0785	2388
BCDHEX8				  CODE	    069B	2204
BCDHEX81			  CODE	    06A9	2212
BCDHEX811			  CODE	    06B2	2216
BCDHEX82			  CODE	    06D4	2240
BDELETE				  CODE	    060D	1964
BDELETE1			  CODE	    061B	1972
BDELETE2			  CODE	    062E	1983
BDELETE3			  CODE	    061F	1974
BEEP				  NUMBER    0007	1698
BLANK				  NUMBER    0020	1692
BUILD				  CODE	    0343	1173
BUILD1				  CODE	    035B	1215
BUILD2				  CODE	    036A	1222
BUILD3				  CODE	    035E	1216
BUILD_ADR			  CODE	    0351	1210
BUZZER				  BIT	      F7	 473
CAP2				  BIT	      C8	 136
CCONV				  BIT	      DD	 157
CFG832				  DATA	      AF	  38
CGRAM				  NUMBER    0040	 488
CHIPID				  DATA	      C2	  52
CLEARDISP			  NUMBER    0001	 478
CLOSED				  NUMBER    0043	 392
CMP16				  CODE	    118C	5030
CMP161				  CODE	    11A9	5049
CMP162				  CODE	    11B5	5058
CMP32				  CODE	    122D	5177
CMP321				  CODE	    1256	5204
CMP322				  CODE	    1262	5213

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CNT2				  BIT	      C9	 137
CORDIC				  CODE	    12F6	5364
CORDIC0				  CODE	    1361	5429
CORDIC00			  CODE	    1347	5414
CORDIC000			  CODE	    131A	5388
CORDIC1				  CODE	    1375	5443
CORDIC2				  CODE	    13A9	5493
CORDIC3				  CODE	    13B4	5500
CORDIC4				  CODE	    13D9	5534
CORDIC40			  CODE	    13DE	5538
CORDIC41			  CODE	    13F7	5554
CORDIC5				  CODE	    13FD	5560
CORDIC50			  CODE	    140F	5570
CORDIC51			  CODE	    1428	5585
CORDIC52			  CODE	    1433	5594
CORDIC5A			  CODE	    140D	5569
CORDIC5B			  CODE	    1426	5584
CORDIC_ATAN			  CODE	    1436	5600
CORDIC_ERROR			  CODE	    132A	5396
CORDIC_MIN90			  CODE	    132F	5400
CORDIC_NUL			  CODE	    1353	5420
CORDIC_PLUS90			  CODE	    133B	5407
CPHA				  BIT	      FA	 174
CPOL				  BIT	      FB	 175
CR				  NUMBER    000D	1695
CS0				  BIT	      D8	 152
CS1				  BIT	      D9	 153
CS2				  BIT	      DA	 154
CS3				  BIT	      DB	 155
CURSATHOM			  NUMBER    0002	 479
CURSOROFF			  NUMBER    000C	 484
CURSORONB			  NUMBER    000F	 485
CURSORONN			  NUMBER    000E	 486
CY				  BIT	      D7	 151
D0				  BIT	      ED	 161
D0EN				  BIT	      EB	 160
D1				  BIT	      EF	 163
D1EN				  BIT	      EE	 162
DAC0H				  DATA	      FA	  82
DAC0L				  DATA	      F9	  81
DAC1H				  DATA	      FC	  84
DAC1L				  DATA	      FB	  83
DACCON				  DATA	      FD	  85
DCON				  DATA	      E8	  70
DDRAM				  NUMBER    0080	 489
DEBOUNCE			  NUMBER    0042	 391
DELAY				  CODE	    006F	 253
DELAY2MS			  CODE	    0378	1239
DELAY2MS1			  CODE	    037E	1242
DELAY60US			  CODE	    0389	1259
DELAY60US1			  CODE	    039B	1273
DELAY60US2			  CODE	    0399	1272
DIPSWITCH			  NUMBER    0001	 345
DISPDPTR			  CODE	    0563	1806
DISPDPTRLCD			  CODE	    017D	 694
DISPLAYOF			  NUMBER    0008	 483

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DISPLAYON			  NUMBER    0001	 482
DIV16				  CODE	    0C72	3782
DIV160				  CODE	    0C80	3793
DIV161				  CODE	    0C9E	3816
DIV162				  CODE	    0CB1	3832
DIV163				  CODE	    0CCD	3857
DIV164				  CODE	    0CDF	3875
DIV32				  CODE	    0D1C	3946
DIV320				  CODE	    0D2C	3959
DIV320A				  CODE	    0D36	3970
DIV320B				  CODE	    0D54	3998
DIV320C				  CODE	    0D79	4026
DIV322				  CODE	    0D9E	4060
DIV323				  CODE	    0DE8	4136
DIV324				  CODE	    0E1A	4186
DIV8				  CODE	    0C2F	3709
DIV81				  CODE	    0C47	3725
DMA				  BIT	      DE	 158
DMAH				  DATA	      D3	  62
DMAL				  DATA	      D2	  61
DMAP				  DATA	      D4	  63
DPCON				  DATA	      A7	  34
DPH				  DATA	      83	  11
DPL				  DATA	      82	  10
DPP				  DATA	      84	  12
E				  BIT	      F1	 470
EA				  BIT	      AF	 111
EADC				  BIT	      AE	 110
EADRH				  DATA	      C7	  54
EADRL				  DATA	      C6	  53
ECON				  DATA	      B9	  46
EDATA1				  DATA	      BC	  47
EDATA2				  DATA	      BD	  48
EDATA3				  DATA	      BE	  49
EDATA4				  DATA	      BF	  50
ENDBUF				  NUMBER    007F	1704
ENTRYMODE			  NUMBER    0006	 481
ES				  BIT	      AC	 108
ET0				  BIT	      A9	 105
ET1				  BIT	      AB	 107
ET2				  BIT	      AD	 109
EX0				  BIT	      A8	 104
EX1				  BIT	      AA	 106
EXEN2				  BIT	      CB	 139
EXF2				  BIT	      CE	 142
F0				  BIT	      D5	 149
F1				  BIT	      D1	 145
FF				  NUMBER    000C	1694
FUNCTIONS			  NUMBER    0028	 487
GEMIDDELDE			  CODE	    0080	 265
HEXBCD16			  CODE	    078E	2424
HEXBCD161			  CODE	    079C	2431
HEXBCD16_U			  CODE	    0791	2425
HEXBCD8				  CODE	    06DD	2265
HEXBCD81			  CODE	    06E7	2270
HEXBCD82			  CODE	    06EC	2272

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBCD83			  CODE	    06F6	2278
HEXBUF2LCD			  CODE	    0259	 960
HEXBUF2LCD1			  CODE	    027D	 976
HEXBUF2LCDE			  CODE	    0294	 987
HEXBUFTXT			  CODE	    02A2	 996
HOUR				  DATA	      A5	  32
HTHSEC				  DATA	      A2	  29
I2CADD				  DATA	      9B	  24
I2CCON				  DATA	      E8	  71
I2CDAT				  DATA	      9A	  23
I2CI				  BIT	      E8	 164
I2CINBYTEA1			  CODE	    03E5	1381
I2CINBYTEACK			  CODE	    03DE	1378
I2CINBYTEN1			  CODE	    0406	1405
I2CINBYTENACK			  CODE	    03FF	1402
I2CINIT				  CODE	    03A3	1323
I2CM				  BIT	      EB	 167
I2COUTBYTE			  CODE	    03BE	1355
I2COUTBYTE1			  CODE	    03C5	1358
I2CPCF8574			  NUMBER    0040	1314
I2CPCF8574A			  NUMBER    0070	1315
I2CRCVDATA			  CODE	    0460	1507
I2CRCVDATA1			  CODE	    047F	1525
I2CRCVDATA2			  CODE	    0488	1529
I2CRCVDATA3			  CODE	    048F	1534
I2CRCVERROR			  CODE	    049B	1542
I2CRS				  BIT	      EA	 166
I2CSENDDATA			  CODE	    0420	1445
I2CSENDDATA1			  CODE	    043F	1462
I2CSENDERROR			  CODE	    0455	1475
I2CSTART			  CODE	    03AC	1332
I2CSTOP				  CODE	    03B5	1341
I2CTX				  BIT	      E9	 165
IE				  DATA	      A8	  35
IE0				  BIT	      89	  87
IE1				  BIT	      8B	  89
IEIP2				  DATA	      A9	  36
INBUFA				  CODE	    05D2	1921
INBUFA1				  CODE	    05E9	1938
INBUFA2				  CODE	    05D8	1924
INBUFA3				  CODE	    05F6	1944
INBUFA4				  CODE	    05EF	1940
INBUFA5				  CODE	    0609	1952
INBUFA6				  CODE	    05FF	1948
INBUFA7				  CODE	    05F1	1941
INBYTE				  CODE	    05B2	1889
INBYTE1				  CODE	    05CF	1901
INCHAR				  CODE	    05AA	1873
INFLOOP				  CODE	    001C	 201
INITLCD				  CODE	    00AD	 504
INITLCD1			  CODE	    00BE	 521
INITSIO				  CODE	    0510	1718
INITSIO1			  CODE	    0519	1722
INITSIOE			  CODE	    052F	1739
INT0				  BIT	      B2	 114
INT1				  BIT	      B3	 115

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
INTVAL				  DATA	      A6	  33
IP				  DATA	      B8	  45
ISPI				  BIT	      FF	 179
IT0				  BIT	      88	  86
IT1				  BIT	      8A	  88
KEY				  NUMBER    0038	 378
KEY1				  CODE	    15E4	6174
KEY2				  CODE	    15F1	6181
KEYDOWN				  CODE	    15B6	6146
KEYEDGE				  CODE	    15CF	6162
KEYFLAGS			  NUMBER    0020	 353
KEYINIT1			  CODE	    151E	5917
KEYMAP				  NUMBER    0030	 372
KEYMODE				  BIT	      01	 357
KEYSCAN				  CODE	    1553	5994
KEYVALID			  BIT	      00	 355
KEY_INIT			  CODE	    1510	5909
KOLOMLOOP			  CODE	    15F3	6183
LCDBUZOFF			  CODE	    04FF	1663
LCDBUZON			  CODE	    04F2	1647
LCDLIGHTOFF			  CODE	    04E5	1631
LCDLIGHTON			  CODE	    04D8	1614
LCDPORT				  NUMBER    00F0	 469
LCDTOPORT			  CODE	    04BF	1588
LF				  NUMBER    000A	1696
LOOPTILOOP			  CODE	    0089	 269
LOWLOGIC			  CODE	    166C	6366
LOWUPTR				  CODE	    0640	2018
LOWUPTR1			  CODE	    0643	2019
LOWUPTR2			  CODE	    064C	2023
LOWUPTR3			  CODE	    0648	2021
MAGSIG16			  CODE	    07FD	2536
MAGSIG16A			  CODE	    080E	2545
MAGSIG16ACC1			  CODE	    081D	2569
MAGSIG16ACC1A			  CODE	    082E	2578
MAGSIG16ACC1B			  CODE	    0829	2575
MAGSIG16ACC1C			  CODE	    0838	2586
MAGSIG16B			  CODE	    0809	2542
MAGSIG16C			  CODE	    0818	2553
MAGSIG32			  CODE	    083D	2603
MAGSIG32A			  CODE	    084E	2612
MAGSIG32ACC1			  CODE	    0867	2648
MAGSIG32ACC1A			  CODE	    0878	2657
MAGSIG32ACC1B			  CODE	    0873	2654
MAGSIG32ACC1C			  CODE	    088C	2674
MAGSIG32B			  CODE	    0849	2609
MAGSIG32C			  CODE	    0862	2629
MAGSIG8				  CODE	    07C9	2477
MAGSIG8A			  CODE	    07DA	2486
MAGSIG8ACC1			  CODE	    07E3	2507
MAGSIG8ACC1A			  CODE	    07F4	2516
MAGSIG8ACC1B			  CODE	    07EF	2513
MAGSIG8ACC1C			  CODE	    07F8	2520
MAGSIG8B			  CODE	    07D5	2483
MAGSIG8C			  CODE	    07DE	2490
MAP01PTR			  NUMBER    0030	 374

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MAP23PTR			  NUMBER    0034	 377
MATRIX				  NUMBER    0001	 343
MCO				  BIT	      ED	 169
MDE				  BIT	      EE	 170
MDI				  BIT	      EC	 168
MDO				  BIT	      EF	 171
MIN				  DATA	      A4	  31
MUL16				  CODE	    0AE7	3368
MUL16ACC1			  CODE	    0B4C	3457
MUL16_10			  CODE	    0F0B	4444
MUL16_100			  CODE	    0F40	4492
MUL16_I_PI			  CODE	    0EA8	4348
MUL16_I_SQRT2			  CODE	    0EEA	4413
MUL16_PI			  CODE	    0E87	4317
MUL16_SQRT2			  CODE	    0EC9	4380
MUL816				  CODE	    0BD4	3604
MULDIV				  CODE	    0E4B	4259
MULDIV1				  CODE	    0E5B	4271
NEGEDGE				  NUMBER    0044	 393
NEGVALID			  BIT	      03	 362
NOKEY				  CODE	    160B	6204
OUTBYTE				  CODE	    054F	1786
OUTBYTELCD			  CODE	    016C	 675
OUTC				  CODE	    0219	 881
OUTCHAR				  CODE	    0533	1753
OUTCHAR1			  CODE	    0535	1754
OUTCHARLCD			  CODE	    010B	 590
OUTCHARLCD1			  CODE	    0112	 593
OUTCHARLCD2			  CODE	    011C	 597
OUTCHARLCD2_0			  CODE	    0117	 595
OUTCHARLCD3			  CODE	    0125	 607
OUTCHARLCD4			  CODE	    012C	 611
OUTCHARLCD5			  CODE	    0133	 615
OUTCHARLCD6			  CODE	    013A	 619
OUTCHARLCD7			  CODE	    0141	 623
OUTCHARLCD8			  CODE	    0148	 631
OUTCHARLCD9			  CODE	    014D	 639
OUTCHARLCDE			  CODE	    0150	 640
OUTD				  CODE	    01DF	 803
OUTHNIBC			  CODE	    022F	 923
OUTHNIBD			  CODE	    01EF	 851
OUTMSGA				  CODE	    0576	1825
OUTMSGA1			  CODE	    058B	1836
OUTMSGA2			  CODE	    057E	1829
OUTMSGALCD			  CODE	    0190	 718
OUTMSGALCD1			  CODE	    0198	 725
OUTMSGALCDE			  CODE	    01A3	 735
OUTNIB				  CODE	    053B	1767
OUTNIBLCD			  CODE	    0155	 654
OUTNIBLCD1			  CODE	    0160	 659
OUTNIBLCDE			  CODE	    0164	 661
OV				  BIT	      D2	 146
P				  BIT	      D0	 144
P0				  DATA	      80	   8
P1				  DATA	      90	  20
P2				  DATA	      A0	  27

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
P3				  DATA	      B0	  39
PADC				  BIT	      BE	 126
PCF8574A			  NUMBER    0001	1317
PCON				  DATA	      87	  13
PLLCON				  DATA	      D7	  64
PORTTOLCD			  CODE	    04A6	1560
POSEDGE				  NUMBER    0045	 394
POSVALID			  BIT	      04	 364
PRE0				  BIT	      C4	 132
PRE1				  BIT	      C5	 133
PRE2				  BIT	      C6	 134
PRE3				  BIT	      C7	 135
PS				  BIT	      BC	 124
PSI				  BIT	      BF	 127
PSMCON				  DATA	      DF	  68
PSW				  DATA	      D0	  60
PT0				  BIT	      B9	 121
PT1				  BIT	      BB	 123
PT2				  BIT	      BD	 125
PWM0H				  DATA	      B2	  41
PWM0L				  DATA	      B1	  40
PWM1H				  DATA	      B4	  43
PWM1L				  DATA	      B3	  42
PWMCON				  DATA	      AE	  37
PX0				  BIT	      B8	 120
PX1				  BIT	      BA	 122
RB8				  BIT	      9A	  98
RCAP2H				  DATA	      CB	  57
RCAP2L				  DATA	      CA	  56
RCLK				  BIT	      CD	 141
RD				  BIT	      B7	 119
READ_PORT3			  CODE	    1668	6362
READ_SWITCH			  CODE	    1655	6339
READ_SWITCH1			  CODE	    1684	6384
READ_SWITCH2			  CODE	    168F	6390
REGTOLCD			  CODE	    01AC	 755
REGTOLCD1			  CODE	    01BD	 765
REGTOLCD2			  CODE	    01CB	 775
REN				  BIT	      9C	 100
RI				  BIT	      98	  96
RIJLOOP				  CODE	    15E6	6175
RS				  BIT	      F0	 471
RS0				  BIT	      D3	 147
RS1				  BIT	      D4	 148
RXD				  BIT	      B0	 112
SBUF				  DATA	      99	  22
SCANLOOP			  CODE	    156E	6011
SCON				  DATA	      98	  21
SCONV				  BIT	      DC	 156
SEC				  DATA	      A3	  30
SHIFTLEFT1			  CODE	    10B7	4807
SHIFTLEFT2			  CODE	    10BF	4813
SHIFTLEFT3			  CODE	    10C3	4815
SHIFTLEFT32			  CODE	    10AF	4803
SHIFTRIGHT1			  CODE	    108B	4762
SHIFTRIGHT2			  CODE	    1093	4768

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SHIFTRIGHT3			  CODE	    1097	4770
SHIFTRIGHT32			  CODE	    1083	4758
SIGMAG16ACC0			  CODE	    08C3	2747
SIGMAG16ACC0A			  CODE	    08D2	2756
SIGMAG16ACC1			  CODE	    08E3	2782
SIGMAG16ACC1A			  CODE	    08F2	2791
SIGMAG16ACC1H			  CODE	    0903	2817
SIGMAG16ACC1HA			  CODE	    0912	2826
SIGMAG32ACC0			  CODE	    0923	2854
SIGMAG32ACC0A			  CODE	    0932	2863
SIGMAG32ACC1			  CODE	    094D	2898
SIGMAG32ACC1A			  CODE	    095C	2907
SIGMAG8ACC0			  CODE	    0891	2691
SIGMAG8ACC0A			  CODE	    08A0	2699
SIGMAG8ACC1			  CODE	    08AA	2719
SIGMAG8ACC1A			  CODE	    08B9	2727
SM0				  BIT	      9F	 103
SM1				  BIT	      9E	 102
SM2				  BIT	      9D	 101
SP				  DATA	      81	   9
SPE				  BIT	      FD	 177
SPH				  DATA	      B7	  44
SPICON				  DATA	      F8	  80
SPIDAT				  DATA	      F7	  79
SPIM				  BIT	      FC	 176
SPR0				  BIT	      F8	 172
SPR1				  BIT	      F9	 173
SQRT32				  CODE	    0F96	4564
SQRT320				  CODE	    0FBD	4586
SQRT321				  CODE	    0FC2	4588
SQRT322				  CODE	    1025	4670
SQRT323				  CODE	    102B	4674
SQRT324				  CODE	    104E	4698
SQRT3240			  CODE	    1049	4696
SQRT325				  CODE	    1051	4700
STACK_INIT			  NUMBER    0090	 182
START				  CODE	    0003	 189
STARTBUFFER			  NUMBER    0080	 184
STRTBUF				  NUMBER    0054	1703
SUB16				  CODE	    0A5D	3206
SUB161				  CODE	    0A72	3223
SUB32				  CODE	    0AC4	3323
SUB321				  CODE	    0ADF	3348
SWINIT				  CODE	    163F	6260
SWITCH1				  NUMBER    0040	 389
SWITCH2				  NUMBER    0041	 390
SWITCHMAP			  NUMBER    0040	 388
SWITCH_INIT			  CODE	    1631	6252
SWVALID				  BIT	      02	 360
S_ADD16				  CODE	    0977	2944
S_ADD161			  CODE	    099B	2970
S_ADD162			  CODE	    099F	2972
S_ADD163			  CODE	    09A5	2977
S_ADD32				  CODE	    09C7	3037
S_ADD321			  CODE	    09EF	3068
S_ADD322			  CODE	    09F1	3069

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_ADD323			  CODE	    09F7	3074
S_CMP16				  CODE	    1140	4956
S_CMP160			  CODE	    1153	4973
S_CMP161			  CODE	    1161	4983
S_CMP162			  CODE	    116F	4993
S_CMP163			  CODE	    117E	5005
S_CMP32				  CODE	    11BF	5080
S_CMP320			  CODE	    11DA	5100
S_CMP321			  CODE	    11EE	5114
S_CMP322			  CODE	    1202	5128
S_CMP323			  CODE	    1219	5148
S_DIV16				  CODE	    0C4F	3747
S_DIV161			  CODE	    0C5D	3757
S_DIV32				  CODE	    0CF7	3909
S_DIV321			  CODE	    0D07	3921
S_DIV8				  CODE	    0C1D	3686
S_DIV81				  CODE	    0C2E	3692
S_MAC16				  CODE	    0BFB	3646
S_MAC161			  CODE	    0C17	3666
S_MUL16				  CODE	    0BAD	3548
S_MUL16ACC1			  CODE	    0BBA	3566
S_MUL816			  CODE	    0BC7	3585
S_MULDIV			  CODE	    0E26	4215
S_MULDIV1			  CODE	    0E36	4227
S_SHIFTLEFT1			  CODE	    111A	4909
S_SHIFTLEFT2			  CODE	    1122	4915
S_SHIFTLEFT3			  CODE	    1126	4920
S_SHIFTLEFT32			  CODE	    1112	4905
S_SHIFTRIGHT1			  CODE	    10E3	4855
S_SHIFTRIGHT2			  CODE	    10EB	4861
S_SHIFTRIGHT20			  CODE	    10F7	4867
S_SHIFTRIGHT3			  CODE	    10F9	4869
S_SHIFTRIGHT32			  CODE	    10DB	4851
S_SQRT32			  CODE	    106C	4731
S_SQRT321			  CODE	    107A	4739
S_SUB16				  CODE	    0A1F	3142
S_SUB161			  CODE	    0A4D	3177
S_SUB162			  CODE	    0A51	3179
S_SUB163			  CODE	    0A57	3184
S_SUB32				  CODE	    0A7A	3245
S_SUB321			  CODE	    0AB6	3295
S_SUB322			  CODE	    0AB8	3296
S_SUB323			  CODE	    0ABE	3301
T0				  BIT	      B4	 116
T1				  BIT	      B5	 117
T2				  BIT	      90	  94
T2CON				  DATA	      C8	  55
T2EX				  BIT	      91	  95
T3CON				  DATA	      9E	  25
T3FD				  DATA	      9D	  26
TABLE_LU			  CODE	    126C	5240
TABLE_LU1			  CODE	    1291	5266
TABLE_LU2			  CODE	    12A2	5279
TABLE_LU3			  CODE	    12DB	5322
TABLE_LU4			  CODE	    12ED	5335
TABLE_LU_10			  CODE	    1298	5271

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 123



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TB8				  BIT	      9B	  99
TCLK				  BIT	      CC	 140
TCON				  DATA	      88	  14
TF0				  BIT	      8D	  91
TF1				  BIT	      8F	  93
TF2				  BIT	      CF	 143
TH0				  DATA	      8C	  18
TH1				  DATA	      8D	  19
TH2				  DATA	      CD	  59
TI				  BIT	      99	  97
TIJD				  NUMBER    0001	 183
TIMECON				  DATA	      A1	  28
TL0				  DATA	      8A	  16
TL1				  DATA	      8B	  17
TL2				  DATA	      CC	  58
TMOD				  DATA	      89	  15
TOETSIN				  CODE	    15FD	6194
TOETSTABEL			  CODE	    1621	6221
TOETS_FLANK			  CODE	    1535	5948
TOETS_INGEDRUKT			  CODE	    1544	5971
TR0				  BIT	      8C	  90
TR1				  BIT	      8E	  92
TR2				  BIT	      CA	 138
TXD				  BIT	      B1	 113
WAIT_1MS			  CODE	    006B	 250
WAIT_SEL_MS			  CODE	    005E	 243
WCOL				  BIT	      FE	 178
WDCON				  DATA	      C0	  51
WDE				  BIT	      C1	 129
WDIR				  BIT	      C3	 131
WDS				  BIT	      C2	 130
WDWR				  BIT	      C0	 128
WISSEN				  CODE	    050C	1700
WR				  BIT	      B6	 118
XOFF				  NUMBER    0013	1693
XONXOFF				  CODE	    0594	1853
XONXOFF1			  CODE	    05A0	1859
XONXOFF2			  CODE	    059B	1856
XONXOFF3			  CODE	    05A5	1861
