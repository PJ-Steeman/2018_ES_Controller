
ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 18.asm
	Object File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 18.hex
	List File:	C:\Studenten\Anton en Pieter-Jan\Oefeningen\Opdracht 18.lst



 Line  I  Addr  Code            Source

    1:				;Anton Peeters en Pieter-Jan Steeman
    2:
    3:				$nolist
  181:
  182:		N      007F	stack_init	equ	07fh
  183:		N      0000			org	0000h
  184:
  185:	  0000	02 00 0E			ljmp	start
  186:		N      000B			org	000bh
  187:	  000B	02 00 28			ljmp	int0_rout
  188:
  189:	  000E	75 81 7F	start:		mov	sp,#stack_init
  190:	  0011	75 A0 FF			mov	p2,#0FFh
  191:	  0014	75 8A 2E			mov	tl0,#02Eh
  192:	  0017	75 8C 2E			mov	th0,#02Eh
  193:	  001A	75 89 02			mov	tmod,#2
  194:	  001D	75 D7 00			mov	PLLCON,#00h
  195:	  0020	D2 8C				setb	TR0
  196:	  0022	D2 AF				setb	ea
  197:	  0024	D2 A9				setb	et0
  198:	  0026	80 FE		loop:		sjmp	loop
  199:
  200:	  0028	15 A0		int0_rout:	dec	p2
  201:	  002A	32				reti
  202:
  203:				$include (c:/aduc800_mideA.inc)
  204: 1			;******************************************************************************
  205: 1			; Hier kan de gebruiker instellen welke versie van het aduc800 bord er gebruikt
  206: 1			; wordt. V1.1 zal communiceren via een seriële poort, V2.2 via USB
  207: 1			; Dit is ook belangrijk voor het lezen van de schakelaars.  Deze zitten op
  208: 1			; andere poortpinnen bij de twee versies! (zie hardware documentatie)
  209: 1			; Instelling versie ADuC832 bord = V1.1: verander in commentaar voor V2.0 (i2c)
  210: 1			;aduc832_v1_1  set   1               ;versie 1.1, LCD op P0.2-P0.7
  211: 1			;******************************************************************************
  212: 1			; Instelling versie ADuC832 bord = V2.0: verander in commentaar voor V1.1 (P0)
  213: 1	N      0001	aduc832_v2_0  set  1               ;versie 2.0, LCD via pcf8574
  214: 1			;******************************************************************************
  215: 1
  216: 1
  217: 1			;******************************************************************************
  218: 1			; Hier definieren we welke modules uit de aduc800_mide file we effectief nodig
  219: 1			; hebben voor onze toepassing. Door een module te definieren via het
  220: 1			; SET commando is deze modulenaam gekend voor de assembler en kunnen de nodige

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 2



 Line  I  Addr  Code            Source

  221: 1			; modules aan de hand van deze modulenaam conditioneel worden geassembleerd.
  222: 1			; Indien de gebruiker bepaalde modules niet nodig heeft moet de definitie in
  223: 1			; commentaar worden gezet door er een ';' voor te plaatsen.
  224: 1			; Hierdoor zal er ook minder codegeheugen worden gebruikt door de aduc800_mide
  225: 1			; file. De hoeveelheid code per module wordt telkens aangegeven achter de
  226: 1			; definities.
  227: 1			;******************************************************************************
  228: 1	N      0001	aduc_lcd    set        1    ;benodigd codegeheugen = v1.1: 02bfh of 703d bytes
  229: 1			                            ;benodigd codegeheugen = v2.0: 045ch of 1116d bytes
  230: 1			                            ;dit is inclusief met de benodigde aduc_i2c driver
  231: 1	N      0001	aduc_i2c    set        1    ;benodigd codegeheugen = 0168h of 360d bytes
  232: 1	N      0001	aduc_sio    set        1    ;benodigd codegeheugen = 0160h of 352d bytes
  233: 1	N      0001	aduc_math   set        1    ;benodigd codegeheugen = 0d9ah of 3482d bytes!
  234: 1	N      0001	aduc_adc    set        1    ;benodigd codegeheugen = 00bch of 188d bytes
  235: 1	N      0001	aduc_key    set        1    ;benodigd codegeheugen = 0192h of 402d bytes
  236: 1
  237: 1			ifdef    aduc_key
  238: 1			;De volgende definities geven aan of de 8 individuele schakelaars van het
  239: 1			;aduc832 bord (de dipswitches, druktoetsen of extern aangesloten schakel-
  240: 1			;contacten) moeten worden gelezen, of dat er een 4x4 matrixkeyboard moet
  241: 1			;worden gelezen dat is verbonden met het aduc832 bord.
  242: 1			;Bij aduc832v1.1 zijn de 4 druktoetsen parallel geschakeld met de dipswitch
  243: 1			;en de externe connectorpinnen van H2 waar er een extern 4x4 matrixkeybord
  244: 1			;kan worden aangesloten. Het is duidelijk dat bij deze versie V1.1 ofwel een
  245: 1			;definitie moet gemaakt worden van het symbool matrix, ofwel van het symbool
  246: 1			;dipswitch daar deze niet tegelijk kunnen worden gelezen.
  247: 1			;Bij aduc832v2.0 zijn de 4 druktoetsen met P3 verbonden, terwijl de
  248: 1			;dipswitch en de externe connectorpinnen van H0 parallel zijn verbonden.
  249: 1			;Bij deze versie kunnen beide dus wel tegelijk worden gelezen en kunnen beide
  250: 1			;definities wel gemaakt worden.
  251: 1	N      0001	matrix        set      1    ;als er een matrixkeyboard moet worden gelezen
  252: 1			                            ;anders commentaar van maken!
  253: 1	N      0001	dipswitch     set      1    ;als de individuele schakelaars moeten worden
  254: 1			                            ;gelezen, anders commentaar van maken!
  255: 1			;******************************************************************************
  256: 1			;Declaraties van de flags voor de aduc_key driver.
  257: 1			;Deze flags worden gebruikt in de routines voor het lezen van een matrix-
  258: 1			;keybord nl:key_init, keyscan, keydown, keyedge,toets_flank,toets_ingedrukt
  259: 1			;en bij de routines voor het lezen van 8 individuele schakelaars:
  260: 1			;switch_init en read_switch.
  261: 1	N      0020	keyflags    equ        20h      ;dit moet in bit adresseerbaar gebied liggen
  262: 1			                                ;bereik = 20h-2fh!
  263: 1	B	 00	keyvalid    bit        keyflags.0  ;flag die aangeeft dat KEY
  264: 1			                                   ;een geldige waarde bevat
  265: 1	B	 01	keymode     bit        keyflags.1  ;flag voor intern gebruik,
  266: 1			                                   ;die de detectie mode aangeeft
  267: 1			;declaratie van de read_switch flags
  268: 1	B	 02	swvalid     bit        keyflags.2  ;flag die aangeeft dat er actuele
  269: 1			                                   ;ontdenderde schakelaars zijn
  270: 1	B	 03	negvalid    bit        keyflags.3  ;flag die aangeeft dat er negatieve
  271: 1			                                   ;flanken zijn
  272: 1	B	 04	posvalid    bit        keyflags.4  ;flag die aangeeft dat er positieve
  273: 1			                                   ;flanken zijn
  274: 1			ifdef    matrix        ;matrix keyboard
  275: 1			;Declaraties van variabelen (9 bytes) voor de aduc_key driver.
  276: 1			;Deze worden gebruikt in de routines voor het lezen van een matrixkeybord

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 3



 Line  I  Addr  Code            Source

  277: 1			;nl:key_init,Keyscan, Keydown,Keyedge, toets_flank en toets_ingedrukt.
  278: 1			;Deze kunnen door de gebruiker aangepast worden aan de noden van zijn
  279: 1			;toepassing.
  280: 1	N      0030	keymap      equ        30h      ;default startadres van de benodigde 9 byte
  281: 1			                                ;geheugenbuffer
  282: 1	N      0030	map01ptr    equ        keymap   ;intern startadres van de 8 map bytes die de
  283: 1			                                ;debounce en de flankdetectie samples stockeren
  284: 1			                                ;de eerste 4 bytes dienen voor debouncing
  285: 1	N      0034	map23ptr    equ        keymap+4 ;de volgende 4 bytes dienen voor flankdetectie
  286: 1	N      0038	key         equ        keymap+8 ;adres van de variabele die de ingedrukte
  287: 1			                                ;toetswaarde aangeeft
  288: 1			                                ;bij een geldige keyvalid flag ('1')
  289: 1			endif    ;einde matrix keyboard
  290: 1
  291: 1			ifdef    dipswitch
  292: 1			;Declaraties van variabelen (6 bytes) voor het lezen en debouncen van 8
  293: 1			;individuele schakelaars nl: de switch_init en read_switch routine.
  294: 1			;Het startadres kan door de gebruiker worden aangepast aan de noden van de
  295: 1			;toepassing
  296: 1	N      0040	switchmap    equ        40h     ;startadres voor de 6 bytes intern geheugen
  297: 1	N      0040	switch1      equ        switchmap+0 ;adres nieuwste sample schakelaars
  298: 1	N      0041	switch2      equ        switchmap+1 ;adres vorige sample schakelaars
  299: 1	N      0042	debounce     equ        switchmap+2 ;adres ontdenderde schakelaars
  300: 1	N      0043	closed       equ        switchmap+3 ;adres flankdetectie flipflop
  301: 1	N      0044	negedge      equ        switchmap+4 ;adres negatieve flankdetectie
  302: 1	N      0045	posedge      equ        switchmap+5 ;adres positieve flankdetectie
  303: 1			endif    ;einde dipswitch
  304: 1			;******************************************************************************
  305: 1			endif    ;einde aduc_key
  306: 1
  307: 1
  308: 1			ifdef    aduc_lcd                   ;LCD driver is nodig indien gedefinieerd
  309: 1
  310: 1			ifdef    aduc832_v2_0               ;bij v2.0 is de i2c driver nodig ook al
  311: 1	N      0001	aduc_i2c    set        1            ;heeft de gebruiker deze niet gedefinieerd
  312: 1			endif                               ;dus doen we dit hier nog eens!
  313: 1			;******************************************************************************
  314: 1
  315: 1			;******************************************************************************
  316: 1			;
  317: 1			; ADuc_lcd.inc
  318: 1			; Is een include file voor het gebruik van een op een Hitachi HD44870 gebaseerd
  319: 1			; (of compatibel) lcd scherm op het ADuC800 bord.
  320: 1			; Het bord wordt gebruikt met een 1*16 of een 2*16 karakter
  321: 1			; display. De basisroutines zijn ook bruikbaar voor schermen met meerdere
  322: 1			; lijnen en meer chars per lijn. (de gebruiker moet dan wel zelf zorgen voor
  323: 1			; het plaatsen van de cursor op een correcte plaats).
  324: 1			; De routines op het hoogste niveau gaan er van uit dat we een 2*16 karakter
  325: 1			; display gebruiken.
  326: 1			; Parameters worden doorgegeven via de accu, b register, dptr of r0.
  327: 1			; De routines vernietigen geen registers. Alle timing wordt automatisch
  328: 1			; aangepast aan de controller clockfrequentie (aan de waarden in het pllcon
  329: 1			; register). De routines zijn geoptimaliseerd naar de aansluitingen op een
  330: 1			; MGM/[dp] ADuC800 bord. Dit in de versie ADuC832V1.1 of de versie ADuC832V2.0
  331: 1			;
  332: 1			; Versie ADuC832v1.1:

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 4



 Line  I  Addr  Code            Source

  333: 1			; Hier is het LCD verbonden met pinnen van poort0
  334: 1			; DB4=P0.4, DB5=P0.5, DB6=P0.6, DB7=P0.7, E=P0.2, RS=P0.3
  335: 1			; De 2 overblijvende klemmen van poort 0 (P0.0 en P0.1) worden niet aangepast.
  336: 1			;
  337: 1			; Versie ADuC832v2.2:
  338: 1			; Hier is het LCD via een I2C port expander PCF8574 verbonden met de controller
  339: 1			; Via de definitie van het symbool aduc832_v1_1 of aduc832_v2_0 kan er
  340: 1			; conditioneel code worden geassembleerd voor één van de twee versies:
  341: 1			; aduc832_v1_1    set 1 => ADuC832v1.1 (poort0) = default instelling
  342: 1			; aduc832_v2_0  set    1 => ADuC832v2.0 (IIC-bus)
  343: 1			;
  344: 1			;
  345: 1			; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS als lcd.drv
  346: 1			; -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
  347: 1			;  aduclcd0.inc
  348: 1			; -aangepast door Roggemans Marc (MGM) op 11/11/2004
  349: 1			;  aduclcd1.inc
  350: 1			;    -00dh en 00ah worden door outchar verwerkt
  351: 1			;    -bij de init wordt het display anders opgestart
  352: 1			;
  353: 1			; -door [dp] op 22/11/2013 voorzien van extra commentaar met voorbeelden
  354: 1			;  van gebruik en uitgebreid  met :
  355: 1			;  * outcharlcd drukt ook ASCII code 0-7 (Build gedefinieerde karakters) af
  356: 1			;  * barlcd routine voor het afdrukken van een 'bargraph' display
  357: 1			;  * hexbuf2lcd  routine voor afdrukken van interne registers voor
  358: 1			;    debug doeleinden
  359: 1			;  * build_adr routine om vanaf een bepaald intern cgram adres (0-7)
  360: 1			;    user codes aan te maken
  361: 1			;  * conditioneel assembleren voor twee versies van het ADuC832 bord
  362: 1			;  * bug uit outhnibd en outhnibc ivm aansturing p0.0 en p0.1
  363: 1			;
  364: 1			; Beschikbare routines:
  365: 1			; initlcd, outcharlcd, outniblcd, outbytelcd, dispdptrlcd, outmsgalcd,
  366: 1			; regtolcd, outd, outhnibd, outc, outhnibc, hexbuf2lcd, barlcd, build,
  367: 1			; build_adr, delay2ms, delay60us
  368: 1			;******************************************************************************
  369: 1
  370: 1			ifdef    aduc832_v1_1    ;V1.1 gebruikt P0 voor LCD sturing
  371: 1			lcdport       EQU    p0                   ;SELECTIE POORT 0
  372: 1			e             bit    lcdport.2            ;enable
  373: 1			rs            bit    lcdport.3            ;register select
  374: 1			endif    ;einde aduc832_v1_1
  375: 1
  376: 1			ifdef    aduc832_v2_0    ;V2.0 gebruikt een I2C port expander voor LCD sturing
  377: 1	D      00F0	lcdport       EQU    b                    ;b wordt gebruikt als dummy poort
  378: 1	B	 F1	e             bit    lcdport.1            ;enable
  379: 1	B	 F0	rs            bit    lcdport.0            ;register select
  380: 1	B	 F6	backlight     bit    lcdport.6            ;bit waar backlight op zit
  381: 1	B	 F7	buzzer        bit    lcdport.7            ;bit waar buzzer op zit
  382: 1			endif    ;einde aduc832_v2_0
  383: 1
  384: 1			;Hier worden de codes aangegeven die naar het LCD moeten worden gestuurd voor
  385: 1			;het uitvoeren van de overeenkomstige commando's.
  386: 1	N      0001	cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
  387: 1	N      0002	cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
  388: 1

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 5



 Line  I  Addr  Code            Source

  389: 1	N      0006	entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
  390: 1	N      0001	displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
  391: 1	N      0008	displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
  392: 1	N      000C	cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
  393: 1	N      000F	cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
  394: 1	N      000E	cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
  395: 1	N      0028	functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
  396: 1	N      0040	cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
  397: 1	N      0080	ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
  398: 1
  399: 1			;******************************************************************************
  400: 1			;
  401: 1			; initlcd
  402: 1			; Zal het scherm resetten en initialiseren voor gebruik via een 4 bit bus op
  403: 1			; poort0 of via i2c. De routine zet het scherm klaar voor normaal gebruik:
  404: 1			; ingave van links naar rechts zonder display shift, normale karakterfont.
  405: 1			; De cursor staat aan als een knipperend lijntje onderaan de regel.
  406: 1			; Na initialisering wordt het scherm leeg gemaakt.
  407: 1			;
  408: 1			; registergebruik: geen
  409: 1			;
  410: 1			;******************************************************************************
  411: 1
  412: 1  002B	C0 E0		initlcd:      push   acc           ;registers op stack plaatsen
  413: 1  002D	C0 D0		              push   psw
  414: 1  002F	C0 F0		              push   b
  415: 1			ifdef  aduc832_v1_1
  416: 1			              mov    lcdport,#003h ;poort in uitgangstoestand zetten
  417: 1			                                   ;let op:twee laagste bits worden
  418: 1			                                   ;niet gebruikt
  419: 1			endif
  420: 1
  421: 1			ifdef    aduc832_v2_0
  422: 1  0031	12 03 21	              lcall  i2cinit              ;LCD via een I2C bus
  423: 1  0034	75 F0 FD	              mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
  424: 1			                                          ;buzzer en backlight  op 1 gezet
  425: 1  0037	12 04 24	              lcall  porttolcd            ;data uit b naar het scherm
  426: 1			endif
  427: 1
  428: 1  003A	74 10		              mov    a,#010h       ;bij opstarten van Vcc > dan 30ms wachten
  429: 1  003C	12 02 F6	initlcd1:     lcall  delay2ms
  430: 1  003F	D5 E0 FA	              djnz   acc,initlcd1
  431: 1  0042	74 30		              mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
  432: 1  0044	12 01 AD	              lcall  outhnibc      ;beschreven in de HD44870 datasheet
  433: 1  0047	12 02 F6	              lcall  delay2ms      ;om het display altijd opgestart
  434: 1  004A	74 30		              mov    a,#00110000b  ;te krijgen.
  435: 1  004C	12 01 AD	              lcall  outhnibc
  436: 1  004F	12 02 F6	              lcall  delay2ms
  437: 1  0052	74 30		              mov    a,#00110000b
  438: 1  0054	12 01 AD	              lcall  outhnibc
  439: 1  0057	12 02 F6	              lcall  delay2ms
  440: 1  005A	74 20		              mov    a,#00100000b  ;instellen 4 bit interface gebruiken
  441: 1  005C	12 01 AD	              lcall  outhnibc      ;hoge nibble naar het controleregister
  442: 1  005F	12 02 F6	              lcall  delay2ms      ;niet nodig volgens datasheet
  443: 1  0062	74 28		              mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
  444: 1  0064	12 01 97	              lcall  outc          ;naar display

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 6



 Line  I  Addr  Code            Source

  445: 1  0067	12 02 F6	              lcall  delay2ms      ;is iets te lang volgens datasheet
  446: 1  006A	74 0F		              mov    a,#cursoronb  ;display on cursor on and blink
  447: 1  006C	12 01 97	              lcall  outc
  448: 1  006F	12 02 F6	              lcall  delay2ms      ;ook deze delay is iets te lang
  449: 1  0072	74 01		              mov    a,#displayon  ;clear display and home cursor
  450: 1  0074	12 01 97	              lcall  outc
  451: 1  0077	12 02 F6	              lcall  delay2ms      ;deze wachttijd is bijna juist
  452: 1  007A	74 06		              mov    a,#entrymode  ;display klaar zetten normaal gebruik
  453: 1  007C	12 01 97	              lcall  outc
  454: 1  007F	12 02 F6	              lcall  delay2ms      ;wachten weer veel te lang
  455: 1  0082	D0 F0		              pop    b
  456: 1  0084	D0 D0		              pop    psw           ;registers terug in orde zetten
  457: 1  0086	D0 E0		              pop    acc
  458: 1  0088	22		              ret                  ;einde van de initialisatie
  459: 1
  460: 1			;******************************************************************************
  461: 1			;
  462: 1			; outcharlcd
  463: 1			; Zal de ascii code in de accu naar het lcd scherm sturen om af te drukken.
  464: 1			; De codes 00h tot 07h komen overeen met een door de build routine aangemaakte
  465: 1			; user karakters. De codes groter dan 08h en kleiner dan 20h worden als
  466: 1			; controlekarakters bekeken en kunnen door de gebruiker gewoon worden opgenomen
  467: 1			; in de ascii strings die moeten worden weergegeven op het LCD.
  468: 1			; De controlekarakters komen overeen met volgende acties:
  469: 1			;  08h,09h,0bh,0eh-01fh   =nog niet in gebruik
  470: 1			;      00ah   =cursor op eerste char van tweede lijn plaatsen
  471: 1			;              (line feed+ carriage return!)
  472: 1			;      00ch   =form feed : scherm leeg maken en cursor op locatie 000h
  473: 1			;      00dh   =cursor in de home positie (eerste char van de eerste lijn)
  474: 1			;      011h   =cursor on, blink mode
  475: 1			;      012h   =cursor on, no blink mode
  476: 1			;      013h   =cursor off
  477: 1			;  80h-0ffh   =cursor plaatsen op een DDRAM adres. Waneer bit7 is geset(80h)
  478: 1			;              worden de 7 lagere bits geinterpreteerd als het DDRAM adres
  479: 1			;              van het LCD
  480: 1			;              |00|01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|
  481: 1			;              |40|41|42|43|44|45|46|47|48|49|4A|4B|4C|4D|4E|4F|
  482: 1			; Een code bv. C5H zal de cursor dus positioneren op de tweede lijn
  483: 1			; positie 6 (C5H-80H=45H)
  484: 1			;
  485: 1			; Deze routine vernietigt geen registers
  486: 1			;
  487: 1			;******************************************************************************
  488: 1
  489: 1			; we gaan eerst na of het een ascii code betreft uit de afdrukbare ASCII set.
  490: 1			; Als dat zo is,(00h-07h of 20h-07fh) dan mag de data direct naar het
  491: 1			; dataregister van het scherm.
  492: 1			; Indien de code >80H dan stelt dit een DDRAM adres voor en moeten we het als
  493: 1			; controlebyte doorsturen naar het LCD.
  494: 1			; Betreft het een controle karakter (08h-20H), dan is een andere aanpak nodig
  495: 1			; en moeten we de code interpreteren en het gepaste overeenkomende commando
  496: 1			; naar de LCD sturen.
  497: 1
  498: 1  0089	C0 E0		outcharlcd:   push   acc           ;registers op stack
  499: 1  008B	C0 D0		              push   psw
  500: 1  008D	B4 80 00	              cjne   a,#080h,outcharlcd1  ;hogere of gelijke code is adres

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 7



 Line  I  Addr  Code            Source

  501: 1  0090	50 39		outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
  502: 1  0092	B4 08 00	              cjne   a,#08h,outcharlcd2_0  ;lagere code is afdrukbare user char
  503: 1  0095	40 2F		outcharlcd2_0:jc     outcharlcd8   ;bij cy dan code van userchar naar display
  504: 1  0097	B4 20 00	              cjne   a,#020h,outcharlcd2  ;hogere of gelijke code is afdrukbaar
  505: 1  009A	50 2A		outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
  506: 1
  507: 1			; De code in de accu is geen adres of geen geldig afdrukbaar karakter.
  508: 1			; Als het een commando is, moeten we het uitvoeren.
  509: 1			; Indien niet, gewoon terug zonder actie!
  510: 1
  511: 1  009C	B4 0C 04	              cjne   a,#00ch,outcharlcd3  ;geen form feed, dan volgende testen
  512: 1  009F	74 01		              mov    a,#cleardisp         ;"scherm leegmaken" commando
  513: 1  00A1	80 28		              sjmp   outcharlcd9          ;afsluiten
  514: 1
  515: 1  00A3	B4 11 04	outcharlcd3:  cjne   a,#011h,outcharlcd4  ;geen cursor on blink
  516: 1  00A6	74 0F		              mov    a,#cursoronb         ;"cursoron met blink"commando
  517: 1  00A8	80 21		              sjmp   outcharlcd9
  518: 1
  519: 1  00AA	B4 12 04	outcharlcd4:  cjne   a,#012h,outcharlcd5  ;geen cursor on no blink
  520: 1  00AD	74 0E		              mov    a,#cursoronn         ;"cursoron no blink" commando
  521: 1  00AF	80 1A		              sjmp   outcharlcd9
  522: 1
  523: 1  00B1	B4 13 04	outcharlcd5:  cjne   a,#013h,outcharlcd6  ;geen cursoroff
  524: 1  00B4	74 0C		              mov    a,#cursoroff         ;"cursor uitschakelen"commando
  525: 1  00B6	80 13		              sjmp   outcharlcd9
  526: 1
  527: 1  00B8	B4 0D 04	outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen 'cursor home '
  528: 1  00BB	74 02		              mov    a,#cursathom         ;"cursor in home positie"commando
  529: 1  00BD	80 0C		              sjmp   outcharlcd9
  530: 1
  531: 1  00BF	B4 0A 0C	outcharlcd7:  cjne   a,#00ah,outcharlcde  ;geen line feed, terug zonder actie
  532: 1  00C2	74 C0		              mov    a,#0c0h             ;DDRAM adres:1ste plaats 2de lijn
  533: 1  00C4	80 05		              sjmp   outcharlcd9
  534: 1
  535: 1
  536: 1			; Dit label wordt uitgevoerd als de code in de accumulator een  ascii code
  537: 1			; is van een afdrukbaar karakter, deze code mag dan naar het data register.
  538: 1
  539: 1  00C6	12 01 5D	outcharlcd8:  lcall  outd          ;display het karakter op het LCD
  540: 1  00C9	80 03		              sjmp   outcharlcde   ;einde routine
  541: 1
  542: 1			; De volgende instructies worden uitgevoerd als de hoogste bit van de code in
  543: 1			; de accu geset is. Dit geeft immers aan dat de 7 laagste bits een adres
  544: 1			; voorstellen. De code in de accu is dan meteen ook een commando om de cursor
  545: 1			; op dat adres te zetten.
  546: 1
  547: 1  00CB	12 01 97	outcharlcd9:  lcall  outc          ;klaar
  548: 1  00CE	D0 D0		outcharlcde:  pop    psw           ;registers herstellen
  549: 1  00D0	D0 E0		              pop    acc
  550: 1  00D2	22		              ret
  551: 1
  552: 1			;******************************************************************************
  553: 1			;
  554: 1			; outniblcd
  555: 1			; Zal de lage nibble omzetten in een ascii code en die afdrukken
  556: 1			; op het lcd scherm.

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 8



 Line  I  Addr  Code            Source

  557: 1			;
  558: 1			; de routine vernietigt geen registers
  559: 1			;
  560: 1			;******************************************************************************
  561: 1
  562: 1  00D3	C0 E0		outniblcd:    push   acc           ;registers op stack zetten
  563: 1  00D5	C0 D0		              push   psw
  564: 1  00D7	54 0F		              anl    a,#00fh       ;laagste 4 bits overhouden
  565: 1  00D9	24 30		              add    a,#030h       ;omvormen naar ascii codes 0-9
  566: 1  00DB	B4 3A 00	              cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
  567: 1  00DE	40 02		outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
  568: 1  00E0	24 07		              add    a,#007h       ;omvormen naar hoofdletter
  569: 1  00E2	12 01 5D	outniblcde:   lcall  outd          ;naar het scherm
  570: 1  00E5	D0 D0		              pop    psw
  571: 1  00E7	D0 E0		              pop    acc
  572: 1  00E9	22		              ret
  573: 1
  574: 1			;******************************************************************************
  575: 1			;
  576: 1			; outbytelcd
  577: 1			; Zal de inhoud van de accu als hex getal afdrukken op het lcd scherm.
  578: 1			;
  579: 1			; de routine vernietigt geen registers
  580: 1			;
  581: 1			;******************************************************************************
  582: 1
  583: 1  00EA	C0 E0		outbytelcd:   push   acc           ;registers op de stack zetten
  584: 1  00EC	C0 D0		              push   psw
  585: 1  00EE	C4		              swap   a             ;bitjes omruilen
  586: 1  00EF	12 00 D3	              lcall  outniblcd
  587: 1  00F2	C4		              swap   a             ;nog eens
  588: 1  00F3	12 00 D3	              lcall  outniblcd
  589: 1  00F6	D0 D0		              pop    psw
  590: 1  00F8	D0 E0		              pop    acc
  591: 1  00FA	22		              ret
  592: 1
  593: 1			;******************************************************************************
  594: 1			;
  595: 1			; dispdptrlcd
  596: 1			; Zal de inhoud van de dptr als hex getal afdrukken op het lcd scherm
  597: 1			;
  598: 1			; de routine vernietigt geen registers
  599: 1			;
  600: 1			;******************************************************************************
  601: 1
  602: 1  00FB	C0 E0		dispdptrlcd:  push   acc           ;registers bewaren op stack
  603: 1  00FD	C0 D0		              push   psw
  604: 1  00FF	E5 83		              mov    a,dph         ;hoge deel eerst naar het scherm
  605: 1  0101	12 00 EA	              lcall  outbytelcd
  606: 1  0104	E5 82		              mov    a,dpl         ;dan het lage deel
  607: 1  0106	12 00 EA	              lcall  outbytelcd
  608: 1  0109	D0 D0		              pop    psw
  609: 1  010B	D0 E0		              pop    acc
  610: 1  010D	22		              ret
  611: 1
  612: 1			;******************************************************************************

ASEM-51 V1.3                                         Copyright (c) 2002 by W.W. Heinz                                         PAGE 9



 Line  I  Addr  Code            Source

  613: 1			;
  614: 1			; outmsgalcd
  615: 1			; Zal een string ascii codes op het scherm afdrukken. Het startadres
  616: 1			; van de string staat in de dptr. De string wordt afgesloten met een 000h.
  617: 1			; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
  618: 1			; scherm. De zelf aangemaakte user karakters 00h-07h (via de build routine) en
  619: 1			; de positionnering van de cursor en cursorcontrole kan in de ascii string
  620: 1			; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
  621: 1			;
  622: 1			; de routine vernietigt geen registers
  623: 1			;
  624: 1			;******************************************************************************
  625: 1
  626: 1  010E	C0 E0		outmsgalcd:   push   acc           ;registers op de stack
  627: 1  0110	C0 D0		              push   psw
  628: 1  0112	C0 83		              push   dph           ;ook de data pointer
  629: 1  0114	C0 82		              push   dpl
  630: 1
  631: 1			;We lezen karakters uit code memory tot de 000h code gevonden wordt.
  632: 1
  633: 1  0116	E4		outmsgalcd1:  clr    a             ;waarde zit in onze weg
  634: 1  0117	93		              movc   a,@a+dptr     ;waarde lezen
  635: 1  0118	60 07		              jz     outmsgalcde   ;als 0 dan naar einde springen
  636: 1
  637: 1			; de code is niet 0 dus versturen met outchar
  638: 1
  639: 1  011A	12 00 89	              lcall  outcharlcd    ;weg er mee
  640: 1  011D	A3		              inc    dptr          ;naar volgende ascii code wijzen
  641: 1  011E	02 01 16	              ljmp   outmsgalcd1   ;lus sluiten
  642: 1
  643: 1  0121	D0 82		outmsgalcde:  pop    dpl           ;registers herstellen
  644: 1  0123	D0 83		              pop    dph
  645: 1  0125	D0 D0		              pop    psw
  646: 1  0127	D0 E0		              pop    acc
  647: 1  0129	22		              ret
  648: 1
  649: 1			;******************************************************************************
  650: 1			;
  651: 1			; regtolcd
  652: 1			; Is een subroutine die de ASCII gegevens uit een interne buffer, die een copie
  653: 1			; is van de tekst die op het volledige scherm moet komen, naar de lcd stuurt.
  654: 1			; De routine gaat er van uit dat er op het scherm maar 16 karakters per lijn
  655: 1			; beschikbaar zijn. De string ascii codes in het geheugen moet ook 32 karakters
  656: 1			; bevatten. De routine verwacht in r0 het startadres van de buffer.
  657: 1			;
  658: 1			; de routine vernietigt geen registers
  659: 1			;
  660: 1			;******************************************************************************
  661: 1
  662: 1
  663: 1  012A	C0 E0		regtolcd:     push   acc           ;registers op de stack
  664: 1  012C	C0 D0		              push   psw
  665: 1  012E	E8		              mov    a,r0
  666: 1  012F	C0 E0		              push   acc
  667: 1  0131	E9		              mov    a,r1
  668: 1  0132	C0 E0		              push   acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 10



 Line  I  Addr  Code            Source

  669: 1  0134	74 80		              mov    a,#80h          ;dit is het eerste adres op de eerstelijn
  670: 1  0136	12 00 89	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  671: 1			                                   ;plaats
  672: 1  0139	79 00		              mov    r1,#000h      ;werkt als loopcounter
  673: 1  013B	E6		regtolcd1:    mov    a,@r0         ;karakter lezen
  674: 1  013C	12 00 89	              lcall  outcharlcd    ;weg er mee
  675: 1  013F	08		              inc    r0
  676: 1  0140	09		              inc    r1
  677: 1  0141	B9 10 F7	              cjne   r1,#016d,regtolcd1   ;als deze waarde 16 is moet een
  678: 1			                                          ;nieuwe lijn genomen worden
  679: 1  0144	74 C0		              mov    a,#(80h+40h)  ;dit is het eerste adres op de tweede lijn
  680: 1  0146	12 00 89	              lcall  outcharlcd    ;hiermee plaatsen we de cursor op de juiste
  681: 1			                                   ;plaats
  682: 1
  683: 1  0149	E6		regtolcd2:    mov    a,@r0         ;karakter lezen
  684: 1  014A	12 00 89	              lcall  outcharlcd    ;weg er mee
  685: 1  014D	08		              inc    r0
  686: 1  014E	09		              inc    r1
  687: 1  014F	B9 20 F7	              cjne   r1,#032d,regtolcd2   ;als deze waarde 32 is stoppen
  688: 1  0152	D0 E0		              pop    acc
  689: 1  0154	F9		              mov    r1,a
  690: 1  0155	D0 E0		              pop    acc
  691: 1  0157	F8		              mov    r0,a
  692: 1  0158	D0 D0		              pop    psw           ;registers herstellen
  693: 1  015A	D0 E0		              pop    acc
  694: 1  015C	22		              ret
  695: 1
  696: 1			;******************************************************************************
  697: 1			;
  698: 1			; outd
  699: 1			; Is een routine die naar het data register van het display een
  700: 1			; volledige byte stuurt.
  701: 1			; Deze routine kan oa. nuttig gebruikt worden om karakters met code 0a0h - offh
  702: 1			; (de aziatische karakterset en de Griekse symbolen) of de user gedefinieerde
  703: 1			; karakters (via build routine) met code 00h-07h af te drukken op het lcdscherm
  704: 1			; Vb:  mov a,#0E0H  ; code van het alfa symbool (zie karakterset LCD)
  705: 1			;      lcall  outd  ; druk alfa af op de plaats van de cursor
  706: 1			;
  707: 1			; De routine vernietigt geen registers.
  708: 1			;
  709: 1			;******************************************************************************
  710: 1
  711: 1  015D	C0 E0		outd:         push   acc           ;registers op stack zetten
  712: 1  015F	C0 D0		              push   psw
  713: 1  0161	12 01 6D	              lcall  outhnibd      ;hoogste vier bits verzenden
  714: 1			ifdef     aduc832_v1_1
  715: 1			              lcall  delay60us     ;niet echt nodig
  716: 1			endif
  717: 1  0164	C4		              swap   a             ;bitjes omruilen
  718: 1  0165	12 01 6D	              lcall  outhnibd      ;naar het scherm sturen
  719: 1
  720: 1			ifdef    aduc832_v1_1
  721: 1			              lcall  delay60us     ;altijd goed
  722: 1			endif
  723: 1
  724: 1  0168	D0 D0		              pop    psw           ;registers terug herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 11



 Line  I  Addr  Code            Source

  725: 1  016A	D0 E0		              pop    acc
  726: 1  016C	22		              ret
  727: 1
  728: 1			;******************************************************************************
  729: 1			;
  730: 1			; outhnibd
  731: 1			; Stuurt de hoogste 4 bits van de accu naar het data register van het
  732: 1			; lcd scherm.
  733: 1			; Een databyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  734: 1			; de routine vernietigt geen registers.
  735: 1			;
  736: 1			;******************************************************************************
  737: 1			ifdef     aduc832_v1_1
  738: 1			outhnibd:     push   acc           ;registers op stack plaatsen
  739: 1			              push   psw
  740: 1			              setb   rs            ;controle lijn in orde
  741: 1			              clr    e             ;deselectie display
  742: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  743: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  744: 1			              mov     c,acc.6      ;afblijven!
  745: 1			              mov     lcdport.6,c
  746: 1			              mov     c,acc.5
  747: 1			              mov     lcdport.5,c
  748: 1			              mov     c,acc.4
  749: 1			              mov     lcdport.4,c
  750: 1			              setb   e             ;display enabelen
  751: 1			              nop                  ;450ns is normaal gezien voldoende
  752: 1			              clr    e             ;display deselecteren
  753: 1			              pop    psw           ;registers herstellen
  754: 1			              pop    acc
  755: 1			              ret
  756: 1			endif
  757: 1
  758: 1			ifdef    aduc832_v2_0
  759: 1  016D	C0 E0		outhnibd:     push   acc           ;registers op stack plaatsen
  760: 1  016F	C0 D0		              push   psw
  761: 1  0171	C0 F0		              push   b             ;werkregister
  762: 1  0173	12 04 3D	              lcall  lcdtoport     ;lees de expander naar b register
  763: 1  0176	D2 F0		              setb   rs            ;controle lijn in orde
  764: 1  0178	C2 F1		              clr    e             ;deselectie display
  765: 1  017A	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  766: 1  017C	03		              rr     a             ;bits op juiste plaats zetten
  767: 1  017D	03		              rr     a             ;voor b reg
  768: 1  017E	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  769: 1  0181	42 F0		              orl    b,a           ;bij elkaar voegen
  770: 1  0183	12 04 24	              lcall  porttolcd     ;naar expander
  771: 1  0186	D2 F1		              setb   e             ;display enabelen
  772: 1  0188	12 04 24	              lcall  porttolcd
  773: 1  018B	C2 F1		              clr    e             ;display deselecteren
  774: 1  018D	12 04 24	              lcall  porttolcd
  775: 1  0190	D0 F0		              pop    b
  776: 1  0192	D0 D0		              pop    psw           ;registers herstellen
  777: 1  0194	D0 E0		              pop    acc
  778: 1  0196	22		              ret
  779: 1			endif
  780: 1			;******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 12



 Line  I  Addr  Code            Source

  781: 1			;
  782: 1			; outc
  783: 1			; Is een routine die naar het controleregister van het display een
  784: 1			; volledige byte (commando) stuurt.
  785: 1			; De routine vernietigt geen registers.
  786: 1			;
  787: 1			;******************************************************************************
  788: 1
  789: 1  0197	C0 E0		outc:         push   acc           ;registers op stack zetten
  790: 1  0199	C0 D0		              push   psw
  791: 1  019B	12 01 AD	              lcall  outhnibc      ;hoogste vier bits verzenden
  792: 1  019E	12 02 F6	              lcall  delay2ms      ;niet echt nodig
  793: 1  01A1	C4		              swap   a             ;bitjes omruilen
  794: 1  01A2	12 01 AD	              lcall  outhnibc      ;naar het scherm sturen
  795: 1  01A5	12 02 F6	              lcall  delay2ms      ;altijd goed voor traagste commando
  796: 1  01A8	D0 D0		              pop    psw           ;registers terug herstellen
  797: 1  01AA	D0 E0		              pop    acc
  798: 1  01AC	22		              ret
  799: 1
  800: 1			;******************************************************************************
  801: 1			;
  802: 1			; outhnibc
  803: 1			; Deze routine stuurt de hoge 4 bits van de accu naar het controle register van
  804: 1			; het lcd scherm.
  805: 1			; Een controlebyte naar het lcd scherm sturen gebeurt in twee maal via deze routine.
  806: 1			; de routine vernietigt geen registers.
  807: 1			;
  808: 1			;******************************************************************************
  809: 1			ifdef     aduc832_v1_1
  810: 1			outhnibc:     push   acc           ;registers op stack plaatsen
  811: 1			              push   psw
  812: 1			              clr    rs            ;controle lijn in orde
  813: 1			              clr    e             ;deselectie display
  814: 1			              mov     c,acc.7      ;4 meest beduidende bits naar
  815: 1			              mov     lcdport.7,c  ;de lcd poort sturen en van bit1 en bit0
  816: 1			              mov     c,acc.6      ;afblijven!
  817: 1			              mov     lcdport.6,c
  818: 1			              mov     c,acc.5
  819: 1			              mov     lcdport.5,c
  820: 1			              mov     c,acc.4
  821: 1			              mov     lcdport.4,c
  822: 1			              setb   e             ;display enabelen
  823: 1			              nop                  ;450ns is normaal gezien voldoende
  824: 1			              clr    e             ;display deselecteren
  825: 1			              pop    psw           ;registers herstellen
  826: 1			              pop    acc
  827: 1			              ret
  828: 1			endif
  829: 1
  830: 1			ifdef    aduc832_v2_0
  831: 1  01AD	C0 E0		outhnibc:     push   acc           ;registers op stack plaatsen
  832: 1  01AF	C0 D0		              push   psw
  833: 1  01B1	C0 F0		              push   b             ;werkregister
  834: 1  01B3	12 04 3D	              lcall  lcdtoport     ;lees de expander naar b register
  835: 1  01B6	C2 F0		              clr    rs            ;controle lijn in orde
  836: 1  01B8	C2 F1		              clr    e             ;deselectie display

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 13



 Line  I  Addr  Code            Source

  837: 1  01BA	54 F0		              anl    a,#0f0h       ;hoogste 4 bits afzonderen
  838: 1  01BC	03		              rr     a             ;bits op juiste plaats zetten
  839: 1  01BD	03		              rr     a             ;voor b reg
  840: 1  01BE	53 F0 C3	              anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
  841: 1  01C1	42 F0		              orl    b,a           ;bij elkaar voegen
  842: 1  01C3	12 04 24	              lcall  porttolcd     ;naar expnder
  843: 1  01C6	D2 F1		              setb   e             ;display enabelen
  844: 1  01C8	12 04 24	              lcall  porttolcd
  845: 1  01CB	C2 F1		              clr    e             ;display deselecteren
  846: 1  01CD	12 04 24	              lcall  porttolcd
  847: 1  01D0	D0 F0		              pop    b
  848: 1  01D2	D0 D0		              pop    psw           ;registers herstellen
  849: 1  01D4	D0 E0		              pop    acc
  850: 1  01D6	22		              ret
  851: 1			endif
  852: 1
  853: 1			;******************************************************************************
  854: 1			; hexbuf2lcd
  855: 1			; Deze debug routine laat toe om op het scherm een interne geheugen-
  856: 1			; buffer van 4 bytes af te drukken in hexadecimaal formaat.
  857: 1			; Dit is vooral handig in een debug fase van een userprogramma.
  858: 1			; Het startadres van de buffer wordt doorgegeven via R0.
  859: 1			; De buffer wordt met de nodige info afgedrukt op de twee lijnen van de LCD
  860: 1			; zoals hieronder met een voorbeeld wordt aangegeven.
  861: 1			;
  862: 1			; ADR| HEX DATA  |
  863: 1			; 42 |AF 2D 23 5A|
  864: 1			;
  865: 1			; Deze routine vernietigt geen registers
  866: 1			;******************************************************************************
  867: 1
  868: 1  01D7	C0 E0		hexbuf2lcd:   push   acc
  869: 1  01D9	C0 F0		              push   b
  870: 1  01DB	C0 D0		              push   psw
  871: 1  01DD	C0 82		              push   dpl
  872: 1  01DF	C0 83		              push   dph
  873: 1  01E1	E8		              mov     a,r0
  874: 1  01E2	C0 E0		              push   acc
  875: 1  01E4	90 02 20	              mov    dptr,#hexbuftxt ;eerst de infotekst schrijven
  876: 1  01E7	12 01 0E	              lcall   outmsgalcd
  877: 1  01EA	E8		              mov    a,r0            ;neem pointerwaarde
  878: 1  01EB	12 00 EA	              lcall  outbytelcd      ;byte afdrukken als startadres
  879: 1  01EE	74 20		              mov    a,#' '          ;spatie afdrukken
  880: 1  01F0	12 00 89	              lcall  outcharlcd
  881: 1  01F3	74 7C		              mov    a,#'|'          ;pipe afdrukken
  882: 1  01F5	12 00 89	              lcall  outcharlcd
  883: 1  01F8	75 F0 04	              mov    b,#4            ;bytecounter=4
  884: 1  01FB	E6		hexbuf2lcd1:  mov    a,@r0           ;hex byte ophalen
  885: 1  01FC	12 00 EA	              lcall  outbytelcd      ;byte naar buiten
  886: 1  01FF	74 20		              mov    a,#' '          ;neem whitespace char
  887: 1  0201	12 00 89	              lcall  outcharlcd       ;druk af
  888: 1  0204	08		              inc    r0              ;volgende byte
  889: 1  0205	D5 F0 CF	              djnz   b,hexbuf2lcd    ;4 bytes op een lijn
  890: 1			;Hex.bytes staan nu op lcd, nu nog pipe erachter zetten
  891: 1  0208	74 CF		              mov    a,#0cfh         ;adres laatste char
  892: 1  020A	12 00 89	              lcall   outcharlcd

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 14



 Line  I  Addr  Code            Source

  893: 1  020D	74 7C		              mov    a,#'|'          ;neem pipe
  894: 1  020F	12 00 89	              lcall  outcharlcd      ;ascii code afdrukken
  895: 1  0212	D0 E0		hexbuf2lcde:  pop    acc
  896: 1  0214	F8		              mov   r0,a
  897: 1  0215	D0 83		              pop   dph
  898: 1  0217	D0 82		              pop   dpl
  899: 1  0219	D0 D0		              pop   psw
  900: 1  021B	D0 F0		              pop   b
  901: 1  021D	D0 E0		              pop   acc
  902: 1  021F	22		              ret
  903: 1			                        ;'0123456789abcdef'
  904: 1  0220	13 80 41 44	hexbuftxt:    db 13h,80h,'ADR| HEX DATA  |',0c0h,0
       1  0224	52 7C 20 48
       1  0228	45 58 20 44
       1  022C	41 54 41 20
       1  0230	20 7C C0 00
  905: 1
  906: 1
  907: 1			;******************************************************************************
  908: 1			; barlcd
  909: 1			; Deze routine vormt een horizontale bargraph op het LCD scherm
  910: 1			; De startlocatie (00h-0fh of 40h-4fh) van de bargraph wordt aangegeven door
  911: 1			; de inhoud van A
  912: 1			; Het actuele aantal af te drukken bar's "|" wordt aangegeven door de inhoud
  913: 1			; van B. Het maximum aantal bar's dat moet kunnen afgedrukt worden, wordt
  914: 1			; aangegeven door R0. Via build moeten eerst de nodige spaciale char's worden
  915: 1			; aangemaakt in de LCD CGRAM.
  916: 1			; Deze speciale chars moeten op locaties 0 tot 4 zitten.
  917: 1			; vb:    mov  dptr,#barchars   ;maak speciale chars aan
  918: 1			;       lcall build
  919: 1			;       mov     r0,#40      ;we willen maximum 40 bars gebruiken als bargraph
  920: 1			;       mov     a, #42h     ;de startlocatie is 42h
  921: 1			;       mov  b, #20         ;de bargraph is tot de helft gevuld
  922: 1			;       lcall barlcd        ;geef de bargraph weer op het dislpay
  923: 1			;
  924: 1			; Deze routine vernietigt geen registers.
  925: 1			;******************************************************************************
  926: 1
  927: 1  0234	C0 82		barlcd:       push   dpl
  928: 1  0236	88 82		              mov     dpl,r0
  929: 1  0238	C0 82		              push   dpl
  930: 1  023A	C0 E0		              push   acc            ;bewaar startlocatie
  931: 1  023C	C0 D0		              push   psw            ;bewaar status
  932: 1  023E	C0 F0		              push   b              ;bewaar aantal bar's
  933: 1  0240	F5 F0		              mov    b,a            ;bewaar startlocatie
  934: 1			;Bereken het aantal karakters (5x8) die maximum nodig zijn voor de bargraph
  935: 1  0242	E8		              mov    a,r0           ;neem maximum aantal bar's
  936: 1  0243	C0 F0		              push   b              ;bewaar startadres
  937: 1  0245	75 F0 05	              mov    b,#5           ;max aantal bar's/ aantal bars per blokje
  938: 1  0248	84		              div    ab             ;bereken dus het aantal nodige blokjes
  939: 1  0249	F8		              mov    r0,a           ;initaliseer hiermee de karaktercounter
  940: 1  024A	E5 F0		              mov    a,b            ;neem restbars
  941: 1  024C	60 01		              jz     barlcd_1       ;als nul dan verder
  942: 1  024E	08		              inc    r0             ;als rest niet nul,an 1 char meer nemen
  943: 1  024F	D0 E0		barlcd_1:     pop    acc            ;startadres terugnemen in ACCU
  944: 1  0251	44 80		              orl    a,#10000000b   ;maak er een set DDRAM address commando van

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 15



 Line  I  Addr  Code            Source

  945: 1  0253	12 00 89	              lcall  outcharlcd     ;plaats de cursor op het gevraagde adres
  946: 1			;We berekenen het aantal volle 5x8 blokjes en eventueel de rest
  947: 1  0256	74 13		              mov    a,#13h         ;cursor off
  948: 1  0258	12 00 89	              lcall  outcharlcd     ;stuur naar LCD
  949: 1  025B	D0 F0		              pop    b              ;aantal af te drukken bar's terugnemen
  950: 1  025D	C0 F0		              push   b              ;en weer bewaren
  951: 1  025F	E5 F0		              mov    a,b            ;bereken aantal volle blokjes, en de rest
  952: 1  0261	60 1C		              jz     barlcd3        ;als gevraagde aantal bar's nul is: wissen
  953: 1  0263	75 F0 05	              mov    b,#5           ;5 bars per karakter= maximum
  954: 1  0266	84		              div    ab             ;A=aantal volle blokjes, B=rest
  955: 1  0267	C0 F0		              push   b              ;bewaar rest
  956: 1  0269	60 0B		              jz     barlcd2        ;geen volle blokjes: dan rest afdrukken
  957: 1  026B	F5 F0		              mov    b,a            ;blokjescounter=aantal volle blokjes
  958: 1
  959: 1			;Druk de volle 5x8 blokjes af van de bargraph
  960: 1  026D	74 04		              mov    a,#4           ;neem code voor vol blokje
  961: 1  026F	12 01 5D	barlcd1:      lcall  outd           ;stuur vol blokje naar het scherm
  962: 1  0272	18		              dec    r0             ;verminder karaktersteller
  963: 1  0273	D5 F0 F9	              djnz   b,barlcd1      ;doe dit voor aantal=blokjescounter
  964: 1
  965: 1			;Druk het onvolledige blokje (rest) af
  966: 1  0276	D0 E0		barlcd2:      pop    acc            ;haal rest weer op
  967: 1  0278	60 05		              jz     barlcd3        ;is de rest nul, dan gedaan
  968: 1  027A	14		              dec    a              ;converteer rest naar code voor de
  969: 1			                                    ;overeenkomende bar's
  970: 1  027B	12 01 5D	              lcall  outd           ;druk resterende bar's af
  971: 1  027E	18		              dec    r0             ;verminder karakterteller
  972: 1
  973: 1			;Test of we aan het einde van de bargraph zitten..
  974: 1  027F	B8 00 02	barlcd3:      cjne   r0,#0,barlcd4  ;karakterteller niet nul: spaces afdrukken
  975: 1  0282	80 08		              sjmp   barlcde        ;als de karakterteller nul is, dan klaar!
  976: 1
  977: 1			;Spaties afdrukken tot einde bargraph om vorige bargraph te overschrijven!
  978: 1  0284	74 20		barlcd4:      mov    a,#' '         ;neem spatie
  979: 1  0286	12 01 5D	              lcall  outd           ;en druk af
  980: 1  0289	18		              dec    r0             ;karakterteller verminderen
  981: 1  028A	80 F3		              sjmp   barlcd3        ;druk spaties af tot einde bargraph
  982: 1
  983: 1  028C	D0 F0		barlcde:      pop    b              ;haal aantal afgedrukte bar's weer
  984: 1  028E	D0 D0		              pop    psw            ;haal status weer
  985: 1  0290	D0 E0		              pop    acc            ;haal startlocatie weer
  986: 1  0292	D0 82		              pop    dpl
  987: 1  0294	A8 82		              mov    r0,dpl
  988: 1  0296	D0 82		              pop    dpl
  989: 1  0298	22		              ret
  990: 1
  991: 1
  992: 1
  993: 1			;******************************************************************************
  994: 1			; barchars
  995: 1			; Dit zijn de 5 char's die nodig zijn voor de routine barlcd die een
  996: 1			; bargraph vormt op het LCD scherm. Deze char's moeten eerst door de gebruiker
  997: 1			; via de build routine in de CGRAM van de LCD module worden geplaatst, en
  998: 1			; kunnen pas daarna worden gebruikt.
  999: 1			; Indien de gebruiker zelf nog andere speciale char's nodig heeft, kunnen deze
 1000: 1			; achter deze 5 char's worden geplaatst via de build_adr routine

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 16



 Line  I  Addr  Code            Source

 1001: 1			; (max. 3 extra char's).
 1002: 1			; De gebruiker moet er op letten dat de laatste byte van de laatste char wordt
 1003: 1			; opgeslagen met MSB=1.
 1004: 1			;******************************************************************************
 1005: 1
 1006: 1  0299	10		barchars:     db 00010000b    ;1 vertikale bar links in pixelruimte 5x8
 1007: 1  029A	10		              db 00010000b
 1008: 1  029B	10		              db 00010000b
 1009: 1  029C	10		              db 00010000b
 1010: 1  029D	10		              db 00010000b
 1011: 1  029E	10		              db 00010000b
 1012: 1  029F	10		              db 00010000b
 1013: 1  02A0	10		              db 00010000b
 1014: 1
 1015: 1  02A1	18		              db 00011000b    ;2 vertikale bars links in pixelruimte 5x8
 1016: 1  02A2	18		              db 00011000b
 1017: 1  02A3	18		              db 00011000b
 1018: 1  02A4	18		              db 00011000b
 1019: 1  02A5	18		              db 00011000b
 1020: 1  02A6	18		              db 00011000b
 1021: 1  02A7	18		              db 00011000b
 1022: 1  02A8	18		              db 00011000b
 1023: 1
 1024: 1  02A9	1C		              db 00011100b    ;3 vertikale bars links in pixelruimte 5x8
 1025: 1  02AA	1C		              db 00011100b
 1026: 1  02AB	1C		              db 00011100b
 1027: 1  02AC	1C		              db 00011100b
 1028: 1  02AD	1C		              db 00011100b
 1029: 1  02AE	1C		              db 00011100b
 1030: 1  02AF	1C		              db 00011100b
 1031: 1  02B0	1C		              db 00011100b
 1032: 1
 1033: 1  02B1	1E		              db 00011110b    ;4 vertikale bars links in pixelruimte 5x8
 1034: 1  02B2	1E		              db 00011110b
 1035: 1  02B3	1E		              db 00011110b
 1036: 1  02B4	1E		              db 00011110b
 1037: 1  02B5	1E		              db 00011110b
 1038: 1  02B6	1E		              db 00011110b
 1039: 1  02B7	1E		              db 00011110b
 1040: 1  02B8	1E		              db 00011110b
 1041: 1
 1042: 1  02B9	1F		              db 00011111b    ;volledig zwarte pixelruimte 5x8
 1043: 1  02BA	1F		              db 00011111b
 1044: 1  02BB	1F		              db 00011111b
 1045: 1  02BC	1F		              db 00011111b
 1046: 1  02BD	1F		              db 00011111b
 1047: 1  02BE	1F		              db 00011111b
 1048: 1  02BF	1F		              db 00011111b
 1049: 1  02C0	9F		bareinde:     db 10011111b    ;opgelet dit is de laatste byte, hier is MSB=1!
 1050: 1
 1051: 1			;******************************************************************************
 1052: 1			;
 1053: 1			; build
 1054: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het startadres 00h
 1055: 1			; zal laden met de bitpatronen voor maximaal 8 karakters, die dan daarna
 1056: 1			; overeen komen met de ASCII codes 00h-07h.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 17



 Line  I  Addr  Code            Source

 1057: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1058: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1059: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1060: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1061: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1062: 1			;
 1063: 1			; De routine vernietigt geen registers.
 1064: 1			;
 1065: 1			; Vb.  mov dptr,#eigenkarakter   ; wijs naar de bitmap met eigen karakters
 1066: 1			;      lcall  build              ; en maak ze aan in de CGRAM vanaf positie 0
 1067: 1			;      mov    a,#00h             ; we gaan zelfgemaakte karakter 0 afdrukken
 1068: 1			;      lcall  outcharlcd         ; druk de karakter af
 1069: 1			;
 1070: 1			;eigenkarakter:
 1071: 1			;      db 00001110b
 1072: 1			;      db 00001010b
 1073: 1			;      db 00001110b
 1074: 1			;      db 00000100b
 1075: 1			;      db 00011111b
 1076: 1			;      db 00000100b
 1077: 1			;      db 00001010b
 1078: 1			;      db 10010001b              ;laatste byte van onze enige karakter(msb=1)
 1079: 1			;******************************************************************************
 1080: 1
 1081: 1  02C1	C0 E0		build:        push   acc           ;bewaar de gebruikte registers
 1082: 1  02C3	C0 D0		              push   psw
 1083: 1  02C5	74 40		              mov     a,#CGRAM     ;Zet adres van de CGRAM op 0
 1084: 1  02C7	12 02 CF	              lcall  build_adr
 1085: 1  02CA	D0 D0		              pop    psw
 1086: 1  02CC	D0 E0		              pop    acc
 1087: 1  02CE	22		              ret                  ;terug
 1088: 1
 1089: 1			;******************************************************************************
 1090: 1			; build_adr
 1091: 1			; Is een routine die de karaktergenerator RAM (CGRAM) vanaf het adres aan-
 1092: 1			; gegeven in de ACCU zal laden met de bitpatronen voor maximaal 8 karakters,
 1093: 1			; die overeen komen met de ASCII codes 00h-07h.
 1094: 1			; De routine gebruikt een door de gebruiker aangemaakte bitmap op het adres
 1095: 1			; aangegeven in DPTR. Deze bitmap wordt afgesloten door in de laatste byte van
 1096: 1			; de laatste aan te maken karakter bit7 op  1 te zetten.
 1097: 1			; Na het schrijven van de bitmap in CGRAM wordt terug de data display RAM
 1098: 1			; (DDRAM) geselecteerd en ingesteld op adres 00H
 1099: 1			;
 1100: 1			; De routine vernietigt geen registers.
 1101: 1			;
 1102: 1			; Vb.  mov  a,#05h              ; maak userchar op de zesde locatie in CGRAM
 1103: 1			;      mov dptr,#eigenkarakters ; wijs naar de bitmap met eigen karakters
 1104: 1			;      lcall  build_adr         ; en maak ze aan in de CGRAM vanaf positie 05h
 1105: 1			;      mov    a,#05h            ; we gaan zelfgemaakte karakter 5 afdrukken
 1106: 1			;      lcall  outcharlcd        ; druk de karakter af
 1107: 1			;
 1108: 1			;eigenkarakters:
 1109: 1			;      db 00001110b
 1110: 1			;      db 00001010b
 1111: 1			;      db 00001110b
 1112: 1			;       db 00000100b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 18



 Line  I  Addr  Code            Source

 1113: 1			;      db 00011111b
 1114: 1			;      db 00000100b
 1115: 1			;      db 00001010b
 1116: 1			;      db 10010001b             ;de laatste byte van onze enige karakter
 1117: 1			;******************************************************************************
 1118: 1  02CF	C0 E0		build_adr:      push   acc
 1119: 1  02D1	C0 D0		              push   psw
 1120: 1  02D3	C0 83		              push   dph
 1121: 1  02D5	C0 82		              push   dpl
 1122: 1  02D7	44 40		              orl    a,#01000000b  ;maak er een adrescommando van
 1123: 1  02D9	12 01 97	build1:       lcall  outc          ;NAAR SCHERM VERSTUREN
 1124: 1  02DC	74 00		build3:       mov    a,#000h       ;ACCU OP NUL ZETTEN
 1125: 1  02DE	93		              movc   a,@a+dptr     ;EERSTE CODE UIT TABEL LEZEN
 1126: 1  02DF	12 01 5D	              lcall  outd          ;NAAR KARAKTER GENERATOR RAM STUREN
 1127: 1  02E2	20 E7 03	              jb     acc.7,build2  ;ALS BIT 1 DAN EINDE
 1128: 1  02E5	A3		              inc    dptr          ;NAAR VOLGENDE LOKATIE WIJZEN
 1129: 1  02E6	80 F4		              sjmp   build3
 1130: 1  02E8	74 80		build2:       mov    a,#DDRAM      ;zet adres DATA DISPLAY RAM op 0
 1131: 1  02EA	12 01 97	              lcall  outc          ;NAAR KONTROLE REGISTER STUREN
 1132: 1  02ED	D0 82		              pop    dpl
 1133: 1  02EF	D0 83		              pop    dph
 1134: 1  02F1	D0 D0		              pop    psw
 1135: 1  02F3	D0 E0		              pop    acc
 1136: 1  02F5	22		              ret
 1137: 1
 1138: 1			;******************************************************************************
 1139: 1			;
 1140: 1			; delay2ms
 1141: 1			; Is een vertragingsroutine van 2ms.
 1142: 1			;
 1143: 1			; De routine vernietigt geen registers.
 1144: 1			;
 1145: 1			;******************************************************************************
 1146: 1
 1147: 1  02F6	C0 E0		delay2ms:     push   acc           ;registers op de stack zetten
 1148: 1  02F8	C0 D0		              push   psw
 1149: 1  02FA	74 20		              mov    a,#032d       ;aantal keer 60us wachten
 1150: 1  02FC	12 03 07	delay2ms1:    lcall  delay60us
 1151: 1  02FF	D5 E0 FA	              djnz   acc,delay2ms1
 1152: 1  0302	D0 D0		              pop    psw           ;registers herstellen
 1153: 1  0304	D0 E0		              pop    acc
 1154: 1  0306	22		              ret
 1155: 1
 1156: 1			;******************************************************************************
 1157: 1			;
 1158: 1			; delay60us.
 1159: 1			; Deze routine genereert een delay van 60us als vertraging in de LCD driver.
 1160: 1			; De tijdsvertraging klopt bij de hoogste kloksnelheid van de
 1161: 1			; controller. Bij de traagste snelheid wordt de routine overgeslagen.
 1162: 1			;
 1163: 1			; de routine vernietigt geen registers.
 1164: 1			;
 1165: 1			;******************************************************************************
 1166: 1
 1167: 1  0307	C0 E0		delay60us:    push   acc           ;registers op de stack plaatsen
 1168: 1  0309	C0 D0		              push   psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 19



 Line  I  Addr  Code            Source

 1169: 1  030B	E5 D7		              mov    a,pllcon      ;pllcon inlezen
 1170: 1  030D	54 07		              anl    a,#00000111b  ;beduidende bits overhouden
 1171: 1
 1172: 1			; Hoe kleiner de waarde in de pllcon, hoe sneller de controller loopt.
 1173: 1			; door wat bitbangen maken we er een bruikbare waarde van.
 1174: 1
 1175: 1  030F	B4 6F 05	              cjne   a,#00000111,delay60us2  ;als traagste snelheid stoppen
 1176: 1  0312	D0 E0		              pop    acc           ;registers herstellen
 1177: 1  0314	D0 D0		              pop    psw
 1178: 1  0316	22		              ret
 1179: 1
 1180: 1  0317	74 19		delay60us2:   mov    a,#25d        ;loopcounter laden
 1181: 1  0319	D5 E0 FD	delay60us1:   djnz   acc,delay60us1 ;telkens twee cycles tijd verliezen
 1182: 1  031C	D0 D0		              pop    psw
 1183: 1  031E	D0 E0		              pop    acc
 1184: 1  0320	22		              ret
 1185: 1
 1186: 1			endif        ;einde van aduc_lcd
 1187: 1
 1188: 1
 1189: 1
 1190: 1
 1191: 1			ifdef aduc_i2c
 1192: 1			;******************************************************************************
 1193: 1			;
 1194: 1			; Dit is een I2C driver voor een ADuC8xx microcontroller.
 1195: 1			; De driver bevat alle routines om de ADuC als single master te gebruiken.
 1196: 1			; Als I/O worden de specifieke I2C pinnen sdata en sclock gebruikt.
 1197: 1			;
 1198: 1			; Door de hardwarematige beperking dat de fysische pinnen van de sclock-
 1199: 1			; en sdatalijn niet kunnen gelezen worden als ze als output worden gebruikt
 1200: 1			; is multimaster werking met arbittrage en clockstretching niet mogelijk.
 1201: 1			;
 1202: 1			; Origineel geschreven door Roggemans Marc (MGM) op 03/2005 v0
 1203: 1			; Toevoegingen van high level routines door [dp] op 01/2014
 1204: 1			;
 1205: 1			; Beschikbare routines:
 1206: 1			; i2cinit      :klaar zetten van de i2c bus voor gebruik
 1207: 1			; i2cstart     :verzenden van een start conditie
 1208: 1			; i2cstop      :verzenden van een stop conditie
 1209: 1			; i2coutbyte   :verzenden van 1 byte vanuit de accu, er wordt een negende klok
 1210: 1			;               verzonden, in de carry wordt de ack van de slave weergegeven
 1211: 1			; i2cinbyteack :leest een byte van de i2c bus en genereert een ack op de
 1212: 1			;               negende klokpuls
 1213: 1			; i2cinbytenack :leest een byte van de i2c bus en genereert een nack op de
 1214: 1			;               negende klokpuls
 1215: 1			;
 1216: 1			; Toevoeging [dp]
 1217: 1			; i2csenddata  :adresseert en stuurt de inhoud van een geheugenbuffer naar
 1218: 1			;               een slavedevice
 1219: 1			; i2crcvdata   :adresseert en ontvangt één of meerdere databytes van een slave
 1220: 1			;               en plaatst deze in een geheugenbuffer
 1221: 1			;******************************************************************************
 1222: 1	N      0040	i2cpcf8574		equ		01000000b		;port expander basisadres gewone ver
       1			sie
 1223: 1	N      0070	i2cpcf8574A		equ		01110000b		;port expander basisadres A versie

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 20



 Line  I  Addr  Code            Source

 1224: 1			;pcf8574		set		1				;bij gewone portexpander met
       1			 adres 40h
 1225: 1	N      0001	pcf8574A		set		1				;bij A versie portexpander m
       1			et adres 70h
 1226: 1
 1227: 1			;******************************************************************************
 1228: 1			; i2cinit
 1229: 1			; Dit is een subroutine die de i2c bus van de ADuC als master instelt
 1230: 1			;******************************************************************************
 1231: 1  0321	D2 EF		i2cinit:        setb    mdo             ;data moet hoog wakker worden
 1232: 1  0323	D2 ED		                setb    mco             ;klok moet hoog wakker worden
 1233: 1  0325	D2 EE		                setb    mde             ;data wordt als output geschakeld
 1234: 1  0327	D2 EB		                setb    i2cm            ;master mode inschakelen
 1235: 1  0329	22		                ret
 1236: 1			;******************************************************************************
 1237: 1			; i2cstart
 1238: 1			; Dit is een subroutine die de start conditie op de pinnen plaatst
 1239: 1			;******************************************************************************
 1240: 1  032A	D2 ED		i2cstart:       setb    mco             ;zeker zijn dat de klok hoog is
 1241: 1  032C	C2 EF		                clr     mdo             ;data moet laag worden
 1242: 1  032E	D2 EE		                setb    mde             ;data pin enable
 1243: 1  0330	C2 ED		                clr     mco             ;klok laag maken
 1244: 1  0332	22		                ret
 1245: 1			;******************************************************************************
 1246: 1			; i2cstop
 1247: 1			; Dit is een subroutine die de stop conditie opwekt.
 1248: 1			;******************************************************************************
 1249: 1  0333	C2 EF		i2cstop:        clr     mdo             ;data moet laag worden
 1250: 1  0335	D2 EE		                setb    mde             ;data mag naar buiten
 1251: 1  0337	D2 ED		                setb    mco             ;nu moet de klok omhoog
 1252: 1  0339	D2 EF		                setb    mdo             ;nu data pin hoog maken
 1253: 1  033B	22		                ret
 1254: 1
 1255: 1			;******************************************************************************
 1256: 1			; i2coutbyte
 1257: 1			; Deze routine stuurt één databyte (MSbit eerst) naar een I2C slave device.
 1258: 1			; De routine vernietigt geen registers.
 1259: 1			; input : De te versturen byte wordt doorgegeven in ACCU
 1260: 1			; output: De carry zal de waarde van de ack bit bevatten na het
 1261: 1			;         uitvoeren van de routine.
 1262: 1			;******************************************************************************
 1263: 1  033C	C0 E0		i2coutbyte:     push    acc             ;worden effe op stack bewaard
 1264: 1  033E	C0 F0		                push    b
 1265: 1  0340	75 F0 08	                mov     b,#008h         ;loopcounter
 1266: 1  0343	33		i2coutbyte1:    rlc     a               ;bit in de carry plaatsen
 1267: 1  0344	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1268: 1  0346	D2 EE		                setb    mde             ;pin als output activeren
 1269: 1  0348	D2 ED		                setb    mco             ;klokpukls hoog
 1270: 1  034A	C2 ED		                clr     mco             ;klokpuls laag
 1271: 1  034C	D5 F0 F4	                djnz    b,i2coutbyte1   ;volledige byte verzenden
 1272: 1  034F	C2 EE		                clr     mde             ;iic data pin als input schakelen
 1273: 1  0351	D2 ED		                setb    mco             ;klokpuls hoog
 1274: 1  0353	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1275: 1  0355	C2 ED		                clr     mco             ;klokpuls terug laag
 1276: 1  0357	D0 F0		                pop     b
 1277: 1  0359	D0 E0		                pop     acc             ;registers herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 21



 Line  I  Addr  Code            Source

 1278: 1  035B	22		                ret
 1279: 1
 1280: 1			;******************************************************************************
 1281: 1			; i2cinbyteack
 1282: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1283: 1			; De routine vernietigt geen registers. De routine zal als
 1284: 1			; negende bit een ack verzenden.
 1285: 1			;******************************************************************************
 1286: 1  035C	C0 F0		i2cinbyteack:   push    b               ;deze registers worden gebruikt
 1287: 1  035E	C0 D0		                push    psw
 1288: 1  0360	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1289: 1  0363	C2 EE		i2cinbytea1:    clr     mde             ;iic data pin als input schakelen
 1290: 1  0365	D2 ED		                setb    mco             ;klokpuls hoog
 1291: 1  0367	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1292: 1  0369	C2 ED		                clr     mco             ;klokpuls terug laag
 1293: 1  036B	33		                rlc     a               ;in accu shiften
 1294: 1  036C	D5 F0 F4	                djnz    b,i2cinbytea1   ;volledige byte ontvangen
 1295: 1  036F	C3		                clr     c               ;ack verzenden
 1296: 1  0370	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1297: 1  0372	D2 EE		                setb    mde             ;pin als output activeren
 1298: 1  0374	D2 ED		                setb    mco             ;klokpukls hoog
 1299: 1  0376	C2 ED		                clr     mco             ;klokpuls laag
 1300: 1  0378	D0 D0		                pop     psw             ;registers herstellen
 1301: 1  037A	D0 F0		                pop     b
 1302: 1  037C	22		                ret
 1303: 1
 1304: 1			;******************************************************************************
 1305: 1			; i2cinbytenack
 1306: 1			; Deze routine zal in de accu een byte inlezen, msb eerst.
 1307: 1			; De routine vernietigt geen registers. De routine zal als
 1308: 1			; negende bit een nack verzenden.
 1309: 1			;******************************************************************************
 1310: 1  037D	C0 F0		i2cinbytenack:  push    b               ;deze registers worden gebruikt
 1311: 1  037F	C0 D0		                push    psw
 1312: 1  0381	75 F0 08	                mov     b,#008h         ;wordt gebruikt als loopcounter
 1313: 1  0384	C2 EE		i2cinbyten1:    clr     mde             ;iic data pin als input schakelen
 1314: 1  0386	D2 ED		                setb    mco             ;klokpuls hoog
 1315: 1  0388	A2 EC		                mov     c,mdi           ;data inlezen in de carry
 1316: 1  038A	C2 ED		                clr     mco             ;klokpuls terug laag
 1317: 1  038C	33		                rlc     a               ;in accu shiften
 1318: 1  038D	D5 F0 F4	                djnz    b,i2cinbyten1   ;volledige byte ontvangen
 1319: 1  0390	D3		                setb    c               ;nack verzenden
 1320: 1  0391	92 EF		                mov     mdo,c           ;carry naar de mdo pin
 1321: 1  0393	D2 EE		                setb    mde             ;pin als output activeren
 1322: 1  0395	D2 ED		                setb    mco             ;klokpukls hoog
 1323: 1  0397	C2 ED		                clr     mco             ;klokpuls laag
 1324: 1  0399	D0 D0		                pop     psw             ;registers herstellen
 1325: 1  039B	D0 F0		                pop     b
 1326: 1  039D	22		                ret
 1327: 1
 1328: 1			;******************************************************************************
 1329: 1			; i2csenddata
 1330: 1			; Adresseert en stuurt één of meerdere bytes over de I2C bus naar een
 1331: 1			; slave device op de bus. Het 7 bit slave-adres, met de Write aanduiding "0"
 1332: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1333: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 22



 Line  I  Addr  Code            Source

 1334: 1			; zijn met de write aanduiding '0'. Er worden hier maar twee nuttige adresbits
 1335: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1336: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1337: 1			;
 1338: 1			; Het te versturen datablok moet in inwendig geheugen staan en R0 is een
 1339: 1			; pointer naar deze data.  .
 1340: 1
 1341: 1			; Via B wordt aangegeven hoeveel bytes moeten worden verzonden uit het datablok
 1342: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Write (bit=0)
 1343: 1			;         B       = aantal te versturen bytes (minimum 1)
 1344: 1			;         R0      = startadres van te versturen datablok
 1345: 1			;
 1346: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de verstuurde data
 1347: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave wordt de Cy bit
 1348: 1			;               geset bij return. R0 wijst in dit geval naar de laatste
 1349: 1			;               verzonden byte waarvoor er geen ack kwam.
 1350: 1			;
 1351: 1			; Deze routine vernietigt niets...
 1352: 1			;******************************************************************************
 1353: 1  039E	C0 E0		i2csenddata:        push   acc           ;registers bewaren
 1354: 1  03A0	C0 D0		                    push   psw
 1355: 1  03A2	E8		                    mov    a,r0
 1356: 1  03A3	C0 E0		                    push   acc           ;r0 op stack
 1357: 1
 1358: 1  03A5	12 03 2A	                    lcall  i2cstart      ;genereer startconditie
 1359: 1  03A8	E5 83		                    mov    a,dph         ;neem adresbyte
 1360: 1  03AA	12 03 3C	                    lcall  i2coutbyte    ;en verstuur naar slave
 1361: 1  03AD	40 24		                    jc     i2csenderror  ;indien geen ack, fout!
 1362: 1  03AF	E5 83		                    mov    a,dph         ;7bit of 10bit adresbyte
 1363: 1  03B1	54 F9		                    anl    a,#11111001b  ;maskeer de adresbits bij 10bit
 1364: 1  03B3	B4 F0 07	                    cjne   a,#0f0h,i2csenddata1 ;10 bit adressering?(11110xx0)
 1365: 1			;10 bit adressering!
 1366: 1  03B6	E5 82		                    mov    a,dpl         ;neem low byte van het 10bit adres
 1367: 1  03B8	12 03 3C	                    lcall  i2coutbyte    ;en verstuur naar slave
 1368: 1  03BB	40 16		                    jc     i2csenderror  ;indien geen ack, fout!
 1369: 1			;7 bit adressering!
 1370: 1  03BD	E6		i2csenddata1:       mov    a,@r0         ;haal databyte uit geheugenbuffer
 1371: 1  03BE	12 03 3C	                    lcall  i2coutbyte    ;en verstuur naar slave
 1372: 1  03C1	40 10		                    jc     i2csenderror  ;indien geen ack, fout!
 1373: 1  03C3	08		                    inc    r0            ;volgende byte
 1374: 1  03C4	D5 F0 F6	                    djnz   b,i2csenddata1 ;zijn alle bytes verzonden?
 1375: 1  03C7	12 03 33	                    lcall  i2cstop        ;klaar, stuur een stop conditie
 1376: 1  03CA	D0 E0		                    pop    acc
 1377: 1  03CC	F8		                    mov    r0,a          ;r0 wijst naar start van data
 1378: 1  03CD	D0 D0		                    pop    psw
 1379: 1  03CF	C3		                    clr    c             ;alles is ok!
 1380: 1  03D0	D0 E0		                    pop    acc
 1381: 1  03D2	22		                    ret
 1382: 1			;fout: geen ack gekregen bij het versturen van het adres of data
 1383: 1  03D3	12 03 33	i2csenderror:       lcall  i2cstop      ;stopconditie genereren
 1384: 1  03D6	D0 E0		                    pop    acc          ;dummy, r0 niet herstellen
 1385: 1  03D8	D0 D0		                    pop    psw
 1386: 1  03DA	D3		                    setb   c            ;terug met foutmelding
 1387: 1  03DB	D0 E0		                    pop    acc
 1388: 1  03DD	22		                    ret
 1389: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 23



 Line  I  Addr  Code            Source

 1390: 1			;******************************************************************************
 1391: 1			; i2crcvdata
 1392: 1			; Adresseert en ontvangt één of meerdere bytes over de I2C bus van een
 1393: 1			; slave device op de bus. Het 7 bit slave-adres, met de Read aanduiding "1"
 1394: 1			; op bitpositie 0 wordt doorgegeven via dph. Bij 10 bit adressering (indien het
 1395: 1			; aan te spreken I2C device dit vereist) zal het 7 bit adres in dph '11110xx'
 1396: 1			; zijn met de Read aanduiding '1'. Er worden hier maar twee nuttige adresbits
 1397: 1			; doorgegeven. De volgende 8 bits (LSB) van het 10bit adres moeten in dit geval
 1398: 1			; worden doorgegeven via dpl. Bij 7 bit adressering wordt dpl niet gebruikt.
 1399: 1			;
 1400: 1			; Het te ontvangen datablok zal in inwendig geheugen geplaatst worden en R0
 1401: 1			; is een pointer naar de start van dit ontvangen datablok.
 1402: 1			;
 1403: 1			; Via B wordt aangegeven hoeveel bytes moeten worden ontvangen
 1404: 1			; input : dph,dpl = slave adres, 7bits (dph) of 10bits (+dpl) met Read (bit=1)
 1405: 1			;         B       = aantal te ontvangen bytes (minimum 1)
 1406: 1			;         R0      = startadres waar de ontvangen data wordt opgeslagen
 1407: 1			;
 1408: 1			; output: cy=0 :Verzenden is ok en R0 = startadres van de ontvangen data
 1409: 1			;         cy=1 :Wanneer er geen ack bit komt van de slave bij het versturen van
 1410: 1			;               het adres, wordt de CY bit geset bij return.
 1411: 1			;               R0 = startadres van de buffer voor de te ontvangen data
 1412: 1			;
 1413: 1			; Deze routine vernietigt verder niets...
 1414: 1			;******************************************************************************
 1415: 1  03DE	C0 E0		i2crcvdata:         push    acc             ;registers op stack
 1416: 1  03E0	C0 D0		                    push    psw
 1417: 1  03E2	E8		                    mov     a,r0            ;r0 op stack
 1418: 1  03E3	C0 E0		                    push    acc
 1419: 1
 1420: 1  03E5	12 03 2A	                    lcall   i2cstart        ;genereer startconditie
 1421: 1  03E8	E5 83		                    mov     a,dph           ;neem adresbyte
 1422: 1  03EA	12 03 3C	                    lcall   i2coutbyte      ;en verstuur naar slave
 1423: 1  03ED	40 2A		                    jc      i2crcverror     ;indien geen ack, fout!
 1424: 1  03EF	E5 83		                    mov     a,dph           ;7bit of 10bit adresbyte
 1425: 1  03F1	54 F9		                    anl     a,#11111001b    ;maskeer de adresbits bij 10bit
 1426: 1  03F3	B4 F1 07	                    cjne    a,#0f1h,i2crcvdata1 ;10 bit adressering?(11110xx1)
 1427: 1			;10 bit adressering!
 1428: 1  03F6	E5 82		                    mov     a,dpl           ;neem low byte van het 10bit adres
 1429: 1  03F8	12 03 3C	                    lcall   i2coutbyte      ;en verstuur naar slave
 1430: 1  03FB	40 1C		                    jc      i2crcverror     ;indien geen ack, fout!
 1431: 1			;7 bit adressering!
 1432: 1
 1433: 1  03FD	D5 F0 06	i2crcvdata1:        djnz    b,i2crcvdata2   ;niet nul, byte lezen met ack!
 1434: 1  0400	12 03 7D	                    lcall   i2cinbytenack   ;de laatste byte lezen met nack!
 1435: 1  0403	F6		                    mov     @r0,a           ;en deze ook bewaren
 1436: 1  0404	80 07		                    sjmp    i2crcvdata3
 1437: 1  0406	12 03 5C	i2crcvdata2:        lcall   i2cinbyteack    ;lees byte van slave en geef ack
 1438: 1  0409	F6		                    mov     @r0,a           ;bewaar de data in buffer
 1439: 1  040A	08		                    inc     r0              ;pointer verhogen
 1440: 1  040B	80 F0		                    sjmp    i2crcvdata1      ;volgende byte ontvangen
 1441: 1
 1442: 1  040D	12 03 33	i2crcvdata3:        lcall   i2cstop         ;klaar, stuur een stopconditie
 1443: 1  0410	D0 E0		                    pop     acc
 1444: 1  0412	F8		                    mov     r0,a            ;r0 wijst naar start van data
 1445: 1  0413	D0 D0		                    pop     psw

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 24



 Line  I  Addr  Code            Source

 1446: 1  0415	C3		                    clr     c               ;alles is ok!
 1447: 1  0416	D0 E0		                    pop     acc
 1448: 1  0418	22		                    ret
 1449: 1			;fout: geen ack gekregen bij het versturen van het adres
 1450: 1  0419	12 03 33	i2crcverror:        lcall    i2cstop        ;stopconditie genereren
 1451: 1  041C	D0 E0		                    pop        acc          ;dummy,r0 is nog niet veranderd
 1452: 1  041E	D0 D0		                    pop        psw
 1453: 1  0420	D3		                    setb    c               ;terug met foutmelding
 1454: 1  0421	D0 E0		                    pop        acc
 1455: 1  0423	22		                    ret
 1456: 1
 1457: 1
 1458: 1			;******************************************************************************
 1459: 1			;
 1460: 1			; porttolcd
 1461: 1			; Dit is een subroutine die de inhoud van het b register naar het lcd
 1462: 1			; scherm stuurt via de port expander.
 1463: 1			;
 1464: 1			; Gebruikt geen registers
 1465: 1			;
 1466: 1			;******************************************************************************
 1467: 1
 1468: 1  0424	C0 E0		porttolcd:    push   acc           ;geen registers gebruiken
 1469: 1  0426	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1470: 1  0428	12 03 2A	              lcall  i2cstart      ;vertrokken
 1471: 1			ifdef    pcf8574
 1472: 1			              mov    a,#01000000b  ;schrijven naar expander
 1473: 1			endif
 1474: 1			ifdef    pcf8574A
 1475: 1  042B	74 70		              mov    a,#01110000b  ;schrijven naar expander
 1476: 1			endif
 1477: 1  042D	12 03 3C	              lcall  i2coutbyte    ;weg er mee
 1478: 1  0430	E5 F0		              mov    a,b           ;data verzenden
 1479: 1  0432	12 03 3C	              lcall  i2coutbyte
 1480: 1  0435	12 03 33	              lcall  i2cstop       ;transactie sluiten
 1481: 1  0438	D0 D0		              pop    psw
 1482: 1  043A	D0 E0		              pop    acc
 1483: 1  043C	22		              ret
 1484: 1
 1485: 1			;******************************************************************************
 1486: 1			;
 1487: 1			; lcdtoport
 1488: 1			; Dit is een routine die de waarde van de expander uitleest naar het b register
 1489: 1			; Op die manier kunnen we onthouden wat de waarde van de LCD pinnen is voor het
 1490: 1			; aansturen van de buzzer en backlight.
 1491: 1			;
 1492: 1			; output: b register
 1493: 1			;
 1494: 1			;******************************************************************************
 1495: 1
 1496: 1  043D	C0 E0		lcdtoport:    push   acc           ;geen registers gebruiken
 1497: 1  043F	C0 D0		              push   psw           ;trekken ons niks aan van ack bit
 1498: 1  0441	12 03 2A	              lcall  i2cstart      ;vertrokken
 1499: 1			ifdef    pcf8574
 1500: 1			              mov    a,#01000000b  ;schrijven naar expander
 1501: 1			endif

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 25



 Line  I  Addr  Code            Source

 1502: 1			ifdef    pcf8574A
 1503: 1  0444	74 71		              mov    a,#01110001b  ;schrijven naar expander
 1504: 1			endif
 1505: 1  0446	12 03 3C	              lcall  i2coutbyte    ;weg er mee
 1506: 1  0449	12 03 7D	              lcall  i2cinbytenack ;data inlezen
 1507: 1  044C	12 03 33	              lcall  i2cstop
 1508: 1  044F	F5 F0		              mov    b,a
 1509: 1  0451	D0 D0		              pop    psw
 1510: 1  0453	D0 E0		              pop    acc
 1511: 1  0455	22		              ret
 1512: 1
 1513: 1			;******************************************************************************
 1514: 1			;
 1515: 1			; lcdlighton
 1516: 1			; Dit is een subroutine die de backlight inschakeld
 1517: 1			;
 1518: 1			; Gebruikt geen registers
 1519: 1			;
 1520: 1			;******************************************************************************
 1521: 1
 1522: 1  0456	C0 F0		lcdlighton:   push   b
 1523: 1  0458	12 04 3D	              lcall  lcdtoport     ;expander lezen
 1524: 1  045B	C2 F6		              clr    b.6           ;licht aan doen
 1525: 1  045D	12 04 24	              lcall  porttolcd     ;expander schrijven
 1526: 1  0460	D0 F0		              pop    b
 1527: 1  0462	22		              ret
 1528: 1
 1529: 1
 1530: 1			;******************************************************************************
 1531: 1			;
 1532: 1			; lcdlightoff
 1533: 1			; Dit is een subroutine die de backlight uitschakeld
 1534: 1			;
 1535: 1			; Gebruikt geen registers
 1536: 1			;
 1537: 1			;******************************************************************************
 1538: 1
 1539: 1  0463	C0 F0		lcdlightoff:  push   b
 1540: 1  0465	12 04 3D	              lcall  lcdtoport     ;expander lezen
 1541: 1  0468	D2 F6		              setb   b.6           ;licht uit doen
 1542: 1  046A	12 04 24	              lcall  porttolcd     ;expander schrijven
 1543: 1  046D	D0 F0		              pop    b
 1544: 1  046F	22		              ret
 1545: 1
 1546: 1			;******************************************************************************
 1547: 1			;
 1548: 1			; lcdbuzon
 1549: 1			; Dit is een subroutine die de buzzer inschakeld
 1550: 1			;
 1551: 1			; Gebruikt geen registers
 1552: 1			;
 1553: 1			;******************************************************************************
 1554: 1
 1555: 1  0470	C0 F0		lcdbuzon:     push   b
 1556: 1  0472	12 04 3D	              lcall  lcdtoport     ;expander lezen
 1557: 1  0475	C2 F7		              clr    b.7           ;buzzer aan doen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 26



 Line  I  Addr  Code            Source

 1558: 1  0477	12 04 24	              lcall  porttolcd     ;expander schrijven
 1559: 1  047A	D0 F0		              pop    b
 1560: 1  047C	22		              ret
 1561: 1
 1562: 1			;******************************************************************************
 1563: 1			;
 1564: 1			; lcdbuzoff
 1565: 1			; Dit is een subroutine die de buzzer uitschakeld
 1566: 1			;
 1567: 1			; Gebruikt geen registers
 1568: 1			;
 1569: 1			;******************************************************************************
 1570: 1
 1571: 1  047D	C0 F0		lcdbuzoff:    push   b
 1572: 1  047F	12 04 3D	              lcall  lcdtoport     ;expander lezen
 1573: 1  0482	D2 F7		              setb   b.7           ;buzzer aan doen
 1574: 1  0484	12 04 24	              lcall  porttolcd     ;expander schrijven
 1575: 1  0487	D0 F0		              pop    b
 1576: 1  0489	22		              ret
 1577: 1
 1578: 1			endif    ;einde aduc_i2c
 1579: 1			;******************************************************************************
 1580: 1
 1581: 1
 1582: 1
 1583: 1			ifdef    aduc_sio    ;driver voor de seriële poort (UART)
 1584: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1585: 1			;
 1586: 1			; ADuCsio.inc
 1587: 1			; Is een include file voor de ADuC832 microcontroller.
 1588: 1			; De file laat toe om de seriele poort te gebruiken en biedt de standaard
 1589: 1			; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
 1590: 1			; De file wordt achteraan in de .asm file ge-included. De belangrijkste
 1591: 1			; afwijking van de standaard routines is de initsio subroutine.
 1592: 1			; Die laat toe om 9600 baud in te stellen, maar zal rekening houden met de PLL
 1593: 1			; waarde. Wil je de initsio routine aanroepen, dan moet de PLL reeds geladen
 1594: 1			; zijn.
 1595: 1			;
 1596: 1			; Geschreven door Roggemans Marc (MGM) op 11/2004 v0
 1597: 1			;
 1598: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1599: 1
 1600: 1	N      0020	blank         equ    020h          ;ascii code voor een blank
 1601: 1	N      0013	xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
 1602: 1	N      000C	ff            equ    00ch          ;ascii code voor nieuw blad
 1603: 1	N      000D	cr            equ    00dh          ;ascii code voor een wagenterugloop
 1604: 1	N      000A	lf            equ    00ah          ;ascii code voor volgende lijn
 1605: 1	N      0008	backsp        equ    008h          ;ascii code voor het bs karakter
 1606: 1	N      0007	beep          equ    007h          ;ascii code voor een beep
 1607: 1
 1608: 1  048A	08 20 08 00	wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
 1609: 1			                                                        ;van het scherm
 1610: 1
 1611: 1	N      0054	strtbuf       equ     054h         ;start adres van de buffer
 1612: 1	N      007F	endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
 1613: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 27



 Line  I  Addr  Code            Source

 1614: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1615: 1			;
 1616: 1			; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
 1617: 1			; De routine maakt gebruik van de pllcon waarde om te bepalen hoe de timer 3
 1618: 1			; als baud rate generator ingesteld moet worden. Indien de instelling niet
 1619: 1			; mogelijk is wordt de carry geset. In het andere geval wordt de carry laag
 1620: 1			; gemaakt. De routine is pedagogisch geschreven en kan dus korter
 1621: 1			;
 1622: 1			; de routine gebruikt de psw
 1623: 1			;
 1624: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1625: 1
 1626: 1  048E	C0 E0		initsio:      push   acc           ;registers op de stack zetten
 1627: 1  0490	E5 D7		              mov    a,pllcon      ;we lezen het pllcon SFR uit
 1628: 1  0492	54 07		              anl    a,#007h       ;alleen de laagste 3 bits tellen
 1629: 1  0494	B4 06 00	              cjne   a,#006h,initsio1   ;005h is maximaal toegelaten
 1630: 1  0497	50 14		initsio1:     jnc    initsioe      ;geen carry dan is waarde in pllcon >=6
 1631: 1
 1632: 1			; de waarde in pllcon is bruikbaar. We gebruiken de waarde om de inhoud van
 1633: 1			; t3con te bepalen. t3fd is altijd 02dh voor 9600 baud.
 1634: 1
 1635: 1  0499	75 9D 2D	              mov    t3fd,#02dh    ;zie databoek t3 als baud rate generator
 1636: 1  049C	F4		              cpl    a             ;bitbangen om laten uit te komen
 1637: 1  049D	C3		              clr    c             ;verder doen
 1638: 1  049E	94 02		              subb   a,#002h       ;laagste 3 bits zijn 0k
 1639: 1  04A0	54 07		              anl    a,#007h       ;hoogste 5 bits op 0
 1640: 1  04A2	24 80		              add    a,#080h       ;nu alles in orde
 1641: 1  04A4	F5 9E		              mov    t3con,a       ;baud rate klaar
 1642: 1  04A6	75 98 50	              mov    scon,#01010000b ;UART initialiseren
 1643: 1  04A9	C3		              clr    c             ;aangeven init ok (overbodige instructie)
 1644: 1  04AA	D0 E0		              pop    acc
 1645: 1  04AC	22		              ret
 1646: 1
 1647: 1  04AD	D3		initsioe:     setb   c             ;aangeven initialisatie niet mogelijk
 1648: 1  04AE	D0 E0		              pop    acc
 1649: 1  04B0	22		              ret
 1650: 1
 1651: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1652: 1			;
 1653: 1			; OUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
 1654: 1			; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
 1655: 1			; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
 1656: 1			;
 1657: 1			; de routine gebruikt geen registers.
 1658: 1			;
 1659: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1660: 1
 1661: 1  04B1	F5 99		OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
 1662: 1  04B3	30 99 FD	OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
 1663: 1  04B6	C2 99		              CLR    TI            ;LAAG MAKEN VAN DE BIT
 1664: 1  04B8	22		              RET
 1665: 1
 1666: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1667: 1			;
 1668: 1			; OUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
 1669: 1			; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 28



 Line  I  Addr  Code            Source

 1670: 1			;
 1671: 1			; de routine gebruikt geen registers.
 1672: 1			;
 1673: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1674: 1
 1675: 1  04B9	C0 E0		OUTNIB:       push   acc           ;registers op de stack
 1676: 1  04BB	C0 D0		              push   psw
 1677: 1  04BD	54 0F		              ANL    A,#00FH       ;AFZONDEREN
 1678: 1  04BF	12 05 CB	              LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
 1679: 1  04C2	12 04 B1	              LCALL  OUTCHAR       ;VERSTUREN
 1680: 1  04C5	12 05 12	              LCALL  XONXOFF       ;FLOW CONTROL
 1681: 1  04C8	D0 D0		              pop    psw           ;registers herstellen
 1682: 1  04CA	D0 E0		              pop    acc
 1683: 1  04CC	22		              RET
 1684: 1
 1685: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1686: 1			;
 1687: 1			; OUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
 1688: 1			; WORDT XONXOFF GEBRUIKT.
 1689: 1			;
 1690: 1			; de routine gebruikt geen registers.
 1691: 1			;
 1692: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1693: 1
 1694: 1  04CD	C0 E0		OUTBYTE:      push   acc           ;registers op de stack zetten
 1695: 1  04CF	C0 D0		              push   psw
 1696: 1  04D1	C0 E0		              PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
 1697: 1  04D3	C4		              SWAP   A             ;EERST HOOGSTE DEEL
 1698: 1  04D4	12 04 B9	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1699: 1  04D7	D0 E0		              POP    ACC           ;HERSTELLEN VAN DE ACCU
 1700: 1  04D9	12 04 B9	              LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
 1701: 1  04DC	D0 D0		              pop    psw           ;registers herstellen
 1702: 1  04DE	D0 E0		              pop    acc
 1703: 1  04E0	22		              RET
 1704: 1
 1705: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1706: 1			;
 1707: 1			; DISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
 1708: 1			; VAN DE CURSOR.
 1709: 1			;
 1710: 1			; de routine gebruikt geen registers.
 1711: 1			;
 1712: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1713: 1
 1714: 1  04E1	C0 E0		DISPDPTR:     push   acc           ;registers op de stack zetten
 1715: 1  04E3	C0 D0		              push   psw
 1716: 1  04E5	E5 83		              MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
 1717: 1  04E7	12 04 CD	              LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
 1718: 1  04EA	E5 82		              MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
 1719: 1  04EC	12 04 CD	              LCALL  OUTBYTE       ;WEG ER MEE
 1720: 1  04EF	D0 D0		              pop    psw           ;registers herstellen
 1721: 1  04F1	D0 E0		              pop    acc
 1722: 1  04F3	22		              RET                  ;EINDE
 1723: 1
 1724: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1725: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 29



 Line  I  Addr  Code            Source

 1726: 1			; OUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
 1727: 1			; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
 1728: 1			;
 1729: 1			; de routine gebruikt geen registers.
 1730: 1			;
 1731: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1732: 1
 1733: 1  04F4	C0 E0		OUTMSGA:      push   acc           ;alles op de stack zetten
 1734: 1  04F6	C0 D0		              push   psw
 1735: 1  04F8	C0 82		              push   dpl
 1736: 1  04FA	C0 83		              push   dph
 1737: 1  04FC	E4		outmsga2:     CLR    A             ;ACCU LEEG MAKEN
 1738: 1  04FD	93		              MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
 1739: 1  04FE	60 09		              JZ     OUTMSGA1      ;ALS NUL DAN EINDE
 1740: 1  0500	12 04 B1	              LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
 1741: 1  0503	12 05 12	              LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
 1742: 1  0506	A3		              INC    DPTR          ;DPTR AANPASSEN
 1743: 1  0507	80 F3		              SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
 1744: 1  0509	D0 83		OUTMSGA1:     pop    dph           ;alles herstellen
 1745: 1  050B	D0 82		              pop    dpl
 1746: 1  050D	D0 D0		              pop    psw
 1747: 1  050F	D0 E0		              pop    acc
 1748: 1  0511	22		              RET                  ;EINDE ROUTINE
 1749: 1
 1750: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1751: 1			;
 1752: 1			; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
 1753: 1			; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
 1754: 1			; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
 1755: 1			; VERDER DOORGEGEVEN.
 1756: 1			;
 1757: 1			; de routine gebruikt geen registers.
 1758: 1			;
 1759: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1760: 1
 1761: 1  0512	C0 E0		XONXOFF:      push   acc           ;registers op de stack zetten
 1762: 1  0514	C0 D0		              push   psw
 1763: 1  0516	10 98 05	              JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
 1764: 1  0519	D0 D0		XONXOFF2:     pop    psw           ;registers herstellen
 1765: 1  051B	D0 E0		              pop    acc
 1766: 1  051D	22		              RET                  ;ANDERS EINDE
 1767: 1  051E	E5 99		XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
 1768: 1  0520	B4 13 F6	              CJNE   A,#XOFF,XONXOFF2   ;ALS NIET XOFF DAN VERDER
 1769: 1  0523	10 98 F3	XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
 1770: 1  0526	80 FB		              SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
 1771: 1
 1772: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1773: 1			;
 1774: 1			; INCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
 1775: 1			; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
 1776: 1			;
 1777: 1			; de routine gebruikt de accu.
 1778: 1			;
 1779: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1780: 1
 1781: 1  0528	30 98 FD	INCHAR:       JNB    RI,INCHAR     ;BLIJF WACHTEN OP HET KARAKTER

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 30



 Line  I  Addr  Code            Source

 1782: 1  052B	C2 98		              CLR    RI            ;BIT LAAG MAKEN
 1783: 1  052D	E5 99		              MOV    A,SBUF        ;KARAKTER IN DE ACCU
 1784: 1  052F	22		              RET
 1785: 1
 1786: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1787: 1			;
 1788: 1			; INBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
 1789: 1			; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
 1790: 1			; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
 1791: 1			; DE CARRY OP 1 GEZET WORDEN.
 1792: 1			;
 1793: 1			; De routine gebruikt de accu EN PSW.
 1794: 1			;
 1795: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1796: 1
 1797: 1  0530	C0 F0		INBYTE:       PUSH     B
 1798: 1  0532	12 05 28	              LCALL  INCHAR         ;EERSTE KARAKTER INLEZEN
 1799: 1  0535	12 05 BE	              LCALL  LOWUPTR
 1800: 1  0538	12 05 D9	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR HEX GETAL
 1801: 1  053B	40 10		              JC     INBYTE1        ;BIJ ERROR AKTIE ONDERNEMEN
 1802: 1  053D	C4		              SWAP   A              ;IS HOOGSTE NIBBLE
 1803: 1  053E	F5 F0		              MOV    B,A            ;ACCU TIJDELIJK BEWAREN
 1804: 1  0540	12 05 28	              LCALL  INCHAR         ;TWEEDE KARAKTER OPHALEN
 1805: 1  0543	12 05 BE	              LCALL  LOWUPTR
 1806: 1  0546	12 05 D9	              LCALL  ASCBINTRANS    ;OMZETTEN NAAR BIN GETAL
 1807: 1  0549	40 02		              JC     INBYTE1        ;BIJ ERROR ....
 1808: 1  054B	45 F0		              ORL    A,B            ;BIJDE GETALLEN SAMEN VOEGEN
 1809: 1  054D	D0 F0		INBYTE1:      POP     B
 1810: 1  054F	22		              RET
 1811: 1
 1812: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1813: 1			;
 1814: 1			; INBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
 1815: 1			; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
 1816: 1			; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
 1817: 1			; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
 1818: 1			; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
 1819: 1			; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
 1820: 1			; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
 1821: 1			; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
 1822: 1			; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
 1823: 1			; bepalen.
 1824: 1			;
 1825: 1			; De routine gebruikt  r0 .
 1826: 1			;
 1827: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1828: 1
 1829: 1  0550	C0 E0		INBUFA:       push   acc            ;registers bewaren
 1830: 1  0552	C0 D0		              push   psw
 1831: 1  0554	78 54		              MOV    R0,#STRTBUF    ;START ADRES VAN DE BUFFER LADEN
 1832: 1  0556	12 05 28	INBUFA2:      LCALL  INCHAR         ;KARAKTER LEZEN
 1833: 1  0559	54 7F		              ANL    A,#07FH        ;KARAKTERS OMVORMEN TOT ASCII 0
 1834: 1			; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
 1835: 1			; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
 1836: 1			; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
 1837: 1			; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 31



 Line  I  Addr  Code            Source

 1838: 1			; GEVOERD.
 1839: 1  055B	12 05 BE	              LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
 1840: 1  055E	B4 0D 06	              CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
 1841: 1  0561	F6		              MOV    @R0,A                ;IN GEHEUGEN ZETTEN
 1842: 1  0562	D0 D0		              pop    psw                  ;registers herstellen
 1843: 1  0564	D0 E0		              pop    acc
 1844: 1  0566	22		              RET                         ;EINDE VAN DE ROUTINE
 1845: 1
 1846: 1  0567	B4 08 13	INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
 1847: 1  056A	B8 54 07	              CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
 1848: 1  056D	74 07		INBUFA4:      MOV    A,#BEEP
 1849: 1  056F	12 04 B1	INBUFA7:      LCALL  OUTCHAR
 1850: 1  0572	80 E2		              SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
 1851: 1
 1852: 1  0574	18		INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
 1853: 1  0575	90 04 8A	              MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
 1854: 1  0578	12 04 F4	              LCALL  OUTMSGA
 1855: 1  057B	80 D9		              SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
 1856: 1  057D	12 05 B0	INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
 1857: 1  0580	40 EB		              JC     INBUFA4              ;BEEP NAAR SCHERM
 1858: 1  0582	B8 7E 02	              CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
 1859: 1  0585	80 E6		              SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
 1860: 1  0587	F6		INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
 1861: 1  0588	08		              INC    R0                   ;BUFFER POINTER AANPASSEN
 1862: 1  0589	80 E4		              SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
 1863: 1
 1864: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1865: 1			;
 1866: 1			; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
 1867: 1			;
 1868: 1			; De routine gebruikt niets.
 1869: 1			;
 1870: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1871: 1
 1872: 1  058B	C0 E0		BDELETE:      PUSH     ACC
 1873: 1  058D	C0 D0		              PUSH     PSW
 1874: 1  058F	E8		              MOV     A,R0                  ;BEWAAR REGISTERS
 1875: 1  0590	C0 E0		              PUSH     ACC
 1876: 1  0592	E9		              MOV     A,R1
 1877: 1  0593	C0 E0		              PUSH     ACC
 1878: 1  0595	78 54		              MOV    R0,#STRTBUF          ;START ADRES IN R0
 1879: 1  0597	79 54		              MOV    R1,#STRTBUF          ;START ADRES IN R1
 1880: 1  0599	E6		BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
 1881: 1  059A	B4 20 0F	              CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
 1882: 1  059D	08		BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
 1883: 1  059E	B8 80 F8	              CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
 1884: 1  05A1	D0 E0		              POP     ACC                  ;REGISTERS HERSTELLEN
 1885: 1  05A3	F9		              MOV     R1,A
 1886: 1  05A4	D0 E0		              POP     ACC
 1887: 1  05A6	F8		              MOV     R0,A
 1888: 1  05A7	D0 D0		              POP     PSW
 1889: 1  05A9	D0 E0		              POP     ACC
 1890: 1  05AB	22		              RET                         ;EINDE VAN DE ROUTINE
 1891: 1  05AC	F7		BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
 1892: 1  05AD	09		              INC    R1
 1893: 1  05AE	80 ED		              SJMP   BDELETE3

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 32



 Line  I  Addr  Code            Source

 1894: 1
 1895: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1896: 1			;
 1897: 1			; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
 1898: 1			; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
 1899: 1			; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
 1900: 1			; AANZIEN.
 1901: 1			;
 1902: 1			; De routine gebruikt de accu en de psw.
 1903: 1			;
 1904: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1905: 1
 1906: 1  05B0	B4 20 00	ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
 1907: 1  05B3	40 07		ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
 1908: 1  05B5	B4 7F 00	              CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
 1909: 1  05B8	50 02		ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
 1910: 1  05BA	C3		              CLR    C                    ;AANGEVEN GEEN FOUT
 1911: 1  05BB	22		              RET
 1912: 1  05BC	D3		ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
 1913: 1  05BD	22		              RET
 1914: 1
 1915: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1916: 1			;
 1917: 1			; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
 1918: 1			; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
 1919: 1			; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
 1920: 1			; AANGEPAST WORDEN.
 1921: 1			;
 1922: 1			; De routine gebruikt de accu en psw .
 1923: 1			;
 1924: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1925: 1
 1926: 1  05BE	B4 7B 00	LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
 1927: 1  05C1	50 07		LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
 1928: 1  05C3	B4 61 00	              CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
 1929: 1  05C6	40 02		LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
 1930: 1  05C8	94 20		              SUBB   A,#020H              ;OMZETTING
 1931: 1  05CA	22		LOWUPTR2:     RET                         ;EINDE OMZETTING
 1932: 1
 1933: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1934: 1			;
 1935: 1			; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
 1936: 1			; ASCII CODE.
 1937: 1			;
 1938: 1			; De routine gebruikt de accu .
 1939: 1			;
 1940: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1941: 1
 1942: 1  05CB	C0 D0		BATRANS:      PUSH   PSW
 1943: 1  05CD	B4 0A 00	              CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
 1944: 1  05D0	40 02		BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
 1945: 1  05D2	24 07		              ADD    A,#007H              ;ANDERS 30+7=37
 1946: 1  05D4	24 30		BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
 1947: 1  05D6	D0 D0		              POP     PSW
 1948: 1  05D8	22		              RET
 1949: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 33



 Line  I  Addr  Code            Source

 1950: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1951: 1			;
 1952: 1			; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
 1953: 1			; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
 1954: 1			; GEVAL WORDT DE CARRY GEZET.
 1955: 1			;
 1956: 1			; De routine gebruikt de accu en de psw.
 1957: 1			;
 1958: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1959: 1
 1960: 1  05D9	C3		ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
 1961: 1  05DA	94 30		              SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
 1962: 1  05DC	40 10		              JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
 1963: 1  05DE	B4 0A 00	              CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
 1964: 1  05E1	40 0A		ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
 1965: 1  05E3	94 07		              SUBB   A,#007H              ;VERDER MET DE OMZETTING
 1966: 1  05E5	40 07		              JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
 1967: 1  05E7	B4 10 00	              CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
 1968: 1  05EA	B3		ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
 1969: 1  05EB	40 01		              JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
 1970: 1  05ED	C3		ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
 1971: 1  05EE	22		ASCBINTRANS1: RET
 1972: 1
 1973: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1974: 1			;
 1975: 1			; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
 1976: 1			; DE ROUTINE VERANDERD OOK DE VLAGGEN.
 1977: 1			;
 1978: 1			; De routine gebruikt de accu en de psw.
 1979: 1			;
 1980: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1981: 1
 1982: 1  05EF	E6		ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
 1983: 1  05F0	12 05 D9	              LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
 1984: 1  05F3	22		              RET                         ;EINDE OMZETTING
 1985: 1
 1986: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1987: 1			;
 1988: 1			; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
 1989: 1			; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
 1990: 1			; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
 1991: 1			;
 1992: 1			; De routine gebruikt de accu, r0.
 1993: 1			;
 1994: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 1995: 1
 1996: 1  05F4	C0 F0		ASCII2:       PUSH   B
 1997: 1  05F6	12 05 EF	              LCALL  ASCII1               ;OMZETTEN
 1998: 1  05F9	40 0B		              JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
 1999: 1  05FB	C4		              SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
 2000: 1  05FC	F5 F0		              MOV    B,A                 ;TIJDELIJK WEG STOPPEN
 2001: 1  05FE	08		              INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
 2002: 1  05FF	12 05 EF	              LCALL  ASCII1               ;KARAKTER OMZETTEN
 2003: 1  0602	40 02		              JC     ASCII21               ;WEG ALS C=1
 2004: 1  0604	45 F0		              ORL    A,B                  ;GETALLEN BIJ ELKAAR VOEGEN
 2005: 1  0606	D0 F0		ASCII21:      POP     B

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 34



 Line  I  Addr  Code            Source

 2006: 1  0608	22		              RET
 2007: 1
 2008: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2009: 1			;
 2010: 1			; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
 2011: 1			; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
 2012: 1			; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
 2013: 1			; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
 2014: 1			;
 2015: 1			; De routine gebruikt de accu, r0, r1 en de psw.
 2016: 1			;
 2017: 1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2018: 1
 2019: 1  0609	12 05 F4	ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
 2020: 1  060C	40 0A		              JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
 2021: 1  060E	F5 83		              MOV    DPH,A                ;HEX GETAL IN DE DPTRH
 2022: 1  0610	08		              INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
 2023: 1  0611	12 05 F4	              LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
 2024: 1  0614	40 02		              JC     ASCII41              ;BIJ FOUT DAN WEG
 2025: 1  0616	F5 82		              MOV    DPL,A                ;IN DPTR LADEN
 2026: 1  0618	22		ASCII41:      RET
 2027: 1
 2028: 1			endif        ;einde van aduc_sio
 2029: 1			;*******************************************************************************
 2030: 1
 2031: 1
 2032: 1			ifdef        aduc_math    ;rekenkundige routines
 2033: 1			;*******************************************************************************
 2034: 1			; aduc_math
 2035: 1			; Rekenkundige routines voor 8051 compatibele (ook aduc832) microcontrollers
 2036: 1			; De routines zijn gebaseerd op het verwerken van de getallen in twee 32 bit
 2037: 1			; software accumulatoren ACC0 en ACC1. De accumulatoren hebben elk hun tekenbit
 2038: 1			; waarmee het teken wordt bepaald bij de rekenkundige bewerkingen.
 2039: 1			; Deze accumulatoren bestaan uit R0 tot R7
 2040: 1			; zoals aangegeven:
 2041: 1			;
 2042: 1			;    msb 31  24 23  16 15   8 7    0 lsb
 2043: 1			;        ---------------------------
 2044: 1			; ACC0  |  R3  |  R2  |  R1  |  R0  |    tekenbit van ACC0 = f0  errorbit  = CY
 2045: 1			;        ---------------------------                             statusbit = f0
 2046: 1			;        ---------------------------
 2047: 1			; ACC1  |  R7  |  R6  |  R5  |  R4  |    tekenbit van ACC1 = f1
 2048: 1			;        ---------------------------
 2049: 1			; Bij 8bit bewerkingen zullen steeds de minst beduidende bytes (R0 en R4) worden
 2050: 1			; gebruikt, bij 16bit bewerkingen de minst beduidende woorden (R1,R0 en R5,R4).
 2051: 1			; De userbits F0 en F1 worden gebruikt als tekenbits, of als statusbits bij
 2052: 1			; return en moeten hiervoor worden gereserveerd.
 2053: 1			; De CY bit wordt gebruikt als errorbit bij return.
 2054: 1			; Er zijn routines voorzien voor bewerkingen op signed (2' s complement)
 2055: 1			; en unsigned getallen.
 2056: 1			;
 2057: 1			; Beschikbare routines:
 2058: 1			;
 2059: 1			; Conversie routines:
 2060: 1			; bcdhex8, hexbcd8, bcdhex16, hexbcd16, hexbcd16_u, magsig8, magsig8acc1,
 2061: 1			; magsig16, magsig16acc1, magsig32, magsig32acc1, sigmag8acc0, sigmag8acc1,

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 35



 Line  I  Addr  Code            Source

 2062: 1			; sigmag16acc0, sigmag16acc1, sigmag16acc1h, sigmag32acc0, sigmag32acc1
 2063: 1			;
 2064: 1			; Som:
 2065: 1			; s_add16, add16, s_add32, add32
 2066: 1			;
 2067: 1			; Verschil:
 2068: 1			; s_sub16, sub16, s_sub32, sub32
 2069: 1			;
 2070: 1			; Vermenigvuldigen:
 2071: 1			; mul16, mul16acc1, s_mul16, s_mul16acc1, s_mul816, mul816, s_mac16
 2072: 1			;
 2073: 1			; Delen:
 2074: 1			; s_div8, div8, s_div16, div16, s_div32, div32, s_muldiv, muldiv
 2075: 1			;
 2076: 1			; Vemenigvuldig met factor:
 2077: 1			; mul16_pi, mul16_i_pi,mul16_sqrt2, mul16_i_sqrt2, mul16_10, mul16_100
 2078: 1			;
 2079: 1			; Vierkantswortel:
 2080: 1			; sqrt32, s_sqrt32
 2081: 1			;
 2082: 1			; Schuiven:
 2083: 1			; shiftright32, shiftleft32, s_shiftright32, s_shiftleft32
 2084: 1			;
 2085: 1			; Vergelijken:
 2086: 1			; s_cmp16, cmp16, s_cmp32, cmp32
 2087: 1			;
 2088: 1			; Tabel lookup:
 2089: 1			; table_lu
 2090: 1			;
 2091: 1			; Gonemetrische functies:
 2092: 1			; Cordic = sinus,cosinus
 2093: 1			;
 2094: 1			;*******************************************************************************
 2095: 1
 2096: 1			;*******************************************************************************
 2097: 1			;
 2098: 1			; bcdhex8     (45,77us @16.777216MHz)
 2099: 1			; Deze routine zal een positief of negatief 8bit bcd getal in acc0 (R0) omzetten
 2100: 1			; naar een 2's complement hex getal.
 2101: 1			; Bij een positief getal (F0=0) zal een bcdgetal 00h tot 99h worden omgezet naar
 2102: 1			; een waarde 00h tot 63h.
 2103: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 00h tot 99h worden omgezet naar
 2104: 1			; een waarde 00h,ffh tot 9dh  (9dh is de 2's complement voorstelling van -63h).
 2105: 1			; input:      R0 = waarde tussen 00h en 99h.
 2106: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2107: 1			; output:     R0 = 2's complement waarde
 2108: 1			;             cy=1 bij out of range van r0
 2109: 1			;             cy=0 bij conversie ok
 2110: 1			; vernietigt: niets
 2111: 1			;*******************************************************************************
 2112: 1  0619	C0 E0		bcdhex8:      push   acc                  ;registers op de stack zetten
 2113: 1  061B	C0 D0		              push   psw
 2114: 1  061D	C0 F0		              push   b
 2115: 1
 2116: 1  061F	E8		              mov    a,r0                 ;neem te converteren waarde
 2117: 1  0620	F5 F0		              mov    b,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 36



 Line  I  Addr  Code            Source

 2118: 1  0622	54 0F		              anl    a,#0fh
 2119: 1  0624	B4 0A 00	              cjne   a,#0ah,bcdhex81      ;test low nibble
 2120: 1  0627	50 29		bcdhex81:     jnc    bcdhex82             ;nibble te groot = error
 2121: 1  0629	E5 F0		              mov    a,b
 2122: 1  062B	54 F0		              anl    a,#0f0h
 2123: 1  062D	B4 A0 00	              cjne   a,#0a0h,bcdhex811    ;test high nibble
 2124: 1  0630	50 20		bcdhex811:    jnc    bcdhex82             ;nibble te groot = error
 2125: 1
 2126: 1  0632	E8		              mov    a,r0
 2127: 1  0633	54 F0		              anl    a,#0f0h              ;maskeer hoogste bits
 2128: 1  0635	C4		              swap   a
 2129: 1  0636	75 F0 0A	              mov    b,#10                ;bereken de waarde van de  4 msb's
 2130: 1  0639	A4		              mul    ab
 2131: 1  063A	F5 F0		              mov    b,a                  ;bewaar dit product even
 2132: 1  063C	E8		              mov    a,r0
 2133: 1  063D	54 0F		              anl    a,#00fh
 2134: 1  063F	F8		              mov    r0,a
 2135: 1  0640	E5 F0		              mov    a,b
 2136: 1  0642	28		              add    a,r0                 ;eenheden er bijtellen
 2137: 1  0643	F8		              mov    r0,a
 2138: 1
 2139: 1  0644	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2140: 1  0646	12 07 47	              lcall  magsig8              ;omzetten naar 2's complement
 2141: 1
 2142: 1  0649	D0 F0		              pop    b
 2143: 1  064B	D0 D0		              pop    psw
 2144: 1  064D	C2 D7		              clr    cy                   ;geen fout
 2145: 1  064F	D0 E0		              pop    acc
 2146: 1  0651	22		              ret
 2147: 1
 2148: 1  0652	D0 F0		bcdhex82:     pop    b
 2149: 1  0654	D0 D0		              pop    psw
 2150: 1  0656	D2 D7		              setb   cy                   ;fout! r0 out of range
 2151: 1  0658	D0 E0		              pop    acc
 2152: 1  065A	22		              ret
 2153: 1
 2154: 1			;*******************************************************************************
 2155: 1			;
 2156: 1			; hexbcd8     (38,4us @16.777216MHz)
 2157: 1			; Deze routine zal een 8bit 2's complement getal in acc0 (R0) omzetten
 2158: 1			; naar een 8bit bcd getal.
 2159: 1			; Bij een positief getal zal een waarde 00h tot 63h worden omgezet naar een
 2160: 1			; bcdgetal van 00h tot +99h.
 2161: 1			; Bij een negatief getal zal een waarde 00h,ffh tot 9dh
 2162: 1			; (9dh is de 2's complement voorstelling van -63h) worden omgezet naar een
 2163: 1			; bcdgetal 00h tot -99h
 2164: 1			;
 2165: 1			; input:      R0 = 2's complement waarde tussen 9dh..ffh,0,01h..63h.
 2166: 1			;
 2167: 1			; output:     R0 = bcd getal tussen -99h en 99h
 2168: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2169: 1			;             cy=1 bij out of range van r0
 2170: 1			;             cy=0 bij conversie ok
 2171: 1			; vernietigt: niets
 2172: 1			;*******************************************************************************
 2173: 1  065B	C0 E0		hexbcd8:        push    acc             ;registers bewaren

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 37



 Line  I  Addr  Code            Source

 2174: 1  065D	C0 D0		                push    psw
 2175: 1  065F	C0 F0		                push    b
 2176: 1  0661	E8		                mov     a,r0            ;neem 2's complement getal en test het
 2177: 1  0662	B4 64 00	                cjne    a,#64h,hexbcd81 ;bereik van het getal.
 2178: 1  0665	40 0D		hexbcd81:       jc      hexbcd83        ;als  9dh> getal >63h dan out of range
 2179: 1  0667	B4 9D 00	                cjne    a,#9dh,hexbcd82
 2180: 1  066A	50 08		hexbcd82:       jnc     hexbcd83        ;geen carry, dan ok
 2181: 1  066C	D0 F0		                pop     b
 2182: 1  066E	D0 D0		                pop     psw             ;jammer maar helaas fout...
 2183: 1  0670	D3		                setb    c
 2184: 1  0671	D0 E0		                pop     acc
 2185: 1  0673	22		                ret
 2186: 1  0674	12 08 0F	hexbcd83:       lcall    sigmag8acc0    ;2's compl. naar abs. waarde + teken f0
 2187: 1  0677	E8		                mov     a,r0            ;zet getal om naar 00h..99h en klaar...
 2188: 1  0678	75 F0 0A	                mov     b,#10
 2189: 1  067B	84		                div     ab
 2190: 1  067C	C4		                swap    a
 2191: 1  067D	25 F0		                add     a,b
 2192: 1  067F	F8		                mov     r0,a
 2193: 1  0680	D0 F0		                pop     b               ;registers herstellen
 2194: 1  0682	D0 E0		                pop     acc             ;psw van stack halen
 2195: 1  0684	A2 D5		                mov     c,f0            ;we moeten de f0 flag als teken houden
 2196: 1  0686	92 E5		                mov     acc.5,c
 2197: 1  0688	F5 D0		                mov     psw,a           ;f0 flag in psw is correct
 2198: 1  068A	C3		                clr     c               ;status: conversie ok
 2199: 1  068B	D0 E0		                pop     acc
 2200: 1  068D	22		                ret
 2201: 1
 2202: 1
 2203: 1
 2204: 1			;*******************************************************************************
 2205: 1			;
 2206: 1			; bcdhex16    (86,6us @16.777216MHz)
 2207: 1			; Deze routine zal een positief of negatief 16 bit bcd getal in acc0 (R1,R0)
 2208: 1			; omzetten naar een 2's complement hex getal.
 2209: 1			; Bij een positief getal (F0=0) zal een bcdgetal 0000h tot 9999h worden omgezet
 2210: 1			; naareen waarde 0000h tot 270fh.
 2211: 1			; Bij een negatief getal (F0=1) zal een bcdgetal 0000h tot -9999h worden omgezet
 2212: 1			; naar een waarde 0000h,ffffh tot d8f1h (d8f1h is de 2's complement voorstelling
 2213: 1			; van -270fh).
 2214: 1			; input:      R1,R0 = waarde tussen 0000h en 9999h.  (R1=msb,R0=lsb)
 2215: 1			;             F0 = tekenbit, 1=negatief, 0=positief.
 2216: 1			; output:     R1,R0 = 2's complement waarde
 2217: 1			;             cy=1 bij out of range van r1,r0
 2218: 1			;             cy=0 bij conversie ok
 2219: 1			; vernietigt: niets
 2220: 1			;*******************************************************************************
 2221: 1  068E	C0 E0		bcdhex16:     push   acc                  ;registers op de stack zetten
 2222: 1  0690	C0 D0		              push   psw
 2223: 1  0692	C0 F0		              push   b
 2224: 1
 2225: 1  0694	E8		              mov    a,r0                  ;low byte van te converteren waarde
 2226: 1  0695	F5 F0		              mov    b,a
 2227: 1  0697	54 0F		              anl    a,#0fh
 2228: 1  0699	B4 0A 00	              cjne   a,#0ah,bcdhex161      ;test low nibble
 2229: 1  069C	50 65		bcdhex161:    jnc    bcdhex162             ;nibble te groot = error

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 38



 Line  I  Addr  Code            Source

 2230: 1  069E	E5 F0		              mov    a,b
 2231: 1  06A0	54 F0		              anl    a,#0f0h
 2232: 1  06A2	B4 A0 00	              cjne   a,#0a0h,bcdhex1611    ;test high nibble
 2233: 1  06A5	50 5C		bcdhex1611:   jnc    bcdhex162             ;nibble te groot = error
 2234: 1  06A7	E9		              mov    a,r1                  ;high byte van te converteren waarde
 2235: 1  06A8	F5 F0		              mov    b,a
 2236: 1  06AA	54 0F		              anl    a,#0fh
 2237: 1  06AC	B4 0A 00	              cjne   a,#0ah,bcdhex1612      ;test low nibble
 2238: 1  06AF	50 52		bcdhex1612:   jnc    bcdhex162             ;nibble te groot = error
 2239: 1  06B1	E5 F0		              mov    a,b
 2240: 1  06B3	54 F0		              anl    a,#0f0h
 2241: 1  06B5	B4 A0 00	              cjne   a,#0a0h,bcdhex1613    ;test high nibble
 2242: 1  06B8	50 49		bcdhex1613:   jnc    bcdhex162             ;nibble te groot = error
 2243: 1
 2244: 1  06BA	E8		              mov    a,r0                  ;neem low byte voor conversie
 2245: 1  06BB	54 0F		              anl    a,#00fh               ;eenheden afzonderen
 2246: 1  06BD	C0 E0		              push   acc                   ;en even bewaren
 2247: 1
 2248: 1  06BF	E8		              mov    a,r0
 2249: 1  06C0	C4		              swap   a
 2250: 1  06C1	54 0F		              anl    a,#00fh              ;tientallen
 2251: 1  06C3	75 F0 0A	              mov    b,#00ah              ;maal tien
 2252: 1  06C6	A4		              mul    ab                   ;
 2253: 1  06C7	D0 F0		              pop    b                    ;neem eenheden
 2254: 1  06C9	25 F0		              add    a,b                  ;tel bij tientallen
 2255: 1  06CB	C0 E0		              push   acc                  ;weer bewaren
 2256: 1
 2257: 1  06CD	E9		              mov    a,r1                 ;neem high byte voor conversie
 2258: 1  06CE	54 F0		              anl    a,#0f0h
 2259: 1  06D0	C4		              swap   a
 2260: 1  06D1	C0 E0		              push   acc                  ;bewaar de duizendtallen
 2261: 1
 2262: 1  06D3	E9		              mov    a,r1                  ;neem high byte voor conversie
 2263: 1  06D4	54 0F		              anl    a,#00fh              ;zonder de honderdtallen af
 2264: 1  06D6	75 F0 64	              mov    b,#100d              ;en maal honderd
 2265: 1  06D9	A4		              mul    ab
 2266: 1  06DA	A9 F0		              mov    r1,b
 2267: 1  06DC	F8		              mov    r0,a
 2268: 1
 2269: 1  06DD	D0 E0		              pop    acc                  ;neem de duizendtallen en
 2270: 1  06DF	75 F0 0A	              mov    b,#10d               ;vermenigvuldig met *10*100=*1000
 2271: 1  06E2	A4		              mul    ab                   ;resultaat zit nog helemaal in accu
 2272: 1  06E3	75 F0 64	              mov    b,#100d              ;volgende stap *100
 2273: 1  06E6	A4		              mul    ab
 2274: 1  06E7	28		              add    a,r0                 ;tel honderdtallen bij de
 2275: 1  06E8	F8		              mov    r0,a                 ;duizendtallen
 2276: 1  06E9	E9		              mov    a,r1
 2277: 1  06EA	35 F0		              addc   a,b
 2278: 1  06EC	F9		              mov    r1,a
 2279: 1
 2280: 1  06ED	D0 E0		              pop    acc                  ;neem de tientallen en eenheden
 2281: 1  06EF	28		              add    a,r0                 ;en tel bij de honderdtallen en
 2282: 1  06F0	F8		              mov    r0,a                 ;duizendtallen
 2283: 1  06F1	74 00		              mov    a,#000h
 2284: 1  06F3	39		              addc   a,r1
 2285: 1  06F4	F9		              mov    r1,a                 ;omzetting klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 39



 Line  I  Addr  Code            Source

 2286: 1
 2287: 1  06F5	C2 D1		              clr    f1                   ;tweede tekenbit = positief
 2288: 1  06F7	12 07 7B	              lcall  magsig16             ;omzetten naar 2's complement
 2289: 1
 2290: 1  06FA	D0 F0		              pop    b
 2291: 1  06FC	D0 D0		              pop    psw
 2292: 1  06FE	C2 D7		              clr    cy                   ;geen fout
 2293: 1  0700	D0 E0		              pop    acc
 2294: 1  0702	22		              ret
 2295: 1
 2296: 1  0703	D0 F0		bcdhex162:    pop    b
 2297: 1  0705	D0 D0		              pop    psw
 2298: 1  0707	D2 D7		              setb   cy                  ;fout! r1,r0 out of range
 2299: 1  0709	D0 E0		              pop    acc
 2300: 1  070B	22		              ret
 2301: 1
 2302: 1			;*******************************************************************************
 2303: 1			;
 2304: 1			; hexbcd16    (1,415ms @16.777216MHz)
 2305: 1			; Deze routine zal een 16 bit 2's complement getal in acc0 (r1,r0) omzetten
 2306: 1			; naar een 24bit bcd getal.
 2307: 1			; Bij een positief getal zal een waarde 0000h tot 7fffh worden omgezet naar een
 2308: 1			; bcdgetal van 000000h tot +032767h.
 2309: 1			; Bij een negatief getal zal een waarde 0000h,ffffh tot 8000h worden omgezet
 2310: 1			; naar een bcdgetal 000000h tot -032768h
 2311: 1			;
 2312: 1			; input:      r1,r0 = 16 bit 2's complement getal
 2313: 1			;
 2314: 1			; output:     r2,r1,r0 = acc0 = bcd getal tussen -032768 en +032767
 2315: 1			;              F0 = tekenbit, 1=negatief, 0=positief.
 2316: 1			;
 2317: 1			; vernietigt: niets
 2318: 1			;*******************************************************************************
 2319: 1			;
 2320: 1			; hexbcd16_u    (1,405ms @16.777216MHz)
 2321: 1			; Deze routine zal een 16 bit unsigned getal in acc0 (r1,r0) omzetten
 2322: 1			; naar een 24bit bcd getal.
 2323: 1			; Dit positief getal met een waarde 0000h tot ffffh zal worden omgezet naar een
 2324: 1			; bcdgetal van 000000h tot 065535h.
 2325: 1			;
 2326: 1			; input:      r1,r0 = 16 bit getal (absolute waarde)
 2327: 1			;
 2328: 1			; output:     r2,r1,r0 = acc0 = 24 bit bcd getal tussen 0 en 065535h
 2329: 1			;
 2330: 1			; vernietigt: niets
 2331: 1			;*******************************************************************************
 2332: 1  070C	12 08 41	hexbcd16:       lcall   sigmag16acc0    ;2's compl. naar abs. waarde +teken f0
 2333: 1  070F	C0 E0		hexbcd16_u:     push   acc             ;registers bewaren
 2334: 1  0711	C0 D0		                push   psw
 2335: 1  0713	C0 F0		                push   b
 2336: 1  0715	C0 82		                push   dpl
 2337: 1
 2338: 1  0717	75 F0 05	                mov    b,#005h         ;loopcounter voor 5 digits
 2339: 1  071A	7C 0A		hexbcd161:      mov    r4,#0ah         ;deler '10d' in acc1 laden
 2340: 1  071C	7D 00		                mov    r5,#00h         ;omzetten naar 10-delig talstelsel
 2341: 1  071E	12 0B F0	                lcall  div16           ;deling uitvoeren, Q=r1,r0  rest=r5,r4

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 40



 Line  I  Addr  Code            Source

 2342: 1  0721	EC		                mov    a,r4            ;rest is steeds kleiner dan 10 (msb=0)
 2343: 1  0722	C0 E0		                push   acc             ;dit als resultaatbyte op stack zetten
 2344: 1			                                        ;dus eerst eenheden, dan tientallen
 2345: 1			                                        ;honderdtallen, duizendtallen en
 2346: 1			                                        ;tienduizendtallen
 2347: 1  0724	D5 F0 F3	                djnz   b,hexbcd161      ;quotient nogmaals delen
 2348: 1
 2349: 1			;nu alle resultaatbytes weer van stack halen en combineren
 2350: 1
 2351: 1  0727	D0 E0		                pop    acc              ;tienduizendtallen van stack halen
 2352: 1  0729	FA		                mov    r2,a             ;ms digit in outputregister stoppen
 2353: 1  072A	D0 E0		                pop    acc              ;duizendtallen ophalen
 2354: 1  072C	C4		                swap   a                ;en combineren met de
 2355: 1  072D	F5 82		                mov    dpl,a
 2356: 1  072F	D0 E0		                pop    acc              ;honderdtallen van de stack
 2357: 1  0731	25 82		                add    a,dpl
 2358: 1  0733	F9		                mov    r1,a             ;volgende 2 digits in outputregister
 2359: 1  0734	D0 E0		                pop    acc              ;tientallen van de stack halen
 2360: 1  0736	C4		                swap   a
 2361: 1  0737	F5 82		                mov    dpl,a
 2362: 1  0739	D0 E0		                pop    acc              ;en combineren met de eenheden
 2363: 1  073B	25 82		                add    a,dpl
 2364: 1  073D	F8		                mov    r0,a             ;laatste 2 digits in outputregisters
 2365: 1
 2366: 1  073E	D0 82		                pop    dpl              ;registers herstellen
 2367: 1  0740	D0 F0		                pop    b
 2368: 1  0742	D0 D0		                pop    psw              ;we krijgen onze tekenbit terug
 2369: 1  0744	D0 E0		                pop    acc
 2370: 1  0746	22		                ret
 2371: 1
 2372: 1			;*******************************************************************************
 2373: 1			; magsig8        (13,6us @16.777216MHz)
 2374: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2375: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2376: 1			; input:    r0 = acc0 absolute waarde (0..80h)
 2377: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2378: 1			;           (f0 en f1 zijn 1 als negatief)
 2379: 1			;
 2380: 1			; output:   r0 = 2's complement
 2381: 1			;
 2382: 1			; vernietigt: niets
 2383: 1			;*******************************************************************************
 2384: 1
 2385: 1  0747	C0 E0		magsig8:       push   acc                ;bewaar gebruikte registers
 2386: 1  0749	C0 D0		               push   psw
 2387: 1  074B	20 D5 05	               jb     f0, magsig8b       ;test eerste tekenbit
 2388: 1  074E	20 D1 07	               jb     f1, magsig8a       ;test tweede tekenbit
 2389: 1  0751	80 09		               sjmp   magsig8c
 2390: 1
 2391: 1  0753	30 D1 02	magsig8b:      jnb    f1, magsig8a
 2392: 1  0756	80 04		               sjmp   magsig8c
 2393: 1
 2394: 1  0758	E8		magsig8a:      mov    a,r0               ;als r0 negatief, neem abs waarde
 2395: 1  0759	F4		               cpl    a                  ;complementeer abs waarde
 2396: 1  075A	04		               inc    a                  ;r0 = complement(r0)+1
 2397: 1  075B	F8		               mov    r0,a               ;bewaar in 2's complement

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 41



 Line  I  Addr  Code            Source

 2398: 1  075C	D0 D0		magsig8c:      pop    psw
 2399: 1  075E	D0 E0		               pop    acc
 2400: 1  0760	22		               ret                        ;klaar
 2401: 1
 2402: 1			;*******************************************************************************
 2403: 1			; magsig8acc1        (13,6us @16.777216MHz)
 2404: 1			; 8-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2405: 1			; Outputbereik getallen: -128 tot  +127 (80h..ffh,0,01h..7fh)
 2406: 1			; input:    r4 = acc1 absolute waarde (0..80h)
 2407: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2408: 1			;           (f0 en f1 zijn 1 als negatief)
 2409: 1			;
 2410: 1			; output:   r4 = 2's complement
 2411: 1			;
 2412: 1			; vernietigt: niets
 2413: 1			;*******************************************************************************
 2414: 1
 2415: 1  0761	C0 E0		magsig8acc1:   push    acc                ;bewaar gebruikte registers
 2416: 1  0763	C0 D0		               push    psw
 2417: 1  0765	20 D5 05	               jb      f0, magsig8acc1b   ;test eerste tekenbit
 2418: 1  0768	20 D1 07	               jb      f1, magsig8acc1a   ;test tweede tekenbit
 2419: 1  076B	80 EF		               sjmp    magsig8c
 2420: 1
 2421: 1  076D	30 D1 02	magsig8acc1b:  jnb     f1, magsig8acc1a
 2422: 1  0770	80 04		               sjmp    magsig8acc1c
 2423: 1
 2424: 1  0772	EC		magsig8acc1a:  mov     a,r4              ;als r4 negatief, neem abs waarde
 2425: 1  0773	F4		               cpl     a                 ;complementeer abs waarde
 2426: 1  0774	04		               inc     a                 ;r4 = complement(r0)+1
 2427: 1  0775	FC		               mov     r4,a              ;bewaar in 2's complement
 2428: 1  0776	D0 D0		magsig8acc1c:  pop     psw
 2429: 1  0778	D0 E0		               pop     acc
 2430: 1  077A	22		               ret                       ;klaar
 2431: 1
 2432: 1			;*******************************************************************************
 2433: 1			; magsig16        (16,6us @16.777216MHz)
 2434: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2435: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2436: 1			; input:    r1,r0 = acc0 absolute waarde (0..8000h)(r1=msb)
 2437: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2438: 1			;           (f0 en f1 zijn 1 als negatief)
 2439: 1			;
 2440: 1			; output:   r1,r0 = 2's complement
 2441: 1			;
 2442: 1			; vernietigt: niets
 2443: 1			;*******************************************************************************
 2444: 1  077B	C0 E0		magsig16:      push    acc              ;bewaar gebruikte registers
 2445: 1  077D	C0 D0		               push    psw
 2446: 1  077F	20 D5 05	               jb      f0,magsig16b     ;test eerste tekenbit
 2447: 1  0782	20 D1 07	               jb      f1,magsig16a     ;test tweede tekenbit
 2448: 1  0785	80 0F		               sjmp    magsig16c
 2449: 1
 2450: 1  0787	30 D1 02	magsig16b:     jnb     f1,magsig16a
 2451: 1  078A	80 0A		               sjmp    magsig16c
 2452: 1
 2453: 1  078C	E8		magsig16a:     mov     a,r0             ;als het een negatief getal is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 42



 Line  I  Addr  Code            Source

 2454: 1  078D	F4		               cpl     a                ;complementeer het dan
 2455: 1  078E	24 01		               add     a, #1            ;en tel er 1 bij
 2456: 1  0790	F8		               mov     r0,a
 2457: 1  0791	E9		               mov     a,r1             ;neem volgende byte
 2458: 1  0792	F4		               cpl     a                ;complementeer en tel carry erbij
 2459: 1  0793	34 00		               addc    a,#0
 2460: 1  0795	F9		               mov     r1,a
 2461: 1  0796	D0 D0		magsig16c:     pop     psw
 2462: 1  0798	D0 E0		               pop     acc
 2463: 1  079A	22		               ret
 2464: 1
 2465: 1			;*******************************************************************************
 2466: 1			; magsig16acc1        (16,6us @16.777216MHz)
 2467: 1			; 16-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2468: 1			; Outputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2469: 1			; input:    r5,r4 = acc1 absolute waarde (0..8000h) (r1=msb)
 2470: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2471: 1			;           (f0 en f1 zijn 1 als negatief)
 2472: 1			;
 2473: 1			; output:   r5,r4 = 2's complement
 2474: 1			;
 2475: 1			; vernietigt: niets
 2476: 1			;*******************************************************************************
 2477: 1  079B	C0 E0		magsig16acc1:   push    acc                 ;bewaar gebruikte registers
 2478: 1  079D	C0 D0		                push    psw
 2479: 1  079F	20 D5 05	                jb      f0,magsig16acc1b    ;test eerste tekenbit
 2480: 1  07A2	20 D1 07	                jb      f1,magsig16acc1a    ;test tweede tekenbit
 2481: 1  07A5	80 0F		                sjmp    magsig16acc1c
 2482: 1
 2483: 1  07A7	30 D1 02	magsig16acc1b:  jnb     f1,magsig16acc1a
 2484: 1  07AA	80 0A		                sjmp    magsig16acc1c
 2485: 1
 2486: 1  07AC	EC		magsig16acc1a:  mov     a,r4                ;als het een negatief getal is
 2487: 1  07AD	F4		                cpl     a                   ;complementeer het dan
 2488: 1  07AE	24 01		                add     a,#1                ;en tel er 1 bij
 2489: 1  07B0	FC		                mov     r4,a
 2490: 1  07B1	ED		                mov     a,r5                ;neem volgende byte
 2491: 1  07B2	F4		                cpl     a                   ;complementeer en tel carry erbij
 2492: 1  07B3	34 00		                addc    a,#0
 2493: 1  07B5	FD		                mov     r5,a
 2494: 1  07B6	D0 D0		magsig16acc1c:  pop     psw
 2495: 1  07B8	D0 E0		                pop     acc
 2496: 1  07BA	22		                ret
 2497: 1
 2498: 1			;*******************************************************************************
 2499: 1			; magsig32        (22,2us @16.777216MHz)
 2500: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2501: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2502: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2503: 1			; input:    r3,r2,r1,r0 = acc0 absolute waarde (0..80000000h)(r3=msb)
 2504: 1			;           Bits f0 & f1 = tekenbits van acc0 en acc1
 2505: 1			;           (f0 en f1 zijn 1 als negatief)
 2506: 1			;
 2507: 1			; output:   r3,r2,r1,r0 = 2's complement
 2508: 1			;
 2509: 1			; vernietigt: niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 43



 Line  I  Addr  Code            Source

 2510: 1			;*******************************************************************************
 2511: 1  07BB	C0 E0		magsig32:      push    acc              ;bewaar gebruikte registers
 2512: 1  07BD	C0 D0		               push    psw
 2513: 1  07BF	20 D5 05	               jb      f0,magsig32b     ;test eerste tekenbit
 2514: 1  07C2	20 D1 07	               jb      f1,magsig32a     ;test tweede tekenbit
 2515: 1  07C5	80 19		               sjmp    magsig32c
 2516: 1
 2517: 1  07C7	30 D1 02	magsig32b:     jnb     f1,magsig32a
 2518: 1  07CA	80 14		               sjmp    magsig32c
 2519: 1
 2520: 1  07CC	E8		magsig32a:     mov     a,r0             ;als het een negatief getal is
 2521: 1  07CD	F4		               cpl     a                 ;complementeer het dan
 2522: 1  07CE	24 01		               add     a,#1             ;en tel er 1 bij
 2523: 1  07D0	F8		               mov     r0,a
 2524: 1  07D1	E9		               mov     a,r1             ;neem volgende byte
 2525: 1  07D2	F4		               cpl     a                 ;complementeer en tel carry erbij
 2526: 1  07D3	34 00		               addc    a,#0
 2527: 1  07D5	F9		               mov     r1,a
 2528: 1  07D6	EA		               mov     a,r2            ;neem volgende byte
 2529: 1  07D7	F4		               cpl     a                ;complementeer en tel carry erbij
 2530: 1  07D8	34 00		               addc    a,#0
 2531: 1  07DA	FA		               mov     r2,a
 2532: 1  07DB	EB		               mov     a,r3            ;neem volgende byte
 2533: 1  07DC	F4		               cpl     a                ;complementeer en tel carry erbij
 2534: 1  07DD	34 00		               addc    a,#0
 2535: 1  07DF	FB		               mov     r3,a
 2536: 1
 2537: 1  07E0	D0 D0		magsig32c:     pop     psw
 2538: 1  07E2	D0 E0		               pop     acc
 2539: 1  07E4	22		               ret
 2540: 1
 2541: 1
 2542: 1
 2543: 1			;*******************************************************************************
 2544: 1			; magsig32acc1        (22,2us @16.777216MHz)
 2545: 1			; 32-Bit absolute waarde/ tekenBits omzetting naar 2's Complement waarde
 2546: 1			; Outputbereik getallen: -2147483648 tot +2147483647
 2547: 1			;                  (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2548: 1			; input:    r7,r6,r5,r4 = acc1 absolute waarde (0..80000000h) (r7=msb)
 2549: 1			;           Bits f0 & f1 = tekenbits van acc1 high en acc1 low
 2550: 1			;           (f0 en f1 zijn 1 als negatief)
 2551: 1			;
 2552: 1			; output:   r7,r6,r5,r4 = 2's complement
 2553: 1			;
 2554: 1			; vernietigt: niets
 2555: 1			;*******************************************************************************
 2556: 1  07E5	C0 E0		magsig32acc1:  push    acc               ;bewaar gebruikte registers
 2557: 1  07E7	C0 D0		               push    psw
 2558: 1  07E9	20 D5 05	               jb      f0,magsig32acc1b  ;test eerste tekenbit
 2559: 1  07EC	20 D1 07	               jb      f1,magsig32acc1a  ;test tweede tekenbit
 2560: 1  07EF	80 19		               sjmp    magsig32acc1c
 2561: 1
 2562: 1  07F1	30 D1 02	magsig32acc1b: jnb     f1,magsig32acc1a
 2563: 1  07F4	80 14		               sjmp    magsig32acc1c
 2564: 1
 2565: 1  07F6	EC		magsig32acc1a: mov     a,r4             ;als het een negatief getal is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 44



 Line  I  Addr  Code            Source

 2566: 1  07F7	F4		               cpl     a                 ;complementeer het dan
 2567: 1  07F8	24 01		               add     a,#1             ;en tel er 1 bij
 2568: 1  07FA	FC		               mov     r4,a
 2569: 1  07FB	ED		               mov     a,r5             ;neem volgende byte
 2570: 1  07FC	F4		               cpl     a                 ;complementeer en tel carry erbij
 2571: 1  07FD	34 00		               addc    a,#0
 2572: 1  07FF	FD		               mov     r5,a
 2573: 1  0800	EE		               mov     a,r6             ;neem volgende byte
 2574: 1  0801	F4		               cpl     a                 ;complementeer en tel carry erbij
 2575: 1  0802	34 00		               addc    a,#0
 2576: 1  0804	FE		               mov     r6,a
 2577: 1  0805	EF		               mov     a,r7             ;neem volgende byte
 2578: 1  0806	F4		               cpl     a                ;complementeer en tel carry erbij
 2579: 1  0807	34 00		               addc    a,#0
 2580: 1  0809	FF		               mov     r7,a
 2581: 1
 2582: 1  080A	D0 D0		magsig32acc1c: pop     psw
 2583: 1  080C	D0 E0		               pop     acc
 2584: 1  080E	22		               ret
 2585: 1
 2586: 1
 2587: 1			;*******************************************************************************
 2588: 1			; sigmag8acc0        (13,0us @16.777216MHz)
 2589: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2590: 1			; Outputbereik getallen: 00h..80h, f0 als tekenbit
 2591: 1			; input:     r0 = 2's complement byte in acc0
 2592: 1			;                 80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2593: 1			; output:    r0 = absolute waarde
 2594: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2595: 1			;
 2596: 1			; vernietigt: niets
 2597: 1			;*******************************************************************************
 2598: 1
 2599: 1  080F	C0 E0		sigmag8acc0:    push    acc                ;bewaar registers
 2600: 1  0811	C0 D0		                push    psw
 2601: 1  0813	E8		                mov     a,r0               ;neem lsb van acc0
 2602: 1  0814	20 E7 07	                jb      acc.7,sigmag8acc0a ;kijk of het negatief is
 2603: 1  0817	D0 D0		                pop     psw
 2604: 1  0819	C2 D5		                clr     f0                 ;nee, positief...klaar
 2605: 1  081B	D0 E0		                pop     acc
 2606: 1  081D	22		                ret
 2607: 1  081E	F4		sigmag8acc0a:   cpl     a                   ;negatief, bepaal absolute waarde
 2608: 1  081F	04		                inc     a                   ;een erbij
 2609: 1  0820	F8		                mov     r0,a               ;bewaar
 2610: 1  0821	D0 D0		                pop     psw
 2611: 1  0823	D2 D5		                setb    f0                 ;f0=1 als negatief
 2612: 1  0825	D0 E0		                pop     acc
 2613: 1  0827	22		                ret
 2614: 1
 2615: 1			;*******************************************************************************
 2616: 1			; sigmag8acc1        (13,0us @16.777216MHz)
 2617: 1			; 8-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2618: 1			; Outputbereik getallen: 00h..80h, f1 als tekenbit
 2619: 1			; input:     r4 = 2's complement byte in acc1
 2620: 1			;            80h..ffh,0,01h..7fh     (-128d tot  +127d)
 2621: 1			; output:    r4 = absolute waarde

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 45



 Line  I  Addr  Code            Source

 2622: 1			;            Bit f1 = tekenbit (f1=1 als acc0 negatief is)
 2623: 1			;
 2624: 1			; vernietigt: niets
 2625: 1			;*******************************************************************************
 2626: 1
 2627: 1  0828	C0 E0		sigmag8acc1:    push    acc                ;bewaar registers
 2628: 1  082A	C0 D0		                push    psw
 2629: 1  082C	EC		                mov     a,r4               ;neem lsb van acc0
 2630: 1  082D	20 E7 07	                jb      acc.7,sigmag8acc1a ;kijk of het negatief is
 2631: 1  0830	D0 D0		                pop     psw
 2632: 1  0832	C2 D1		                clr     f1                 ;nee, positief...klaar
 2633: 1  0834	D0 E0		                pop     acc
 2634: 1  0836	22		                ret
 2635: 1  0837	F4		sigmag8acc1a:   cpl     a                   ;negatief, bepaal absolute waarde
 2636: 1  0838	04		                inc     a                   ;een erbij
 2637: 1  0839	FC		                mov     r4,a               ;bewaar
 2638: 1  083A	D0 D0		                pop     psw
 2639: 1  083C	D2 D1		                setb    f1                 ;f0=1 als negatief
 2640: 1  083E	D0 E0		                pop     acc
 2641: 1  0840	22		                ret
 2642: 1
 2643: 1			;*******************************************************************************
 2644: 1			; sigmag16acc0        (16,6us @16.777216MHz)
 2645: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2646: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2647: 1			; input:     r1,r0 = 2's complement word in acc0
 2648: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2649: 1			; output:    r1,r0 = absolute waarde
 2650: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2651: 1			;
 2652: 1			; vernietigt: niets
 2653: 1			;*******************************************************************************
 2654: 1
 2655: 1  0841	C0 E0		sigmag16acc0:   push    acc                ;bewaar registers
 2656: 1  0843	C0 D0		                push    psw
 2657: 1  0845	E9		                mov     a,r1               ; neem msb van acc0
 2658: 1  0846	20 E7 07	                jb      acc.7,sigmag16acc0a ;kijk of het negatief is
 2659: 1  0849	D0 D0		                pop     psw
 2660: 1  084B	C2 D5		                clr     f0                 ;f0=0 als positief
 2661: 1  084D	D0 E0		                pop     acc
 2662: 1  084F	22		                ret                        ;klaar
 2663: 1
 2664: 1  0850	E8		sigmag16acc0a:  mov     a,r0               ;getal is negatief
 2665: 1  0851	F4		                cpl     a                  ;complementeren
 2666: 1  0852	24 01		                add     a,#1               ;en een bijtellen
 2667: 1  0854	F8		                mov     r0,a
 2668: 1  0855	E9		                mov     a,r1
 2669: 1  0856	F4		                cpl     a                  ;complement eer volgende byte
 2670: 1  0857	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2671: 1  0859	F9		                mov     r1,a
 2672: 1  085A	D0 D0		                pop     psw
 2673: 1  085C	D2 D5		                setb    f0                 ;f0=1 als negatief
 2674: 1  085E	D0 E0		                pop     acc
 2675: 1  0860	22		                ret
 2676: 1
 2677: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 46



 Line  I  Addr  Code            Source

 2678: 1			;*******************************************************************************
 2679: 1			; sigmag16acc1        (16,6us @16.777216MHz)
 2680: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2681: 1			; Outputbereik getallen: 0000h..8000h, f1 als tekenbit
 2682: 1			; input:     r5,r4 = 2's complement word in acc1
 2683: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2684: 1			; output:    r5,r4 = absolute waarde
 2685: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2686: 1			;
 2687: 1			; vernietigt: niets
 2688: 1			;*******************************************************************************
 2689: 1
 2690: 1  0861	C0 E0		sigmag16acc1:   push    acc                ;bewaar registers
 2691: 1  0863	C0 D0		                push    psw
 2692: 1  0865	ED		                mov     a,r5               ;neem msb van acc1
 2693: 1  0866	20 E7 07	                jb      acc.7,sigmag16acc1a ;kijk of het negatief is
 2694: 1  0869	D0 D0		                pop     psw
 2695: 1  086B	C2 D1		                clr     f1                 ;f1=0 als positief
 2696: 1  086D	D0 E0		                pop    acc
 2697: 1  086F	22		                ret                        ;klaar
 2698: 1
 2699: 1  0870	EC		sigmag16acc1a:  mov     a,r4               ;getal is negatief
 2700: 1  0871	F4		                cpl     a                   ;complementeren
 2701: 1  0872	24 01		                add     a,#1               ;en een bijtellen
 2702: 1  0874	FC		                mov     r4,a
 2703: 1  0875	ED		                mov     a,r5
 2704: 1  0876	F4		                cpl     a                  ;complementeer volgende byte
 2705: 1  0877	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2706: 1  0879	FD		                mov     r5,a
 2707: 1  087A	D0 D0		                pop     psw
 2708: 1  087C	D2 D1		                setb    f1                ;f1=1 als negatief
 2709: 1  087E	D0 E0		                pop     acc
 2710: 1  0880	22		                ret
 2711: 1
 2712: 1
 2713: 1			;*******************************************************************************
 2714: 1			; sigmag16acc1h        (16,6us @16.777216MHz)
 2715: 1			; 16-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2716: 1			; Outputbereik getallen: 0000h..8000h, f0 als tekenbit
 2717: 1			; input:     r7,r6 = 2's complement word in acc1 high word
 2718: 1			;            8000h..ffff,0,1..7fffh (-32768 tot  +32767)
 2719: 1			; output:    r7,r6 = absolute waarde
 2720: 1			;            Bit f0 = tekenbit (f0=1 als acc1 high word negatief is)
 2721: 1			;
 2722: 1			; vernietigt: niets
 2723: 1			;*******************************************************************************
 2724: 1
 2725: 1  0881	C0 E0		sigmag16acc1h:  push    acc                 ;bewaar registers
 2726: 1  0883	C0 D0		                push    psw
 2727: 1  0885	EF		                mov     a,r7                ; neem msb van acc1 high
 2728: 1  0886	20 E7 07	                jb      acc.7,sigmag16acc1ha ;kijk of het negatief is
 2729: 1  0889	D0 D0		                pop     psw
 2730: 1  088B	C2 D5		                clr     f0                  ;f0=0 als positief
 2731: 1  088D	D0 E0		                pop     acc
 2732: 1  088F	22		                ret                         ;klaar
 2733: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 47



 Line  I  Addr  Code            Source

 2734: 1  0890	EE		sigmag16acc1ha: mov     a,r6               ;getal is negatief
 2735: 1  0891	F4		                cpl     a                   ;complementeren
 2736: 1  0892	24 01		                add     a,#1               ;en een bijtellen
 2737: 1  0894	FE		                mov     r6,a
 2738: 1  0895	EF		                mov     a,r7
 2739: 1  0896	F4		                cpl     a                  ;complementeer volgende byte
 2740: 1  0897	34 00		                addc    a,#0               ;carry bij volgende byte tellen
 2741: 1  0899	FF		                mov     r7,a
 2742: 1  089A	D0 D0		                pop     psw
 2743: 1  089C	D2 D5		                setb    f0                ;f0=1 als negatief
 2744: 1  089E	D0 E0		                pop     acc
 2745: 1  08A0	22		                ret
 2746: 1
 2747: 1
 2748: 1			;*******************************************************************************
 2749: 1			; sigmag32acc0        (22,2us @16.777216MHz)
 2750: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2751: 1			; Outputbereik getallen: 00000000h..80000000h, f0 als tekenbit
 2752: 1			;
 2753: 1			; input:     r3,r2,r1,r0 = 2's complement longword in acc0
 2754: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2755: 1			;            (-2147483648 tot +2147483647)
 2756: 1			; output:    r3,r2,r1,r0 = absolute waarde
 2757: 1			;            Bit f0 = tekenbit (f0=1 als acc0 negatief is)
 2758: 1			;
 2759: 1			; vernietigt: niets
 2760: 1			;*******************************************************************************
 2761: 1
 2762: 1  08A1	C0 E0		sigmag32acc0:   push    acc                ;bewaar registers
 2763: 1  08A3	C0 D0		                push    psw
 2764: 1  08A5	EB		                mov     a,r3               ;neem msb van acc0
 2765: 1  08A6	20 E7 07	                jb      acc.7,sigmag32acc0a  ;kijk of het getal negatief is
 2766: 1  08A9	D0 D0		                pop     psw                ;nee, positief
 2767: 1  08AB	C2 D5		                clr     f0
 2768: 1  08AD	D0 E0		                pop     acc
 2769: 1  08AF	22		                ret                        ;klaar
 2770: 1
 2771: 1  08B0	E8		sigmag32acc0a:  mov     a,r0               ;getal is negatief
 2772: 1  08B1	F4		                cpl     a                  ;complementeren
 2773: 1  08B2	24 01		                add     a,#1               ;en een bijtellen
 2774: 1  08B4	F8		                mov     r0,a
 2775: 1  08B5	E9		                mov     a,r1               ;neem volgende byte
 2776: 1  08B6	F4		                cpl     a                  ;complementeer volgende byte
 2777: 1  08B7	34 00		                addc    a,#0
 2778: 1  08B9	F9		                mov     r1,a
 2779: 1  08BA	EA		                mov     a,r2               ;neem volgende byte
 2780: 1  08BB	F4		                cpl     a                  ;complementeer volgende byte
 2781: 1  08BC	34 00		                addc    a,#0
 2782: 1  08BE	FA		                mov     r2,a
 2783: 1  08BF	EB		                mov     a,r3               ;neem volgende byte
 2784: 1  08C0	F4		                cpl     a                  ;complementeer volgende byte
 2785: 1  08C1	34 00		                addc    a,#0
 2786: 1  08C3	FB		                mov     r3,a
 2787: 1  08C4	D0 D0		                pop     psw
 2788: 1  08C6	D2 D5		                setb    f0                 ;negatief: f0=1
 2789: 1  08C8	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 48



 Line  I  Addr  Code            Source

 2790: 1  08CA	22		                ret                        ;klaar
 2791: 1
 2792: 1			;*******************************************************************************
 2793: 1			; sigmag32acc1        (22,2us @16.777216MHz)
 2794: 1			; 32-Bit signed (2's Complement) omzetting naar magnitude / Sign Bit Conversion
 2795: 1			; Outputbereik getallen: 00000000h..80000000h, f1 als tekenbit
 2796: 1			;
 2797: 1			; input:     r7,r6,r5,r4 = 2's complement longword in acc1
 2798: 1			;            80000000h..ffffffffh,0,00000001h..7fffffffh
 2799: 1			;            (-2147483648 tot +2147483647)
 2800: 1			; output:    r7,r6,r5,r4 = absolute waarde
 2801: 1			;            Bit f1 = tekenbit (f1=1 als acc1 negatief is)
 2802: 1			;
 2803: 1			; vernietigt: niets
 2804: 1			;*******************************************************************************
 2805: 1
 2806: 1  08CB	C0 E0		sigmag32acc1:   push    acc                ;bewaar registers
 2807: 1  08CD	C0 D0		                push    psw
 2808: 1  08CF	EF		                mov     a,r7               ;neem msb van acc0
 2809: 1  08D0	20 E7 07	                jb      acc.7,sigmag32acc1a  ;kijk of het getal negatief is
 2810: 1  08D3	D0 D0		                pop     psw                ;nee, positief
 2811: 1  08D5	C2 D1		                clr     f1
 2812: 1  08D7	D0 E0		                pop     acc
 2813: 1  08D9	22		                ret                        ;klaar
 2814: 1
 2815: 1  08DA	EC		sigmag32acc1a:  mov     a,r4               ;getal is negatief
 2816: 1  08DB	F4		                cpl     a                   ;complementeren
 2817: 1  08DC	24 01		                add     a,#1               ;en een bijtellen
 2818: 1  08DE	FC		                mov     r4,a
 2819: 1  08DF	ED		                mov     a,r5               ;neem volgende byte
 2820: 1  08E0	F4		                cpl     a                  ;complementeer volgende byte
 2821: 1  08E1	34 00		                addc    a,#0
 2822: 1  08E3	FD		                mov     r5,a
 2823: 1  08E4	EE		                mov     a,r6               ;neem volgende byte
 2824: 1  08E5	F4		                cpl     a                  ;complementeer volgende byte
 2825: 1  08E6	34 00		                addc    a,#0
 2826: 1  08E8	FE		                mov     r6,a
 2827: 1  08E9	EF		                mov     a,r7               ;neem volgende byte
 2828: 1  08EA	F4		                cpl     a                  ;complementeer volgende byte
 2829: 1  08EB	34 00		                addc    a,#0
 2830: 1  08ED	FF		                mov     r7,a
 2831: 1  08EE	D0 D0		                pop     psw
 2832: 1  08F0	D2 D1		                setb    f1                 ;negatief: f0=1
 2833: 1  08F2	D0 E0		                pop     acc
 2834: 1  08F4	22		                ret                        ;klaar
 2835: 1
 2836: 1
 2837: 1			;*******************************************************************************
 2838: 1			; s_add16        (19,35us @16.777216MHz)
 2839: 1			; 16-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2840: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 2841: 1			; input:     r1,r0 = acc0
 2842: 1			;            r5,r4 = acc1
 2843: 1			;
 2844: 1			; output:    r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2845: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 49



 Line  I  Addr  Code            Source

 2846: 1			;                  gebruik van r3,r2 is niet nodig
 2847: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 2848: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 2849: 1			;
 2850: 1			; vernietigt:  niets
 2851: 1			;*******************************************************************************
 2852: 1  08F5	C0 E0		s_add16:       push    acc            ;bewaar gebruikte registers
 2853: 1  08F7	C0 D0		               push    psw
 2854: 1
 2855: 1  08F9	E8		               mov     a,r0           ;tel de soft accumulators op
 2856: 1  08FA	2C		               add     a,r4           ;low byte eerst
 2857: 1  08FB	F8		               mov     r0,a           ;resultaat bewaren
 2858: 1  08FC	E9		               mov     a,r1           ;nu de high bytes
 2859: 1  08FD	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2860: 1  08FE	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2861: 1
 2862: 1  08FF	92 D5		               mov     f0,c
 2863: 1  0901	A2 D2		               mov     c,ov          ;bewaar overflow flag voor sign extention
 2864: 1  0903	92 D1		               mov     f1,c
 2865: 1  0905	A2 D5		               mov     c,f0           ;herstel carrybit
 2866: 1
 2867: 1  0907	74 00		               mov     a,#00h
 2868: 1  0909	34 00		               addc    a,#00h
 2869: 1  090B	FA		               mov     r2,a            ;24bit resultaat klaar
 2870: 1
 2871: 1  090C	30 D1 14	               jnb     f1,s_add163     ;bij overflow, sign extention toepassen
 2872: 1
 2873: 1  090F	EA		               mov     a,r2            ;ja, sign extention toepassen!
 2874: 1  0910	30 E0 06	               jnb     acc.0,s_add161  ;als lsb van r2=0, dan r3,r2=0000h
 2875: 1  0913	7A FF		               mov     r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 2876: 1  0915	7B FF		               mov     r3,#0ffh
 2877: 1  0917	80 04		               sjmp    s_add162
 2878: 1  0919	7A 00		s_add161:      mov     r2,#00h
 2879: 1  091B	7B 00		               mov     r3,#00h
 2880: 1  091D	D0 D0		s_add162:      pop     psw
 2881: 1  091F	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2882: 1  0920	D0 E0		               pop     acc             ;resultaat groter is dan 16bits!
 2883: 1  0922	22		               ret
 2884: 1
 2885: 1  0923	D0 D0		s_add163:      pop     psw             ;binnen 16bit bereik!geen overflow
 2886: 1  0925	C3		               clr     c
 2887: 1  0926	D0 E0		               pop     acc
 2888: 1  0928	22		               ret
 2889: 1
 2890: 1			;*******************************************************************************
 2891: 1			; add16        (13,6us @16.777216MHz)
 2892: 1			; 16-Bit Unsigned optelling (acc0 = acc0+acc1)
 2893: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 2894: 1			; input:     r1,r0 = acc0
 2895: 1			;            r5,r4 = acc1
 2896: 1			;
 2897: 1			; output:    (r2),r1,r0 = acc0 = acc0+acc1
 2898: 1			;            indien het resultaat groter wordt dan 16 bit, r2 als msb gebruiken
 2899: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 2900: 1			;                  gebruik van meer beduidende byte (r2=0) is niet nodig
 2901: 1			;            CY=1 :het resultaat is groter dan 16bit (buiten bereik) dus ook de

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 50



 Line  I  Addr  Code            Source

 2902: 1			;                  meer beduidende byte (r2) van het resultaat gebruiken
 2903: 1			;
 2904: 1			; vernietigt:  niets
 2905: 1			;*******************************************************************************
 2906: 1
 2907: 1  0929	C0 E0		add16:         push    acc            ;bewaar gebruikte registers
 2908: 1  092B	C0 D0		               push    psw
 2909: 1  092D	E8		               mov     a,r0           ;tel de soft accumulators op
 2910: 1  092E	2C		               add     a,r4           ;low byte eerst
 2911: 1  092F	F8		               mov     r0,a           ;resultaat bewaren
 2912: 1  0930	E9		               mov     a,r1           ;nu de high bytes
 2913: 1  0931	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2914: 1  0932	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2915: 1  0933	50 08		               jnc     add161          ;geen 24 bit resultaat
 2916: 1
 2917: 1  0935	7A 01		               mov     r2,#01h         ;24bit resultaat klaar
 2918: 1  0937	D0 D0		               pop     psw
 2919: 1  0939	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2920: 1  093A	D0 E0		               pop     acc             ;resultaat 24 bits groot is
 2921: 1  093C	22		               ret
 2922: 1
 2923: 1  093D	7A 00		add161:        mov     r2,#00h
 2924: 1  093F	D0 D0		               pop     psw
 2925: 1  0941	C3		               clr     c               ;aangeven aan de gebruiker dat het
 2926: 1  0942	D0 E0		               pop     acc             ;resultaat 16 bits groot is
 2927: 1  0944	22		               ret
 2928: 1
 2929: 1			;*******************************************************************************
 2930: 1			; s_add32        (28,0us @16.777216MHz)
 2931: 1			; 32-Bit Signed (2's Complement) optelling (acc0=acc0+acc1)
 2932: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 2933: 1			;                      (80000000h..ffffffffh,0,00000001h..7fffffffh)
 2934: 1			; input:     r3,r2,r1,r0 = acc0
 2935: 1			;            r7,r6,r5,r4 = acc1
 2936: 1			;
 2937: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1  met teken
 2938: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2939: 1			;                  gebruik van een meer beduidende byte (r4=0) is niet nodig
 2940: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 2941: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 2942: 1			;
 2943: 1			; vernietigt:  niets
 2944: 1			;*******************************************************************************
 2945: 1  0945	C0 E0		s_add32:       push    acc             ;bewaar gebruikte registers
 2946: 1  0947	C0 D0		               push    psw
 2947: 1
 2948: 1  0949	E8		               mov     a,r0           ;tel de soft accumulators op
 2949: 1  094A	2C		               add     a,r4           ;low byte eerst
 2950: 1  094B	F8		               mov     r0,a           ;resultaat bewaren
 2951: 1  094C	E9		               mov     a,r1           ;nu de hogere bytes
 2952: 1  094D	3D		               addc    a,r5           ;optellen met eventuele overdracht
 2953: 1  094E	F9		               mov     r1,a           ;16 bit resultaat is klaar
 2954: 1
 2955: 1  094F	EA		               mov     a,r2           ;derde bytes optellen
 2956: 1  0950	3E		               addc    a,r6           ;optellen met eventuele overdracht
 2957: 1  0951	FA		               mov     r2,a           ;24bit resultaat is klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 51



 Line  I  Addr  Code            Source

 2958: 1  0952	EB		               mov     a,r3           ;nu de ms bytes
 2959: 1  0953	3F		               addc    a,r7           ;optellen met eventuele overdracht
 2960: 1  0954	FB		               mov     r3,a           ;32 bit resultaat is klaar
 2961: 1
 2962: 1  0955	92 D5		               mov     f0,c
 2963: 1  0957	A2 D2		               mov     c,ov           ;bewaar overflow flag voor sign extention
 2964: 1  0959	92 D1		               mov     f1,c
 2965: 1  095B	A2 D5		               mov     c,f0           ;herstel carrybit
 2966: 1
 2967: 1  095D	74 00		               mov     a,#00h
 2968: 1  095F	34 00		               addc    a,#00h
 2969: 1  0961	FC		               mov     r4,a            ;40bit resultaat klaar
 2970: 1
 2971: 1  0962	30 D1 10	               jnb     f1,s_add323     ;als overflow, sign extention toepassen
 2972: 1  0965	EC		               mov     a,r4            ;ja, sign extention toepassen!
 2973: 1  0966	30 E0 04	               jnb     acc.0,s_add321  ;als lsb van r4=0, dan r4=00h
 2974: 1  0969	7C FF		               mov     r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 2975: 1  096B	80 02		               sjmp    s_add322
 2976: 1  096D	7C 00		s_add321:      mov     r4,#00h
 2977: 1  096F	D0 D0		s_add322:      pop     psw
 2978: 1  0971	D3		               setb    c               ;aangeven aan de gebruiker dat het
 2979: 1  0972	D0 E0		               pop     acc             ;resultaat groter is dan 32bits!
 2980: 1  0974	22		               ret
 2981: 1
 2982: 1  0975	D0 D0		s_add323:      pop     psw             ;binnen 32bit bereik!
 2983: 1  0977	C3		               clr     c
 2984: 1  0978	D0 E0		               pop     acc
 2985: 1  097A	22		               ret
 2986: 1
 2987: 1
 2988: 1			;*******************************************************************************
 2989: 1			; add32        (18,0us @16.777216MHz)
 2990: 1			; 32-Bit Unsigned optelling (acc0 = acc0+acc1)
 2991: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 2992: 1			; input:     r3,r2,r1,r0 = acc0
 2993: 1			;            r7,r6,r5,r4 = acc1
 2994: 1			;
 2995: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0+acc1
 2996: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 2997: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 2998: 1			;                  gebruik van meer beduidende byte (r4=0) is niet nodig
 2999: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3000: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3001: 1			;
 3002: 1			; vernietigt:  niets
 3003: 1			;*******************************************************************************
 3004: 1  097B	C0 E0		add32:         push    acc             ;bewaar gebruikte registers
 3005: 1  097D	C0 D0		               push    psw
 3006: 1  097F	E8		               mov     a,r0           ;tel de soft accumulators op
 3007: 1  0980	2C		               add     a,r4           ;low byte eerst
 3008: 1  0981	F8		               mov     r0,a           ;resultaat bewaren
 3009: 1  0982	E9		               mov     a,r1           ;nu de hogere bytes
 3010: 1  0983	3D		               addc    a,r5           ;optellen met eventuele overdracht
 3011: 1  0984	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3012: 1
 3013: 1  0985	EA		               mov     a,r2           ;derde bytes optellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 52



 Line  I  Addr  Code            Source

 3014: 1  0986	3E		               addc    a,r6           ;optellen met eventuele overdracht
 3015: 1  0987	FA		               mov     r2,a           ;24bit resultaat is klaar
 3016: 1  0988	EB		               mov     a,r3           ;nu de ms bytes
 3017: 1  0989	3F		               addc    a,r7           ;optellen met eventuele overdracht
 3018: 1  098A	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3019: 1
 3020: 1  098B	50 08		               jnc     add321          ;geen 40 bit resultaat
 3021: 1
 3022: 1  098D	7C 01		               mov     r4,#01h         ;40bit resultaat klaar
 3023: 1  098F	D0 D0		               pop     psw
 3024: 1  0991	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3025: 1  0992	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3026: 1  0994	22		               ret
 3027: 1
 3028: 1  0995	7C 00		add321:        mov     r4,#00h
 3029: 1  0997	D0 D0		               pop     psw
 3030: 1  0999	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3031: 1  099A	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3032: 1  099C	22		               ret
 3033: 1
 3034: 1
 3035: 1			;*******************************************************************************
 3036: 1			; s_sub16        (24,4us @16.777216MHz)
 3037: 1			; 16-Bit Signed (2's Complement) verschil (acc0=acc0-acc1)
 3038: 1			; Inputbereik getallen: -32768 tot  +32767 (8000h..ffff,0,1..7fffh)
 3039: 1			; input:     r1,r0 = acc0
 3040: 1			;            r5,r4 = acc1
 3041: 1			;
 3042: 1			; output:    r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3043: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3044: 1			;                  gebruik van r3,r2 is niet nodig
 3045: 1			;            CY=1 :als het resultaat groter werd dan 16bit (buiten bereik) dan,
 3046: 1			;                  meer beduidende bytes (r3,r2) van het resultaat ook gebruiken
 3047: 1			;
 3048: 1			; vernietigt:  niets
 3049: 1			;*******************************************************************************
 3050: 1  099D	C0 E0		s_sub16:        push    acc             ;bewaar gebruikte registers
 3051: 1  099F	C0 D0		                push    psw
 3052: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3053: 1
 3054: 1  09A1	EC		                mov   	a,r4            ;verander het teken van acc1
 3055: 1  09A2	F4		                cpl    	a               ;door het 2's complement te nemen
 3056: 1  09A3	24 01		                add   	a,#1
 3057: 1  09A5	FC		                mov    	r4,a
 3058: 1  09A6	ED		                mov    	a,r5
 3059: 1  09A7	F4		                cpl    	a
 3060: 1  09A8	34 00		                addc	a,#0
 3061: 1  09AA	FD		                mov    	r5,a
 3062: 1			;acc0+acc1
 3063: 1  09AB	E8						mov		a,r0
 3064: 1  09AC	2C						add		a,r4
 3065: 1  09AD	F8						mov		r0,a
 3066: 1  09AE	E9						mov		a,r1
 3067: 1  09AF	3D						addc	a,r5
 3068: 1  09B0	F9						mov		r1,a
 3069: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 53



 Line  I  Addr  Code            Source

 3070: 1  09B1	92 D5		                mov    f0,c
 3071: 1  09B3	A2 D2		                mov    c,ov          ;bewaar overflow flag voor sign extention
 3072: 1  09B5	92 D1		                mov    f1,c
 3073: 1  09B7	A2 D5		                mov    c,f0            ;herstel carrybit
 3074: 1
 3075: 1  09B9	74 00		                mov    a,#00h
 3076: 1  09BB	34 00		                addc   a,#00h
 3077: 1  09BD	FA		                mov    r2,a            ;24bit resultaat klaar
 3078: 1
 3079: 1  09BE	30 D1 14	                jnb    f1,s_sub163     ;als overflow;sign extention toepassen
 3080: 1  09C1	EA		                mov    a,r2            ;ja, sign extention toepassen!
 3081: 1  09C2	30 E0 06	                jnb    acc.0,s_sub161  ;als lsb van r2=0, dan r3,r2=0000h
 3082: 1  09C5	7A FF		                mov    r2,#0ffh        ;als lsb van r2=1, dan r3,r2=ffffh
 3083: 1  09C7	7B FF		                mov    r3,#0ffh
 3084: 1  09C9	80 04		                sjmp   s_sub162
 3085: 1  09CB	7A 00		s_sub161:       mov    r2,#00h
 3086: 1  09CD	7B 00		                mov    r3,#00h
 3087: 1  09CF	D0 D0		s_sub162:       pop    psw
 3088: 1  09D1	D3		                setb   c               ;aangeven aan de gebruiker dat het
 3089: 1  09D2	D0 E0		                pop    acc             ;resultaat groter is dan 16bits!
 3090: 1  09D4	22		                ret
 3091: 1
 3092: 1  09D5	D0 D0		s_sub163:       pop    psw             ;binnen 16bit bereik!geen overflow
 3093: 1  09D7	C3		                clr    c
 3094: 1  09D8	D0 E0		                pop    acc
 3095: 1  09DA	22		                ret
 3096: 1
 3097: 1			;*******************************************************************************
 3098: 1			; sub16            (14,4us @16.777216MHz)
 3099: 1			; 16-Bit Unsigned verschil (acc0 = acc0-acc1)
 3100: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3101: 1			; input:     r1,r0 = acc0
 3102: 1			;            r5,r4 = acc1
 3103: 1			;
 3104: 1			; output:    (r2),r1,r0 = acc0 = acc0-acc1
 3105: 1			;            bij een underflow r2 op ffh zetten
 3106: 1			;            CY=0 :het resultaat zit binnen het 16bit bereik
 3107: 1			;                  gebruik van meer beduidende byte (r2) is niet nodig
 3108: 1			;            CY=1 :underflow, het resultaat is negatief (buiten bereik)
 3109: 1			;                  de meer beduidende byte (r2) van het resultaat staat op ffh
 3110: 1			;
 3111: 1			; vernietigt:  niets
 3112: 1			;*******************************************************************************
 3113: 1
 3114: 1  09DB	C0 E0		sub16:          push    acc             ;bewaar gebruikte registers
 3115: 1  09DD	C0 D0		                push    psw
 3116: 1  09DF	C3		                clr     c
 3117: 1  09E0	E8		                mov     a,r0            ;tel de soft accumulators op
 3118: 1  09E1	9C		                subb    a,r4            ;low byte eerst
 3119: 1  09E2	F8		                mov     r0,a            ;resultaat bewaren
 3120: 1  09E3	E9		                mov     a,r1            ;nu de high bytes
 3121: 1  09E4	9D		                subb    a,r5            ;verschil met eventuele overdracht
 3122: 1  09E5	F9		                mov    r1,a             ;16 bit resultaat is klaar
 3123: 1  09E6	50 08		                jnc    sub161           ;geen 24 bit resultaat
 3124: 1
 3125: 1  09E8	7A FF		                mov     r2,#0ffh        ;24bit resultaat klaar

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 54



 Line  I  Addr  Code            Source

 3126: 1  09EA	D0 D0		                pop     psw
 3127: 1  09EC	D3		                setb    c               ;aangeven aan de gebruiker dat het
 3128: 1  09ED	D0 E0		                pop     acc             ;resultaat 24 bits groot is
 3129: 1  09EF	22		                ret
 3130: 1
 3131: 1  09F0	7A 00		sub161:         mov     r2,#00h
 3132: 1  09F2	D0 D0		                pop     psw
 3133: 1  09F4	C3		                clr     c               ;aangeven aan de gebruiker dat het
 3134: 1  09F5	D0 E0		                pop     acc             ;resultaat 16 bits groot is
 3135: 1  09F7	22		                ret
 3136: 1
 3137: 1			;*******************************************************************************
 3138: 1			; s_sub32        (27,2us @16.777216MHz)
 3139: 1			; 32-Bit Signed (2's Complement) verschil (acc0=acc0+acc1)
 3140: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3141: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3142: 1			; input:     r3,r2,r1,r0 = acc0
 3143: 1			;            r7,r6,r5,r4 = acc1
 3144: 1			;
 3145: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1  met teken
 3146: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3147: 1			;                  gebruik van r4 is niet nodig
 3148: 1			;            CY=1 :als het resultaat groter werd dan 32bit (buiten bereik) dan,
 3149: 1			;                  de meer beduidende byte (r4) van het resultaat ook gebruiken
 3150: 1			;
 3151: 1			; vernietigt:  niets
 3152: 1			;*******************************************************************************
 3153: 1  09F8	C0 E0		s_sub32:        push   acc             ;bewaar gebruikte registers
 3154: 1  09FA	C0 D0		                push   psw
 3155: 1
 3156: 1			;maak 2's complement van acc1, dan kunnen we acc0 en acc1 optellen!
 3157: 1
 3158: 1  09FC	EC		                mov    	a,r4            ;verander het teken van acc1
 3159: 1  09FD	F4		                cpl    	a               ;door het 2's complement te nemen
 3160: 1  09FE	24 01		                add    	a,#1
 3161: 1  0A00	FC		                mov    	r4,a
 3162: 1  0A01	ED		                mov    	a,r5
 3163: 1  0A02	F4		                cpl    	a
 3164: 1  0A03	34 00		                addc	a,#0
 3165: 1  0A05	FD		                mov    	r5,a
 3166: 1  0A06	EE		                mov    	a,r6
 3167: 1  0A07	F4		                cpl    	a
 3168: 1  0A08	34 00		                addc   	a,#0
 3169: 1  0A0A	FE		                mov    	r6,a
 3170: 1  0A0B	EF		                mov    	a,r7
 3171: 1  0A0C	F4		                cpl    	a
 3172: 1  0A0D	34 00		                addc   	a,#0
 3173: 1  0A0F	FF		                mov    	r7,a
 3174: 1			;acc0+acc1
 3175: 1  0A10	E8						mov		a,r0
 3176: 1  0A11	2C						add		a,r4
 3177: 1  0A12	F8						mov		r0,a
 3178: 1  0A13	E9						mov		a,r1
 3179: 1  0A14	3D						addc	a,r5
 3180: 1  0A15	F9						mov		r1,a
 3181: 1  0A16	EA						mov		a,r2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 55



 Line  I  Addr  Code            Source

 3182: 1  0A17	3E						addc	a,r6
 3183: 1  0A18	FA						mov		r2,a
 3184: 1  0A19	EB						mov		a,r3
 3185: 1  0A1A	3F						addc	a,r7
 3186: 1  0A1B	FB						mov		r3,a
 3187: 1
 3188: 1  0A1C	92 D5		                mov   f0,c
 3189: 1  0A1E	A2 D2		                mov   c,ov            ;bewaar overflow flag voor sign extention
 3190: 1  0A20	92 D1		                mov   f1,c
 3191: 1  0A22	A2 D5		                mov   c,f0            ;herstel carrybit
 3192: 1
 3193: 1  0A24	74 00		                mov   a,#00h
 3194: 1  0A26	34 00		                addc  a,#00h
 3195: 1  0A28	FC		                mov   r4,a            ;40bit resultaat klaar
 3196: 1
 3197: 1  0A29	30 D1 10	                jnb  f1,s_sub323      ;bij overflow, sign extention toepassen
 3198: 1
 3199: 1  0A2C	EC		                mov   a,r4            ;ja, sign extention toepassen!
 3200: 1  0A2D	30 E0 04	                jnb   acc.0,s_sub321  ;als lsb van r4=0, dan r4=00h
 3201: 1  0A30	7C FF		                mov   r4,#0ffh        ;als lsb van r4=1, dan r4=ffh
 3202: 1  0A32	80 02		                sjmp   s_sub322
 3203: 1  0A34	7C 00		s_sub321:       mov   r4,#00h
 3204: 1  0A36	D0 D0		s_sub322:       pop   psw
 3205: 1  0A38	D3		                setb  c                ;aangeven aan de gebruiker dat het
 3206: 1  0A39	D0 E0		                pop   acc               ;resultaat groter is dan 32bits!
 3207: 1  0A3B	22		                ret
 3208: 1
 3209: 1  0A3C	D0 D0		s_sub323:       pop   psw              ;binnen 32bit bereik!geen overflow
 3210: 1  0A3E	C3		                clr   c
 3211: 1  0A3F	D0 E0		                pop   acc
 3212: 1  0A41	22		                ret
 3213: 1
 3214: 1
 3215: 1			;*******************************************************************************
 3216: 1			; sub32        (18,7us @16.777216MHz)
 3217: 1			; 32-Bit Unsigned verschil (acc0 = acc0-acc1)
 3218: 1			; Inputbereik getallen: 0 tot  +4294967295  (00000000h...ffffffffh)
 3219: 1			; input:     r3,r2,r1,r0 = acc0
 3220: 1			;            r7,r6,r5,r4 = acc1
 3221: 1			;
 3222: 1			; output:    (r4),r3,r2,r1,r0 = acc0 = acc0-acc1
 3223: 1			;            indien het resultaat groter wordt dan 32 bit, r4 als msb gebruiken
 3224: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3225: 1			;                  gebruik van meer beduidende byte (r4) is niet nodig
 3226: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik) dus ook de
 3227: 1			;                  meer beduidende byte (r4) van het resultaat gebruiken
 3228: 1			;
 3229: 1			; vernietigt:  niets
 3230: 1			;*******************************************************************************
 3231: 1  0A42	C0 E0		sub32:         push    acc            ;bewaar gebruikte registers
 3232: 1  0A44	C0 D0		               push    psw
 3233: 1  0A46	C3		               clr       c
 3234: 1  0A47	E8		               mov     a,r0           ;maak verschil van de soft accumulators
 3235: 1  0A48	9C		               subb    a,r4           ;low byte eerst
 3236: 1  0A49	F8		               mov     r0,a           ;resultaat bewaren
 3237: 1  0A4A	E9		               mov     a,r1           ;nu de hogere bytes

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 56



 Line  I  Addr  Code            Source

 3238: 1  0A4B	9D		               subb    a,r5           ;verschil met eventuele overdracht
 3239: 1  0A4C	F9		               mov     r1,a           ;16 bit resultaat is klaar
 3240: 1
 3241: 1  0A4D	EA		               mov     a,r2           ;derde bytes optellen
 3242: 1  0A4E	9E		               subb    a,r6           ;verschil met eventuele overdracht
 3243: 1  0A4F	FA		               mov     r2,a           ;24bit resultaat is klaar
 3244: 1  0A50	EB		               mov     a,r3           ;nu de ms bytes
 3245: 1  0A51	9F		               subb    a,r7           ;verschil met eventuele overdracht
 3246: 1  0A52	FB		               mov     r3,a           ;32 bit resultaat is klaar
 3247: 1
 3248: 1  0A53	50 08		               jnc     sub321         ;geen 40 bit resultaat
 3249: 1
 3250: 1  0A55	7C FF		               mov     r4,#0ffh       ;40bit resultaat klaar
 3251: 1  0A57	D0 D0		               pop     psw
 3252: 1  0A59	D3		               setb    c               ;aangeven aan de gebruiker dat het
 3253: 1  0A5A	D0 E0		               pop     acc             ;resultaat 40 bits groot is
 3254: 1  0A5C	22		               ret
 3255: 1
 3256: 1  0A5D	7C 00		sub321:        mov     r4,#00h
 3257: 1  0A5F	D0 D0		               pop     psw
 3258: 1  0A61	C3		               clr     c               ;aangeven aan de gebruiker dat het
 3259: 1  0A62	D0 E0		               pop     acc             ;resultaat 32 bits groot is
 3260: 1  0A64	22		               ret
 3261: 1
 3262: 1
 3263: 1
 3264: 1			;*******************************************************************************
 3265: 1			; mul16        (71,2us @16.777216MHz)
 3266: 1			; 16-Bit Unsigned product (acc0 = acc0 x acc1) naar 32bit resultaat
 3267: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3268: 1			; input:     r1,r0 = acc0
 3269: 1			;            r5,r4 = acc1
 3270: 1			;
 3271: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3272: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3273: 1			;
 3274: 1			; vernietigt:  niets
 3275: 1			;*******************************************************************************
 3276: 1  0A65	C0 E0		mul16:          push    acc                ;bewaar de gebruikte registers
 3277: 1  0A67	C0 D0		                push    psw
 3278: 1  0A69	C0 F0		                push    b
 3279: 1  0A6B	C0 82		                push    dpl
 3280: 1  0A6D	C0 83		                push    dph
 3281: 1
 3282: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3283: 1
 3284: 1  0A6F	88 82		                mov     dpl,r0          ;verplaats r0 en r1 naar datapointer
 3285: 1  0A71	89 83		                mov     dph,r1
 3286: 1  0A73	A8 81		                mov     r0,sp           ;r0 = tussenresultaatpointer
 3287: 1  0A75	08		                inc     r0              ;pointer naar eerste vrije plaats
 3288: 1  0A76	A9 81		                mov     r1,sp           ;stackpointer bewaren tot einde
 3289: 1  0A78	E5 81		                mov     a,sp            ;plaats alloceren
 3290: 1  0A7A	24 03		                add     a,#3            ;3 bytes nodig
 3291: 1  0A7C	F5 81		                mov     sp,a            ;stackpointer verzetten
 3292: 1
 3293: 1  0A7E	E5 82		                mov     a,dpl            ;acc0 lsb

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 57



 Line  I  Addr  Code            Source

 3294: 1  0A80	8C F0		                mov     b,r4            ;acc1 lsb
 3295: 1  0A82	A4		                mul     ab
 3296: 1  0A83	F6		                mov     @r0,a            ;bewaar lsb resultaat
 3297: 1  0A84	08		                inc     r0
 3298: 1  0A85	A6 F0		                mov     @r0,b            ;bewaar tussenresultaat
 3299: 1
 3300: 1  0A87	E5 83		                mov     a,dph            ;acc0 msb
 3301: 1  0A89	8C F0		                mov     b,r4            ;acc1 lsb
 3302: 1  0A8B	A4		                mul     ab
 3303: 1
 3304: 1  0A8C	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3305: 1  0A8D	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3306: 1  0A8E	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3307: 1  0A90	34 00		                addc    a,#0
 3308: 1  0A92	08		                inc     r0               ;bewaar als tussenresultaat
 3309: 1  0A93	F6		                mov     @r0,a
 3310: 1
 3311: 1  0A94	E5 82		                mov     a,dpl            ;acc0 lsb
 3312: 1  0A96	8D F0		                mov     b,r5             ;acc1 msb
 3313: 1  0A98	A4		                mul     ab
 3314: 1  0A99	18		                dec     r0
 3315: 1  0A9A	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3316: 1  0A9B	F6		                mov     @r0,a            ;en bewaar weer
 3317: 1  0A9C	08		                inc     r0
 3318: 1  0A9D	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3319: 1  0A9F	36		                addc    a,@r0
 3320: 1  0AA0	F6		                mov     @r0,a            ;en bewaar weer
 3321: 1  0AA1	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3322: 1
 3323: 1  0AA3	E5 83		                mov     a,dph            ;acc0 msb
 3324: 1  0AA5	8D F0		                mov     b,r5             ;acc1 msb
 3325: 1  0AA7	A4		                mul     AB
 3326: 1  0AA8	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3327: 1  0AA9	FA		                mov     r2,a
 3328: 1  0AAA	E5 F0		                mov     a,b
 3329: 1  0AAC	34 00		                addc    a,#0
 3330: 1
 3331: 1  0AAE	A2 D5		                mov     c,f0             ;tel opgeslagen carry hier ook nog bij
 3332: 1  0AB0	34 00		                addc    a,#0
 3333: 1
 3334: 1  0AB2	FB		                mov     r3,a         ;product is klaar, outputregisters vullen
 3335: 1  0AB3	18		                dec     r0
 3336: 1  0AB4	86 83		                mov     dph,@r0
 3337: 1  0AB6	18		                dec     r0
 3338: 1  0AB7	86 82		                mov     dpl,@r0
 3339: 1
 3340: 1  0AB9	89 81		                mov     sp,r1            ;zet stackpointer terug
 3341: 1  0ABB	A9 83		                mov     r1,dph
 3342: 1  0ABD	A8 82		                mov     r0,dpl
 3343: 1
 3344: 1  0ABF	D0 83		                pop     dph              ;herstel de bewaarde registers
 3345: 1  0AC1	D0 82		                pop     dpl
 3346: 1  0AC3	D0 F0		                pop     b
 3347: 1  0AC5	D0 D0		                pop     psw
 3348: 1  0AC7	D0 E0		                pop     acc
 3349: 1  0AC9	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 58



 Line  I  Addr  Code            Source

 3350: 1
 3351: 1
 3352: 1
 3353: 1			;*******************************************************************************
 3354: 1			; mul16acc1        (71,2us @16.777216MHz)
 3355: 1			; 16-Bit Unsigned product (acc1 = acc1low x acc1high) naar 32bit resultaat
 3356: 1			; Inputbereik getallen: 0 tot  +65535 (0000h...ffffh)
 3357: 1			; input:     r5,r4 = acc1 low
 3358: 1			;            r7,r6 = acc1 high
 3359: 1			;
 3360: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low) x acc1(high)
 3361: 1			;            0 tot  +4294836225  (00000000h...fffe0001h)
 3362: 1			;
 3363: 1			; vernietigt:  niets
 3364: 1			;*******************************************************************************
 3365: 1  0ACA	C0 E0		mul16acc1:      push    acc              ;bewaar de gebruikte registers
 3366: 1  0ACC	C0 D0		                push    psw
 3367: 1  0ACE	C0 F0		                push    b
 3368: 1  0AD0	C0 82		                push    dpl
 3369: 1  0AD2	C0 83		                push    dph
 3370: 1
 3371: 1			;we bewaren de tussenresultaten in 3 gealloceerde bytes  stackgeheugen!
 3372: 1
 3373: 1  0AD4	88 82		                mov     dpl,r0           ;verplaats r0 en r1 naar datapointer
 3374: 1  0AD6	89 83		                mov     dph,r1           ;om ze als pointer te gebruiken
 3375: 1
 3376: 1  0AD8	A8 81		                mov     r0,sp            ;r0 = tussenresultaatpointer
 3377: 1  0ADA	08		                inc     r0               ;pointer naar eerste vrije plaats
 3378: 1  0ADB	A9 81		                mov     r1,sp            ;stackpointer bewaren tot einde
 3379: 1  0ADD	E5 81		                mov     a,sp             ;plaats alloceren
 3380: 1  0ADF	24 03		                add     a,#3             ;3 bytes nodig
 3381: 1  0AE1	F5 81		                mov     sp,a             ;stackpointer verzetten
 3382: 1
 3383: 1  0AE3	EC		                mov     a,r4             ;acc1 low lsb
 3384: 1  0AE4	8E F0		                mov     b,r6             ;acc1 high lsb
 3385: 1  0AE6	A4		                mul     ab
 3386: 1  0AE7	F6		                mov     @r0,a            ;bewaar lsb tussenresultaat
 3387: 1  0AE8	08		                inc     r0
 3388: 1  0AE9	A6 F0		                mov     @r0,b            ;bewaar msb tussenresultaat
 3389: 1
 3390: 1  0AEB	ED		                mov     a,r5             ;acc1 low msb
 3391: 1  0AEC	8E F0		                mov     b,r6             ;acc1 high lsb
 3392: 1  0AEE	A4		                mul     ab
 3393: 1
 3394: 1  0AEF	26		                add     a,@r0            ;tel lsb bij msb tussenresultaat
 3395: 1  0AF0	F6		                mov     @r0,a            ;bewaar als tussenresultaat
 3396: 1  0AF1	E5 F0		                mov     a,b              ;tel eventuele carry bij msb
 3397: 1  0AF3	34 00		                addc    a,#0
 3398: 1  0AF5	08		                inc     r0               ;bewaar als tussenresultaat
 3399: 1  0AF6	F6		                mov     @r0,a
 3400: 1
 3401: 1  0AF7	EC		                mov     a,r4             ;acc1 low lsb
 3402: 1  0AF8	8F F0		                mov     b,r7             ;acc1 high msb
 3403: 1  0AFA	A4		                mul     ab
 3404: 1  0AFB	18		                dec     r0
 3405: 1  0AFC	26		                add     a,@r0            ;tel lsb bij tussenresultaat

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 59



 Line  I  Addr  Code            Source

 3406: 1  0AFD	F6		                mov     @r0,a            ;en bewaar weer
 3407: 1  0AFE	08		                inc     r0
 3408: 1  0AFF	E5 F0		                mov     a,b              ;tel msb bij tussenresultaat
 3409: 1  0B01	36		                addc    a,@r0
 3410: 1  0B02	F6		                mov     @r0,a            ;en bewaar weer
 3411: 1  0B03	92 D5		                mov     f0,c             ;bewaar de carry van de laatste addc
 3412: 1
 3413: 1  0B05	ED		                mov     a,r5             ;acc1 low msb
 3414: 1  0B06	8F F0		                mov     b,r7             ;acc1 high msb
 3415: 1  0B08	A4		                mul     AB
 3416: 1
 3417: 1  0B09	26		                add     a,@r0            ;tel lsb bij tussenresultaat
 3418: 1  0B0A	FE		                mov     r6,a             ;deze byte van product is al klaar
 3419: 1  0B0B	E5 F0		                mov     a,b
 3420: 1  0B0D	34 00		                addc    a,#0
 3421: 1  0B0F	A2 D5		                mov     c,f0            ;tel opgeslagen carry hier ook nog bij
 3422: 1  0B11	34 00		                addc    a,#0
 3423: 1
 3424: 1  0B13	FF		                mov     r7,a          ;product is klaar, outputregisters vullen
 3425: 1  0B14	18		                dec     r0
 3426: 1  0B15	E6		                mov     a,@r0
 3427: 1  0B16	FD		                mov     r5,a
 3428: 1  0B17	18		                dec     r0
 3429: 1  0B18	E6		                mov     a,@r0
 3430: 1  0B19	FC		                mov     r4,a             ;r7,r6,r5,en r4 zijn klaar
 3431: 1
 3432: 1  0B1A	89 81		                mov     sp,r1            ;zet stackpointer terug
 3433: 1  0B1C	A9 83		                mov     r1,dph
 3434: 1  0B1E	A8 82		                mov     r0,dpl
 3435: 1
 3436: 1  0B20	D0 83		                pop     dph              ;herstel de bewaarde registers
 3437: 1  0B22	D0 82		                pop     dpl
 3438: 1  0B24	D0 F0		                pop     b
 3439: 1  0B26	D0 D0		                pop     psw
 3440: 1  0B28	D0 E0		                pop     acc
 3441: 1  0B2A	22		                ret
 3442: 1
 3443: 1			;*******************************************************************************
 3444: 1			; s_mul16        (121,1us @16.777216MHz)
 3445: 1			; 16-Bit signed product (acc0 = acc0 x acc1) naar 32bit signed resultaat
 3446: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3447: 1			; input:     r1,r0 = acc0
 3448: 1			;            r5,r4 = acc1
 3449: 1			;
 3450: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1
 3451: 1			;                                  -1073709056 tot +1073741824
 3452: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
 3453: 1			;
 3454: 1			; vernietigt:  niets
 3455: 1			;*******************************************************************************
 3456: 1  0B2B	12 08 41	s_mul16:        lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3457: 1  0B2E	12 08 61	                lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3458: 1  0B31	12 0A 65	                lcall    mul16           ;maak product
 3459: 1  0B34	12 07 BB	                lcall    magsig32        ;maak 2's complement formaat
 3460: 1  0B37	22		                ret                      ;klaar
 3461: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 60



 Line  I  Addr  Code            Source

 3462: 1			;*******************************************************************************
 3463: 1			; s_mul16acc1        (121,1us @16.777216MHz)
 3464: 1			; 16-Bit signed product (acc1 = acc1high x acc1low) naar 32bit signed resultaat
 3465: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3466: 1			; input:     r5,r4 = acc1 low
 3467: 1			;            r7,r6 = acc1 high
 3468: 1			;
 3469: 1			; output:    r7,r6,r5,r4 = acc1 = acc1(low word) x acc1(high word)
 3470: 1			;                                  -1073709056 tot +1073741824
 3471: 1			;                                  (c0008000h..ffffffffh,0,00000001h..40000000)
       1
 3472: 1			; vernietigt:  niets
 3473: 1			;*******************************************************************************
 3474: 1  0B38	12 08 61	s_mul16acc1:    lcall    sigmag16acc1    ;acc1 = absolute waarde + teken f1
 3475: 1  0B3B	12 08 81	                lcall    sigmag16acc1h   ;acc1 high = absolute waarde + teken f0
 3476: 1  0B3E	12 0A CA	                lcall    mul16acc1       ;maak product
 3477: 1  0B41	12 07 E5	                lcall    magsig32acc1    ;maak 2's complement formaat
 3478: 1  0B44	22		                ret                      ;klaar
 3479: 1
 3480: 1			;*******************************************************************************
 3481: 1			; s_mul816        (83,5us @16.777216MHz)
 3482: 1			; 8bit x 16-Bit signed product (acc0 = acc1 x acc0) naar 24bit signed resultaat
 3483: 1			; Inputbereik getallen: acc0: 8000h..ffffh,0,0001h..7fffh (-32768d tot  +32767d)
 3484: 1			;                        acc1: 80h..ffh,0,01h..7fh         (-128d tot  +127d)
 3485: 1			; input:     r1,r0 = acc0
 3486: 1			;               r4 = acc1
 3487: 1			;
 3488: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat, r3=00h)
 3489: 1			;                                  -4194176 tot +4194304
 3490: 1			;                                  (c00080h..ffffffh,0,000001h..400000h)
 3491: 1			; vernietigt:  niets
 3492: 1			;*******************************************************************************
 3493: 1  0B45	12 08 41	s_mul816:       lcall    sigmag16acc0    ;acc0 = absolute waarde + teken f0
 3494: 1  0B48	12 08 28	                lcall    sigmag8acc1     ;acc1 = absolute waarde + teken f1
 3495: 1  0B4B	12 0B 52	                lcall    mul816          ;8bit x 16 bit product
 3496: 1  0B4E	12 07 BB	                lcall    magsig32        ;abs. waarde naar 2's complement
 3497: 1  0B51	22		                ret
 3498: 1
 3499: 1			;*******************************************************************************
 3500: 1			; mul816        (29,4us @16.777216MHz)
 3501: 1			; 8bit x 16-Bit Unsigned product (acc0 = acc1 x acc0) naar 24bit resultaat
 3502: 1			; Inputbereik getallen: acc0: 0 tot 65535 (0000h...ffffh)
 3503: 1			;                       acc1: 0 tot 255     (00h...ffh)
 3504: 1			; input:     r1,r0 = acc0
 3505: 1			;               r4 = acc1
 3506: 1			;
 3507: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x acc1  (24 bit resultaat,r3=00h)
 3508: 1			;                           0..16711425 (000000h..feff01h)
 3509: 1			;
 3510: 1			; vernietigt:  niets
 3511: 1			;*******************************************************************************
 3512: 1  0B52	C0 E0		mul816:         push    acc             ;bewaar registers
 3513: 1  0B54	C0 F0		                push    b
 3514: 1  0B56	C0 D0		                push    psw
 3515: 1  0B58	EC		                mov     a,r4            ;neem acc1
 3516: 1  0B59	88 F0		                mov     b,r0            ;neem lsb van acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 61



 Line  I  Addr  Code            Source

 3517: 1  0B5B	A4		                mul     ab              ;maak product
 3518: 1  0B5C	F8		                mov     r0,a            ;bewaar lsb van het product is klaar
 3519: 1  0B5D	C0 F0		                push    b               ;bewaar lsb van het product
 3520: 1  0B5F	EC		                mov     a,r4            ;neem acc1
 3521: 1  0B60	89 F0		                mov     b,r1            ;neem msb can acc0
 3522: 1  0B62	A4		                mul     ab              ;maak product
 3523: 1  0B63	AA F0		                mov     r2,b            ;bewaar msb van product even
 3524: 1  0B65	F5 F0		                mov     b,a             ;verplaats lsb van product
 3525: 1  0B67	D0 E0		                pop     acc             ;neem msb van vorig product
 3526: 1  0B69	25 F0		                add     a,b             ;en tel bij lsb van laatste product
 3527: 1  0B6B	F9		                mov     r1,a            ;de middenste byte is klaar
 3528: 1  0B6C	EA		                mov     a,r2            ;tel nu de eventuele
 3529: 1  0B6D	34 00		                addc    a,#0            ;carry bij de msb
 3530: 1  0B6F	FA		                mov     r2,a            ;en bewaar, de msb is klaar
 3531: 1  0B70	7B 00		                mov     r3,#0
 3532: 1  0B72	D0 D0		                pop     psw
 3533: 1  0B74	D0 F0		                pop     b
 3534: 1  0B76	D0 E0		                pop     acc
 3535: 1  0B78	22		                ret
 3536: 1
 3537: 1			;*******************************************************************************
 3538: 1			; s_mac16        (145,1us @16.777216MHz)
 3539: 1			; 16-Bit signed product naar 32bit signed resultaat plus signed optelling
 3540: 1			; met 32bit resultaat in acc0,  acc0 = (acc1low x acc1high) + acc0
 3541: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3542: 1			; input:     r7,r6 = acc1 (high word)
 3543: 1			;            r5,r4 = acc1 (low  word)
 3544: 1			;
 3545: 1			; output:    r7,r6,r5,r4 = acc1 = product acc1(low) x acc1(high)
 3546: 1			;            r3,r2,r1,r0 = acc0 = acc1 +acc0
 3547: 1			;                          -2147483648 tot +2147483647
 3548: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3549: 1			;            CY=0 :het resultaat zit binnen het 32bit bereik
 3550: 1			;            CY=1 :het resultaat is groter dan 32bit (buiten bereik)
 3551: 1			;
 3552: 1			; vernietigt:  niets
 3553: 1			;*******************************************************************************
 3554: 1  0B79	12 0B 38	s_mac16:        lcall    s_mul16acc1     ;product van acc1 low en acc1 high
 3555: 1  0B7C	C0 E0		                push    acc
 3556: 1  0B7E	C0 D0		                push    psw
 3557: 1  0B80	EC		                mov     a,r4            ;tel r7,r6,r5,r4 op bij
 3558: 1  0B81	28		                add     a,r0            ;het getal in r3,r2,r1,r0
 3559: 1  0B82	F8		                mov     r0,a
 3560: 1  0B83	ED		                mov     a,r5
 3561: 1  0B84	39		                addc    a,r1
 3562: 1  0B85	F9		                mov     r1,a
 3563: 1  0B86	EE		                mov     a,r6
 3564: 1  0B87	3A		                addc    a,r2
 3565: 1  0B88	FA		                mov     r2,a
 3566: 1  0B89	EF		                mov     a,r7
 3567: 1  0B8A	3B		                addc    a,r3
 3568: 1  0B8B	FB		                mov     r3,a
 3569: 1  0B8C	20 D2 06	                jb      ov,s_mac161
 3570: 1  0B8F	D0 D0		                pop     psw
 3571: 1  0B91	C3		                clr     c                ;ok, 32bit som binnen bereik
 3572: 1  0B92	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 62



 Line  I  Addr  Code            Source

 3573: 1  0B94	22		                ret
 3574: 1  0B95	D0 D0		s_mac161:       pop     psw
 3575: 1  0B97	D3		                setb    c                ;fout! 32bit som buiten bereik
 3576: 1  0B98	D0 E0		                pop     acc
 3577: 1  0B9A	22		                ret
 3578: 1
 3579: 1
 3580: 1			;*******************************************************************************
 3581: 1			; s_div8        (78us @16.777216MHz)
 3582: 1			; signed  8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3583: 1			; Inputbereik getallen: 80h..ffh,0,01h..7fh  (-128 tot  +127)
 3584: 1			; input:    r0 = acc0 deeltal (2's compl)
 3585: 1			;           r4 = acc1 deler   (2's compl)
 3586: 1			;
 3587: 1			; output:   r0 = quotient van deling acc0/acc1 (2's compl)
 3588: 1			;           r4 = rest (2's compl)
 3589: 1			;           cy=1 bij acc1=0 (deling door nul)
 3590: 1			;            cy=0 in andere gevallen
 3591: 1			;
 3592: 1			; vernietigt: niets
 3593: 1			;*******************************************************************************
 3594: 1  0B9B	12 08 0F	s_div8:         lcall   sigmag8acc0      ;2's comp naar abs.waarde en teken f0
 3595: 1  0B9E	12 08 28	                lcall   sigmag8acc1      ;2's comp naar abs.waarde en teken f1
 3596: 1  0BA1	12 0B AD	                lcall   div8
 3597: 1  0BA4	40 06		                jc      s_div81          ;bij deling door nul, gedaan!
 3598: 1  0BA6	12 07 47	                lcall   magsig8          ;abs.waarde en teken naar 2's Compl
 3599: 1  0BA9	12 07 61	                lcall   magsig8acc1      ;rest ook omzetten naar 2's compl
 3600: 1  0BAC	22		s_div81:        ret
 3601: 1
 3602: 1			;*******************************************************************************
 3603: 1			; div8        (19,4us @16.777216MHz)
 3604: 1			; 8-Bit (acc0) door 8-Bit (acc1) deling naar 8-Bit Quotient en 8bit rest
 3605: 1			; absolute waarde
 3606: 1			; Inputbereik getallen: 00h..ffh  (0 tot 255)
 3607: 1			; input:    r0 = acc0 deeltal
 3608: 1			;           r4 = acc1 deler
 3609: 1			;
 3610: 1			; output:   r0 = quotient van deling acc0/acc1
 3611: 1			;           r4 = rest
 3612: 1			;           cy=1 bij acc1=0 (deling door nul)
 3613: 1			;            cy=0 in andere gevallen
 3614: 1			;
 3615: 1			; vernietigt: niets
 3616: 1			;*******************************************************************************
 3617: 1  0BAD	C0 E0		div8:           push    acc             ;bewaar registers
 3618: 1  0BAF	C0 F0		                push    b
 3619: 1  0BB1	C0 D0		                push    psw
 3620: 1  0BB3	EC		                mov     a,r4            ;neem deler
 3621: 1  0BB4	60 0F		                jz      div81           ;deling door nul?
 3622: 1  0BB6	E8		                mov     a,r0            ;nee, neem deeltal
 3623: 1  0BB7	8C F0		                mov     b,r4            ;en deler
 3624: 1  0BB9	84		                div     ab              ;en maak deling
 3625: 1  0BBA	F8		                mov     r0,a            ;bewaar quotient in acc0
 3626: 1  0BBB	AC F0		                mov     r4,b            ;bewaar rest in acc1
 3627: 1  0BBD	D0 D0		                pop     psw             ;herstel registers
 3628: 1  0BBF	D0 F0		                pop     b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 63



 Line  I  Addr  Code            Source

 3629: 1  0BC1	D0 E0		                pop     acc
 3630: 1  0BC3	C3		                clr     c                ;geen deling door nul
 3631: 1  0BC4	22		                ret
 3632: 1
 3633: 1  0BC5	D0 D0		div81:          pop     psw              ;fout, deling door nul!
 3634: 1  0BC7	D0 F0		                pop     b
 3635: 1  0BC9	D0 E0		                pop     acc
 3636: 1  0BCB	D3		                setb    c
 3637: 1  0BCC	22		                ret
 3638: 1
 3639: 1
 3640: 1			;*******************************************************************************
 3641: 1			; s_div16        (469,1us @16.777216MHz)
 3642: 1			; 16Bit (acc0) door 16Bit (acc1) deling naar 16Bit Quotient en 16bit rest
 3643: 1			; 2's Complement Format
 3644: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 3645: 1			; input:    r1, r0 = acc0 deeltal (2's compl)
 3646: 1			;           r5, r4 = acc1 deler   (2's compl)
 3647: 1			;
 3648: 1			; output:   r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3649: 1			;           r5, r4 = rest
 3650: 1			;           cy=1 bij acc1=0 (deling door nul)
 3651: 1			;            cy=0 in andere gevallen
 3652: 1			;
 3653: 1			; vernietigt: niets
 3654: 1			;*******************************************************************************
 3655: 1  0BCD	C0 E0		s_div16:        push    acc
 3656: 1  0BCF	C0 D0		                push    psw
 3657: 1  0BD1	ED		                mov     a,r5            ;neem msb van deler
 3658: 1  0BD2	4C		                orl     a,r4            ;combineer met lsb van deler
 3659: 1  0BD3	70 06		                jnz     s_div161        ;deler is ok als dit niet nul is
 3660: 1  0BD5	D0 D0		                pop     psw             ;anders fout, deling door nul!
 3661: 1  0BD7	D0 E0		                pop     acc
 3662: 1  0BD9	D3		                setb    C               ;fout, deling door nul!
 3663: 1  0BDA	22		                ret
 3664: 1
 3665: 1  0BDB	12 08 41	s_div161:       lcall   sigmag16acc0    ;2's comp naar abs. waarde en teken f0
 3666: 1  0BDE	12 08 61	                lcall   sigmag16acc1    ;2's comp naar abs. waarde en teken f1
 3667: 1  0BE1	12 0B F0	                lcall   div16
 3668: 1  0BE4	12 07 7B	                lcall   magsig16        ;abs.waarde en f0 en f1 naar 2's Compl
 3669: 1  0BE7	12 07 9B	                lcall   magsig16acc1    ;rest ook omzetten naar 2's compl
 3670: 1  0BEA	D0 D0		                pop     psw
 3671: 1  0BEC	C3		                clr     C               ;delig ok
 3672: 1  0BED	D0 E0		                pop     acc
 3673: 1  0BEF	22		                ret                     ;klaar
 3674: 1
 3675: 1			;*******************************************************************************
 3676: 1			; div16            (405,1us @16.777216MHz)
 3677: 1			; 16-Bit / 16-Bit naar 16-Bit Quotient & Rest absolute waarde deling
 3678: 1			; Inputbereik getallen: 0000h..ffffh  (0 tot 65535d)
 3679: 1			; input:    r1, r0 = Deeltal (acc0)
 3680: 1			;           r5, r4 = Deler   (acc1)
 3681: 1			;
 3682: 1			; output:   r1, r0 = quotient van de deling acc0/acc1
 3683: 1			;           r5, r4 = rest van de deling acc0/acc1
 3684: 1			;            cy=1 bij deling door nul (acc1=0)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 64



 Line  I  Addr  Code            Source

 3685: 1			;            cy=0 bij normale deling
 3686: 1			;
 3687: 1			; vernietigt: niets
 3688: 1			;*******************************************************************************
 3689: 1
 3690: 1  0BF0	C0 E0		div16:          push    acc            ;bewaar de registers waar we mee werken
 3691: 1  0BF2	C0 D0		                push    psw
 3692: 1			;check voor deling door nul
 3693: 1  0BF4	EC		                mov     a,r4           ;neem lsb deler
 3694: 1  0BF5	4D		                orl     a,r5           ;combineer met msb van deler
 3695: 1  0BF6	70 06		                jnz     div160         ;niet nul, dan verder werken
 3696: 1  0BF8	D0 D0		                pop     psw            ;als nul, dikke snul
 3697: 1  0BFA	D3		                setb    c              ;terug met errorstatus
 3698: 1  0BFB	D0 E0		                pop     acc
 3699: 1  0BFD	22		                ret
 3700: 1
 3701: 1  0BFE	C0 F0		div160:         push    b              ;registers verder bewaren
 3702: 1  0C00	EF		                mov     a,r7
 3703: 1  0C01	C0 E0		                push    acc            ;push r7 op stack
 3704: 1  0C03	EE		                mov     a,r6
 3705: 1  0C04	C0 E0		                push    acc            ;push r6 op stack
 3706: 1  0C06	EB		                mov     a,r3
 3707: 1  0C07	C0 E0		                push    acc            ;push r3 op stack
 3708: 1  0C09	EA		                mov     a,r2
 3709: 1  0C0A	C0 E0		                push    acc            ;push r2 op stack
 3710: 1  0C0C	C0 83		                push    dph
 3711: 1  0C0E	C0 82		                push    dpl
 3712: 1
 3713: 1  0C10	7A 00		                mov     r2,#0          ;tijdelijk 16 bit quotient op nul zetten
 3714: 1  0C12	7B 00		                mov     r3,#0
 3715: 1  0C14	7F 00		                mov     r7,#0          ;gedeeltelijke 16 bit rest op nul zetten
 3716: 1  0C16	7E 00		                mov     r6,#0
 3717: 1  0C18	75 F0 10	                mov     b,#16          ;initiele lusteller op 16
 3718: 1
 3719: 1			;om zo weinig mogelijk de delerlus (div162) te moeten doorlopen aligneren we het
 3720: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3721: 1			;het aantal significante bits af in de lusteller b
 3722: 1
 3723: 1  0C1B	E9		                mov     a,r1            ;neem de msbyte van het deeltal
 3724: 1  0C1C	20 E7 10	div161:         jb      acc.7,div162    ;test of hoogste bit significant is
 3725: 1  0C1F	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3726: 1  0C20	E8		                mov     a,r0            ;lsb van deeltal nemen
 3727: 1  0C21	33		                rlc     a                ;en opschuiven
 3728: 1  0C22	F8		                mov     r0,a
 3729: 1  0C23	E9		                mov     a,r1            ;msb van deeltal nemen
 3730: 1  0C24	33		                rlc     a
 3731: 1  0C25	F9		                mov     r1,a
 3732: 1  0C26	D5 F0 F3	                djnz    b,div161        ;volgende bit en lusteller decrementeren
 3733: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3734: 1  0C29	7C 00		                mov     r4,#0
 3735: 1  0C2B	7D 00		                mov     r5,#0
 3736: 1  0C2D	80 2E		                sjmp    div164          ;klaar!
 3737: 1
 3738: 1			;deeltal is nu msb gealigneerd en klaar voor deling
 3739: 1
 3740: 1  0C2F	C3		div162:            clr     C            ;start met carry op nul

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 65



 Line  I  Addr  Code            Source

 3741: 1  0C30	E8		                mov     a,r0            ;schuif deeltal naar links
 3742: 1  0C31	33		                rlc     a
 3743: 1  0C32	F8		                mov     r0,a
 3744: 1  0C33	E9		                mov     a,r1
 3745: 1  0C34	33		                rlc     a
 3746: 1  0C35	F9		                mov     r1,a
 3747: 1  0C36	EE		                mov     a,r6            ;schuif carry van deeltal in de
 3748: 1  0C37	33		                rlc     a               ;gedeeltelijke rest
 3749: 1  0C38	FE		                mov     r6,a
 3750: 1  0C39	EF		                mov     a,r7
 3751: 1  0C3A	33		                rlc     a
 3752: 1  0C3B	FF		                mov     r7,a
 3753: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil
 3754: 1  0C3C	EE		                mov     a,r6
 3755: 1  0C3D	C3		                clr     C
 3756: 1  0C3E	9C		                subb    a,r4
 3757: 1  0C3F	F5 82		                mov     dpl,a
 3758: 1  0C41	EF		                mov     a,r7
 3759: 1  0C42	9D		                subb    a,r5
 3760: 1  0C43	F5 83		                mov     dph,a
 3761: 1  0C45	40 04		                jc      div163
 3762: 1  0C47	AF 83		                mov     r7,dph          ;als carry nul, dan tijdelijk verschil
 3763: 1  0C49	AE 82		                mov     r6,dpl          ;in gedeeltelijke rest stoppen
 3764: 1
 3765: 1  0C4B	B3		div163:         cpl     C               ;geinverteerde cy in tijdelijk quotient
 3766: 1  0C4C	EA		                mov     a,r2            ;binnenschuiven
 3767: 1  0C4D	33		                rlc     a
 3768: 1  0C4E	FA		                mov     r2,a
 3769: 1  0C4F	EB		                mov     a,r3
 3770: 1  0C50	33		                rlc     a
 3771: 1  0C51	FB		                mov     r3,a            ;tijdelijk quotient is aangepast
 3772: 1  0C52	D5 F0 DA	                djnz    b,div162        ;doe zolang lusteller niet nul is
 3773: 1
 3774: 1  0C55	EB		                mov     a,r3            ;acc0 vullen met 16 bit quotient
 3775: 1  0C56	F9		                mov     r1,a
 3776: 1  0C57	EA		                mov     a,r2
 3777: 1  0C58	F8		                mov     r0,a
 3778: 1  0C59	EF		                mov     a,r7            ;acc1 vullen met de 16 bit rest
 3779: 1  0C5A	FD		                mov     r5,a
 3780: 1  0C5B	EE		                mov     a,r6
 3781: 1  0C5C	FC		                mov     r4,a
 3782: 1
 3783: 1  0C5D	D0 82		div164:         pop     dpl             ;registers herstellen
 3784: 1  0C5F	D0 83		                pop     dph
 3785: 1  0C61	D0 E0		                pop     acc
 3786: 1  0C63	FA		                mov     r2,a            ;r2 van stack halen
 3787: 1  0C64	D0 E0		                pop     acc
 3788: 1  0C66	FB		                mov     r3,a            ;r3 van stack halen
 3789: 1  0C67	D0 E0		                pop     acc
 3790: 1  0C69	FE		                mov     r6,a            ;r6 van stack halen
 3791: 1  0C6A	D0 E0		                pop     acc
 3792: 1  0C6C	FF		                mov     r7,a            ;r7 van stack halen
 3793: 1  0C6D	D0 F0		                pop     b
 3794: 1  0C6F	D0 D0		                pop     psw
 3795: 1  0C71	C3		                clr     c               ;deling ok
 3796: 1  0C72	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 66



 Line  I  Addr  Code            Source

 3797: 1  0C74	22		                ret
 3798: 1
 3799: 1
 3800: 1			;*******************************************************************************
 3801: 1			; s_div32        (2,15ms @16.777216MHz)
 3802: 1			; 32Bit (acc0) door 33Bit (acc1) deling naar 32Bit Quotient en 32bit rest
 3803: 1			; 2's Complement Format
 3804: 1			; Inputbereik getallen: -2147483648 tot +2147483647
 3805: 1			;                       (80000000h..ffffffffh,0,00000001h..7fffffffh)
 3806: 1			;
 3807: 1			; input:    r3,r2,r1,r0 = acc0 deeltal (2's compl)
 3808: 1			;           r7,r6,r5,r4 = acc1 deler   (2's compl)
 3809: 1			;
 3810: 1			; output:   r3,r2,r1, r0 = quotient van deling acc0/acc1 (2's compl)
 3811: 1			;           r7,r6,r5, r4 = rest
 3812: 1			;           cy=1 bij acc1=0 (deling door nul)
 3813: 1			;            cy=0 in andere gevallen
 3814: 1			;
 3815: 1			; vernietigt: niets
 3816: 1			;*******************************************************************************
 3817: 1  0C75	C0 E0		s_div32:        push    acc
 3818: 1  0C77	C0 D0		                push    psw
 3819: 1  0C79	EF		                mov     a,r7            ;neem msb van deler
 3820: 1  0C7A	4E		                orl     a,r6            ;combineer met lsb's van deler
 3821: 1  0C7B	4D		                orl     a,r5
 3822: 1  0C7C	4C		                orl     a,r4
 3823: 1  0C7D	70 06		                jnz     s_div321        ;deler is ok als dit niet nul is
 3824: 1  0C7F	D0 D0		                pop     psw                ;anders fout, deling door nul!
 3825: 1  0C81	D0 E0		                pop     acc
 3826: 1  0C83	D3		                setb    C                ;fout, deling door nul!
 3827: 1  0C84	22		                ret
 3828: 1
 3829: 1  0C85	12 08 A1	s_div321:       lcall   sigmag32acc0    ;2's comp naar abs. waarde en teken f0
 3830: 1  0C88	12 08 CB	                lcall   sigmag32acc1    ;2's comp naar abs. waarde en teken f1
 3831: 1  0C8B	12 0C 9A	                lcall   div32            ;deel 32bit/32bit
 3832: 1  0C8E	12 07 BB	                lcall   magsig32        ;abs.waarde en f0 en f1 naar 2's Compl
 3833: 1  0C91	12 07 E5	                lcall    magsig32acc1    ;rest ook omzetten naar 2's compl
 3834: 1  0C94	D0 D0		                pop     psw
 3835: 1  0C96	C3		                clr     C                ;delig ok
 3836: 1  0C97	D0 E0		                pop     acc
 3837: 1  0C99	22		                ret                        ;klaar
 3838: 1
 3839: 1
 3840: 1			;*******************************************************************************
 3841: 1			; div32        (2,09ms @16.777216MHz)
 3842: 1			; 32-Bit / 32-Bit naar 32-Bit Quotient & 32-bit Rest (absolute waarde deling)
 3843: 1			; Inputbereik getallen: 00000000h..ffffffffh  (0 tot +4294967296d)
 3844: 1			; input:    r3,r2,r1, r0 = Deeltal (acc0)
 3845: 1			;           r7,r6,r5, r4 = Deler   (acc1)
 3846: 1			;
 3847: 1			; output:   r3,r2,r1, r0 = quotient van de deling acc0/acc1
 3848: 1			;           r7,r6,r5, r4 = rest van de deling acc0/acc1
 3849: 1			;            cy=1 bij deling door nul (acc1=0)
 3850: 1			;            cy=0 bij normale deling
 3851: 1			;
 3852: 1			; vernietigt: niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 67



 Line  I  Addr  Code            Source

 3853: 1			;*******************************************************************************
 3854: 1  0C9A	C0 E0		div32:          push    acc             ;bewaar de registers waar we mee werken
 3855: 1  0C9C	C0 D0		                push    psw
 3856: 1			;check voor deling door nul
 3857: 1  0C9E	EF		                mov     a,r7            ;neem msb van deler
 3858: 1  0C9F	4E		                orl     a,r6            ;combineer met lsb's van deler
 3859: 1  0CA0	4D		                orl     a,r5
 3860: 1  0CA1	4C		                orl     a,r4
 3861: 1  0CA2	70 06		                jnz     div320          ;niet nul, dan verder werken
 3862: 1  0CA4	D0 D0		                pop     psw             ;als nul, dikke snul
 3863: 1  0CA6	D3		                setb    c               ;terug met errorstatus
 3864: 1  0CA7	D0 E0		                pop     acc
 3865: 1  0CA9	22		                ret
 3866: 1
 3867: 1  0CAA	C0 F0		div320:         push    b                ;registers verder bewaren
 3868: 1  0CAC	C0 83		                push    dph
 3869: 1  0CAE	C0 82		                push    dpl
 3870: 1
 3871: 1  0CB0	75 F0 20	                mov     b,#32            ;initiele lusteller op 32
 3872: 1
 3873: 1			;om zo weinig mogelijk de delerlus (div322) te moeten doorlopen aligneren we het
 3874: 1			;deeltal met zijn meest significante bit op de msb van het deeltal en we tellen
 3875: 1			;het aantal significante bits af in de lusteller b
 3876: 1
 3877: 1  0CB3	EB		                mov     a,r3            ;neem de msbyte van het deeltal
 3878: 1  0CB4	20 E7 1B	div320a:        jb     acc.7,div320b    ;test of hoogste bit significant is
 3879: 1  0CB7	C3		                clr     c               ;nee, het is een nul, deeltal opschuiven
 3880: 1  0CB8	E8		                mov     a,r0            ;lsb van deeltal nemen
 3881: 1  0CB9	33		                rlc     a               ;en opschuiven
 3882: 1  0CBA	F8		                mov     r0,a
 3883: 1  0CBB	E9		                mov     a,r1           ;volgende byte van deeltal nemen
 3884: 1  0CBC	33		                rlc     a
 3885: 1  0CBD	F9		                mov     r1,a
 3886: 1  0CBE	EA		                mov     a,r2           ;volgende byte van deeltal nemen
 3887: 1  0CBF	33		                rlc     a
 3888: 1  0CC0	FA		                mov     r2,a
 3889: 1  0CC1	EB		                mov     a,r3           ;lsb van deeltal nemen
 3890: 1  0CC2	33		                rlc     a
 3891: 1  0CC3	FB		                mov     r3,a
 3892: 1  0CC4	D5 F0 ED	                djnz    b,div320a       ;volgende bit en lusteller decrementeren
 3893: 1			;lusteller=0, dus deeltal is nul, het resultaat is dus gekend acc0=0 en acc1=0
 3894: 1  0CC7	7F 00		                mov     r7,#0           ;rest is dan ook nul
 3895: 1  0CC9	7E 00		                mov     r6,#0
 3896: 1  0CCB	7D 00		                mov     r5,#0
 3897: 1  0CCD	7C 00		                mov     r4,#0
 3898: 1  0CCF	02 0D 98	                ljmp    div324           ;klaar!
 3899: 1
 3900: 1			;Alloceer 12 bytes voor lokale variabelen op de stack.
 3901: 1			;In de vier laagste bytes wordt de deler opgeslagen, de vier hogere bytes zijn
 3902: 1			;het tijdelijk verschil (X=rest-deler) en de vier hoogste bytes is het quotient.
 3903: 1			;We maken twee pointers vrij die wijzen naar de deler en het tijdelijk verschil
 3904: 1			;en in dpl bewaren we het adres van de lage byte van het quotient.
 3905: 1
 3906: 1  0CD2			div320b:
 3907: 1  0CD2	85 81 83	                mov     dph,sp          ;stackpointer opslaan voor na de deling
 3908: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 68



 Line  I  Addr  Code            Source

 3909: 1  0CD5	E5 81		                mov     a,sp            ;we gaan nu de stackpointer verzetten
 3910: 1  0CD7	24 0C		                add     a,#12           ;met 12 plaatsen
 3911: 1  0CD9	F5 81		                mov     sp,a            ;nieuwe stackpointer klaar
 3912: 1
 3913: 1  0CDB	E9		                mov     a,r1            ;bewaar r1 op nieuwe stack
 3914: 1  0CDC	C0 E0		                push    acc
 3915: 1  0CDE	E8		                mov     a,r0            ;bewaar r0 op nieuwe stack
 3916: 1  0CDF	C0 E0		                push    acc
 3917: 1
 3918: 1  0CE1	A8 83		                mov     r0,dph          ;pointer maken naar de lage byte van
 3919: 1  0CE3	08		                inc     r0              ;de deler
 3920: 1  0CE4	E5 83		                mov     a,dph           ;pointer maken naar de lage byte van
 3921: 1  0CE6	24 05		                add     a,#5            ;het tijdelijk verschil X
 3922: 1  0CE8	F9		                mov     r1,a            ;pointer naar tijdelijk verschil
 3923: 1  0CE9	E5 83		                mov     a,dph           ;adres berekenen van lage byte van het
 3924: 1  0CEB	24 09		                add     a,#9            ;quotient
 3925: 1  0CED	F5 82		                mov     dpl,a           ;opslaan voor gebruik als pointer
 3926: 1
 3927: 1			;Eenmalig de variabelen op stack initaliseren
 3928: 1			;Tijdelijk quotient op nul zetten
 3929: 1
 3930: 1  0CEF	C5 82		                xch     a,dpl            ;lsb adres van quotient in accu
 3931: 1  0CF1	C9		                xch     a,r1             ;r1=lsb adres van quotient, a=X
 3932: 1  0CF2	C0 F0		                push    b                ;loopteller deling bewaren
 3933: 1  0CF4	75 F0 04	                mov     b,#4
 3934: 1  0CF7	77 00		div320c:        mov     @r1,#0           ;maak quotient nul
 3935: 1  0CF9	09		                inc     r1
 3936: 1  0CFA	D5 F0 FA	                djnz    b,div320c
 3937: 1  0CFD	D0 F0		                pop     b                ;loopteller deling ophalen
 3938: 1  0CFF	19		                dec     r1
 3939: 1  0D00	19		                dec     r1
 3940: 1  0D01	19		                dec     r1
 3941: 1  0D02	19		                dec     r1               ;pointer weer op startadres quotient
 3942: 1  0D03	C9		                xch     a,r1             ;weer omwisselen
 3943: 1  0D04	C5 82		                xch     a,dpl
 3944: 1
 3945: 1			;deler in r7,r6,r5,r4 in lokale variabele op stack zetten
 3946: 1  0D06	EC		                mov     a,r4
 3947: 1  0D07	F6		                mov     @r0,a
 3948: 1  0D08	08		                inc     r0
 3949: 1  0D09	ED		                mov     a,r5
 3950: 1  0D0A	F6		                mov     @r0,a
 3951: 1  0D0B	08		                inc     r0
 3952: 1  0D0C	EE		                mov     a,r6
 3953: 1  0D0D	F6		                mov     @r0,a
 3954: 1  0D0E	08		                inc     r0
 3955: 1  0D0F	EF		                mov     a,r7
 3956: 1  0D10	F6		                mov     @r0,a
 3957: 1  0D11	18		                dec     r0             ;pointer herstellen naar lsb van deler
 3958: 1  0D12	18		                dec     r0
 3959: 1  0D13	18		                dec     r0
 3960: 1
 3961: 1  0D14	7F 00		                mov     r7,#0          ;gedeeltelijke 32 bit rest op nul zetten
 3962: 1  0D16	7E 00		                mov     r6,#0
 3963: 1  0D18	7D 00		                mov     r5,#0
 3964: 1  0D1A	7C 00		                mov     r4,#0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 69



 Line  I  Addr  Code            Source

 3965: 1
 3966: 1
 3967: 1			;deeltal is reeds msb gealigneerd en klaar voor deling
 3968: 1  0D1C	C3		div322:         clr     C               ;start met carry op nul
 3969: 1
 3970: 1  0D1D	D0 E0		                pop     acc             ;low byte r0 van deeltal weer van stack
 3971: 1  0D1F	33		                rlc     a
 3972: 1  0D20	C0 E0		                push    acc             ;r0 van deeltal weer op stack
 3973: 1  0D22	15 81		                dec     sp              ;wijs naar r1 van deeltal op stack
 3974: 1  0D24	D0 E0		                pop     acc             ;r1 van deeltal van stack
 3975: 1  0D26	33		                rlc     a
 3976: 1  0D27	C0 E0		                push    acc             ;en weer bewaren
 3977: 1  0D29	05 81		                inc     sp              ;stackpointer weer corrigeren
 3978: 1
 3979: 1  0D2B	EA		                mov     a,r2
 3980: 1  0D2C	33		                rlc     a
 3981: 1  0D2D	FA		                mov     r2,a
 3982: 1  0D2E	EB		                mov     a,r3
 3983: 1  0D2F	33		                rlc     a
 3984: 1  0D30	FB		                mov     r3,a            ;deeltal is 1 plaats verschoven
 3985: 1
 3986: 1  0D31	EC		                mov     a,r4            ;schuif carry van deeltal in de
 3987: 1  0D32	33		                rlc     a               ;gedeeltelijke rest r7..r4
 3988: 1  0D33	FC		                mov     r4,a
 3989: 1  0D34	ED		                mov     a,r5
 3990: 1  0D35	33		                rlc     a
 3991: 1  0D36	FD		                mov     r5,a
 3992: 1  0D37	EE		                mov     a,r6
 3993: 1  0D38	33		                rlc     a
 3994: 1  0D39	FE		                mov     r6,a
 3995: 1  0D3A	EF		                mov     a,r7
 3996: 1  0D3B	33		                rlc     a
 3997: 1  0D3C	FF		                mov     r7,a            ;tijdelijke rest is verschoven
 3998: 1
 3999: 1			;trek de deler van de gedeeltelijke rest af en bewaar tijdelijk verschil X
 4000: 1
 4001: 1  0D3D	C3		                clr     C               ;de deler zit in gealloceerd geheugen!!
 4002: 1  0D3E	EC		                mov     a,r4            ;neem lsb van gedeeltelijke rest
 4003: 1  0D3F	96		                subb    a,@r0           ;trek er de lsb deler af
 4004: 1  0D40	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4005: 1  0D41	08		                inc     r0              ;pointers aanpassen
 4006: 1  0D42	09		                inc     r1
 4007: 1  0D43	ED		                mov     a,r5            ;volgende byte van gedeeltelijke rest
 4008: 1  0D44	96		                subb    a,@r0           ;trek er volgende byte deler af
 4009: 1  0D45	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4010: 1  0D46	08		                inc     r0              ;pointers aanpassen
 4011: 1  0D47	09		                inc     r1
 4012: 1  0D48	EE		                mov     a,r6            ;volgende byte van gedeeltelijke rest
 4013: 1  0D49	96		                subb    a,@r0           ;trek er volgende byte deler af
 4014: 1  0D4A	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4015: 1  0D4B	08		                inc     r0              ;pointers aanpassen
 4016: 1  0D4C	09		                inc     r1
 4017: 1  0D4D	EF		                mov     a,r7            ;msb van gedeeltelijke rest
 4018: 1  0D4E	96		                subb    a,@r0           ;trek er msb deler af
 4019: 1  0D4F	F7		                mov     @r1,a           ;en bewaar in tijdelijk verschil
 4020: 1  0D50	18		                dec     r0              ;pointers herstellen naar lsb's

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 70



 Line  I  Addr  Code            Source

 4021: 1  0D51	18		                dec     r0
 4022: 1  0D52	18		                dec     r0
 4023: 1  0D53	19		                dec     r1
 4024: 1  0D54	19		                dec     r1
 4025: 1  0D55	19		                dec     r1
 4026: 1
 4027: 1  0D56	40 0E		                jc      div323          ;test of er een carry werd gegenereerd
 4028: 1  0D58	E7		                mov     a,@r1           ;nee, dan het tijdelijk verschil
 4029: 1  0D59	FC		                mov     r4,a            ;in de gedeeltelijke rest stoppen
 4030: 1  0D5A	09		                inc     r1
 4031: 1  0D5B	E7		                mov     a,@r1
 4032: 1  0D5C	FD		                mov     r5,a
 4033: 1  0D5D	09		                inc     r1
 4034: 1  0D5E	E7		                mov     a,@r1
 4035: 1  0D5F	FE		                mov     r6,a
 4036: 1  0D60	09		                inc     r1
 4037: 1  0D61	E7		                mov     a,@r1
 4038: 1  0D62	FF		                mov     r7,a
 4039: 1  0D63	19		                dec     r1              ;met pointer weer naar lsb van
 4040: 1  0D64	19		                dec     r1              ;het tijdelijk verschil wijzen
 4041: 1  0D65	19		                dec     r1
 4042: 1
 4043: 1
 4044: 1  0D66	B3		div323:         cpl     C               ;/cy in tijdelijk quotient schuiven
 4045: 1  0D67	C5 82		                xch     a,dpl           ;lsb adres van quotient in accu
 4046: 1  0D69	C9		                xch     a,r1            ;r1=lsb adres van quotient, a=X
 4047: 1  0D6A	C0 E0		                push    acc            ;pointer naar verschil X even bewaren
 4048: 1  0D6C	E7		                mov     a,@r1           ;neem lsb van qoutient
 4049: 1  0D6D	33		                rlc     a               ;geinverteerde cy binnenschuiven
 4050: 1  0D6E	F7		                mov     @r1,a
 4051: 1  0D6F	09		                inc     r1              ;volgende byte
 4052: 1  0D70	E7		                mov     a,@r1
 4053: 1  0D71	33		                rlc     a
 4054: 1  0D72	F7		                mov     @r1,a
 4055: 1  0D73	09		                inc     r1              ;volgende byte
 4056: 1  0D74	E7		                mov     a,@r1
 4057: 1  0D75	33		                rlc     a
 4058: 1  0D76	F7		                mov     @r1,a
 4059: 1  0D77	09		                inc     r1              ;volgende byte
 4060: 1  0D78	E7		                mov     a,@r1
 4061: 1  0D79	33		                rlc     a
 4062: 1  0D7A	F7		                mov     @r1,a           ;tijdelijk quotient is aangepast
 4063: 1  0D7B	19		                dec     r1
 4064: 1  0D7C	19		                dec     r1
 4065: 1  0D7D	19		                dec     r1              ;pointer verzetten naar lsb quotient
 4066: 1  0D7E	D0 E0		                pop     acc             ;pointer naar verschil X ophalen
 4067: 1  0D80	C9		                xch     a,r1            ;r1=pointer naar verschil
 4068: 1  0D81	C5 82		                xch     a,dpl           ;dpl=adres lsb quotient
 4069: 1
 4070: 1  0D83	D5 F0 96	                djnz    b,div322        ;doe zolang lusteller niet nul is
 4071: 1
 4072: 1			;De deling is klaar, nu nog de output registers vullen met het resultaat
 4073: 1			;In r7,r6,r5,r4 staat reeds de rest, dus enkel het quotient nog verplaatsen
 4074: 1
 4075: 1  0D86	A8 81		                mov     r0,sp           ;pointer maken naar msb quotient
 4076: 1  0D88	18		                dec     r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 71



 Line  I  Addr  Code            Source

 4077: 1  0D89	18		                dec     r0
 4078: 1  0D8A	E6		                mov     a,@r0           ;msb van quotient eerst nemen
 4079: 1  0D8B	FB		                mov     r3,a            ;en verplaatsen
 4080: 1  0D8C	18		                dec     r0              ;volgende byte
 4081: 1  0D8D	E6		                mov     a,@r0
 4082: 1  0D8E	FA		                mov     r2,a
 4083: 1  0D8F	18		                dec     r0              ;volgende byte
 4084: 1  0D90	E6		                mov     a,@r0
 4085: 1  0D91	F9		                mov     r1,a
 4086: 1  0D92	18		                dec     r0              ;volgende byte
 4087: 1  0D93	E6		                mov     a,@r0
 4088: 1  0D94	F8		                mov     r0,a            ;laatste byte verplaatst!
 4089: 1
 4090: 1  0D95	85 83 81	                mov     sp,dph          ;plaats van de lokale variabelen
 4091: 1			                                         ;weer vrijgeven
 4092: 1
 4093: 1
 4094: 1  0D98	D0 82		div324:         pop     dpl             ;registers herstellen
 4095: 1  0D9A	D0 83		                pop     dph
 4096: 1  0D9C	D0 F0		                pop     b
 4097: 1  0D9E	D0 D0		                pop     psw
 4098: 1  0DA0	C3		                clr     c               ;normale deling
 4099: 1  0DA1	D0 E0		                pop     acc
 4100: 1  0DA3	22		                ret
 4101: 1
 4102: 1			;*******************************************************************************
 4103: 1			; s_muldiv        (2,08ms @16.777216MHz)
 4104: 1			; 16-Bit signed product acc1(low word) x acc1(high word) naar 32bit signed
 4105: 1			; resultaat  gevolgd door 32bit signed deling door 32 bit getal acc0 met als
 4106: 1			; resultaat een 32bit quotient in acc0 en 32bit rest in acc1
 4107: 1			;
 4108: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh  (-32768 tot  +32767)
 4109: 1			;
 4110: 1			; input:     r5,r4 = acc1 (low word product)
 4111: 1			;            r7,r6 = acc1 (high word product)
 4112: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4113: 1			;
 4114: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4115: 1			;            r7,r6,r5,r4 = acc1 = rest
 4116: 1			;                          -2147483648 tot +2147483647
 4117: 1			;                          (80000000h..ffffffffh,0,00000001h..7fffffffh)
 4118: 1			;             cy=1 bij deling door nul (acc0=0)
 4119: 1			;             cy=0 bij normale deling
 4120: 1			;
 4121: 1			; vernietigt:  niets
 4122: 1			;*******************************************************************************
 4123: 1  0DA4	C0 E0		s_muldiv:       push    acc
 4124: 1  0DA6	C0 D0		                push    psw
 4125: 1  0DA8	E8		                mov     a,r0            ;neem msb van deler
 4126: 1  0DA9	49		                orl     a,r1            ;combineer met lsb's van deler
 4127: 1  0DAA	4A		                orl     a,r2
 4128: 1  0DAB	4B		                orl     a,r3
 4129: 1  0DAC	70 06		                jnz     s_muldiv1       ;deler is ok als dit niet nul is
 4130: 1  0DAE	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4131: 1  0DB0	D0 E0		                pop     acc
 4132: 1  0DB2	D3		                setb    C               ;fout, deling door nul!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 72



 Line  I  Addr  Code            Source

 4133: 1  0DB3	22		                ret
 4134: 1
 4135: 1  0DB4	12 08 61	s_muldiv1:      lcall    sigmag16acc1    ;acc1 low naar absolute waarde
 4136: 1  0DB7	12 08 81	                lcall    sigmag16acc1h   ;acc1 high naar absolute waarde
 4137: 1  0DBA	12 0D C9	                lcall    muldiv          ;maak product en daarna de deling
 4138: 1  0DBD	12 07 BB	                lcall    magsig32        ;quotient naar 2's complement
 4139: 1  0DC0	12 07 E5	                lcall    magsig32acc1    ;rest naar 2's complement
 4140: 1  0DC3	D0 D0		                pop     psw
 4141: 1  0DC5	C3		                clr     c                ;deling is ok
 4142: 1  0DC6	D0 E0		                pop    acc
 4143: 1  0DC8	22		                ret
 4144: 1
 4145: 1			;*******************************************************************************
 4146: 1			; muldiv        (2,0ms @16.777216MHz)
 4147: 1			; 16-Bit absolute waarde product acc1(low word) x acc1(high word) naar 32bit
 4148: 1			; absolute waarde resultaat  gevolgd door een 32bit absolute waarde deling door
 4149: 1			; acc0 als deler met als resultaat een 32bit quotient in acc0 en
 4150: 1			; 32bit rest in acc1.
 4151: 1			; acc1(low word) x acc1(high word) / acc0 = acc0(Quotient) en acc1(rest)
 4152: 1			;
 4153: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4154: 1			;
 4155: 1			; input:     r5,r4 = acc1 (low word product)
 4156: 1			;            r7,r6 = acc1 (high word product)
 4157: 1			;             r3,r2,r1,r0 = acc0  32bit deler
 4158: 1			;
 4159: 1			; output:    r3,r2,r1,r0 = acc0 = quotient
 4160: 1			;            r7,r6,r5,r4 = acc1 = rest
 4161: 1			;                          0 tot  +4294967296  (00000000h...ffffffffh)
 4162: 1			;             cy=1 bij deling door nul (acc0=0)
 4163: 1			;             cy=0 bij normale deling
 4164: 1			;
 4165: 1			; vernietigt:  niets
 4166: 1			;*******************************************************************************
 4167: 1  0DC9	C0 E0		muldiv:         push    acc
 4168: 1  0DCB	C0 D0		                push    psw
 4169: 1  0DCD	E8		                mov     a,r0            ;neem msb van deler
 4170: 1  0DCE	49		                orl     a,r1            ;combineer met lsb's van deler
 4171: 1  0DCF	4A		                orl     a,r2
 4172: 1  0DD0	4B		                orl     a,r3
 4173: 1  0DD1	70 06		                jnz     muldiv1         ;deler is ok als dit niet nul is
 4174: 1  0DD3	D0 D0		                pop     psw             ;anders fout, deling door nul!
 4175: 1  0DD5	D0 E0		                pop     acc
 4176: 1  0DD7	D3		                setb    C               ;fout, deling door nul!
 4177: 1  0DD8	22		                ret
 4178: 1
 4179: 1  0DD9	12 0A CA	muldiv1:        lcall    mul16acc1      ;16 bit product maken
 4180: 1  0DDC	EC		                mov     a,r4            ;registers verplaatsen voor deling
 4181: 1  0DDD	C0 E0		                push    acc
 4182: 1  0DDF	ED		                mov     a,r5
 4183: 1  0DE0	C0 E0		                push    acc
 4184: 1  0DE2	EE		                mov     a,r6
 4185: 1  0DE3	C0 E0		                push    acc
 4186: 1  0DE5	EF		                mov     a,r7
 4187: 1  0DE6	C0 E0		                push    acc             ;product staat nu op stack
 4188: 1

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 73



 Line  I  Addr  Code            Source

 4189: 1  0DE8	E8		                mov     a,r0            ;deler in acc1 stoppen
 4190: 1  0DE9	FC		                mov     r4,a
 4191: 1  0DEA	E9		                mov     a,r1
 4192: 1  0DEB	FD		                mov     r5,a
 4193: 1  0DEC	EA		                mov     a,r2
 4194: 1  0DED	FE		                mov     r6,a
 4195: 1  0DEE	EB		                mov     a,r3
 4196: 1  0DEF	FF		                mov     r7,a            ;deler zit volledig in acc1
 4197: 1
 4198: 1  0DF0	D0 E0		                pop     acc             ;deeltal in acc0 stoppen
 4199: 1  0DF2	FB		                mov     r3,a
 4200: 1  0DF3	D0 E0		                pop     acc
 4201: 1  0DF5	FA		                mov     r2,a
 4202: 1  0DF6	D0 E0		                pop     acc
 4203: 1  0DF8	F9		                mov     r1,a
 4204: 1  0DF9	D0 E0		                pop     acc
 4205: 1  0DFB	F8		                mov     r0,a            ;deeltal zit volledig in acc0
 4206: 1  0DFC	12 0C 9A	                lcall   div32           ;maak deling
 4207: 1
 4208: 1  0DFF	D0 D0		                pop     psw            ;herstel registers
 4209: 1  0E01	D0 E0		                pop     acc
 4210: 1  0E03	C3		                clr     C              ;resultaat ok!
 4211: 1  0E04	22		                ret
 4212: 1
 4213: 1			;*******************************************************************************
 4214: 1			; mul16_pi        (257,1us @16.777216MHz)
 4215: 1			; acc0 = acc0 x pi
 4216: 1			; 16 bit absolute waarde product van acc0 low (r1,r0) met pi=3.1416
 4217: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4218: 1			;
 4219: 1			; input:     r1,r0 = acc0 (low word)
 4220: 1			;
 4221: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x pi (0 tot 03243ch) r3=00h
 4222: 1			;
 4223: 1			; vernietigt:  niets
 4224: 1			;*******************************************************************************
 4225: 1  0E05	C0 E0		mul16_pi:       push    acc            ;registers bewaren
 4226: 1  0E07	C0 D0		                push    psw
 4227: 1  0E09	EC		                mov     a,r4
 4228: 1  0E0A	C0 E0		                push    acc
 4229: 1  0E0C	ED		                mov     a,r5
 4230: 1  0E0D	C0 E0		                push    acc
 4231: 1  0E0F	7D C9		                mov     r5,#0c9h       ;acc1 laden met pi x 2^14
 4232: 1  0E11	7C 0F		                mov     r4,#0fH
 4233: 1  0E13	12 0A 65	                lcall   mul16           ;acc0 = acc0 x acc1
 4234: 1  0E16	7C 0E		                mov     r4,#14          ;14 plaatsen naar rechts schuiven
 4235: 1  0E18	12 10 01	                lcall   shiftright32    ;om te delen door 2^14
 4236: 1  0E1B	D0 E0		                pop     acc
 4237: 1  0E1D	FD		                mov     r5,a
 4238: 1  0E1E	D0 E0		                pop     acc
 4239: 1  0E20	FC		                mov     r4,a
 4240: 1  0E21	D0 D0		                pop     psw
 4241: 1  0E23	D0 E0		                pop     acc
 4242: 1  0E25	22		                ret
 4243: 1
 4244: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 74



 Line  I  Addr  Code            Source

 4245: 1			; mul16_i_pi        (279,1us @16.777216MHz)
 4246: 1			; acc0 = acc0 x 1/pi
 4247: 1			; 16 bit absolute waarde product acc0 low (r1,r0) met (1/pi)=0,3183
 4248: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4249: 1			;
 4250: 1			; input:     r1,r0 = acc0 (low word)
 4251: 1			;
 4252: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/pi (0 tot +20860d) (0000h tot 517ch)
 4253: 1			;
 4254: 1			; vernietigt:  niets
 4255: 1			;*******************************************************************************
 4256: 1  0E26	C0 E0		mul16_i_pi:     push    acc             ;registers bewaren
 4257: 1  0E28	C0 D0		                push    psw
 4258: 1  0E2A	EC		                mov     a,r4
 4259: 1  0E2B	C0 E0		                push    acc
 4260: 1  0E2D	ED		                mov     a,r5
 4261: 1  0E2E	C0 E0		                push    acc
 4262: 1  0E30	7D 51		                mov     r5,#051h        ;acc1 laden met 1/pi x 2^16
 4263: 1  0E32	7C 7D		                mov     r4,#07dH
 4264: 1  0E34	12 0A 65	                lcall    mul16          ;acc0 = acc0 x acc1
 4265: 1  0E37	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4266: 1  0E39	12 10 01	                lcall   shiftright32    ;om te delen door 2^16
 4267: 1  0E3C	D0 E0		                pop     acc
 4268: 1  0E3E	FD		                mov     r5,a
 4269: 1  0E3F	D0 E0		                pop     acc
 4270: 1  0E41	FC		                mov     r4,a
 4271: 1  0E42	D0 D0		                pop     psw
 4272: 1  0E44	D0 E0		                pop     acc
 4273: 1  0E46	22		                ret
 4274: 1
 4275: 1			;*******************************************************************************
 4276: 1			; mul16_sqrt2        (268,1us @16.777216MHz)
 4277: 1			; acc0 = acc0 x sqrt2
 4278: 1			; Vermenigvuldigt acc0 low (r1,r0) met sqrt2 (2^1/2) =1,1442
 4279: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4280: 1			;
 4281: 1			; input:     r1,r0 = acc0 (low word)
 4282: 1			;
 4283: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x sqrt2
 4284: 1			;                                 0 tot  +74985  (000000h  0124e9ch)
 4285: 1			;
 4286: 1			; vernietigt:  niets
 4287: 1			;*******************************************************************************
 4288: 1  0E47	C0 E0		mul16_sqrt2:    push    acc             ;registers bewaren
 4289: 1  0E49	C0 D0		                push    psw
 4290: 1  0E4B	EC		                mov     a,r4
 4291: 1  0E4C	C0 E0		                push    acc
 4292: 1  0E4E	ED		                mov     a,r5
 4293: 1  0E4F	C0 E0		                push    acc
 4294: 1  0E51	7D B5		                mov     r5,#0b5h        ;acc1 laden met sqrt2x2^15
 4295: 1  0E53	7C 05		                mov     r4,#005H
 4296: 1  0E55	12 0A 65	                lcall   mul16           ;acc0 = acc0 x acc1
 4297: 1  0E58	7C 0F		                mov     r4,#15          ;15 plaatsen naar rechts schuiven
 4298: 1  0E5A	12 10 01	                lcall   shiftright32    ;om te delen door 2^15
 4299: 1  0E5D	D0 E0		                pop     acc
 4300: 1  0E5F	FD		                mov     r5,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 75



 Line  I  Addr  Code            Source

 4301: 1  0E60	D0 E0		                pop     acc
 4302: 1  0E62	FC		                mov     r4,a
 4303: 1  0E63	D0 D0		                pop     psw
 4304: 1  0E65	D0 E0		                pop     acc
 4305: 1  0E67	22		                ret
 4306: 1
 4307: 1
 4308: 1
 4309: 1			;*******************************************************************************
 4310: 1			; mul16_i_sqrt2            (279,1us @16.777216MHz)
 4311: 1			; acc0 = acc0 x 1/sqrt2
 4312: 1			; Vermenigvuldigt acc0 low (r1,r0) met 1/sqrt2=0,7071
 4313: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4314: 1			;
 4315: 1			; input:     r1,r0 = acc0 (low word)
 4316: 1			;
 4317: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 1/sqrt2 (0 tot 46340d)  (0000h..b504h)
 4318: 1			;
 4319: 1			; vernietigt:  niets
 4320: 1			;*******************************************************************************
 4321: 1  0E68	C0 E0		mul16_i_sqrt2:  push    acc             ;registers bewaren
 4322: 1  0E6A	C0 D0		                push    psw
 4323: 1  0E6C	EC		                mov     a,r4
 4324: 1  0E6D	C0 E0		                push    acc
 4325: 1  0E6F	ED		                mov     a,r5
 4326: 1  0E70	C0 E0		                push    acc
 4327: 1  0E72	7D B5		                mov     r5,#0b5h        ;acc1 laden met 1/sqrt2 x2^16
 4328: 1  0E74	7C 05		                mov     r4,#005H
 4329: 1  0E76	12 0A 65	                lcall   mul16           ;acc0 = acc0 x acc1
 4330: 1  0E79	7C 10		                mov     r4,#16          ;16 plaatsen naar rechts schuiven
 4331: 1  0E7B	12 10 01	                lcall   shiftright32    ;om te delen door 2^16
 4332: 1  0E7E	D0 E0		                pop     acc
 4333: 1  0E80	FD		                mov     r5,a
 4334: 1  0E81	D0 E0		                pop     acc
 4335: 1  0E83	FC		                mov     r4,a
 4336: 1  0E84	D0 D0		                pop     psw
 4337: 1  0E86	D0 E0		                pop     acc
 4338: 1  0E88	22		                ret
 4339: 1
 4340: 1			;*******************************************************************************
 4341: 1			; mul16_10        (98,7us @16.777216MHz)
 4342: 1			; acc0 = acc0 x 10
 4343: 1			; Vermenigvuldigt acc0 low (r1,r0) met 10
 4344: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4345: 1			;
 4346: 1			; input:     r1,r0 = acc0 (low word)
 4347: 1			;
 4348: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 10   (r3=00h)
 4349: 1			;                                 0 tot  655350 (000000h..09fff6h)
 4350: 1			; vernietigt:  niets
 4351: 1			;*******************************************************************************
 4352: 1  0E89	C0 E0		mul16_10:       push    acc             ;registers bewaren
 4353: 1  0E8B	C0 D0		                push    psw
 4354: 1  0E8D	EC		                mov     a,r4
 4355: 1  0E8E	C0 E0		                push    acc
 4356: 1  0E90	7C 01		                mov     r4,#1           ;acc0 x2

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 76



 Line  I  Addr  Code            Source

 4357: 1  0E92	12 10 2D	                lcall   shiftleft32     ;acc0 = acc0 x 2
 4358: 1  0E95	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4359: 1  0E96	C0 E0		                push    acc
 4360: 1  0E98	EA		                mov     a,r2
 4361: 1  0E99	C0 E0		                push    acc
 4362: 1  0E9B	E9		                mov     a,r1
 4363: 1  0E9C	C0 E0		                push    acc
 4364: 1  0E9E	E8		                mov     a,r0
 4365: 1  0E9F	C0 E0		                push    acc             ;acc0 op stack
 4366: 1  0EA1	7C 02		                mov     r4,#2           ;acc0 x4, in totaal dus x8!
 4367: 1  0EA3	12 10 2D	                lcall   shiftleft32     ;acc0 =acc0 x4
 4368: 1  0EA6	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4369: 1  0EA8	28		                add     a,r0            ;tel bij huidige acc0
 4370: 1  0EA9	F8		                mov     r0,a
 4371: 1  0EAA	D0 E0		                pop     acc
 4372: 1  0EAC	39		                addc    a,r1
 4373: 1  0EAD	F9		                mov     r1,a
 4374: 1  0EAE	D0 E0		                pop     acc
 4375: 1  0EB0	3A		                addc    a,r2
 4376: 1  0EB1	FA		                mov     r2,a
 4377: 1  0EB2	D0 E0		                pop     acc
 4378: 1  0EB4	3B		                addc    a,r3
 4379: 1  0EB5	FB		                mov     r3,a            ;acc0 =acc0x2 + acc0x8 = acc0x10
 4380: 1
 4381: 1
 4382: 1  0EB6	D0 E0		                pop     acc
 4383: 1  0EB8	FC		                mov     r4,a
 4384: 1  0EB9	D0 D0		                pop     psw
 4385: 1  0EBB	D0 E0		                pop     acc
 4386: 1  0EBD	22		                ret
 4387: 1
 4388: 1			;*******************************************************************************
 4389: 1			; mul16_100        (169,1us @16.777216MHz)
 4390: 1			; acc0 = acc0 x 100
 4391: 1			; Vermenigvuldigt acc0 low (r1,r0) met 100
 4392: 1			; Inputbereik getallen: 0000h..ffffh (0 tot 65535d)
 4393: 1			;
 4394: 1			; input:     r1,r0 = acc0 (low word)
 4395: 1			;
 4396: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 x 100  (r3=00h)
 4397: 1			;                                 0 tot  6553500 (000000h..63ff9ch)
 4398: 1			; vernietigt:  niets
 4399: 1			;*******************************************************************************
 4400: 1  0EBE	C0 E0		mul16_100:      push    acc             ;registers bewaren
 4401: 1  0EC0	C0 D0		                push    psw
 4402: 1  0EC2	EC		                mov     a,r4
 4403: 1  0EC3	C0 E0		                push    acc
 4404: 1  0EC5	7C 02		                mov     r4,#2           ;acc0 x4
 4405: 1  0EC7	12 10 2D	                lcall   shiftleft32     ;acc0 = acc0 x 4
 4406: 1  0ECA	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4407: 1  0ECB	C0 E0		                push    acc
 4408: 1  0ECD	EA		                mov     a,r2
 4409: 1  0ECE	C0 E0		                push    acc
 4410: 1  0ED0	E9		                mov     a,r1
 4411: 1  0ED1	C0 E0		                push    acc
 4412: 1  0ED3	E8		                mov     a,r0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 77



 Line  I  Addr  Code            Source

 4413: 1  0ED4	C0 E0		                push    acc             ;acc0 op stack
 4414: 1
 4415: 1  0ED6	7C 03		                mov     r4,#3           ;acc0 x8, in totaal dus x32!
 4416: 1  0ED8	12 10 2D	                lcall   shiftleft32     ;acc0 =acc0 x8
 4417: 1  0EDB	EB		                mov     a,r3            ;bewaar tussenresultaat op stack
 4418: 1  0EDC	C0 E0		                push    acc
 4419: 1  0EDE	EA		                mov     a,r2
 4420: 1  0EDF	C0 E0		                push    acc
 4421: 1  0EE1	E9		                mov     a,r1
 4422: 1  0EE2	C0 E0		                push    acc
 4423: 1  0EE4	E8		                mov     a,r0
 4424: 1  0EE5	C0 E0		                push    acc             ;acc0 op stack
 4425: 1
 4426: 1  0EE7	7C 01		                mov     r4,#1           ;acc0 x2, in totaal dus x64!
 4427: 1  0EE9	12 10 2D	                lcall   shiftleft32     ;acc0 =acc0 x2
 4428: 1  0EEC	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4429: 1  0EEE	28		                add     a,r0            ;tel bij huidige acc0
 4430: 1  0EEF	F8		                mov     r0,a
 4431: 1  0EF0	D0 E0		                pop     acc
 4432: 1  0EF2	39		                addc    a,r1
 4433: 1  0EF3	F9		                mov     r1,a
 4434: 1  0EF4	D0 E0		                pop     acc
 4435: 1  0EF6	3A		                addc    a,r2
 4436: 1  0EF7	FA		                mov     r2,a
 4437: 1  0EF8	D0 E0		                pop     acc
 4438: 1  0EFA	3B		                addc    a,r3
 4439: 1  0EFB	FB		                mov     r3,a            ;acc0 =acc0x64 + acc0x32 = acc0x96
 4440: 1
 4441: 1  0EFC	D0 E0		                pop     acc             ;haal tussenresultaat van stack en
 4442: 1  0EFE	28		                add     a,r0            ;tel bij huidige acc0
 4443: 1  0EFF	F8		                mov     r0,a
 4444: 1  0F00	D0 E0		                pop     acc
 4445: 1  0F02	39		                addc    a,r1
 4446: 1  0F03	F9		                mov     r1,a
 4447: 1  0F04	D0 E0		                pop     acc
 4448: 1  0F06	3A		                addc    a,r2
 4449: 1  0F07	FA		                mov     r2,a
 4450: 1  0F08	D0 E0		                pop     acc
 4451: 1  0F0A	3B		                addc    a,r3
 4452: 1  0F0B	FB		                mov     r3,a            ;acc0 =acc0x96+ acc0x4 = acc0x100
 4453: 1
 4454: 1  0F0C	D0 E0		                pop     acc
 4455: 1  0F0E	FC		                mov     r4,a
 4456: 1  0F0F	D0 D0		                pop     psw
 4457: 1  0F11	D0 E0		                pop     acc
 4458: 1  0F13	22		                ret
 4459: 1
 4460: 1			;*******************************************************************************
 4461: 1			; sqrt32        (2,99ms @16.777216MHz)
 4462: 1			; acc0 = acc0 ^(1/2)
 4463: 1			; Deze routine neemt de vierkantswortel van de absolute 32 bit waarde van acc0.
 4464: 1			; Inputbereik getal in acc0:  00000000h..ffffffffh (0 tot  +4294967295d)
 4465: 1			;
 4466: 1			; input:     r3,r2,r1,r0 = acc0
 4467: 1			;
 4468: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 78



 Line  I  Addr  Code            Source

 4469: 1			;
 4470: 1			; vernietigt:  niets
 4471: 1			;*******************************************************************************
 4472: 1  0F14	C0 E0		sqrt32:         push    acc              ;bewaren van de gebruikte registers
 4473: 1  0F16	C0 F0		                push    b
 4474: 1  0F18	C0 D0		                push    psw
 4475: 1  0F1A	C0 82		                push    dpl
 4476: 1  0F1C	C0 83		                push    dph
 4477: 1  0F1E	EC		                mov     a,r4
 4478: 1  0F1F	C0 E0		                push    acc
 4479: 1  0F21	ED		                mov     a,r5
 4480: 1  0F22	C0 E0		                push    acc
 4481: 1  0F24	EE		                mov     a,r6
 4482: 1  0F25	C0 E0		                push    acc
 4483: 1  0F27	EF		                mov     a,r7
 4484: 1  0F28	C0 E0		                push    acc
 4485: 1
 4486: 1  0F2A	7C 00		                mov     r4,#0           ;acc1 op nul zetten
 4487: 1  0F2C	7D 00		                mov     r5,#0
 4488: 1  0F2E	7E 00		                mov     r6,#0
 4489: 1  0F30	7F 00		                mov     r7,#0
 4490: 1  0F32	75 82 00	                mov     dpl,#0          ;wortel op nul zetten
 4491: 1  0F35	75 83 00	                mov     dph,#0
 4492: 1  0F38	75 F0 10	                mov     b,#16           ;lusteller op 16 zetten
 4493: 1			;hier start het algorithme voor het berekenen van de wortel
 4494: 1  0F3B	C0 F0		sqrt320:        push    b               ;lusteller wortel even bewaren
 4495: 1  0F3D	75 F0 02	                mov     b,#2            ;we schuiven acc0 2 bitposities naar
 4496: 1  0F40	C3		sqrt321:        clr     c               ;links, de twee msb's komen zo
 4497: 1  0F41	E8		                mov     a,r0            ;stelselmatig in acc1 terecht waar ze
 4498: 1  0F42	33		                rlc     a                ;getest worden om een wortelbit te
 4499: 1  0F43	F8		                mov     r0,a            ;berekenen, acc0 geraakt stilaan vol
 4500: 1  0F44	E9		                mov     a,r1            ;met nullen!
 4501: 1  0F45	33		                rlc     a
 4502: 1  0F46	F9		                mov     r1,a
 4503: 1  0F47	EA		                mov     a,r2
 4504: 1  0F48	33		                rlc     a
 4505: 1  0F49	FA		                mov     r2,a
 4506: 1  0F4A	EB		                mov     a,r3
 4507: 1  0F4B	33		                rlc     a
 4508: 1  0F4C	FB		                mov     r3,a            ;acco is nu een bitpositie opgeschoven
 4509: 1
 4510: 1  0F4D	EC		                mov     a,r4            ;msb van acco in lsb van acc1 schuiven
 4511: 1  0F4E	33		                rlc     a
 4512: 1  0F4F	FC		                mov     r4,a
 4513: 1  0F50	ED		                mov     a,r5
 4514: 1  0F51	33		                rlc     a
 4515: 1  0F52	FD		                mov     r5,a
 4516: 1  0F53	EE		                mov     a,r6
 4517: 1  0F54	33		                rlc     a
 4518: 1  0F55	FE		                mov     r6,a
 4519: 1  0F56	EF		                mov     a,r7
 4520: 1  0F57	33		                rlc     a
 4521: 1  0F58	FF		                mov     r7,a            ;acc1 is nu ook 1 positie opgeschoven
 4522: 1  0F59	D5 F0 E4	                djnz    b,sqrt321       ;doe dit nog eens: 2 bits opschuiven!
 4523: 1
 4524: 1  0F5C	D0 F0		                pop     b               ;lusteller wortel weer terugnemen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 79



 Line  I  Addr  Code            Source

 4525: 1
 4526: 1  0F5E	D3		                setb    c               ;we schuiven nu een 1 binnen op de lsb
 4527: 1  0F5F	E5 82		                mov     a,dpl           ;van de voorlopige wortel
 4528: 1  0F61	33		                rlc     a
 4529: 1  0F62	F5 82		                mov     dpl,a
 4530: 1  0F64	E5 83		                mov     a,dph
 4531: 1  0F66	33		                rlc     a
 4532: 1  0F67	F5 83		                mov     dph,a           ;wortel is 1 bitpositie opgeschoven
 4533: 1
 4534: 1			;kwadraat van de voorlopige wortel berekenen om te vergelijken met acc1
 4535: 1  0F69	E8		                mov     a,r0            ;de inhoud van acc0 en acc1 even
 4536: 1  0F6A	C0 E0		                push    acc             ;bewaren voor het berekenen van het
 4537: 1  0F6C	E9		                mov     a,r1            ;kwadraat van de voorlopige wortel
 4538: 1  0F6D	C0 E0		                push    acc             ;in acc1 en voor het vergelijken van
 4539: 1  0F6F	EA		                mov     a,r2            ;dit kwadraat met de huidige inhoud
 4540: 1  0F70	C0 E0		                push    acc             ;van acc1
 4541: 1  0F72	EB		                mov     a,r3
 4542: 1  0F73	C0 E0		                push    acc
 4543: 1  0F75	EC		                mov     a,r4
 4544: 1  0F76	C0 E0		                push    acc
 4545: 1  0F78	ED		                mov     a,r5
 4546: 1  0F79	C0 E0		                push    acc
 4547: 1  0F7B	EE		                mov     a,r6
 4548: 1  0F7C	C0 E0		                push    acc
 4549: 1  0F7E	EF		                mov     a,r7
 4550: 1  0F7F	C0 E0		                push    acc             ;acc0 en acc1 zijn opgeslagen
 4551: 1
 4552: 1  0F81	AC 82		                mov     r4,dpl          ;voorlopige wortel in acc1 low
 4553: 1  0F83	AD 83		                mov     r5,dph
 4554: 1  0F85	AE 82		                mov     r6,dpl          ;voorlopige wortel in acc1 high
 4555: 1  0F87	AF 83		                mov     r7,dph
 4556: 1  0F89	12 0A CA	                lcall    mul16acc1      ;maak kwadraat in acc1 (r7,r6,r5,r4)
 4557: 1
 4558: 1  0F8C	D0 E0		                pop     acc             ;haal huidige acc1 weer op en stop even
 4559: 1  0F8E	FB		                mov     r3,a            ;in acc0 om te kunnen vergelijken met
 4560: 1  0F8F	D0 E0		                pop     acc             ;het kwadraat van de voorlopige
 4561: 1  0F91	FA		                mov     r2,a            ;wortel die nu in acc1 zit.
 4562: 1  0F92	D0 E0		                pop     acc             ;hierbij vermindert de stackpointer met
 4563: 1  0F94	F9		                mov     r1,a            ;vier plaatsen en wijst hij naar acc0 op
 4564: 1  0F95	D0 E0		                pop     acc             ;de stack...
 4565: 1  0F97	F8		                mov     r0,a            ;huidige acc1 zit nu volledig in acc0
 4566: 1
 4567: 1  0F98	C3		                clr     c               ;we gaan nu vergelijken of de huidige
 4568: 1  0F99	E8		                mov     a,r0            ;acc1 groter of gelijk is aan het
 4569: 1  0F9A	9C		                subb    a,r4            ;kwadraat van de voorlopige wortel
 4570: 1  0F9B	E9		                mov     a,r1            ;in acc1.
 4571: 1  0F9C	9D		                subb    a,r5            ;We doen dit door de carry van het
 4572: 1  0F9D	EA		                mov     a,r2            ;verschil acc0-acc1 te evalueren.
 4573: 1  0F9E	9E		                subb    a,r6
 4574: 1  0F9F	EB		                mov     a,r3
 4575: 1  0FA0	9F		                subb    a,r7            ;als acc1>= kwadraat, dan: geen carry
 4576: 1  0FA1	50 06		                jnc     sqrt323         ;en de laatst ingeschoven 1 van de
 4577: 1			                                        ;wortel behouden
 4578: 1  0FA3	E5 82		sqrt322:        mov     a,dpl          ;We verwerpen de laatst ingeschoven 1 in
 4579: 1  0FA5	54 FE		                anl     a,#0feh         ;de wortel! kwadraat is te groot!
 4580: 1  0FA7	F5 82		                mov     dpl,a          ;wortel aanpassen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 80



 Line  I  Addr  Code            Source

 4581: 1
 4582: 1  0FA9	E5 81		sqrt323:        mov     a,sp           ;verzet de stackpointer weer naar boven
 4583: 1  0FAB	24 04		                add     a,#4           ;zodat de huidige acc1 die nog op stack
 4584: 1  0FAD	F5 81		                mov     sp,a           ;opnieuw kan worden opgehaald
 4585: 1
 4586: 1  0FAF	D0 E0		                pop     acc            ;haal acc1 weer op
 4587: 1  0FB1	FF		                mov     r7,a
 4588: 1  0FB2	D0 E0		                pop     acc
 4589: 1  0FB4	FE		                mov     r6,a
 4590: 1  0FB5	D0 E0		                pop     acc
 4591: 1  0FB7	FD		                mov     r5,a
 4592: 1  0FB8	D0 E0		                pop     acc
 4593: 1  0FBA	FC		                mov     r4,a           ;huidige acc1 weer hersteld
 4594: 1
 4595: 1  0FBB	D0 E0		                pop     acc            ;nu nog acc0 van stack halen
 4596: 1  0FBD	FB		                mov     r3,a
 4597: 1  0FBE	D0 E0		                pop     acc
 4598: 1  0FC0	FA		                mov     r2,a
 4599: 1  0FC1	D0 E0		                pop     acc
 4600: 1  0FC3	F9		                mov     r1,a
 4601: 1  0FC4	D0 E0		                pop     acc
 4602: 1  0FC6	F8		                mov     r0,a           ;acc0 is helemaal hersteld
 4603: 1
 4604: 1  0FC7	D5 F0 02	sqrt3240:       djnz    b,sqrt324      ;blijf herhalen voor alle bit duo's
 4605: 1  0FCA	80 03		                sjmp    sqrt325
 4606: 1  0FCC	02 0F 3B	sqrt324:        ljmp    sqrt320        ;uit acc0
 4607: 1
 4608: 1  0FCF	A9 83		sqrt325:        mov     r1,dph         ;voorlopige wortel is de vierkants-
 4609: 1  0FD1	A8 82		                mov     r0,dpl         ;wortel van acc0!
 4610: 1
 4611: 1  0FD3	D0 E0		                pop     acc            ;herstel de gebruikte registers
 4612: 1  0FD5	FF		                mov     r7,a
 4613: 1  0FD6	D0 E0		                pop     acc
 4614: 1  0FD8	FE		                mov     r6,a
 4615: 1  0FD9	D0 E0		                pop     acc
 4616: 1  0FDB	FD		                mov     r5,a
 4617: 1  0FDC	D0 E0		                pop     acc
 4618: 1  0FDE	FC		                mov     r4,a           ;acc1 is hersteld
 4619: 1  0FDF	D0 83		                pop     dph
 4620: 1  0FE1	D0 82		                pop     dpl
 4621: 1  0FE3	D0 D0		                pop     psw
 4622: 1  0FE5	D0 F0		                pop     b
 4623: 1  0FE7	D0 E0		                pop     acc
 4624: 1
 4625: 1  0FE9	22		                ret                    ;eindelijk klaar...
 4626: 1
 4627: 1			;*******************************************************************************
 4628: 1			; s_sqrt32        (2,99ms @16.777216MHz)
 4629: 1			; acc0 = acc0 ^(1/2)
 4630: 1			; Deze routine neemt de vierkantswortel van de signed 32 bit waarde van acc0.
 4631: 1			; Inputbereik getal in acc0: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4632: 1			;                           (-2147483648 tot +2147483647)
 4633: 1			; input:     r3,r2,r1,r0 = acc0
 4634: 1			;
 4635: 1			; output:    r3,r2,r1,r0 = acc0^(1/2)     r3=r2=00h
 4636: 1			;            CY = 1 als acc0 negatief is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 81



 Line  I  Addr  Code            Source

 4637: 1			; vernietigt:  niets
 4638: 1			;*******************************************************************************
 4639: 1  0FEA	C0 E0		s_sqrt32:       push    acc
 4640: 1  0FEC	C0 D0		                push    psw
 4641: 1  0FEE	EB		                mov     a,r3
 4642: 1  0FEF	30 E7 06	                jnb     acc.7,s_sqrt321  ;als positief dan verder werken...
 4643: 1  0FF2	D0 D0		                pop     psw
 4644: 1  0FF4	D3		                setb    c                ;als negatief dan error
 4645: 1  0FF5	D0 E0		                pop     acc
 4646: 1  0FF7	22		                ret
 4647: 1  0FF8	D0 D0		s_sqrt321:      pop     psw
 4648: 1  0FFA	D0 E0		                pop     acc
 4649: 1  0FFC	12 0F 14	                lcall   sqrt32            ;wortel trekken
 4650: 1  0FFF	C3		                clr     c                 ;wortel ok
 4651: 1  1000	22		                ret                       ;klaar
 4652: 1
 4653: 1			;*******************************************************************************
 4654: 1			; shiftright32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4655: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar rechts.
 4656: 1			; (logical shift)
 4657: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4658: 1			;
 4659: 1			; input:     r3,r2,r1,r0 = acc0
 4660: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4661: 1			;
 4662: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4663: 1			;            CY=1 als N>=32
 4664: 1			; vernietigt:  niets
 4665: 1			;*******************************************************************************
 4666: 1  1001	C0 E0		shiftright32:   push    acc             ;bewaren van de registers
 4667: 1  1003	C0 D0		                push    psw
 4668: 1  1005	EC		                mov     a,r4            ;neem aantal shifts
 4669: 1  1006	B4 21 00	                cjne    a,#33,shiftright1 ;test waarde van N
 4670: 1  1009	40 06		shiftright1:    jc      shiftright2
 4671: 1  100B	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4672: 1  100D	D3		                setb    c               ;N buiten bereik
 4673: 1  100E	D0 E0		                pop     acc
 4674: 1  1010	22		                ret
 4675: 1
 4676: 1  1011	C0 F0		shiftright2:    push    b               ;ok, N is kleiner dan 32
 4677: 1  1013	8C F0		                mov     b,r4            ;lusteller initialiseren
 4678: 1  1015	C3		shiftright3:    clr     c               ;nullen binnenschuiven in msb
 4679: 1  1016	EB		                mov     a,r3            ;start bij msb
 4680: 1  1017	13		                rrc     a
 4681: 1  1018	FB		                mov     r3,a
 4682: 1  1019	EA		                mov     a,r2
 4683: 1  101A	13		                rrc     a
 4684: 1  101B	FA		                mov     r2,a
 4685: 1  101C	E9		                mov     a,r1
 4686: 1  101D	13		                rrc     a
 4687: 1  101E	F9		                mov     r1,a
 4688: 1  101F	E8		                mov     a,r0
 4689: 1  1020	13		                rrc     a
 4690: 1  1021	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4691: 1  1022	D5 F0 F0	                djnz    b,shiftright3   ;herhaal N maal
 4692: 1  1025	D0 F0		                pop     b               ;registers herstellen

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 82



 Line  I  Addr  Code            Source

 4693: 1  1027	D0 D0		                pop     psw
 4694: 1  1029	C3		                clr     c               ;N is binnen bereik
 4695: 1  102A	D0 E0		                pop     acc
 4696: 1  102C	22		                ret
 4697: 1
 4698: 1			;*******************************************************************************
 4699: 1			; shiftleft32        (359,1us met N=32, 25,94us met N=1  @16.777216MHz)
 4700: 1			; Schuift de 32 bit inhoud van acc0 N plaatsen naar links.
 4701: 1			; (logical shift)
 4702: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot  +4294967296d)
 4703: 1			;
 4704: 1			; input:     r3,r2,r1,r0 = acc0
 4705: 1			;                     r4 = N  (te schuiven aantal posities  0<N<32)
 4706: 1			;
 4707: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 <<N
 4708: 1			;
 4709: 1			; vernietigt:  niets
 4710: 1			;*******************************************************************************
 4711: 1  102D	C0 E0		shiftleft32:    push    acc             ;bewaren van de registers
 4712: 1  102F	C0 D0		                push    psw
 4713: 1  1031	EC		                mov     a,r4            ;neem aantal shifts
 4714: 1  1032	B4 21 00	                cjne    a,#33,shiftleft1;test waarde van N
 4715: 1  1035	40 06		shiftleft1:     jc      shiftleft2
 4716: 1  1037	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4717: 1  1039	D3		                setb    c               ;N buiten bereik
 4718: 1  103A	D0 E0		                pop     acc
 4719: 1  103C	22		                ret
 4720: 1
 4721: 1  103D	C0 F0		shiftleft2:     push    b               ;ok, N is kleiner dan 32
 4722: 1  103F	8C F0		                mov     b,r4            ;lusteller initialiseren
 4723: 1  1041	C3		shiftleft3:     clr     c                ;nullen binnenschuiven in lsb
 4724: 1  1042	E8		                mov     a,r0            ;start bij lsb
 4725: 1  1043	33		                rlc     a
 4726: 1  1044	F8		                mov     r0,a
 4727: 1  1045	E9		                mov     a,r1
 4728: 1  1046	33		                rlc     a
 4729: 1  1047	F9		                mov     r1,a
 4730: 1  1048	EA		                mov     a,r2
 4731: 1  1049	33		                rlc     a
 4732: 1  104A	FA		                mov     r2,a
 4733: 1  104B	EB		                mov     a,r3
 4734: 1  104C	33		                rlc     a
 4735: 1  104D	FB		                mov     r3,a            ;32bits zijn 1 plaats verschoven
 4736: 1  104E	D5 F0 F0	                djnz    b,shiftleft3    ;herhaal N maal
 4737: 1  1051	D0 F0		                pop     b               ;registers herstellen
 4738: 1  1053	D0 D0		                pop     psw
 4739: 1  1055	C3		                clr     c               ;N is binnen bereik
 4740: 1  1056	D0 E0		                pop     acc
 4741: 1  1058	22		                ret
 4742: 1
 4743: 1			;*******************************************************************************
 4744: 1			; s_shiftright32        (353,1us met N=31, 30,34us met N=1  @16.777216MHz)
 4745: 1			; (arithmetic shift)
 4746: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar rechts.
 4747: 1			; De tekenbit wordt als bit binnengeschoven langs links, het getal verandert dus
 4748: 1			; niet van teken!

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 83



 Line  I  Addr  Code            Source

 4749: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4750: 1			;                       (-2147483648 tot +2147483647)
 4751: 1			;
 4752: 1			; input:     r3,r2,r1,r0 = acc0
 4753: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4754: 1			;
 4755: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4756: 1			;            CY=1 als N>=31
 4757: 1			; vernietigt:  niets
 4758: 1			;*******************************************************************************
 4759: 1  1059	C0 E0		s_shiftright32: push    acc             ;bewaren van de registers
 4760: 1  105B	C0 D0		                push    psw
 4761: 1  105D	EC		                mov     a,r4            ;neem aantal shifts
 4762: 1  105E	B4 20 00	                cjne    a,#32,s_shiftright1 ;test waarde van N
 4763: 1  1061	40 06		s_shiftright1:  jc      s_shiftright2
 4764: 1  1063	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4765: 1  1065	D3		                setb    c               ;N buiten bereik
 4766: 1  1066	D0 E0		                pop     acc
 4767: 1  1068	22		                ret
 4768: 1
 4769: 1  1069	C0 F0		s_shiftright2:  push    b               ;ok, N is kleiner dan 32
 4770: 1  106B	8C F0		                mov     b,r4            ;lusteller initialiseren
 4771: 1  106D	EB		                mov     a,r3
 4772: 1  106E	20 E7 04	                jb      acc.7,s_shiftright20
 4773: 1  1071	C2 D5		                clr     f0              ;geef aan dat getal positief is
 4774: 1  1073	80 02		                sjmp    s_shiftright3
 4775: 1  1075	D2 D5		s_shiftright20: setb    f0              ;geef aan dat getal negatief is
 4776: 1
 4777: 1  1077	A2 D5		s_shiftright3:  mov     c,f0            ;teken binnenschuiven in msb
 4778: 1  1079	EB		                mov     a,r3            ;start bij msb
 4779: 1  107A	13		                rrc     a
 4780: 1  107B	FB		                mov     r3,a
 4781: 1  107C	EA		                mov     a,r2
 4782: 1  107D	13		                rrc     a
 4783: 1  107E	FA		                mov     r2,a
 4784: 1  107F	E9		                mov     a,r1
 4785: 1  1080	13		                rrc     a
 4786: 1  1081	F9		                mov     r1,a
 4787: 1  1082	E8		                mov     a,r0
 4788: 1  1083	13		                rrc     a
 4789: 1  1084	F8		                mov     r0,a            ;32bits zijn 1 plaats verschoven
 4790: 1  1085	D5 F0 EF	                djnz    b,s_shiftright3 ;herhaal N maal
 4791: 1  1088	D0 F0		                pop     b               ;registers herstellen
 4792: 1  108A	D0 D0		                pop     psw
 4793: 1  108C	C3		                clr     c               ;N is binnen bereik
 4794: 1  108D	D0 E0		                pop     acc
 4795: 1  108F	22		                ret
 4796: 1
 4797: 1			;*******************************************************************************
 4798: 1			; s_shiftleft32        (393,1us met N=31, 27,2us met N=1  @16.777216MHz)
 4799: 1			; (arithmetic shift)
 4800: 1			; Schuift de signed (2's compl.) 32 bit inhoud van acc0 N plaatsen naar links.
 4801: 1			; De tekenbit wordt als bit behouden op de msb, het getal verandert dus
 4802: 1			; niet van teken! Er worden langs rechts nullen binnengeschoven.
 4803: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4804: 1			;                       (-2147483648 tot +2147483647)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 84



 Line  I  Addr  Code            Source

 4805: 1			;
 4806: 1			; input:     r3,r2,r1,r0 = acc0
 4807: 1			;                     r4 = N  (te schuiven aantal posities  0<N<31)
 4808: 1			;
 4809: 1			; output:    r3,r2,r1,r0 = acc0 = acc0 >>N
 4810: 1			;            CY=1 als N>=31
 4811: 1			; vernietigt:  niets
 4812: 1			;*******************************************************************************
 4813: 1  1090	C0 E0		s_shiftleft32:  push    acc             ;bewaren van de registers
 4814: 1  1092	C0 D0		                push    psw
 4815: 1  1094	EC		                mov     a,r4            ;neem aantal shifts
 4816: 1  1095	B4 20 00	                cjne    a,#32,s_shiftleft1;test waarde van N
 4817: 1  1098	40 06		s_shiftleft1:   jc      s_shiftleft2
 4818: 1  109A	D0 D0		                pop     psw             ;als 32 of groter dan buiten bereik!
 4819: 1  109C	D3		                setb    c               ;N buiten bereik
 4820: 1  109D	D0 E0		                pop     acc
 4821: 1  109F	22		                ret
 4822: 1
 4823: 1  10A0	C0 F0		s_shiftleft2:   push    b               ;ok, N is kleiner dan 32
 4824: 1  10A2	8C F0		                mov     b,r4            ;lusteller initialiseren
 4825: 1
 4826: 1
 4827: 1
 4828: 1  10A4	C3		s_shiftleft3:   clr     c                ;nullen binnenschuiven in lsb
 4829: 1  10A5	E8		                mov     a,r0             ;start bij lsb
 4830: 1  10A6	33		                rlc     a
 4831: 1  10A7	F8		                mov     r0,a
 4832: 1  10A8	E9		                mov     a,r1
 4833: 1  10A9	33		                rlc     a
 4834: 1  10AA	F9		                mov     r1,a
 4835: 1  10AB	EA		                mov     a,r2
 4836: 1  10AC	33		                rlc     a
 4837: 1  10AD	FA		                mov     r2,a
 4838: 1  10AE	EB		                mov     a,r3
 4839: 1  10AF	33		                rlc     a
 4840: 1  10B0	92 E7		                mov     acc.7,c          ;tekenbit behouden!
 4841: 1  10B2	FB		                mov     r3,a             ;32bits zijn 1 plaats verschoven
 4842: 1  10B3	D5 F0 EE	                djnz    b,s_shiftleft3    ;herhaal N maal
 4843: 1  10B6	D0 F0		                pop     b                ;registers herstellen
 4844: 1  10B8	D0 D0		                pop     psw
 4845: 1  10BA	C3		                clr     c                ;N is binnen bereik
 4846: 1  10BB	D0 E0		                pop     acc
 4847: 1  10BD	22		                ret
 4848: 1
 4849: 1			;*******************************************************************************
 4850: 1			; s_cmp16    (29,5us @16.777216MHz)
 4851: 1			; Vergelijkt de 2's complement inhoud van acc0 (low) en acc1 (low).
 4852: 1			;
 4853: 1			; Inputbereik getallen: 8000h..ffffh,0,0001h..7fffh (-32768d,0,+32767d)
 4854: 1			;
 4855: 1			; input:     r1,r0 = acc0
 4856: 1			;            r5,r4 = acc1
 4857: 1			;
 4858: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4859: 1			;             f0=0,cy=0  als acc0 > acc1
 4860: 1			;             f0=1 cy=0    als acc1 = acc0

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 85



 Line  I  Addr  Code            Source

 4861: 1			;
 4862: 1			; vernietigt:  niets
 4863: 1			;*******************************************************************************
 4864: 1  10BE	C0 E0		s_cmp16:        push    acc             ;registers bewaren op stack
 4865: 1  10C0	C0 D0		                push    psw
 4866: 1  10C2	E8		                mov     a,r0
 4867: 1  10C3	C0 E0		                push    acc
 4868: 1  10C5	E9		                mov     a,r1
 4869: 1  10C6	C0 E0		                push    acc
 4870: 1
 4871: 1  10C8	E9		                mov     a,r1            ;neem msb van acc0
 4872: 1  10C9	6D		                xrl     a,r5            ;check gelijk aan tekenbit van acc1
 4873: 1  10CA	30 E7 20	                jnb     acc.7,s_cmp162  ;bij gelijk teken, verschil maken
 4874: 1  10CD	E9		                mov     a,r1            ;bij verschillend teken kijken wie er
 4875: 1			                                        ;negatief is
 4876: 1  10CE	20 E7 0E	                jb      acc.7,s_cmp161  ;als r1.7=1, dan is acc0 negatief
 4877: 1			                                        ;en dus acc1 positief. Dus acc0<acc1
 4878: 1
 4879: 1			;als r1.7=0, dan is acc0 positief en dus acc1 negatief. Dus acc0>acc1
       1
 4880: 1			;acc0>acc1
 4881: 1  10D1	D0 E0		s_cmp160:       pop     acc
 4882: 1  10D3	F9		                mov     r1,a
 4883: 1  10D4	D0 E0		                pop     acc
 4884: 1  10D6	F8		                mov     r0,a
 4885: 1  10D7	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 4886: 1  10D9	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 4887: 1  10DB	C3		                clr     c               ;geef dit aan in de outputstatus
 4888: 1  10DC	D0 E0		                pop     acc
 4889: 1  10DE	22		                ret
 4890: 1			;acc0<acc1
 4891: 1  10DF	D0 E0		s_cmp161:       pop     acc
 4892: 1  10E1	F9		                mov     r1,a
 4893: 1  10E2	D0 E0		                pop     acc
 4894: 1  10E4	F8		                mov     r0,a
 4895: 1  10E5	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 4896: 1  10E7	D3		                setb    c               ;groter dan acc0
 4897: 1  10E8	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 4898: 1  10EA	D0 E0		                pop     acc
 4899: 1  10EC	22		                ret
 4900: 1			;gelijk teken, maak verschil
 4901: 1  10ED	C3		s_cmp162:       clr     c               ;teken is gelijk maak verschil
 4902: 1  10EE	E8		                mov     a,r0            ;acc0-acc1
 4903: 1  10EF	9C		                subb    a,r4
 4904: 1  10F0	F8		                mov     r0,a
 4905: 1  10F1	E9		                mov     a,r1
 4906: 1  10F2	9D		                subb    a,r5
 4907: 1  10F3	F9		                mov     r1,a
 4908: 1  10F4	20 E7 E8	                jb      acc.7,s_cmp161  ;als r1.7=1 (underflow) acc0<acc1
 4909: 1  10F7	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 4910: 1  10F8	60 02		                jz      s_cmp163        ;acc0=acc1
 4911: 1  10FA	80 D5		                sjmp    s_cmp160        ;acc0>acc1
 4912: 1			;acc0=acc1
 4913: 1  10FC	D0 E0		s_cmp163:       pop     acc
 4914: 1  10FE	F9		                mov     r1,a
 4915: 1  10FF	D0 E0		                pop     acc

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 86



 Line  I  Addr  Code            Source

 4916: 1  1101	F8		                mov     r0,a
 4917: 1  1102	D0 D0		                pop     psw             ;acc0=acc1
 4918: 1  1104	C3		                clr     c               ;geef dit aan in de outputstatus
 4919: 1  1105	D2 D5		                setb    f0
 4920: 1  1107	D0 E0		                pop     acc
 4921: 1  1109	22		                ret
 4922: 1
 4923: 1			;*******************************************************************************
 4924: 1			; cmp16            (19,9us @16.777216MHz)
 4925: 1			; Vergelijkt de unsigned inhoud van acc0 (low) en acc1 (low).
 4926: 1			;
 4927: 1			; Inputbereikt getallen: 0000h..ffffh (0,+65535d)
 4928: 1			;
 4929: 1			; input:     r1,r0 = acc0
 4930: 1			;            r5,r4 = acc1
 4931: 1			;
 4932: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4933: 1			;             f0=0,cy=0  als acc0 > acc1
 4934: 1			;             f0=1 cy=0    als acc1 = acc0
 4935: 1			;
 4936: 1			; vernietigt:  niets
 4937: 1			;*******************************************************************************
 4938: 1  110A	C0 E0		cmp16:          push    acc             ;bewaar registers
 4939: 1  110C	C0 F0		                push    b
 4940: 1  110E	C0 D0		                push    psw
 4941: 1
 4942: 1  1110	C3		                clr     c               ;vergelijk acc0 met acc1
 4943: 1  1111	E9		                mov     a,r1            ;eerst de msb's
 4944: 1  1112	8D F0		                mov     b,r5            ;test r1-r5
 4945: 1  1114	B5 F0 10	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4946: 1
 4947: 1  1117	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk lsb's
 4948: 1  1118	8C F0		                mov     b,r4            ;test r0-r4
 4949: 1  111A	B5 F0 0A	                cjne    a,b,cmp161      ;niet gelijk, kijk wie grootst is
 4950: 1			;acc0=acc1
 4951: 1  111D	D0 D0		                pop     psw
 4952: 1  111F	D2 D5		                setb    f0
 4953: 1  1121	C3		                clr     c
 4954: 1  1122	D0 F0		                pop     b
 4955: 1  1124	D0 E0		                pop     acc
 4956: 1  1126	22		                ret
 4957: 1  1127	40 0A		cmp161:         jc      cmp162          ;cy=1 indien acc0<acc1
 4958: 1			;acc0>acc1
 4959: 1  1129	D0 D0		                pop     psw
 4960: 1  112B	C2 D5		                clr     f0
 4961: 1  112D	C3		                clr     c
 4962: 1  112E	D0 F0		                pop     b
 4963: 1  1130	D0 E0		                pop     acc
 4964: 1  1132	22		                ret
 4965: 1			;acc0<acc1
 4966: 1  1133	D0 D0		cmp162:         pop     psw
 4967: 1  1135	D3		                setb    c
 4968: 1  1136	C2 D5		                clr     f0
 4969: 1  1138	D0 F0		                pop     b
 4970: 1  113A	D0 E0		                pop     acc
 4971: 1  113C	22		                ret

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 87



 Line  I  Addr  Code            Source

 4972: 1
 4973: 1			;*******************************************************************************
 4974: 1			; s_cmp32        (44,3us @16.777216MHz)
 4975: 1			; Vergelijkt de 2's complement inhoud van acc0  en acc1.
 4976: 1			;
 4977: 1			; Inputbereik getallen: 80000000h..ffffffffh,0,00000001h..7fffffffh
 4978: 1			;                         -2147483648 tot +2147483647
 4979: 1			; input:     r1,r0 = acc0
 4980: 1			;            r5,r4 = acc1
 4981: 1			;
 4982: 1			; output:    f0=0,cy=1  als acc0 < acc1
 4983: 1			;             f0=0,cy=0  als acc0 > acc1
 4984: 1			;             f0=1 cy=0    als acc1 = acc0
 4985: 1			;
 4986: 1			; vernietigt:  niets
 4987: 1			;*******************************************************************************
 4988: 1  113D	C0 E0		s_cmp32:        push    acc             ;registers bewaren op stack
 4989: 1  113F	C0 D0		                push    psw
 4990: 1  1141	E8		                mov     a,r0
 4991: 1  1142	C0 E0		                push    acc
 4992: 1  1144	E9		                mov     a,r1
 4993: 1  1145	C0 E0		                push    acc
 4994: 1  1147	EA		                mov     a,r2
 4995: 1  1148	C0 E0		                push    acc
 4996: 1  114A	EB		                mov     a,r3
 4997: 1  114B	C0 E0		                push    acc
 4998: 1
 4999: 1  114D	EB		                mov     a,r3            ;neem msb van acc0
 5000: 1  114E	6F		                xrl     a,r7            ;check gelijk aan tekenbit van acc1
 5001: 1  114F	A2 E7		                mov     c,acc.7         ;cy=0 bij gelijk teken
 5002: 1  1151	50 2D		                jnc     s_cmp322        ;bij gelijk teken, verschil maken
 5003: 1  1153	EB		                mov     a,r3            ;bij verschillend teken kijken wie er
 5004: 1  1154	A2 E7		                mov     c,acc.7         ;negatief is
 5005: 1  1156	40 14		                jc      s_cmp321        ;als cy=1 dan is acc0 negatief en dus
 5006: 1			                                        ;acc1 positief. Dus acc1>acc0
 5007: 1			;acc0>acc1
 5008: 1  1158	D0 E0		s_cmp320:       pop     acc
 5009: 1  115A	FB		                mov     r3,a
 5010: 1  115B	D0 E0		                pop     acc
 5011: 1  115D	FA		                mov     r2,a
 5012: 1  115E	D0 E0		                pop     acc
 5013: 1  1160	F9		                mov     r1,a
 5014: 1  1161	D0 E0		                pop     acc
 5015: 1  1163	F8		                mov     r0,a
 5016: 1  1164	D0 D0		                pop     psw             ;cy=0, dus acc0 is positief en dus
 5017: 1  1166	C2 D5		                clr     f0              ;groter dan acc1 die negatief is.
 5018: 1  1168	C3		                clr     c               ;geef dit aan in de outputstatus
 5019: 1  1169	D0 E0		                pop     acc
 5020: 1  116B	22		                ret
 5021: 1			;acc0<acc1
 5022: 1  116C	D0 E0		s_cmp321:       pop     acc
 5023: 1  116E	FB		                mov     r3,a
 5024: 1  116F	D0 E0		                pop     acc
 5025: 1  1171	FA		                mov     r2,a
 5026: 1  1172	D0 E0		                pop     acc
 5027: 1  1174	F9		                mov     r1,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 88



 Line  I  Addr  Code            Source

 5028: 1  1175	D0 E0		                pop     acc
 5029: 1  1177	F8		                mov     r0,a
 5030: 1  1178	D0 D0		                pop     psw             ;cy=1, acc0 is negatief en acc1 is dus
 5031: 1  117A	D3		                setb    c               ;groter dan acc0
 5032: 1  117B	C2 D5		                clr     f0              ;geef dit aan in de outputstatus
 5033: 1  117D	D0 E0		                pop     acc
 5034: 1  117F	22		                ret
 5035: 1			;gelijk teken, maak verschil
 5036: 1  1180	C3		s_cmp322:       clr     c               ;teken is gelijk maak verschil
 5037: 1  1181	E8		                mov     a,r0            ;acc0-acc1
 5038: 1  1182	9C		                subb    a,r4
 5039: 1  1183	F8		                mov     r0,a
 5040: 1  1184	E9		                mov     a,r1
 5041: 1  1185	9D		                subb    a,r5
 5042: 1  1186	F9		                mov     r1,a
 5043: 1  1187	EA		                mov     a,r2
 5044: 1  1188	9E		                subb    a,r6
 5045: 1  1189	FA		                mov     r2,a
 5046: 1  118A	EB		                mov     a,r3
 5047: 1  118B	9F		                subb    a,r7
 5048: 1  118C	FB		                mov     r3,a
 5049: 1  118D	20 E7 DC	                jb      acc.7,s_cmp321  ;neem hoogste bit (underflow)acc0<acc1
 5050: 1  1190	4A		                orl     a,r2            ;geen cy, acc0>=acc1
 5051: 1  1191	49		                orl     a,r1
 5052: 1  1192	48		                orl     a,r0            ;kijk of acc0>acc1 of acc0=acc1
 5053: 1  1193	60 02		                jz      s_cmp323        ;acc0=acc1
 5054: 1  1195	80 C1		                sjmp    s_cmp320        ;acc0>acc1
 5055: 1			;acc0=acc1
 5056: 1  1197	D0 E0		s_cmp323:       pop     acc
 5057: 1  1199	FB		                mov     r3,a
 5058: 1  119A	D0 E0		                pop     acc
 5059: 1  119C	FA		                mov     r2,a
 5060: 1  119D	D0 E0		                pop     acc
 5061: 1  119F	F9		                mov     r1,a
 5062: 1  11A0	D0 E0		                pop     acc
 5063: 1  11A2	F8		                mov     r0,a
 5064: 1  11A3	D0 D0		                pop     psw             ;acc0=acc1
 5065: 1  11A5	C3		                clr     c               ;geef dit aan in de outputstatus
 5066: 1  11A6	D2 D5		                setb    f0
 5067: 1  11A8	D0 E0		                pop     acc
 5068: 1  11AA	22		                ret
 5069: 1
 5070: 1			;*******************************************************************************
 5071: 1			; cmp32        (27,14us @16.777216MHz)
 5072: 1			; Vergelijkt de unsigned inhoud van acc0 en acc1.
 5073: 1			;
 5074: 1			; Inputbereik getallen: 00000000h..ffffffffh (0 tot +4294967296d)
 5075: 1			;
 5076: 1			; input:     r3,r2,r1,r0 = acc0
 5077: 1			;            r7,r6,r5,r4 = acc1
 5078: 1			;
 5079: 1			; output:    f0=0,cy=1  als acc0 < acc1
 5080: 1			;            f0=0,cy=0  als acc0 > acc1
 5081: 1			;            f0=1 cy=0    als acc1 = acc0
 5082: 1			;
 5083: 1			; vernietigt:  niets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 89



 Line  I  Addr  Code            Source

 5084: 1			;*******************************************************************************
 5085: 1  11AB	C0 E0		cmp32:          push    acc             ;bewaar registers
 5086: 1  11AD	C0 F0		                push    b
 5087: 1  11AF	C0 D0		                push    psw
 5088: 1
 5089: 1  11B1	C3		                clr     c               ;vergelijk acc0 met acc1
 5090: 1  11B2	EB		                mov     a,r3            ;eerst de msb's, dan volgende bytes
 5091: 1  11B3	8F F0		                mov     b,r7            ;test r3-r7
 5092: 1  11B5	B5 F0 1C	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5093: 1
 5094: 1  11B8	EA		                mov     a,r2            ;msb's zijn gelijk, vergelijk volgende
 5095: 1  11B9	8E F0		                mov     b,r6            ;bytes, test r2-r6
 5096: 1  11BB	B5 F0 16	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5097: 1
 5098: 1  11BE	E9		                mov     a,r1            ;msb's zijn gelijk, vergelijk volgende
 5099: 1  11BF	8D F0		                mov     b,r5            ;bytes,  test r1-r5
 5100: 1  11C1	B5 F0 10	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5101: 1
 5102: 1  11C4	E8		                mov     a,r0            ;msb's zijn gelijk, vergelijk volgende
 5103: 1  11C5	8C F0		                mov     b,r4            ;bytes,  test r0-r4
 5104: 1  11C7	B5 F0 0A	                cjne    a,b,cmp321      ;niet gelijk, kijk wie grootst is
 5105: 1			;acc0=acc1
 5106: 1  11CA	D0 D0		                pop     psw
 5107: 1  11CC	D2 D5		                setb    f0
 5108: 1  11CE	C3		                clr     c
 5109: 1  11CF	D0 F0		                pop     b
 5110: 1  11D1	D0 E0		                pop     acc
 5111: 1  11D3	22		                ret
 5112: 1  11D4	40 0A		cmp321:         jc      cmp322          ;cy=1 indien acc0<acc1
 5113: 1			;acc0>acc1, indien cy=0
 5114: 1  11D6	D0 D0		                pop     psw
 5115: 1  11D8	C2 D5		                clr     f0
 5116: 1  11DA	C3		                clr     c
 5117: 1  11DB	D0 F0		                pop     b
 5118: 1  11DD	D0 E0		                pop     acc
 5119: 1  11DF	22		                ret
 5120: 1			;acc0<acc1
 5121: 1  11E0	D0 D0		cmp322:         pop     psw
 5122: 1  11E2	D3		                setb    c
 5123: 1  11E3	C2 D5		                clr     f0
 5124: 1  11E5	D0 F0		                pop     b
 5125: 1  11E7	D0 E0		                pop     acc
 5126: 1  11E9	22		                ret
 5127: 1
 5128: 1
 5129: 1			;*******************************************************************************
 5130: 1			; table_lu        (42,2us @16.777216MHz worst case)
 5131: 1			; Tabel lookup routine voor tabel met byte (8bit) of word (16bit) items.
 5132: 1			; Indien word items, dan moeten deze steeds met de lsbyte op het laagste
 5133: 1			; adres zitten.
 5134: 1			;
 5135: 1			; Inputbereik getallen:0000h..ffffh (0 tot +65535d)
 5136: 1			;
 5137: 1			; input:     dptr  =  startadres van de tabel (0000h..ffffh)
 5138: 1			;            r1,r0 = acc0 low = index van het gewenste item (0000h..ffffh)
 5139: 1			;      flags f1,f0 = 00 = tabel in codegeheugen, items op 8bit basis

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 90



 Line  I  Addr  Code            Source

 5140: 1			;                    01 = tabel in codegeheugen, items op 16bit basis
 5141: 1			;                    10 = tabel in datageheugen, items op 8bit basis
 5142: 1			;                    11 = tabel in datageheugen, items op 16bit basis
 5143: 1			; output:    r5,r4 = gewenste 8bit (r4)  of 16bit (r5,r4) waarde uit de tabel
 5144: 1			;                cy = 0  lookup is ok
 5145: 1			;                cy = 1  startadres+index groter dan 16bits (overflow)=error!
 5146: 1			; vernietigt:  niets
 5147: 1			;*******************************************************************************
 5148: 1  11EA	C0 E0		table_lu:       push    acc             ;bewaren registers
 5149: 1  11EC	C0 D0		                push    psw
 5150: 1  11EE	C0 82		                push    dpl
 5151: 1  11F0	C0 83		                push    dph
 5152: 1
 5153: 1  11F2	A2 D5		                mov     c,f0            ;byte of word items?
 5154: 1  11F4	40 2A		                jc     table_lu2        ;als cy=1, dan tabel met word items
 5155: 1			;tabel met byte items
 5156: 1  11F6	E5 82		                mov     a,dpl           ;datapointer plus index
 5157: 1  11F8	28		                add     a,r0
 5158: 1  11F9	F5 82		                mov     dpl,a
 5159: 1  11FB	E5 83		                mov     a,dph
 5160: 1  11FD	39		                addc    a,r1
 5161: 1  11FE	F5 83		                mov     dph,a
 5162: 1  1200	40 14		                jc      table_lu_10     ;indien carry dan overflow!
 5163: 1  1202	A2 D1		                mov     c,f1            ;code of datageheugen?
 5164: 1  1204	40 09		                jc      table_lu1       ;als cy=1, dan datageheugen
 5165: 1
 5166: 1			;bytetabel in codegeheugen
 5167: 1  1206	74 00		                mov     a,#0
 5168: 1  1208	93		                movc    a,@a+dptr       ;haal byte op uit codegeheugen
 5169: 1  1209	F8		                mov     r0,a            ;en stop in acc0
 5170: 1  120A	79 00		                mov     r1,#0
 5171: 1  120C	02 12 6B	                ljmp    table_lu4       ;en klaar
 5172: 1
 5173: 1			;bytetabel in datageheugen
 5174: 1  120F	E0		table_lu1:      movx    a,@dptr         ;haal byte op uit datageheugen
 5175: 1  1210	F8		                mov     r0,a            ;en stop in acc0
 5176: 1  1211	79 00		                mov     r1,#0
 5177: 1  1213	02 12 6B	                ljmp    table_lu4       ;en klaar
 5178: 1
 5179: 1  1216	D0 83		table_lu_10:    pop     dph            ;registers herstellen met errorstatus
 5180: 1  1218	D0 82		                pop     dpl
 5181: 1  121A	D0 D0		                pop     psw
 5182: 1  121C	D3		                setb    c              ;foutstatus teruggeven!
 5183: 1  121D	D0 E0		                pop     acc
 5184: 1  121F	22		                ret
 5185: 1
 5186: 1			;tabel met word items
 5187: 1  1220	E8		table_lu2:      mov     a,r0            ;index op stack
 5188: 1  1221	C0 E0		                push    acc
 5189: 1  1223	E9		                mov     a,r1
 5190: 1  1224	C0 E0		                push    acc
 5191: 1
 5192: 1  1226	C3		                clr      c              ;index maal 2 (word items)
 5193: 1  1227	E8		                mov     a,r0
 5194: 1  1228	33		                rlc     a
 5195: 1  1229	F8		                mov     r0,a

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 91



 Line  I  Addr  Code            Source

 5196: 1  122A	E9		                mov     a,r1
 5197: 1  122B	33		                rlc     a
 5198: 1  122C	F9		                mov     r1,a
 5199: 1
 5200: 1  122D	E5 82		                mov     a,dpl           ;datapointer plus index
 5201: 1  122F	28		                add     a,r0
 5202: 1  1230	F5 82		                mov     dpl,a
 5203: 1  1232	E5 83		                mov     a,dph
 5204: 1  1234	39		                addc    a,r1
 5205: 1  1235	F5 83		                mov     dph,a
 5206: 1
 5207: 1  1237	D0 E0		                pop     acc             ;index weer van stack
 5208: 1  1239	F9		                mov     r1,a
 5209: 1  123A	D0 E0		                pop     acc
 5210: 1  123C	F8		                mov     r0,a
 5211: 1
 5212: 1  123D	40 D7		                jc      table_lu_10     ;indien carry dan overflow!
 5213: 1  123F	A2 D1		                mov     c,f1            ;code of datageheugen?
 5214: 1  1241	40 16		                jc      table_lu3       ;als cy=1, dan datageheugen
 5215: 1			;wordtabel in codegeheugen
 5216: 1  1243	74 00		                mov     a,#0
 5217: 1  1245	93		                movc    a,@a+dptr       ;haal lsb op uit codegeheugen
 5218: 1  1246	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5219: 1  1247	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5220: 1  1249	24 01		                add     a,#1
 5221: 1  124B	F5 82		                mov     dpl,a
 5222: 1  124D	E5 83		                mov     a,dph
 5223: 1  124F	34 00		                addc    a,#0
 5224: 1  1251	F5 83		                mov     dph,a
 5225: 1  1253	74 00		                mov     a,#0
 5226: 1  1255	93		                movc    a,@a+dptr        ;haal msb op uit codegeheugen
 5227: 1  1256	F9		                mov     r1,a            ;msb in acc0 stoppen
 5228: 1  1257	80 12		                sjmp    table_lu4        ;en klaar
 5229: 1			;wordtabel    in datageheugen
 5230: 1  1259	E0		table_lu3:      movx    a,@dptr         ;haal lsb op uit codegeheugen
 5231: 1  125A	F8		                mov     r0,a            ;lsb in acc0 stoppen
 5232: 1  125B	E5 82		                mov     a,dpl           ;datapointer incrementeren voor msb
 5233: 1  125D	24 01		                add     a,#1
 5234: 1  125F	F5 82		                mov     dpl,a
 5235: 1  1261	E5 83		                mov     a,dph
 5236: 1  1263	34 00		                addc    a,#0
 5237: 1  1265	F5 83		                mov     dph,a
 5238: 1  1267	74 00		                mov     a,#0
 5239: 1  1269	E0		                movx    a,@dptr         ;haal msb op uit codegeheugen
 5240: 1  126A	F9		                mov     r1,a            ;msb in acc0 stoppen
 5241: 1			                                        ;en klaar
 5242: 1
 5243: 1  126B	D0 83		table_lu4:      pop     dph             ;registers herstellen zonder error
 5244: 1  126D	D0 82		                pop     dpl
 5245: 1  126F	D0 D0		                pop     psw
 5246: 1  1271	D0 E0		                pop     acc
 5247: 1  1273	22		                ret
 5248: 1
 5249: 1
 5250: 1
 5251: 1			;*******************************************************************************

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 92



 Line  I  Addr  Code            Source

 5252: 1			; Cordic        (2,11ms @16.777216MHz)
 5253: 1			; Deze routine berekent de sinus en de cosinus van de in acc0 low als signed
 5254: 1			; waarde (2's complement) opgegeven hoek.
 5255: 1			; De hoek (in rad.) moet vermenigvuldigd worden met een schaalfactor 16384.
 5256: 1			; Het inputhoekbereik gaat van -pi/2 tot pi/2.
 5257: 1			; Dwz. een hoek van pi/2 wordt gegeven als pi/2 * 16384 =25735 (6487h)
 5258: 1			;      een hoek van -pi/2 wordt gegeven als -pi/2*16384 =-25736 (9b78h)
 5259: 1			; De outputparameters zijn de sinus en cosinus van de opgegeven hoek die ook
 5260: 1			; als geschaalde getallen ter beschikking komen.
 5261: 1			; Het outputbereik is hier: -1 (c000h)  tot  +1 (3fffh).
 5262: 1			;
 5263: 1			; input:    r1,r0 = acc0(low)  = hoek (in rad.) geschaald met 16384
 5264: 1			;
 5265: 1			; output:   r1,r0 = acc0(low)  = cosinus van de hoek * 16384
 5266: 1			;             r3,r2 = acc0(high) = sinus van de hoek * 16384
 5267: 1			;            cy = 0 : hoek binnen bereik
 5268: 1			;            cy = 1 : error, hoek buiten bereik
 5269: 1			;            nauwkeurigheid: 12 msbits
 5270: 1			; vernietigt:  niets
 5271: 1			;*******************************************************************************
 5272: 1  1274	C0 E0		cordic:         push    acc                ;bewaar de gebruikte registers
 5273: 1  1276	C0 D0		                push    psw
 5274: 1  1278	C0 83		                push    dph
 5275: 1  127A	C0 82		                push    dpl
 5276: 1  127C	C0 F0		                push    b
 5277: 1
 5278: 1  127E	EF		                mov     a,r7
 5279: 1  127F	C0 E0		                push    acc
 5280: 1  1281	EE		                mov     a,r6
 5281: 1  1282	C0 E0		                push    acc
 5282: 1  1284	ED		                mov     a,r5
 5283: 1  1285	C0 E0		                push    acc
 5284: 1  1287	EC		                mov     a,r4
 5285: 1  1288	C0 E0		                push    acc
 5286: 1
 5287: 1			;Check of de doorgegeven hoek niet kleiner is dan -pi/2 radialen (9b78h)
 5288: 1			;en niet groter dan pi/2 radialen (6478h)
 5289: 1  128A	7C 87		                mov     r4,#87h         ;plaats 6487h (+pi/2) in acc1
 5290: 1  128C	7D 64		                mov     r5,#64h
 5291: 1  128E	12 11 0A	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5292: 1  1291	20 D5 25	                jb      f0,cordic_plus90;gelijk aan +pi/2, resultaat gekend!
 5293: 1  1294	50 02		                jnc     cordic000       ;bij cy=0 is acc0>acc1, dus mogelijk fout
 5294: 1  1296	80 2D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5295: 1
 5296: 1  1298	C2 A0		cordic000:      clr     p2.0
 5297: 1  129A	7C 78		                mov     r4,#78h         ;plaats 9b78h in acc1
 5298: 1  129C	7D 9B		                mov     r5,#9bh
 5299: 1  129E	12 11 0A	                lcall   cmp16           ;vergelijk de hoeken (acc0-acc1)
 5300: 1  12A1	20 D5 09	                jb      f0,cordic_min90 ;bij gelijk aan -pi/2, resultaat gekend!
 5301: 1  12A4	40 02		                jc      cordic_error    ;bij cy=1 is acc0<acc1, dus fout
 5302: 1  12A6	80 1D		                sjmp    cordic00        ;hoek ok, bereken de sinus en cosinus...
 5303: 1
 5304: 1  12A8	C2 A1		cordic_error:   clr     p2.1
 5305: 1  12AA	02 13 5C	                ljmp    cordic40        ;bij fout, terug met foutstatus!
 5306: 1
 5307: 1			;Hoek is -pi/2 resultaat gekend

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 93



 Line  I  Addr  Code            Source

 5308: 1  12AD	7B C0		cordic_min90:   mov     r3,#0c0h        ;sinus is c000h = -1
 5309: 1  12AF	7A 00		                mov     r2,#000h
 5310: 1  12B1	79 00		                mov     r1,#000h        ;cosinus is 0000h = 0
 5311: 1  12B3	78 00		                mov     r0,#000h
 5312: 1  12B5	C3		                clr     c
 5313: 1  12B6	02 13 5C	                ljmp    cordic40        ;en klaar
 5314: 1			;hoek is +pi/2 resultaat gekend
 5315: 1  12B9	7B 3F		cordic_plus90:  mov     r3,#03fh        ;sinus is 3fffh = +1
 5316: 1  12BB	7A FF		                mov     r2,#0ffh
 5317: 1  12BD	79 00		                mov     r1,#000h        ;cosinus is 0000 = 0
 5318: 1  12BF	78 00		                mov     r0,#000h
 5319: 1  12C1	C3		                clr     c
 5320: 1  12C2	02 13 5C	                ljmp    cordic40        ;en klaar
 5321: 1
 5322: 1  12C5	7C 00		cordic00:       mov     r4,#00h         ;plaats 0000h in acc1
 5323: 1  12C7	7D 00		                mov     r5,#00h
 5324: 1  12C9	12 11 0A	                lcall   cmp16            ;vergelijk de hoeken
 5325: 1  12CC	20 D5 02	                jb     f0,cordic_nul    ;bij gelijk aan 0, resultaat gekend!
 5326: 1  12CF	80 0E		                sjmp   cordic0          ;bereken de sinus en cosinus...
 5327: 1			;hoek is 0, resultaat gekend
 5328: 1  12D1	C2 A7		cordic_nul:     clr     p2.7
 5329: 1  12D3	7B 00		                mov     r3,#000h        ;sinus is 0000h = 0
 5330: 1  12D5	7A 00		                mov     r2,#000h
 5331: 1  12D7	79 3F		                mov     r1,#03fh        ;cosinus is 3fff = +1
 5332: 1  12D9	78 FF		                mov     r0,#0ffh
 5333: 1  12DB	C3		                clr     c
 5334: 1  12DC	02 13 5C	                ljmp    cordic40        ;en klaar
 5335: 1
 5336: 1			;De hoek zit binnen bereik, bepaal sin en cos.
 5337: 1  12DF	E8		cordic0:        mov     a,r0            ;bewaar de lsb hoek op stack
 5338: 1  12E0	C0 E0		                push    acc
 5339: 1  12E2	E9		                mov     a,r1            ;bewaar de msb hoek op stack
 5340: 1  12E3	C0 E0		                push    acc
 5341: 1
 5342: 1  12E5	7B 00		                mov     r3,#00h         ;y=0
 5343: 1  12E7	7A 00		                mov     r2,#00h
 5344: 1  12E9	79 26		                mov     r1,#026h        ;x = K * 2^14
 5345: 1  12EB	78 DD		                mov     r0,#0ddh        ;K=0.607252935
 5346: 1
 5347: 1  12ED	75 F0 00	                mov     b,#00h          ;loopteller=0
 5348: 1
 5349: 1  12F0	90 13 B4	                mov     dptr,#cordic_atan    ;wijs naar de atan tabel
 5350: 1
 5351: 1  12F3	EB		cordic1:        mov     a,r3            ;sry=y
 5352: 1  12F4	FF		                mov     r7,a
 5353: 1  12F5	EA		                mov     a,r2
 5354: 1  12F6	FE		                mov     r6,a
 5355: 1  12F7	E9		                mov     a,r1            ;srx=x
 5356: 1  12F8	FD		                mov     r5,a
 5357: 1  12F9	E8		                mov     a,r0
 5358: 1  12FA	FC		                mov     r4,a
 5359: 1
 5360: 1  12FB	12 13 7B	                lcall   cordic5          ;srx en sry >> loopteller
 5361: 1
 5362: 1  12FE	D0 E0		                pop     acc
 5363: 1  1300	20 E7 2F	                jb      acc.7,cordic3    ;als negatief, hoek vergroten

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 94



 Line  I  Addr  Code            Source

 5364: 1
 5365: 1			;De hoek is positief; nieuwe x en y berekenen en de hoek verkleinen
 5366: 1  1303	C3		                clr     c
 5367: 1  1304	E8		                mov     a,r0            ;bereken x=x-sry
 5368: 1  1305	9E		                subb    a,r6            ;dit stelt de voorlopige cosinus voor
 5369: 1  1306	F8		                mov     r0,a
 5370: 1  1307	E9		                mov     a,r1
 5371: 1  1308	9F		                subb    a,r7
 5372: 1  1309	F9		                mov     r1,a
 5373: 1
 5374: 1  130A	EA		                mov     a,r2            ;bereken y=y+srx
 5375: 1  130B	2C		                add     a,r4            ;dit stelt de voorlopige sinus voor
 5376: 1  130C	FA		                mov     r2,a
 5377: 1  130D	EB		                mov     a,r3
 5378: 1  130E	3D		                addc    a,r5
 5379: 1  130F	FB		                mov     r3,a
 5380: 1
 5381: 1			;De hoek verkleinen met de waarde uit de lookuptabel en weer bewaren
 5382: 1  1310	74 00		                mov    a,#0            ;haal lsb atan waarde uit de lookuptabel
 5383: 1  1312	93		                movc    a,@a+dptr
 5384: 1  1313	A3		                inc     dptr
 5385: 1  1314	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5386: 1  1315	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5387: 1  1317	C3		                clr     c               ;verklein de hoek
 5388: 1  1318	9C		                subb    a,r4
 5389: 1  1319	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5390: 1  131B	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5391: 1
 5392: 1  131D	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5393: 1  131F	93		                movc    a,@a+dptr
 5394: 1  1320	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5395: 1  1321	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5396: 1  1322	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5397: 1  1324	9D		                subb    a,r5            ;verklein de hoek
 5398: 1  1325	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5399: 1
 5400: 1			;loopteller incrementeren en testen op einde van de iteratie
 5401: 1  1327	05 F0		cordic2:        inc     b               ;loopteller++
 5402: 1  1329	74 0E		                mov     a,#14           ;iteratie 14 maal uitgevoerd?
 5403: 1  132B	65 F0		                xrl     a,b             ;test op gelijkheid
 5404: 1  132D	60 28		                jz      cordic4         ;ja klaar!
 5405: 1  132F	02 12 F3	                ljmp    cordic1         ;nee, nog even verder...
 5406: 1
 5407: 1			;De hoek is negatief; nieuwe x en y berekenen en de hoek vergroten
 5408: 1  1332	E8		cordic3:        mov     a,r0            ;bereken x=x+sry
 5409: 1  1333	2E		                add     a,r6            ;dit stelt de voorlopige cosinus voor
 5410: 1  1334	F8		                mov     r0,a
 5411: 1  1335	E9		                mov     a,r1
 5412: 1  1336	3F		                addc    a,r7
 5413: 1  1337	F9		                mov     r1,a
 5414: 1
 5415: 1  1338	C3		                clr     c
 5416: 1  1339	EA		                mov     a,r2            ;bereken y=y-srx
 5417: 1  133A	9C		                subb    a,r4            ;dit stelt de voorlopige sinus voor
 5418: 1  133B	FA		                mov     r2,a
 5419: 1  133C	EB		                mov     a,r3

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 95



 Line  I  Addr  Code            Source

 5420: 1  133D	9D		                subb    a,r5
 5421: 1  133E	FB		                mov     r3,a
 5422: 1			;De hoek vergroten met de waarde uit de lookuptabel en weer bewaren
 5423: 1  133F	74 00		                mov     a,#0            ;haal lsb atan waarde uit de lookuptabel
 5424: 1  1341	93		                movc    a,@a+dptr
 5425: 1  1342	A3		                inc     dptr
 5426: 1  1343	FC		                mov     r4,a            ;bewaar in srx die verloren mag gaan
 5427: 1  1344	D0 E0		                pop     acc             ;haal lsb van de hoek van stack
 5428: 1  1346	2C		                add     a,r4            ;vergroot de hoek
 5429: 1  1347	C0 E0		                push    acc             ;en bewaar de lsb van de hoek op stack
 5430: 1  1349	05 81		                inc     sp              ;wijs weer naar msb van de hoek
 5431: 1
 5432: 1  134B	74 00		                mov     a,#0            ;haal msb atan waarde uit de lookuptabel
 5433: 1  134D	93		                movc    a,@a+dptr
 5434: 1  134E	A3		                inc     dptr            ;wijs naar volgende tabelwaarde
 5435: 1  134F	FD		                mov     r5,a            ;bewaar in srx die verloren mag gaan
 5436: 1  1350	D0 E0		                pop     acc             ;haal msb van de hoek van stack
 5437: 1  1352	3D		                addc    a,r5            ;vergroot de hoek
 5438: 1  1353	C0 E0		                push    acc             ;en bewaar de msb van de hoek op stack
 5439: 1
 5440: 1  1355	80 D0		                sjmp    cordic2
 5441: 1
 5442: 1  1357	D0 E0		cordic4:        pop     acc             ;dummy hoek van stack
 5443: 1  1359	D0 E0		                pop     acc             ;dummy hoek van stack
 5444: 1  135B	C3		                clr     c               ;hoek is ok, geen foutstatus!
 5445: 1
 5446: 1  135C	D0 E0		cordic40:       pop     acc
 5447: 1  135E	FC		                mov     r4,a
 5448: 1  135F	D0 E0		                pop     acc
 5449: 1  1361	FD		                mov     r5,a
 5450: 1  1362	D0 E0		                pop     acc
 5451: 1  1364	FE		                mov     r6,a
 5452: 1  1365	D0 E0		                pop     acc
 5453: 1  1367	FF		                mov     r7,a
 5454: 1  1368	D0 F0		                pop     b
 5455: 1  136A	D0 82		                pop     dpl
 5456: 1  136C	D0 83		                pop     dph
 5457: 1  136E	40 05		                jc      cordic41        ;foutstatus:hoek buiten bereik!!
 5458: 1  1370	D0 D0		                pop     psw
 5459: 1  1372	D0 E0		                pop     acc
 5460: 1  1374	22		                ret
 5461: 1
 5462: 1  1375	D0 D0		cordic41:       pop     psw
 5463: 1  1377	D3		                setb    c
 5464: 1  1378	D0 E0		                pop     acc
 5465: 1  137A	22		                ret
 5466: 1			;Deze routine zal de 16 bit schuifregisters srx en sry verschuiven naar rechts
 5467: 1			;over het aantal posities aangegeven in het B register.
 5468: 1  137B	C0 F0		cordic5:        push    b               ;loopteller bewaren
 5469: 1  137D	74 00		                mov     a,#0            ;test of loopteller=0
 5470: 1  137F	65 F0		                xrl     a,b
 5471: 1  1381	60 2E		                jz      cordic52        ;klaar
 5472: 1
 5473: 1  1383	ED		                mov     a,r5            ;test teken van srx
 5474: 1  1384	20 E7 04	                jb      acc.7,cordic5a  ;als negatief: 1 binnenschuiven
 5475: 1  1387	C2 D5		                clr     f0              ;geef aan dat srx positief is

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 96



 Line  I  Addr  Code            Source

 5476: 1  1389	80 02		                sjmp    cordic50
 5477: 1  138B	D2 D5		cordic5a:       setb    f0
 5478: 1  138D	A2 D5		cordic50:       mov     c,f0            ;schuif srx>>1
 5479: 1  138F	ED		                mov     a,r5            ;eerst de msb
 5480: 1  1390	13		                rrc     a
 5481: 1  1391	FD		                mov     r5,a
 5482: 1  1392	EC		                mov     a,r4            ;dan de lsb
 5483: 1  1393	13		                rrc     a
 5484: 1  1394	FC		                mov     r4,a
 5485: 1  1395	D5 F0 F5	                djnz    b,cordic50      ;herhaal tot loopteller nul is
 5486: 1  1398	D0 F0		                pop     b               ;haal de loopteller van stack
 5487: 1  139A	C0 F0		                push    b               ;en bewaar hem weer
 5488: 1  139C	EF		                mov     a,r7            ;test teken van sry
 5489: 1  139D	20 E7 04	                jb      acc.7,cordic5b  ;als negatief: 1 binnenschuiven
 5490: 1  13A0	C2 D5		                clr     f0              ;geef aan dat sry positief is
 5491: 1  13A2	80 02		                sjmp    cordic51
 5492: 1  13A4	D2 D5		cordic5b:       setb    f0
 5493: 1  13A6	A2 D5		cordic51:       mov     c,f0            ;schuif sry>>1
 5494: 1  13A8	EF		                mov     a,r7            ;eerst de msb
 5495: 1  13A9	13		                rrc     a
 5496: 1  13AA	FF		                mov     r7,a
 5497: 1  13AB	EE		                mov     a,r6            ;dan de lsb
 5498: 1  13AC	13		                rrc     a
 5499: 1  13AD	FE		                mov     r6,a
 5500: 1  13AE	D5 F0 F5	                djnz    b,cordic51      ;herhaal tot loopteller nul is
 5501: 1
 5502: 1  13B1	D0 F0		cordic52:       pop     b               ;haal de loopteller van stack
 5503: 1  13B3	22		                ret
 5504: 1
 5505: 1			;Lookuptabel met de hoekwaarden Z=atan(1/2^i) en dit voor i=0 tot 14
 5506: 1			;Alle tabelwaarden zijn vermenigvuldigd met de schaalfactor 16384.
 5507: 1			;De 16bit waarden zijn gestockeerd met de lsbyte op de laagste adreslocatie
 5508: 1  13B4	43 32		cordic_atan:    dw    04332h                ;i=0     1/2^i=1
 5509: 1  13B6	AC 1D		                dw    0ac1dh                ;i=1    1/2^i=1/2
 5510: 1  13B8	AD 0F		                dw    0ad0fh                ;i=2    1/2^i=1/4
 5511: 1  13BA	F5 07		                dw    0f507h                ;i=3    1/2^i=1/8
 5512: 1  13BC	FE 03		                dw    0fe03h                ;i=4    1/2^i=1/16
 5513: 1  13BE	FF 01		                dw    0ff01h                ;i=5    1/2^i=1/32
 5514: 1  13C0	FF 00		                dw    0ff00h                ;i=6    1/2^i=1/64
 5515: 1  13C2	7F 00		                dw    07f00h                ;i=7    1/2^i=1/128
 5516: 1  13C4	3F 00		                dw    03f00h                ;i=8    1/2^i=1/256
 5517: 1  13C6	1F 00		                dw    01f00h                ;i=9    1/2^i=1/512
 5518: 1  13C8	0F 00		                dw    00f00h                ;i=10    1/2^i=1/1024
 5519: 1  13CA	07 00		                dw    00700h                ;i=11    1/2^i=1/2048
 5520: 1  13CC	03 00		                dw    00300h                ;i=12    1/2^i=1/4096
 5521: 1  13CE	01 00		                dw    00100h                ;i=13    1/2^i=1/8192
 5522: 1  13D0	00 00		                dw    00000h                ;i=14    1/2^i=1/16384
 5523: 1
 5524: 1			endif        ;einde van aduc_math
 5525: 1			;******************************************************************************
 5526: 1
 5527: 1			ifdef        aduc_adc    ;A/D conversie routines
 5528: 1			;*******************************************************************************
 5529: 1			; ADuCADC_mide
 5530: 1			; Geschreven door [dp] op 5/1/2014
 5531: 1			; Deze file bevat routines voor het bedienen van de ADConverter in de ADuC832.

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 97



 Line  I  Addr  Code            Source

 5532: 1			; De routine  'adc_init' zal bij het gebruik van de ADC steeds eerst eenmalig
 5533: 1			; moeten uitgevoerd worden. De routine zal de ADC aanschakelen en de referentie-
 5534: 1			; bron instellen.
 5535: 1			; De routine  'adc_single' zal de gebruiker in staat stellen een AD conversie te
 5536: 1			; doen van een instelbaar kanaal, met een instelbare resolutie en dit in een
 5537: 1			; unsigned of signed (2's complement) uitgangsformaat.
 5538: 1			;
 5539: 1			;*******************************************************************************
 5540: 1
 5541: 1			;*******************************************************************************
 5542: 1			; adc_init
 5543: 1			; Deze routine initialiseert de ADC in een ADuC832 voor
 5544: 1			; -  4 track&hold clockperiodes
 5545: 1			; -  clockdivider 4  (4us ADC conversietijd @16.777216MHz)
 5546: 1			; -  softwarematig starten van een ADconversie (via adc_single)
 5547: 1			; De gebruiker kan via R0 een interne (2,5V) of externe referentie instellen.
 5548: 1			; De externe referentie is op het MGM/[dp] ADuC bord meestal ingesteld op 5V.
 5549: 1			;
 5550: 1			; input: R0 =  0  : Interne referentiebron
 5551: 1			;        R0 <> 0  : Externe referentiebron
 5552: 1			;
 5553: 1			; Deze routine vernietigt niets
 5554: 1			;*******************************************************************************
 5555: 1  13D2	C0 E0		adc_init:       push    acc                 ;registers op stack
 5556: 1  13D4	C0 D0		                push    psw
 5557: 1  13D6	75 EF DC	                mov     adccon1,#11011100b  ;init ADC met externe ref
 5558: 1  13D9	E8		                mov     a,r0                ;welke referentiebron?
 5559: 1  13DA	70 03		                jnz     adc_init1           ;als niet nul,dan ok
 5560: 1  13DC	75 EF 9C	                mov     adccon1,#10011100b  ;init ADC met interne ref
 5561: 1  13DF	D0 D0		adc_init1:      pop     psw
 5562: 1  13E1	D0 E0		                pop     acc
 5563: 1  13E3	22		                ret
 5564: 1
 5565: 1			;*******************************************************************************
 5566: 1			; adc_single
 5567: 1			; Deze routine doet een AD conversie van een instelbaar kanaal, met een instel-
 5568: 1			; bare resolutie van 8, 10 of 12 bits en dit met een unsigned of signed
 5569: 1			; (2's complement) formaat van de meetwaarde.
 5570: 1			; _____________________________________________________________
 5571: 1			; resolutie  |     unsigned      |           signed            |
 5572: 1			; -----------|---0V------Vref----|---0V------Vref/2-----Vref---|
 5573: 1			;            | R1  R0   R1  R0   | R1  R0    R1  R0    R1  R0  |
 5574: 1			; 8 bit      | 00h 00h  00h ffh  | ffh 80h   00h 00h   00h 7fh |
 5575: 1			; 10 bit     | 00h 00h  03h ffh  | feh 00h   00h 00h   01h ffh |
 5576: 1			; 12 bit     | 00h 00h  0fh ffh  | f8h 00h   00h 00h   07h ffh |
 5577: 1			; _____________________________________________________________
 5578: 1			;
 5579: 1			; De gemeten waarde wordt doorgegeven aan de gebruiker via de registers R1,R0.
 5580: 1			; Hierbij stelt R1 de MSB en R0 de LSB voor zoals aangegeven hierboven.
 5581: 1			; De ingangsparameter wordt doorgegeven via R0.
 5582: 1			;
 5583: 1			; input:
 5584: 1			;             7    6    5    4    3    2    1    0
 5585: 1			;           _______________________________________
 5586: 1			;       R0 |  x |s/U |res1|res0|ch3 |ch2 |ch1 |ch0 |
 5587: 1			;           ---------------------------------------

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 98



 Line  I  Addr  Code            Source

 5588: 1			;       R0 = kanaalnummer (ch3-0) : 0000b-0111b = kanaal 0 tot 7
 5589: 1			;                                         1000b = temp.sensor
 5590: 1			;       R0 = resolutie (res1,0)   : 00b =8 bits,   01b = 10 bits
 5591: 1			;                                   10b = 12 bits, 11b = 12 bits
 5592: 1			;       R0 = (un)signed (s/U)     : 0 = unsigned   1= signed (2's complement)
 5593: 1			;
 5594: 1			; output: R1,R0 = R1 MSbyte, R0 LSbyte
 5595: 1			;         cy=0  bij conversie ok
 5596: 1			;         cy=1  bij foutief kanaalnummer (geen conversie gedaan)
 5597: 1			;
 5598: 1			; Deze routine vernietigt niets
 5599: 1			;*******************************************************************************
 5600: 1  13E4	C0 E0		adc_single:     push    acc                 ;registers op stack
 5601: 1  13E6	C0 D0		                push    psw
 5602: 1  13E8	C0 F0		                push    b
 5603: 1  13EA	E8		                mov     a,r0                ;neem inputparameter
 5604: 1  13EB	54 0F		                anl     a,#0fh              ;neem kanaalnummer
 5605: 1  13ED	B4 09 00	                cjne    a,#9h,adc_single1   ;controleer kanaalnummer
 5606: 1  13F0	50 3B		adc_single1:    jnc    adc_single21        ;als geen carry, dan fout!
 5607: 1  13F2	F5 D8		                mov     adccon2,a           ;geef kanaalnummer aan ADC
 5608: 1  13F4	D2 DC		                setb    sconv               ;start een meting
 5609: 1  13F6	E8		                mov     a,r0                ;neem parameter terug
 5610: 1  13F7	A2 E6		                mov     c,acc.6
 5611: 1  13F9	92 D5		                mov     f0,c                ;bewaar format bit
 5612: 1  13FB	20 DC FD	                jb      sconv,$             ;wacht hier tot conversie klaar is
 5613: 1  13FE	85 DA F0	                mov     b,adcdatah          ;neem high nibble van resultaat
 5614: 1  1401	20 E4 2C	                jb      acc.4,adc_single3   ;10 bit resultaat gevraagd
 5615: 1  1404	20 E5 5B	                jb      acc.5,adc_single4   ;12 bit resultaat gevraagd
 5616: 1			;*******************************************************************************
 5617: 1			;8 bit resultaat gevraagd
 5618: 1			;*******************************************************************************
 5619: 1  1407	E5 D9		                mov     a,adcdatal           ;neem low byte van resultaat
 5620: 1  1409	C4		                swap    a                    ;swap nibbles
 5621: 1  140A	54 0F		                anl     a,#0fh               ;maskeer low nibble van resultaat
 5622: 1  140C	C5 F0		                xch     a,b                  ;verwissel met high nibble resultaat
 5623: 1  140E	54 0F		                anl     a,#0fh               ;maskeer kanaalnummer
 5624: 1  1410	C4		                swap    a
 5625: 1  1411	45 F0		                orl     a,b                  ;voeg samen met low nibble
 5626: 1  1413	20 D5 05	                jb      f0,adc_single2       ;check formaat
 5627: 1			;8 bit unsigned formaat
 5628: 1  1416	79 00		                mov     r1,#00h              ;unsigned
 5629: 1  1418	F8		                mov     r0,a
 5630: 1  1419	80 63		                sjmp    adc_single42
 5631: 1			;8 bit signed formaat
 5632: 1  141B	20 E7 07	adc_single2:    jb      acc.7,adc_single20    ;test bereik >=80h
 5633: 1  141E	24 80		                add     a,#80h                ;negatief getal van maken
 5634: 1  1420	F8		                mov     r0,a
 5635: 1  1421	79 FF		                mov     r1,#0ffh
 5636: 1  1423	80 59		                sjmp    adc_single42
 5637: 1  1425	C3		adc_single20:   clr     c
 5638: 1  1426	94 80		                subb    a,#80h                ;positief deel verkleinen
 5639: 1  1428	F8		                mov     r0,a
 5640: 1  1429	79 00		                mov     r1,#00h
 5641: 1  142B	80 51		                sjmp    adc_single42
 5642: 1
 5643: 1  142D	02 14 86	adc_single21:   ljmp    adc_single43

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                         PAGE 99



 Line  I  Addr  Code            Source

 5644: 1			;*******************************************************************************
 5645: 1			;10 bit resultaat gevraagd
 5646: 1			;*******************************************************************************
 5647: 1  1430	E5 F0		adc_single3:    mov    a,b            ;neem high nibble resultaat
 5648: 1  1432	54 03		                anl    a,#00000011b   ;twee onderste bits houden en
 5649: 1  1434	03		                rr     a              ;naar msbits roteren
 5650: 1  1435	03		                rr     a
 5651: 1  1436	F5 F0		                mov    b,a            ;even bewaren
 5652: 1  1438	E5 D9		                mov    a,adcdatal     ;neem low byte van resultaat
 5653: 1  143A	03		                rr     a              ;twee plaatsen opschuiven
 5654: 1  143B	03		                rr     a
 5655: 1  143C	54 3F		                anl    a,#00111111b   ;zes onderste bits houden en
 5656: 1  143E	45 F0		                orl    a,b            ;combineren met bits uit high nibble
 5657: 1  1440	F5 F0		                mov    b,a            ;low byte even bewaren
 5658: 1  1442	E5 DA		                mov    a,adcdatah     ;neem high nibble
 5659: 1  1444	54 0C		                anl    a,#00001100b   ;twee msbits overhouden
 5660: 1  1446	03		                rr     a               ;en op hun plaats schuiven
 5661: 1  1447	03		                rr     a
 5662: 1  1448	20 D5 05	                jb     f0,adc_single30 ;check formaat
 5663: 1			;10 bit unsigned formaat
 5664: 1  144B	F9		                mov    r1,a            ;unsigned
 5665: 1  144C	A8 F0		                mov    r0,b
 5666: 1  144E	80 2E		                sjmp   adc_single42
 5667: 1			;10 bit signed formaat
 5668: 1  1450	20 E1 07	adc_single30:   jb     acc.1,adc_single31  ;test bereik >= 200h
 5669: 1  1453	24 FE		                add    a,#0feh             ;negatief getal van maken
 5670: 1  1455	F9		                mov    r1,a
 5671: 1  1456	A8 F0		                mov    r0,b
 5672: 1  1458	80 24		                sjmp   adc_single42
 5673: 1  145A	C3		adc_single31:   clr    c
 5674: 1  145B	94 02		                subb   a,#02h              ;positief deel verkleinen
 5675: 1  145D	F9		                mov    r1,a
 5676: 1  145E	A8 F0		                mov    r0,b
 5677: 1  1460	80 1C		                sjmp   adc_single42
 5678: 1
 5679: 1			;*******************************************************************************
 5680: 1			;12 bit resultaat gevraagd
 5681: 1			;*******************************************************************************
 5682: 1  1462	E5 F0		adc_single4:    mov    a,b                   ;neem high nibble resultaat
 5683: 1  1464	54 0F		                anl    a,#0fh                ;maskeer kanaalnummer
 5684: 1  1466	20 D5 05	                jb     f0,adc_single40       ;check formaat
 5685: 1			;12 bit unsigned formaat
 5686: 1  1469	A8 D9		                mov    r0,adcdatal           ;unsigned
 5687: 1  146B	F9		                mov    r1,a
 5688: 1  146C	80 10		                sjmp   adc_single42
 5689: 1			;12 bit signed formaat
 5690: 1  146E	20 E3 07	adc_single40:   jb     acc.3,adc_single41    ;test bereik >= 800h
 5691: 1  1471	24 F8		                add    a,#0f8h               ;negatief getal van maken
 5692: 1  1473	F9		                mov    r1,a
 5693: 1  1474	A8 D9		                mov    r0,adcdatal
 5694: 1  1476	80 06		                sjmp   adc_single42
 5695: 1  1478	C3		adc_single41:   clr    c
 5696: 1  1479	94 08		                subb   a,#08h                ;positief deel verkleinen
 5697: 1  147B	F9		                mov    r1,a
 5698: 1  147C	A8 D9		                mov    r0,adcdatal
 5699: 1  147E	D0 F0		adc_single42:   pop    b

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 100



 Line  I  Addr  Code            Source

 5700: 1  1480	D0 D0		                pop    psw
 5701: 1  1482	C3		                clr    c
 5702: 1  1483	D0 E0		                pop    acc
 5703: 1  1485	22		                ret
 5704: 1
 5705: 1  1486	D0 F0		adc_single43:   pop    b
 5706: 1  1488	D0 D0		                pop    psw
 5707: 1  148A	D3		                setb   c
 5708: 1  148B	D0 E0		                pop    acc
 5709: 1  148D	22		                ret
 5710: 1
 5711: 1			endif        ;einde van aduc_adc
 5712: 1			;*******************************************************************************
 5713: 1
 5714: 1			ifdef    aduc_key    ;matrix keyboard scanner en lezen/debouncen schakelaars
 5715: 1			;******************************************************************************
 5716: 1			; ADuCKEY_mide.inc
 5717: 1			; Deze routines zorgen voor het scannen van een standaard 4x4 matrix-keyboardje
 5718: 1			; dat op volgende manier is aangesloten op het aduc800 bord v1.1 of v2.0.
 5719: 1			;
 5720: 1			;     V2.0      V1.1
 5721: 1			;                           |   |   |   |
 5722: 1			;     P0.0      P0.0|-R1----1---2---3---A---
 5723: 1			;                   |       |   |   |   |
 5724: 1			;     P0.1      P0.1|-R2----4---5---6---B---
 5725: 1			;                   |       |   |   |   |
 5726: 1			;     P0.2      P3.2|-R3----7---8---9---C---
 5727: 1			;                   |       |   |   |   |
 5728: 1			;     P0.3      P3.3|-R4----*---0---#---D---
 5729: 1			;                   |       |   |   |   |
 5730: 1			;     P0.4      P3.4|-K1----|   |   |   |
 5731: 1			;                   |           |   |   |
 5732: 1			;     P0.5      P3.5|-K2--------|   |   |
 5733: 1			;                   |               |   |
 5734: 1			;     P0.6      P3.6|-K3------------|   |
 5735: 1			;                   |                   |
 5736: 1			;     P0.7      P3.7|-K4----------------|
 5737: 1			;
 5738: 1			; Afhankelijk van de gedefinieerde versie zullen de juiste pinnen worden
 5739: 1			; gebruikt.
 5740: 1			; Het blokschema van het gevolgde algorithme is hieronder aangegeven.
 5741: 1			; Het bestaat uit een debounce circuit gevolgd door een flankdetector.
 5742: 1			; Het blokschema is hier afgebeeld voor één bit (kolomlijn) die gelezen wordt
 5743: 1			; en als ingang wordt aangeboden.
 5744: 1			;
 5745: 1			;                                  ___                 ___
 5746: 1			;                     ____________|   |  |------------|   |
 5747: 1			;              ____  |   ____     |   |  |   ____     |   |
 5748: 1			;             |    | |  |    |    |&  |__|__|    |    |&  |
 5749: 1			;  KOLOM  ----|D  Q|_|__|D  Q|----|___|     |D  Q|---O|___|---- OUT
 5750: 1			; '1'= toets  | cl |    | cl |              | cl |
 5751: 1			;  ingedrukt  |____|    |____|              |____|
 5752: 1			;                |         |                   |
 5753: 1			;      CLOCK     |         |                   |
 5754: 1			;         _______|_________|___________________|
 5755: 1			;

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 101



 Line  I  Addr  Code            Source

 5756: 1			;            DEBOUNCE CIRCUIT              POS. FLANKDETECTIE
 5757: 1			;
 5758: 1			;              MAP0      MAP1                 MAP2         MAP3
 5759: 1			;
 5760: 1			; In werkelijkheid gaat het over 4 bits (kolomlijnen) die telkens tegelijk
 5761: 1			; worden gelezen voor elke van de 4 scantoestanden van de rij-lijnen.
 5762: 1			; De flip-flops zijn softwarematig bitmaps waar de toestand van de kolomlijnen
 5763: 1			; en de afgeleide (doorgeschoven) toestanden worden bewaard.
 5764: 1			; Zo zijn er dus 4 maps van 4x4 bits die worden georganiseerd als 2x4 bytes.
 5765: 1			; Map0 (uitgangen 1ste flip-flop) en map1 (uitgangen 2de flip-flop) worden
 5766: 1			; samen in dezelfde 4 bytes ( 1byte per scanrij) gestockeerd.
 5767: 1			; Ook map2 (uitgangen 3de flip-flop) en map3 (uitgangen 'OUT') worden samen
 5768: 1			; opgeslagen. In map3 zitten de toetsen opgeslagen waarbij er een flank werd
 5769: 1			; gedetecteerd (bit = 1 bij de flank bij het indrukken van een toets)
 5770: 1			;
 5771: 1			;          MAP0    MAP1          MAP2    MAP3
 5772: 1			;         _______________       _______________
 5773: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 1
 5774: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 2
 5775: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 3
 5776: 1			;        |_|_|_|_|_|_|_|_|     |_|_|_|_|_|_|_|_|  <--RIJ LIJN 4
 5777: 1			;
 5778: 1			;         ^ ^ ^ ^ ^ ^ ^ ^       ^ ^ ^ ^ ^ ^ ^ ^
 5779: 1			;         | | | | | | | |       | | | | | | | |
 5780: 1			;        K K K K K K K K       K K K K K K K K
 5781: 1			;         O O O O O O O O       O O O O O O O O
 5782: 1			;         L L L L L L L L       L L L L L L L L
 5783: 1			;         1 2 3 4 1 2 3 4       1 2 3 4 1 2 3 4
 5784: 1			;
 5785: 1			; Het programma algorithme loopt van achter in de figuur naar voor, waarbij
 5786: 1			; eerst de logische functies uitgevoerd worden en dan pas de schuifregister-
 5787: 1			; acties. Het schuiven van de schuifregisters vertaald zich in het copieren
 5788: 1			; van bitmaps van voor naar achter.
 5789: 1			; (map2->map3, map1->map2, map0->map1 en de kolominputs->map0)
 5790: 1			;
 5791: 1			; De gebruiker moet eerst de key_init routine uitvoeren om de nodige bitmaps
 5792: 1			; en variabelen: key, keyvalid flag en keymode flag te initialiseren.
 5793: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de keyscan routine worden
 5794: 1			; de toetsen binnengelezen en gedebounced. Na het uitvoeren van de keyscan-
 5795: 1			; routine kan de gebruiker de routine  key_edge of key_pressed uitvoeren.
 5796: 1			; Deze routines geven via de keyvalid flag aan dat er al dan niet: een toets
 5797: 1			; pas is ingedrukt (key_edge routine) of ingedrukt wordt gehouden (key_pressed
 5798: 1			; routine). De variabele key kan dan door de gebruiker worden gelezen en geeft
 5799: 1			; deze toetswaarde weer.
 5800: 1			;
 5801: 1			;
 5802: 1			;
 5803: 1			;******************************************************************************
 5804: 1
 5805: 1
 5806: 1			;******************************************************************************
 5807: 1			; key_init
 5808: 1			; Dit is de initialisatieroutine voor de keyboardscanner. De keyboardscanner
 5809: 1			; gebruikt 9 bytes intern datageheugen, deze worden hier op 0 gezet.
 5810: 1			; input: niets
 5811: 1			; output: De bitmaps voor de verschillende scanlijnen worden op nul gezet

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 102



 Line  I  Addr  Code            Source

 5812: 1			;         (map0,map1,map2,map3 =0)
 5813: 1			;         key = 0 , keyvalid flag = 0, keymode flag = 0 (keyedge mode)
 5814: 1			; Deze routine vernietigt niets
 5815: 1			;******************************************************************************
 5816: 1
 5817: 1  148E	C0 E0		Key_init:       push    acc          ;bewaar registers
 5818: 1  1490	C0 D0		                push    psw
 5819: 1  1492	E8		                mov     a,r0
 5820: 1  1493	C0 E0		                push    acc
 5821: 1  1495	E9		                mov     a,r1
 5822: 1  1496	C0 E0		                push    acc
 5823: 1  1498	78 30		                mov     r0,#map01ptr ;pointer naar debounce en flankdetector maps
 5824: 1  149A	79 09		                mov     r1,#9        ;9 bytes in de maps
 5825: 1  149C	76 00		Keyinit1:       mov     @r0,#0       ;clear byte in map
 5826: 1  149E	08		                inc     r0           ;volgende byte nemen
 5827: 1  149F	D9 FB		                djnz    r1,Keyinit1  ;zijn we al klaar, nee: dan volgende nemen
 5828: 1  14A1	C2 00		                clr     keyvalid     ;ja, geldige toets-flag afzetten.
 5829: 1  14A3	C2 01		                clr     keymode      ;keybord leesmode op flankdetectie zetten
 5830: 1  14A5	75 38 00	                mov     key,#0       ;default vertrekwaarde KEY
 5831: 1  14A8	D0 E0		                pop     acc          ;herstel registers
 5832: 1  14AA	F9		                mov     r1,a
 5833: 1  14AB	D0 E0		                pop     acc
 5834: 1  14AD	F8		                mov     r0,a
 5835: 1  14AE	D0 D0		                pop     psw
 5836: 1  14B0	D0 E0		                pop     acc
 5837: 1  14B2	22		                ret                    ;terug naar caller
 5838: 1			;******************************************************************************
 5839: 1
 5840: 1
 5841: 1			;******************************************************************************
 5842: 1			; toets_flank
 5843: 1			; Deze routine detecteert de indrukflank van een toets.
 5844: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door
 5845: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5846: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5847: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5848: 1			; minder dan 20ms duurt.
 5849: 1			; input : niets
 5850: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5851: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5852: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5853: 1			;
 5854: 1			; Deze routine vernietigt geen registers.
 5855: 1			;******************************************************************************
 5856: 1  14B3	C0 E0		Toets_flank:    push    acc
 5857: 1  14B5	C0 D0		                push    psw
 5858: 1  14B7	12 14 D1	                lcall   Keyscan
 5859: 1  14BA	12 15 4D	                lcall   Keyedge
 5860: 1  14BD	D0 D0		                pop     psw
 5861: 1  14BF	D0 E0		                pop     acc
 5862: 1  14C1	22		                ret
 5863: 1
 5864: 1			;******************************************************************************
 5865: 1			; toets_ingedrukt
 5866: 1			; Deze routine detecteert een ingedrukte toets.
 5867: 1			; Een geldige toetswaarde wordt gestockeerd in 'key' en aangegeven door

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 103



 Line  I  Addr  Code            Source

 5868: 1			; de 'keyvalid' flag op '1'. Deze routine moet periodisch worden uitgevoerd
 5869: 1			; door de gebruiker (bv. om de 20ms), dit kan door deze routine op te roepen
 5870: 1			; vanuit een timerinterruptroutine (aanbevolen) of in een hoofdprogrammalus die
 5871: 1			; minder dan 20ms duurt.
 5872: 1			; input : niets
 5873: 1			; output: keyvalid flag = 0 : geen geldige toetswaarde in key
 5874: 1			;         keyvalid flag = 1 : er is een geldige toetswaarde in key gestockeerd
 5875: 1			;         key : ascii code van de ingdrukte toets (zie keyvalid flag)
 5876: 1			;
 5877: 1			; Deze routine vernietigt geen registers.
 5878: 1			;******************************************************************************
 5879: 1  14C2	C0 E0		Toets_ingedrukt:push    acc
 5880: 1  14C4	C0 D0		                push    psw
 5881: 1  14C6	12 14 D1	                lcall   Keyscan
 5882: 1  14C9	12 15 34	                lcall   Keydown
 5883: 1  14CC	D0 D0		                pop     psw
 5884: 1  14CE	D0 E0		                pop     acc
 5885: 1  14D0	22		                ret
 5886: 1
 5887: 1
 5888: 1			;******************************************************************************
 5889: 1			; Keyscan  (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 5890: 1			; Deze routine zorgt voor het scannen van de verschillende rij-lijnen, het
 5891: 1			; resultaat  van ingedrukte toetsen komt dan binnen op de kolomlijnen.
 5892: 1			; De Keyscan routine werkt met verschillende bitmaps die bijhouden wat de
 5893: 1			; vorige toestand was van een toets. Deze worden hier verwerkt en doorgeschoven
 5894: 1			; zoals aangegeven in het blokschema van het algorithme.
 5895: 1			; input : niets
 5896: 1			; Output: update van de bitmaps die de toetstoestand en de recente geschiedenis
 5897: 1			;         ervan weergeven
 5898: 1			;
 5899: 1			; Deze routine vernietigt geen registers
 5900: 1			;******************************************************************************
 5901: 1
 5902: 1  14D1	C0 E0		Keyscan:        push    acc            ;gebruikte registers op stack
 5903: 1  14D3	C0 D0		                push    psw
 5904: 1  14D5	C0 F0		                push    b
 5905: 1  14D7	E8		                mov     a,r0
 5906: 1  14D8	C0 E0		                push    acc
 5907: 1  14DA	E9		                mov     a,r1
 5908: 1  14DB	C0 E0		                push    acc
 5909: 1  14DD	EA		                mov     a,r2
 5910: 1  14DE	C0 E0		                push    acc
 5911: 1  14E0	EE		                mov     a,r6
 5912: 1  14E1	C0 E0		                push    acc
 5913: 1
 5914: 1  14E3	7E FE		                mov     r6,#11111110b  ;scanpatroon laden (0 circulatie)
 5915: 1  14E5	75 F0 04	                mov     b,#4           ;scanline counter (4 scanlijnen=rijen)
 5916: 1  14E8	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 5917: 1  14EA	79 34		                mov     r1,#map23ptr   ;pointer naar flankdetectiemaps
 5918: 1
 5919: 1  14EC			Scanloop:
 5920: 1			ifdef        aduc832_v1_1    ;keyboard scanlijnen zitten op twee poorten
 5921: 1			                mov     a,r6           ;splits het scanpatroon op voor p0 en p3
 5922: 1			                mov     c,acc.0        ;alleen twee bits van poort0 aansturen
 5923: 1			                mov     p0.0,c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 104



 Line  I  Addr  Code            Source

 5924: 1			                mov     c,acc.1
 5925: 1			                mov     p0.1,c
 5926: 1			                orl     a,#00000011b ;P3.0 en P3.1 zijn Txd en Rxd -> afblijven
 5927: 1			                mov     p3,a         ;stuur de scanlijnen naar P3
 5928: 1			endif
 5929: 1
 5930: 1			ifdef        aduc832_v2_0    ;keyboardscanlijnen zitten alleen op poort0
 5931: 1  14EC	8E 80		                mov     p0,r6        ;scanline activeren met nul niveau op
 5932: 1			                                      ;een rij-lijn
 5933: 1			endif
 5934: 1
 5935: 1			; Eerst de flipflops implementeren.
 5936: 1			; Dit kan eenvoudig door de bitmaps door te schuiven en een nieuwe entry
 5937: 1			; te lezen van de kolomlijnen
 5938: 1  14EE	E6		                mov     a,@r0         ;4 bits uit de debouncemaps laden
 5939: 1			                                      ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5940: 1  14EF	FA		                mov     r2,a          ;MAP0 en MAP1 even bewaren
 5941: 1  14F0	C4		                swap    a             ;MAP0 en MAP1 omwisselen
 5942: 1  14F1	5A		                anl     a,r2          ;and functie tussen MAP0 en MAP1
 5943: 1  14F2	54 F0		                anl     a,#11110000b  ;maskeren lsb's
 5944: 1  14F4	FA		                mov     r2,a          ;nieuwe map2 even bewaren
 5945: 1  14F5	E7		                mov     a,@r1        ;ophalen oude map2 en map3
 5946: 1  14F6	54 0F		                anl     a,#00001111b  ;oude map2 weggooien
 5947: 1  14F8	4A		                orl     a,r2          ;samenvoegen oude MAP3 en nieuwe map2
 5948: 1  14F9	F7		                mov     @r1,a         ;bewaren nieuwe MAP2 en oude MAP3
 5949: 1  14FA	E6		                mov     a,@r0         ;MAP1 en MAP0 weer nemen
 5950: 1  14FB	C4		                swap    a             ;MAP0 naar MAP1 schuiven en omgekeerd
 5951: 1  14FC	54 0F		                anl     a,#00001111b  ;nieuwe MAP1 bijhouden
 5952: 1  14FE	FA		                mov     r2,a          ;even bewaren in register
 5953: 1
 5954: 1
 5955: 1			ifdef        aduc832_v1_1    ;keyboard kolomlijnen zitten op poort3
 5956: 1			                mov     a,p3          ;nieuwe entry (4 msb's) lezen van de
 5957: 1			                                      ;poort3 kolomlijnen
 5958: 1			endif
 5959: 1			ifdef        aduc832_v2_0    ;keyboardkolom lijnen zitten op poort0
 5960: 1  14FF	E5 80		                mov     a,p0         ;nieuwe entry (4 msb's) lezen van de
 5961: 1			                                     ;poort0 kolomlijnen
 5962: 1			endif
 5963: 1  1501	F4		                cpl     a             ;ingedrukte toets -> een logische '1'
 5964: 1  1502	54 F0		                anl     a,#11110000b  ;scanlijnen (rijen) wegmaskeren
 5965: 1  1504	4A		                orl     a,r2          ;nieuwe entry samenvoegen met nieuwe MAP1
 5966: 1  1505	F6		                mov     @r0,a         ;en bewaren als nieuwe map0 en map1
 5967: 1
 5968: 1			; De flipflops (doorschuiven van maps) zijn nu uitgevoerd.
 5969: 1			; Nu volgen de logische functies uit het blokschema
 5970: 1
 5971: 1  1506	E6		                mov     a,@r0        ;4 bits uit de debouncemaps laden
 5972: 1			                                     ;( MAP0=bit 7..4,MAP1=bit 3..0 )
 5973: 1  1507	FA		                mov     r2,a         ;MAP0 en MAP1 even bewaren
 5974: 1  1508	C4		                swap    a            ;MAP0 en MAP1 omwisselen
 5975: 1  1509	5A		                anl     a,r2         ;and functie tussen MAP0 en MAP1
 5976: 1  150A	54 0F		                anl     a,#00001111b ;low nibble houden
 5977: 1  150C	FA		                mov     r2,a         ;resultaat bewaren
 5978: 1  150D	E7		                mov     a,@r1        ;4 bits uit de flankdetectiemaps laden
 5979: 1			                                     ;(MAP2=bit7..4,MAP3=bit3..0)

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 105



 Line  I  Addr  Code            Source

 5980: 1  150E	F4		                cpl     a            ;MAP2 inverteren( +edge=toets ingedrukt)
 5981: 1  150F	C4		                swap    a            ;map2 naar low nibble schuiven
 5982: 1  1510	5A		                anl     a,r2         ;combineren met output vorige and poort
 5983: 1  1511	54 0F		                anl     a,#00001111b ;low nibble voor MAP3 overhouden
 5984: 1  1513	FA		                mov     r2,a         ;even bewaren
 5985: 1  1514	E7		                mov     a,@r1        ;map2 en map3 weer ophalen
 5986: 1  1515	54 F0		                anl     a,#11110000b ;map2 overhouden
 5987: 1  1517	4A		                orl     a,r2         ;en combineren met nieuwe map3
 5988: 1  1518	F7		                mov     @r1,a        ;en weer wegschrijven in map2 en map3
 5989: 1
 5990: 1			; We gaan nu de volgende lijn scannen
 5991: 1
 5992: 1  1519	EE		                mov     a,r6         ;scanpatroon nemen
 5993: 1  151A	23		                rl      a            ;'0' opschuiven=volgende scanlijn activeren
 5994: 1  151B	FE		                mov     r6,a         ;scanpatroon bewaren
 5995: 1
 5996: 1  151C	08		                inc     r0           ;MAP0 en MAP1 pointer eentje verder zetten
 5997: 1  151D	09		                inc     r1           ;MAP2 en MAP3 pointer eentje verder zetten
 5998: 1  151E	D5 F0 CB	                djnz    b,Scanloop   ;4 lijnen scannen, en daarna gedaan
 5999: 1  1521	D0 E0		                pop     acc          ;herstel registers
 6000: 1  1523	FE		                mov     r6,a
 6001: 1  1524	D0 E0		                pop     acc
 6002: 1  1526	FA		                mov     r2,a
 6003: 1  1527	D0 E0		                pop     acc
 6004: 1  1529	F9		                mov     r1,a
 6005: 1  152A	D0 E0		                pop     acc
 6006: 1  152C	F8		                mov     r0,a
 6007: 1  152D	D0 F0		                pop     b
 6008: 1  152F	D0 D0		                pop     psw
 6009: 1  1531	D0 E0		                pop     acc
 6010: 1  1533	22		                ret                    ;terug naar caller
 6011: 1			;******************************************************************************
 6012: 1
 6013: 1
 6014: 1			;******************************************************************************
 6015: 1			; Keydown, Keyedge (twee entry's)
 6016: 1			; (wordt opgeroepen door de toets_flank en toets_ingedrukt routines)
 6017: 1			;
 6018: 1			; Deze routine zal uit de opgeslagen bitpatronen in de bitmaps de ingedrukte
 6019: 1			; toets bepalen. De Keyscan routine moet steeds eerst worden uitgevoerd.
 6020: 1			; Er zijn twee detectie-modes:
 6021: 1			; flankdetectie mode:   In deze mode zal 'indrukflank' van een toets worden
 6022: 1			;                       aangegeven. Nadat de gebruiker de toetswaarde heeft
 6023: 1			;                       gelezen en de 'keyvalid' flag heeft gereset zal pas
 6024: 1			;                       wanneer de toets wordt losgelaten en opnieuw wordt
 6025: 1			;                       ingedrukt deze opnieuw worden aangegeven.
 6026: 1			; toets ingedrukt mode: In deze mode zal zolang een toets wordt ingedrukt
 6027: 1			;                       deze telkens,na het lezen en resetten van de 'keyvalid'
 6028: 1			;                       flag door de gebruiker, opnieuw worden aangegeven.
 6029: 1			;
 6030: 1			; Keyedge is de entry om na te gaan of een toets pas is ingedrukt
 6031: 1			; (flankdetectie mode).
 6032: 1			; keydown is de entry om na te gaan of een toets continue is ingedrukt
 6033: 1			; (toets ingedrukt mode).
 6034: 1			;
 6035: 1			; De gedetecteerde toetspositie wordt door deze routine via een lookup tabel

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 106



 Line  I  Addr  Code            Source

 6036: 1			; omgezet naar een toetswaarde. De lookuptabel kan door de gebruiker worden
 6037: 1			; aangepast in functie van de toepassing. De default tabel met ascii codes
 6038: 1			; geldt voor een standaard 4x4 keypad.
 6039: 1			;
 6040: 1			; De gedetecteerde toetswaarde wordt door deze routine achtergelaten in de
 6041: 1			; variabele 'Key', en de 'keyvalid' flag geeft aan dat er geldige toetswaarde
 6042: 1			; in 'key' aanwezig is. De gebruiker moet in zijn toepassing na het lezen van
 6043: 1			; de toetswaarde uit 'key' de 'keyvalid' flag zelf weer resetten.
 6044: 1			;
 6045: 1			; input : de door de Keyscan routine aangepaste bitmaps
 6046: 1			; output: key = gedetecteerde toets
 6047: 1			;         keyvalid flag =1 : er zit een geldige waarde in key
 6048: 1			;         keyvalid flag =0 : er is geen nieuwe toetswaarde
 6049: 1			;
 6050: 1			; Deze routine vernietigt geen registers
 6051: 1			;******************************************************************************
 6052: 1
 6053: 1			;'Toets ingedrukt mode' enty van de routine
 6054: 1  1534	C0 E0		Keydown:        push    acc            ;registers bewaren
 6055: 1  1536	C0 D0		                push    psw
 6056: 1  1538	C0 F0		                push    b
 6057: 1  153A	C0 82		                push    dpl
 6058: 1  153C	C0 83		                push    dph
 6059: 1  153E	E8		                mov     a,r0
 6060: 1  153F	C0 E0		                push    acc
 6061: 1  1541	E9		                mov     a,r1
 6062: 1  1542	C0 E0		                push    acc
 6063: 1  1544	EA		                mov     a,r2
 6064: 1  1545	C0 E0		                push    acc
 6065: 1  1547	78 30		                mov     r0,#map01ptr   ;pointer naar debounce maps
 6066: 1  1549	D2 01		                setb    keymode        ;'toets ingedrukt'mode (keymode =1)
 6067: 1  154B	80 15		                sjmp    Key1           ;continue
 6068: 1
 6069: 1			;'Flankdetectiemode' entry van de routine
 6070: 1  154D	C0 E0		Keyedge:        push    acc            ;registers bewaren
 6071: 1  154F	C0 D0		                push    psw
 6072: 1  1551	C0 F0		                push    b
 6073: 1  1553	C0 82		                push    dpl
 6074: 1  1555	C0 83		                push    dph
 6075: 1  1557	E8		                mov     a,r0
 6076: 1  1558	C0 E0		                push    acc
 6077: 1  155A	E9		                mov     a,r1
 6078: 1  155B	C0 E0		                push    acc
 6079: 1  155D	EA		                mov     a,r2
 6080: 1  155E	C0 E0		                push    acc
 6081: 1  1560	78 34		                mov     r0,#map23ptr  ;pointer naar flankdetectie maps
 6082: 1  1562	7A 04		Key1:           mov     r2,#4         ;rijteller laden
 6083: 1  1564	79 04		Rijloop:        mov     r1,#4         ;kolomteller laden
 6084: 1  1566	E6		                mov     a,@r0         ;map entry ophalen
 6085: 1  1567	30 01 05	                jnb     keymode,Key2  ;als flank mode dan verder...
 6086: 1  156A	F5 F0		                mov     b,a           ;nee, dan map0 en map1 even bewaren
 6087: 1  156C	C4		                swap    a             ;map1 en map0 omwisselen
 6088: 1  156D	55 F0		                anl     a,b           ;map0 en map1 'and'en, of debouncen
 6089: 1  156F	C4		Key2:           swap    a             ;map 1 en map0 verwisselen
 6090: 1  1570	33		                rlc     a             ;kolombit testen
 6091: 1  1571	40 08		Kolomloop:      jc      toetsin       ;als carry dan toets gedrukt

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 107



 Line  I  Addr  Code            Source

 6092: 1  1573	33		                rlc    a              ;nee, dan verder roteren
 6093: 1  1574	D9 FB		                djnz    r1,Kolomloop  ;test alle kolommen
 6094: 1  1576	08		                inc     r0            ;rijpointer in maps verder zetten
 6095: 1  1577	DA EB		                djnz    r2,Rijloop    ;test alle rijen
 6096: 1  1579	80 0E		                sjmp    nokey         ;alles getest en geen entry
 6097: 1
 6098: 1			;Er is een toets gedrukt, we gaan nu bepalen waar de overeenkomende code staat
 6099: 1			;in de toetstabel. Dit doen we aan de hand van de rij- en kolom pointers.
 6100: 1			;De offset in de toetstabel berekenen we als volgt: offset=(rij-1)x4+(kolom-1)
 6101: 1
 6102: 1  157B	1A		toetsin:        dec     r2            ;rij-1
 6103: 1  157C	19		                dec     r1            ;kolom-1
 6104: 1  157D	EA		                mov     a,r2          ;neem rij-1
 6105: 1  157E	23		                rl      a             ;(rij-1)x2
 6106: 1  157F	23		                rl      a              ;(rij-1)x4
 6107: 1  1580	29		                add     a,r1          ;offset=(rij-1)x4 + (kolom-1)
 6108: 1  1581	90 15 9F	                mov     dptr,#toetstabel ;startadres van de toetstabel
 6109: 1  1584	93		                movc    a,@a+dptr     ;haal toetscode op startadres+offset
 6110: 1  1585	F5 38		                mov     key,a         ;stop toetscode in de variabele key
 6111: 1  1587	D2 00		                setb    keyvalid      ;geldige toets is gevonden
 6112: 1  1589	C2 01		nokey:          clr     keymode        ;default in flankdetectie-mode
 6113: 1  158B	D0 E0		                pop     acc            ;herstellen registers
 6114: 1  158D	FA		                mov     r2,a
 6115: 1  158E	D0 E0		                pop     acc
 6116: 1  1590	F9		                mov     r1,a
 6117: 1  1591	D0 E0		                pop     acc
 6118: 1  1593	F8		                mov     r0,a
 6119: 1  1594	D0 83		                pop     dph
 6120: 1  1596	D0 82		                pop     dpl
 6121: 1  1598	D0 F0		                pop     b
 6122: 1  159A	D0 D0		                pop     psw
 6123: 1  159C	D0 E0		                pop     acc
 6124: 1  159E	22		                ret                    ;terug naar caller
 6125: 1			;******************************************************************************
 6126: 1			;Toetstabel voor een standaard 4x4 keyboard.
 6127: 1			;De gebruiker kan hier andere waarden voor de toetscodes ingeven
 6128: 1
 6129: 1  159F	2A		toetstabel:     db    '*'    ;kolom1@rij4 toets
 6130: 1  15A0	30		                db    '0'    ;kolom2@rij4 toets
 6131: 1  15A1	23		                db    '#'    ;kolom3@rij4 toets
 6132: 1  15A2	44		                db    'D'    ;kolom4@rij4 toets
 6133: 1
 6134: 1  15A3	37		                db    '7'    ;kolom1@rij3 toets
 6135: 1  15A4	38		                db    '8'    ;kolom2@rij3 toets
 6136: 1  15A5	39		                db    '9'    ;kolom3@rij3 toets
 6137: 1  15A6	43		                db    'C'    ;kolom4@rij3 toets
 6138: 1
 6139: 1  15A7	34		                db    '4'    ;kolom1@rij2 toets
 6140: 1  15A8	35		                db    '5'    ;kolom2@rij2 toets
 6141: 1  15A9	36		                db    '6'    ;kolom3@rij2 toets
 6142: 1  15AA	42		                db    'B'    ;kolom4@rij2 toets
 6143: 1
 6144: 1  15AB	31		                db    '1'    ;kolom1@rij1 toets
 6145: 1  15AC	32		                db    '2'    ;kolom2@rij1 toets
 6146: 1  15AD	33		                db    '3'    ;kolom3@rij1 toets
 6147: 1  15AE	41		                db    'A'    ;kolom4@rij1 toets

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 108



 Line  I  Addr  Code            Source

 6148: 1
 6149: 1			;******************************************************************************
 6150: 1			; switch_init
 6151: 1			; Dit is de initialisatieroutine voor 'read_switch' de switchdebouncer/scanner.
 6152: 1			; Deze gebruikt 6 bytes intern datageheugen, deze worden hier op 0 gezet.
 6153: 1			; input : niets
 6154: 1			; output: De 6 bytes voor de debouncer en flankdetectoren worden op 0 gezet.
 6155: 1			;         Deze routine reset ook de 'swvalid','negvalid' en 'posvalid' flag.
 6156: 1			;
 6157: 1			; Deze routine vernietigt niets
 6158: 1			;******************************************************************************
 6159: 1
 6160: 1  15AF	C0 E0		switch_init:    push    acc
 6161: 1  15B1	C0 D0		                push    psw
 6162: 1  15B3	C0 F0		                push    b
 6163: 1  15B5	E8		                mov     a,r0         ;bewaar registers
 6164: 1  15B6	C0 E0		                push    acc
 6165: 1
 6166: 1  15B8	78 40		                mov     r0,#switch1  ;pointer naar debounce&flankdetectorbytes
 6167: 1  15BA	75 F0 06	                mov     b,#6         ;6 bytes met bitmaps
 6168: 1  15BD	76 00		swinit:         mov     @r0,#0       ;clear byte in map
 6169: 1  15BF	08		                inc     r0           ;volgende byte nemen
 6170: 1  15C0	D5 F0 FA	                djnz    b,swinit     ;zijn we al klaar, nee: dan volgende nemen
 6171: 1  15C3	C2 02		                clr     swvalid      ;ja, flags afzetten.
 6172: 1  15C5	C2 03		                clr     negvalid
 6173: 1  15C7	C2 04		                clr     posvalid
 6174: 1
 6175: 1  15C9	D0 E0		                pop     acc
 6176: 1  15CB	F8		                mov     r0,a
 6177: 1  15CC	D0 F0		                pop     b
 6178: 1  15CE	D0 D0		                pop     psw
 6179: 1  15D0	D0 E0		                pop     acc
 6180: 1  15D2	22		                ret                   ;terug naar caller
 6181: 1
 6182: 1			;******************************************************************************
 6183: 1			; read_switch
 6184: 1			; Dit is de routine voor het lezen, debouncen en de +/- flankdetecties van de
 6185: 1			; 8 DIP schakelaars (of de druktoetsen) tegelijk.
 6186: 1			; Deze routine werkt volgens onderstaand blokschema.
 6187: 1			;
 6188: 1			;                                  ___                    ___
 6189: 1			;                     ____________| 1 |   ---------*-----| 2 |
 6190: 1			;              ____  |   ____     |   |  |   ____  |     |   |
 6191: 1			;SWitch |\    |    | |  |    |    |&  |__*__|    | |     |&  |
 6192: 1			;     --| o---|D  Q|_*__|D  Q|----|___|     |D  Q|-|--*-o|___|---- negedge
 6193: 1			;Px.y   |/    | cl |    | cl |              | cl | |  |   ___  (negvalid-flag)
 6194: 1			;             |____|    |____|              |____|  ----o| 3 |
 6195: 1			;                |         |                   |      |  |   |
 6196: 1			;      CLOCK     |         |                   |      |  |&  | (posvalid-flag)
 6197: 1			;         _______*_________*___________________|       --|___|---- posedge
 6198: 1			;
 6199: 1			;            DEBOUNCE CIRCUIT                   FLANKDETECTIES
 6200: 1			;                              (swvalid-flag)
 6201: 1			;            switch1   switch2    debounce      closed
 6202: 1			;
 6203: 1			; In werkelijkheid gaat het ipv. over 1 bit, zoals in de figuur,over 8 bits

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 109



 Line  I  Addr  Code            Source

 6204: 1			; die telkens tegelijk worden gelezen (8 schakelaars).
 6205: 1			; De flip-flops zijn softwarematig bytes waar de toestand van de schakelaars
 6206: 1			; en de vorige (doorgeschoven) toestanden in worden bewaard.
 6207: 1			; Zo zijn er 6 bytes nodig voor de drie flipflops en de 2 edge detectoren.
 6208: 1			; Switch1 (uitgangen 1ste flip-flop) en switch2 (uitgangen 2de flip-flop)
 6209: 1			; vormen met de eerste and poort de debouncer voor de 8 schakelaars.
 6210: 1			; De byte 'closed' (uitgang 3de flipflop) vormt samen met de tweede and-
 6211: 1			; poort een detector voor negatieve flanken (negedge) en met de derde andpoort
 6212: 1			; een detector voor positieve flanken (posedge).
 6213: 1			;
 6214: 1			; input : de schakelaars wordt gelezen ifv. de versie van het aduc800 bord
 6215: 1			;         bij aduc832v1.1 :
 6216: 1			;         als f0=0 of f0=1 :altijd de schakelaars op p3/p0
 6217: 1			;         bij aduc832v2.0 :
 6218: 1			;         als f0=0 dan: schakelaars op p0
 6219: 1			;          als f0=1 dan: 4 MSB schakelaars op p3, p3.3-p3.0 worden gemaskeerd
 6220: 1			;
 6221: 1			; output: De 5 bytes met bitmaps voor de debouncer en flankdetectoren worden
 6222: 1			;         geactualiseerd.
 6223: 1			;         debounce: een byte waarin een bit op '1' de actueel ingedrukte
 6224: 1			;                  schakelaars weergeeft
 6225: 1			;         swvalid: een flag die aangeeft dat 'debounce' geactualiseerd is.
 6226: 1			;         negedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6227: 1			;                  schakelaar een negetieve flank werd gedetecteerd.
 6228: 1			;         negvalid:een flag die aangeeft dat er een nieuwe negatieve flank
 6229: 1			;                  werd gedetecteerd op een schakelaar.
 6230: 1			;         posedge: een byte waarin een bit op '1' aangeeft dat er voor die
 6231: 1			;                  schakelaar een positieve flank werd gedetecteerd.
 6232: 1			;         posvalid:een flag die aangeeft dat er een nieuwe positieve flank
 6233: 1			;                  werd gedetecteerd op een schakelaar.
 6234: 1			;
 6235: 1			;
 6236: 1			; De gebruiker moet eerst de switch_init routine uitvoeren om de nodige bytes
 6237: 1			; en flags te initialiseren.
 6238: 1			; Bij het periodisch uitvoeren (vb. om de 20ms) van de read_switch routine
 6239: 1			; worden de schakelaars binnengelezen en gedebounced. Na het uitvoeren van de
 6240: 1			; read_switch routine kan de gebruiker de flags 'swvalid', 'negvalid' en
 6241: 1			; 'posvalid' checken en de bijhorende bytes 'debounce', 'negedge' en 'posedge'
 6242: 1			; lezen. De gebruiker zal na het lezen van debounce, negedge of posedge de
 6243: 1			; bijhorende flag resetten.
 6244: 1			;
 6245: 1			; Deze routine vernietigt niets
 6246: 1			;******************************************************************************
 6247: 1  15D3	C0 E0		read_switch:    push    acc            ;registers bewaren
 6248: 1  15D5	C0 D0		                push    psw
 6249: 1  15D7	C0 F0		                push    b
 6250: 1			;Flipflops uitvoeren is bytes doorschuiven
 6251: 1  15D9	85 42 43	                mov     closed,debounce;uitgang eerste andpoort naar 3de FF
 6252: 1  15DC	85 40 41	                mov     switch2,switch1;uitgang 1ste FF naar 2de FF
 6253: 1
 6254: 1			ifdef        aduc832_v1_1    ;schakelaars zitten op twee poorten
 6255: 1			                clr      a
 6256: 1			                mov     c,p0.0        ;lees laagste schakelaars
 6257: 1			                mov     acc.0,c
 6258: 1			                mov     c,p0.1
 6259: 1			                mov     acc.1,c

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 110



 Line  I  Addr  Code            Source

 6260: 1			                mov     b,a            ;even bewaren
 6261: 1			                mov     a,p3           ;lees 6 hoogste schakelaars
 6262: 1			                anl     a,#11111100b   ;maskeer rxd en txd
 6263: 1			                orl     a,b            ;laagste schakelaars bijvoegen
 6264: 1			endif        ;einde aduc832_v1_1
 6265: 1
 6266: 1			ifdef        aduc832_v2_0        ;schakelaars zitten op poort0
 6267: 1  15DF	20 D5 04	                jb      f0,read_port3  ;indien flag=1, dan de druktoetsen lezen
 6268: 1  15E2	E5 80		                mov     a,p0           ;lees de schakelaars
 6269: 1  15E4	80 04		                sjmp    lowlogic
 6270: 1  15E6	E5 B0		read_port3:     mov     a,p3           ;lees druktoetsen
 6271: 1  15E8	44 0F		                orl     a,#0fh         ;en maskeer de 4 lsb's
 6272: 1			endif        ;einde aduc832_2_0
 6273: 1
 6274: 1  15EA	F4		lowlogic:       cpl     a              ;schakelaars complementeren
 6275: 1  15EB	F5 40		                mov     switch1,a      ;en sample opslaan
 6276: 1
 6277: 1			;Flipflops zijn klaar, nu de logische schakelingen (and poorten)
 6278: 1
 6279: 1  15ED	E5 40		                mov     a,switch1      ;neem laatste sample
 6280: 1  15EF	55 41		                anl     a,switch2      ;and met vorige sample,-> ontdender
 6281: 1  15F1	F5 42		                mov     debounce,a    ;en bewaar ontdenderde toestand
 6282: 1  15F3	D2 02		                setb    swvalid       ;nieuwe schakelaartoestand opgeslagen
 6283: 1			;negatieve flankdetectie
 6284: 1  15F5	E5 43		                mov     a,closed      ;neem 3de FF
 6285: 1  15F7	F4		                cpl     a             ;complementeer
 6286: 1  15F8	55 42		                anl     a,debounce    ;en combineer met signaal uit and poort
 6287: 1  15FA	F5 44		                mov     negedge,a     ;bewaar negatieve flanken
 6288: 1  15FC	60 04		                jz      read_switch1  ;spring als geen negatieve flanken
 6289: 1  15FE	D2 03		                setb    negvalid      ;ja, negatieve flank: status updaten
 6290: 1  1600	80 0B		                sjmp    read_switch2  ;negatieve flank, dus er is geen positieve
 6291: 1			;positieve flankdetectie
 6292: 1  1602	E5 42		read_switch1:   mov     a,debounce    ;neem uitgang and poort
 6293: 1  1604	F4		                cpl     a             ;complementeer
 6294: 1  1605	55 43		                anl     a,closed      ;combineer met 3de FF
 6295: 1  1607	F5 45		                mov     posedge,a    ;bewaar positieve flanken
 6296: 1  1609	60 02		                jz      read_switch2 ;spring als geen positieve flanken
 6297: 1  160B	D2 04		                setb    posvalid     ;ja, positieve flank: status updaten
 6298: 1  160D	D0 F0		read_switch2:   pop     b            ;registers herstellen
 6299: 1  160F	D0 D0		                pop     psw
 6300: 1  1611	D0 E0		                pop     acc
 6301: 1  1613	22		                ret
 6302: 1
 6303: 1			endif    ;einde van aduc_key
 6304: 1
 6305: 1
 6306:				end





                     register banks used:  ---

                     no errors


ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 111






ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 112





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 150
ACC				  DATA	      E0	  69
ADCCON1				  DATA	      EF	  72
ADCCON2				  DATA	      D8	  65
ADCCON3				  DATA	      F5	  78
ADCDATAH			  DATA	      DA	  67
ADCDATAL			  DATA	      D9	  66
ADCGAINH			  DATA	      F4	  77
ADCGAINL			  DATA	      F3	  76
ADCI				  BIT	      DF	 159
ADCOFSH				  DATA	      F2	  75
ADCOFSL				  DATA	      F1	  74
ADC_INIT			  CODE	    13D2	5555
ADC_INIT1			  CODE	    13DF	5561
ADC_SINGLE			  CODE	    13E4	5600
ADC_SINGLE1			  CODE	    13F0	5606
ADC_SINGLE2			  CODE	    141B	5632
ADC_SINGLE20			  CODE	    1425	5637
ADC_SINGLE21			  CODE	    142D	5643
ADC_SINGLE3			  CODE	    1430	5647
ADC_SINGLE30			  CODE	    1450	5668
ADC_SINGLE31			  CODE	    145A	5673
ADC_SINGLE4			  CODE	    1462	5682
ADC_SINGLE40			  CODE	    146E	5690
ADC_SINGLE41			  CODE	    1478	5695
ADC_SINGLE42			  CODE	    147E	5699
ADC_SINGLE43			  CODE	    1486	5705
ADD16				  CODE	    0929	2907
ADD161				  CODE	    093D	2923
ADD32				  CODE	    097B	3004
ADD321				  CODE	    0995	3028
ADUC832_V2_0			  NUMBER    0001	 213
ADUC_ADC			  NUMBER    0001	 234
ADUC_I2C			  NUMBER    0001	 231
ADUC_KEY			  NUMBER    0001	 235
ADUC_LCD			  NUMBER    0001	 228
ADUC_MATH			  NUMBER    0001	 233
ADUC_SIO			  NUMBER    0001	 232
ASCBINTRANS			  CODE	    05D9	1960
ASCBINTRANS1			  CODE	    05EE	1971
ASCBINTRANS2			  CODE	    05ED	1970
ASCBINTRANS3			  CODE	    05E1	1964
ASCBINTRANS4			  CODE	    05EA	1968
ASCCTR				  CODE	    05B0	1906
ASCCTR1				  CODE	    05B3	1907
ASCCTR2				  CODE	    05B8	1909
ASCCTR3				  CODE	    05BC	1912
ASCII1				  CODE	    05EF	1982

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 113



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
ASCII2				  CODE	    05F4	1996
ASCII21				  CODE	    0606	2005
ASCII4				  CODE	    0609	2019
ASCII41				  CODE	    0618	2026
B				  DATA	      F0	  73
BACKLIGHT			  BIT	      F6	 380
BACKSP				  NUMBER    0008	1605
BARCHARS			  CODE	    0299	1006
BAREINDE			  CODE	    02C0	1049
BARLCD				  CODE	    0234	 927
BARLCD1				  CODE	    026F	 961
BARLCD2				  CODE	    0276	 966
BARLCD3				  CODE	    027F	 974
BARLCD4				  CODE	    0284	 978
BARLCDE				  CODE	    028C	 983
BARLCD_1			  CODE	    024F	 943
BATRANS				  CODE	    05CB	1942
BATRANS1			  CODE	    05D0	1944
BATRANS2			  CODE	    05D4	1946
BCDHEX16			  CODE	    068E	2221
BCDHEX161			  CODE	    069C	2229
BCDHEX1611			  CODE	    06A5	2233
BCDHEX1612			  CODE	    06AF	2238
BCDHEX1613			  CODE	    06B8	2242
BCDHEX162			  CODE	    0703	2296
BCDHEX8				  CODE	    0619	2112
BCDHEX81			  CODE	    0627	2120
BCDHEX811			  CODE	    0630	2124
BCDHEX82			  CODE	    0652	2148
BDELETE				  CODE	    058B	1872
BDELETE1			  CODE	    0599	1880
BDELETE2			  CODE	    05AC	1891
BDELETE3			  CODE	    059D	1882
BEEP				  NUMBER    0007	1606
BLANK				  NUMBER    0020	1600
BUILD				  CODE	    02C1	1081
BUILD1				  CODE	    02D9	1123
BUILD2				  CODE	    02E8	1130
BUILD3				  CODE	    02DC	1124
BUILD_ADR			  CODE	    02CF	1118
BUZZER				  BIT	      F7	 381
CAP2				  BIT	      C8	 136
CCONV				  BIT	      DD	 157
CFG832				  DATA	      AF	  38
CGRAM				  NUMBER    0040	 396
CHIPID				  DATA	      C2	  52
CLEARDISP			  NUMBER    0001	 386
CLOSED				  NUMBER    0043	 300
CMP16				  CODE	    110A	4938
CMP161				  CODE	    1127	4957
CMP162				  CODE	    1133	4966
CMP32				  CODE	    11AB	5085
CMP321				  CODE	    11D4	5112
CMP322				  CODE	    11E0	5121
CNT2				  BIT	      C9	 137
CORDIC				  CODE	    1274	5272

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 114



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
CORDIC0				  CODE	    12DF	5337
CORDIC00			  CODE	    12C5	5322
CORDIC000			  CODE	    1298	5296
CORDIC1				  CODE	    12F3	5351
CORDIC2				  CODE	    1327	5401
CORDIC3				  CODE	    1332	5408
CORDIC4				  CODE	    1357	5442
CORDIC40			  CODE	    135C	5446
CORDIC41			  CODE	    1375	5462
CORDIC5				  CODE	    137B	5468
CORDIC50			  CODE	    138D	5478
CORDIC51			  CODE	    13A6	5493
CORDIC52			  CODE	    13B1	5502
CORDIC5A			  CODE	    138B	5477
CORDIC5B			  CODE	    13A4	5492
CORDIC_ATAN			  CODE	    13B4	5508
CORDIC_ERROR			  CODE	    12A8	5304
CORDIC_MIN90			  CODE	    12AD	5308
CORDIC_NUL			  CODE	    12D1	5328
CORDIC_PLUS90			  CODE	    12B9	5315
CPHA				  BIT	      FA	 174
CPOL				  BIT	      FB	 175
CR				  NUMBER    000D	1603
CS0				  BIT	      D8	 152
CS1				  BIT	      D9	 153
CS2				  BIT	      DA	 154
CS3				  BIT	      DB	 155
CURSATHOM			  NUMBER    0002	 387
CURSOROFF			  NUMBER    000C	 392
CURSORONB			  NUMBER    000F	 393
CURSORONN			  NUMBER    000E	 394
CY				  BIT	      D7	 151
D0				  BIT	      ED	 161
D0EN				  BIT	      EB	 160
D1				  BIT	      EF	 163
D1EN				  BIT	      EE	 162
DAC0H				  DATA	      FA	  82
DAC0L				  DATA	      F9	  81
DAC1H				  DATA	      FC	  84
DAC1L				  DATA	      FB	  83
DACCON				  DATA	      FD	  85
DCON				  DATA	      E8	  70
DDRAM				  NUMBER    0080	 397
DEBOUNCE			  NUMBER    0042	 299
DELAY2MS			  CODE	    02F6	1147
DELAY2MS1			  CODE	    02FC	1150
DELAY60US			  CODE	    0307	1167
DELAY60US1			  CODE	    0319	1181
DELAY60US2			  CODE	    0317	1180
DIPSWITCH			  NUMBER    0001	 253
DISPDPTR			  CODE	    04E1	1714
DISPDPTRLCD			  CODE	    00FB	 602
DISPLAYOF			  NUMBER    0008	 391
DISPLAYON			  NUMBER    0001	 390
DIV16				  CODE	    0BF0	3690
DIV160				  CODE	    0BFE	3701

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 115



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
DIV161				  CODE	    0C1C	3724
DIV162				  CODE	    0C2F	3740
DIV163				  CODE	    0C4B	3765
DIV164				  CODE	    0C5D	3783
DIV32				  CODE	    0C9A	3854
DIV320				  CODE	    0CAA	3867
DIV320A				  CODE	    0CB4	3878
DIV320B				  CODE	    0CD2	3906
DIV320C				  CODE	    0CF7	3934
DIV322				  CODE	    0D1C	3968
DIV323				  CODE	    0D66	4044
DIV324				  CODE	    0D98	4094
DIV8				  CODE	    0BAD	3617
DIV81				  CODE	    0BC5	3633
DMA				  BIT	      DE	 158
DMAH				  DATA	      D3	  62
DMAL				  DATA	      D2	  61
DMAP				  DATA	      D4	  63
DPCON				  DATA	      A7	  34
DPH				  DATA	      83	  11
DPL				  DATA	      82	  10
DPP				  DATA	      84	  12
E				  BIT	      F1	 378
EA				  BIT	      AF	 111
EADC				  BIT	      AE	 110
EADRH				  DATA	      C7	  54
EADRL				  DATA	      C6	  53
ECON				  DATA	      B9	  46
EDATA1				  DATA	      BC	  47
EDATA2				  DATA	      BD	  48
EDATA3				  DATA	      BE	  49
EDATA4				  DATA	      BF	  50
ENDBUF				  NUMBER    007F	1612
ENTRYMODE			  NUMBER    0006	 389
ES				  BIT	      AC	 108
ET0				  BIT	      A9	 105
ET1				  BIT	      AB	 107
ET2				  BIT	      AD	 109
EX0				  BIT	      A8	 104
EX1				  BIT	      AA	 106
EXEN2				  BIT	      CB	 139
EXF2				  BIT	      CE	 142
F0				  BIT	      D5	 149
F1				  BIT	      D1	 145
FF				  NUMBER    000C	1602
FUNCTIONS			  NUMBER    0028	 395
HEXBCD16			  CODE	    070C	2332
HEXBCD161			  CODE	    071A	2339
HEXBCD16_U			  CODE	    070F	2333
HEXBCD8				  CODE	    065B	2173
HEXBCD81			  CODE	    0665	2178
HEXBCD82			  CODE	    066A	2180
HEXBCD83			  CODE	    0674	2186
HEXBUF2LCD			  CODE	    01D7	 868
HEXBUF2LCD1			  CODE	    01FB	 884
HEXBUF2LCDE			  CODE	    0212	 895

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 116



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HEXBUFTXT			  CODE	    0220	 904
HOUR				  DATA	      A5	  32
HTHSEC				  DATA	      A2	  29
I2CADD				  DATA	      9B	  24
I2CCON				  DATA	      E8	  71
I2CDAT				  DATA	      9A	  23
I2CI				  BIT	      E8	 164
I2CINBYTEA1			  CODE	    0363	1289
I2CINBYTEACK			  CODE	    035C	1286
I2CINBYTEN1			  CODE	    0384	1313
I2CINBYTENACK			  CODE	    037D	1310
I2CINIT				  CODE	    0321	1231
I2CM				  BIT	      EB	 167
I2COUTBYTE			  CODE	    033C	1263
I2COUTBYTE1			  CODE	    0343	1266
I2CPCF8574			  NUMBER    0040	1222
I2CPCF8574A			  NUMBER    0070	1223
I2CRCVDATA			  CODE	    03DE	1415
I2CRCVDATA1			  CODE	    03FD	1433
I2CRCVDATA2			  CODE	    0406	1437
I2CRCVDATA3			  CODE	    040D	1442
I2CRCVERROR			  CODE	    0419	1450
I2CRS				  BIT	      EA	 166
I2CSENDDATA			  CODE	    039E	1353
I2CSENDDATA1			  CODE	    03BD	1370
I2CSENDERROR			  CODE	    03D3	1383
I2CSTART			  CODE	    032A	1240
I2CSTOP				  CODE	    0333	1249
I2CTX				  BIT	      E9	 165
IE				  DATA	      A8	  35
IE0				  BIT	      89	  87
IE1				  BIT	      8B	  89
IEIP2				  DATA	      A9	  36
INBUFA				  CODE	    0550	1829
INBUFA1				  CODE	    0567	1846
INBUFA2				  CODE	    0556	1832
INBUFA3				  CODE	    0574	1852
INBUFA4				  CODE	    056D	1848
INBUFA5				  CODE	    0587	1860
INBUFA6				  CODE	    057D	1856
INBUFA7				  CODE	    056F	1849
INBYTE				  CODE	    0530	1797
INBYTE1				  CODE	    054D	1809
INCHAR				  CODE	    0528	1781
INITLCD				  CODE	    002B	 412
INITLCD1			  CODE	    003C	 429
INITSIO				  CODE	    048E	1626
INITSIO1			  CODE	    0497	1630
INITSIOE			  CODE	    04AD	1647
INT0				  BIT	      B2	 114
INT0_ROUT			  CODE	    0028	 200
INT1				  BIT	      B3	 115
INTVAL				  DATA	      A6	  33
IP				  DATA	      B8	  45
ISPI				  BIT	      FF	 179
IT0				  BIT	      88	  86

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 117



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
IT1				  BIT	      8A	  88
KEY				  NUMBER    0038	 286
KEY1				  CODE	    1562	6082
KEY2				  CODE	    156F	6089
KEYDOWN				  CODE	    1534	6054
KEYEDGE				  CODE	    154D	6070
KEYFLAGS			  NUMBER    0020	 261
KEYINIT1			  CODE	    149C	5825
KEYMAP				  NUMBER    0030	 280
KEYMODE				  BIT	      01	 265
KEYSCAN				  CODE	    14D1	5902
KEYVALID			  BIT	      00	 263
KEY_INIT			  CODE	    148E	5817
KOLOMLOOP			  CODE	    1571	6091
LCDBUZOFF			  CODE	    047D	1571
LCDBUZON			  CODE	    0470	1555
LCDLIGHTOFF			  CODE	    0463	1539
LCDLIGHTON			  CODE	    0456	1522
LCDPORT				  NUMBER    00F0	 377
LCDTOPORT			  CODE	    043D	1496
LF				  NUMBER    000A	1604
LOOP				  CODE	    0026	 198
LOWLOGIC			  CODE	    15EA	6274
LOWUPTR				  CODE	    05BE	1926
LOWUPTR1			  CODE	    05C1	1927
LOWUPTR2			  CODE	    05CA	1931
LOWUPTR3			  CODE	    05C6	1929
MAGSIG16			  CODE	    077B	2444
MAGSIG16A			  CODE	    078C	2453
MAGSIG16ACC1			  CODE	    079B	2477
MAGSIG16ACC1A			  CODE	    07AC	2486
MAGSIG16ACC1B			  CODE	    07A7	2483
MAGSIG16ACC1C			  CODE	    07B6	2494
MAGSIG16B			  CODE	    0787	2450
MAGSIG16C			  CODE	    0796	2461
MAGSIG32			  CODE	    07BB	2511
MAGSIG32A			  CODE	    07CC	2520
MAGSIG32ACC1			  CODE	    07E5	2556
MAGSIG32ACC1A			  CODE	    07F6	2565
MAGSIG32ACC1B			  CODE	    07F1	2562
MAGSIG32ACC1C			  CODE	    080A	2582
MAGSIG32B			  CODE	    07C7	2517
MAGSIG32C			  CODE	    07E0	2537
MAGSIG8				  CODE	    0747	2385
MAGSIG8A			  CODE	    0758	2394
MAGSIG8ACC1			  CODE	    0761	2415
MAGSIG8ACC1A			  CODE	    0772	2424
MAGSIG8ACC1B			  CODE	    076D	2421
MAGSIG8ACC1C			  CODE	    0776	2428
MAGSIG8B			  CODE	    0753	2391
MAGSIG8C			  CODE	    075C	2398
MAP01PTR			  NUMBER    0030	 282
MAP23PTR			  NUMBER    0034	 285
MATRIX				  NUMBER    0001	 251
MCO				  BIT	      ED	 169
MDE				  BIT	      EE	 170

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 118



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
MDI				  BIT	      EC	 168
MDO				  BIT	      EF	 171
MIN				  DATA	      A4	  31
MUL16				  CODE	    0A65	3276
MUL16ACC1			  CODE	    0ACA	3365
MUL16_10			  CODE	    0E89	4352
MUL16_100			  CODE	    0EBE	4400
MUL16_I_PI			  CODE	    0E26	4256
MUL16_I_SQRT2			  CODE	    0E68	4321
MUL16_PI			  CODE	    0E05	4225
MUL16_SQRT2			  CODE	    0E47	4288
MUL816				  CODE	    0B52	3512
MULDIV				  CODE	    0DC9	4167
MULDIV1				  CODE	    0DD9	4179
NEGEDGE				  NUMBER    0044	 301
NEGVALID			  BIT	      03	 270
NOKEY				  CODE	    1589	6112
OUTBYTE				  CODE	    04CD	1694
OUTBYTELCD			  CODE	    00EA	 583
OUTC				  CODE	    0197	 789
OUTCHAR				  CODE	    04B1	1661
OUTCHAR1			  CODE	    04B3	1662
OUTCHARLCD			  CODE	    0089	 498
OUTCHARLCD1			  CODE	    0090	 501
OUTCHARLCD2			  CODE	    009A	 505
OUTCHARLCD2_0			  CODE	    0095	 503
OUTCHARLCD3			  CODE	    00A3	 515
OUTCHARLCD4			  CODE	    00AA	 519
OUTCHARLCD5			  CODE	    00B1	 523
OUTCHARLCD6			  CODE	    00B8	 527
OUTCHARLCD7			  CODE	    00BF	 531
OUTCHARLCD8			  CODE	    00C6	 539
OUTCHARLCD9			  CODE	    00CB	 547
OUTCHARLCDE			  CODE	    00CE	 548
OUTD				  CODE	    015D	 711
OUTHNIBC			  CODE	    01AD	 831
OUTHNIBD			  CODE	    016D	 759
OUTMSGA				  CODE	    04F4	1733
OUTMSGA1			  CODE	    0509	1744
OUTMSGA2			  CODE	    04FC	1737
OUTMSGALCD			  CODE	    010E	 626
OUTMSGALCD1			  CODE	    0116	 633
OUTMSGALCDE			  CODE	    0121	 643
OUTNIB				  CODE	    04B9	1675
OUTNIBLCD			  CODE	    00D3	 562
OUTNIBLCD1			  CODE	    00DE	 567
OUTNIBLCDE			  CODE	    00E2	 569
OV				  BIT	      D2	 146
P				  BIT	      D0	 144
P0				  DATA	      80	   8
P1				  DATA	      90	  20
P2				  DATA	      A0	  27
P3				  DATA	      B0	  39
PADC				  BIT	      BE	 126
PCF8574A			  NUMBER    0001	1225
PCON				  DATA	      87	  13

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 119



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
PLLCON				  DATA	      D7	  64
PORTTOLCD			  CODE	    0424	1468
POSEDGE				  NUMBER    0045	 302
POSVALID			  BIT	      04	 272
PRE0				  BIT	      C4	 132
PRE1				  BIT	      C5	 133
PRE2				  BIT	      C6	 134
PRE3				  BIT	      C7	 135
PS				  BIT	      BC	 124
PSI				  BIT	      BF	 127
PSMCON				  DATA	      DF	  68
PSW				  DATA	      D0	  60
PT0				  BIT	      B9	 121
PT1				  BIT	      BB	 123
PT2				  BIT	      BD	 125
PWM0H				  DATA	      B2	  41
PWM0L				  DATA	      B1	  40
PWM1H				  DATA	      B4	  43
PWM1L				  DATA	      B3	  42
PWMCON				  DATA	      AE	  37
PX0				  BIT	      B8	 120
PX1				  BIT	      BA	 122
RB8				  BIT	      9A	  98
RCAP2H				  DATA	      CB	  57
RCAP2L				  DATA	      CA	  56
RCLK				  BIT	      CD	 141
RD				  BIT	      B7	 119
READ_PORT3			  CODE	    15E6	6270
READ_SWITCH			  CODE	    15D3	6247
READ_SWITCH1			  CODE	    1602	6292
READ_SWITCH2			  CODE	    160D	6298
REGTOLCD			  CODE	    012A	 663
REGTOLCD1			  CODE	    013B	 673
REGTOLCD2			  CODE	    0149	 683
REN				  BIT	      9C	 100
RI				  BIT	      98	  96
RIJLOOP				  CODE	    1564	6083
RS				  BIT	      F0	 379
RS0				  BIT	      D3	 147
RS1				  BIT	      D4	 148
RXD				  BIT	      B0	 112
SBUF				  DATA	      99	  22
SCANLOOP			  CODE	    14EC	5919
SCON				  DATA	      98	  21
SCONV				  BIT	      DC	 156
SEC				  DATA	      A3	  30
SHIFTLEFT1			  CODE	    1035	4715
SHIFTLEFT2			  CODE	    103D	4721
SHIFTLEFT3			  CODE	    1041	4723
SHIFTLEFT32			  CODE	    102D	4711
SHIFTRIGHT1			  CODE	    1009	4670
SHIFTRIGHT2			  CODE	    1011	4676
SHIFTRIGHT3			  CODE	    1015	4678
SHIFTRIGHT32			  CODE	    1001	4666
SIGMAG16ACC0			  CODE	    0841	2655
SIGMAG16ACC0A			  CODE	    0850	2664

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 120



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SIGMAG16ACC1			  CODE	    0861	2690
SIGMAG16ACC1A			  CODE	    0870	2699
SIGMAG16ACC1H			  CODE	    0881	2725
SIGMAG16ACC1HA			  CODE	    0890	2734
SIGMAG32ACC0			  CODE	    08A1	2762
SIGMAG32ACC0A			  CODE	    08B0	2771
SIGMAG32ACC1			  CODE	    08CB	2806
SIGMAG32ACC1A			  CODE	    08DA	2815
SIGMAG8ACC0			  CODE	    080F	2599
SIGMAG8ACC0A			  CODE	    081E	2607
SIGMAG8ACC1			  CODE	    0828	2627
SIGMAG8ACC1A			  CODE	    0837	2635
SM0				  BIT	      9F	 103
SM1				  BIT	      9E	 102
SM2				  BIT	      9D	 101
SP				  DATA	      81	   9
SPE				  BIT	      FD	 177
SPH				  DATA	      B7	  44
SPICON				  DATA	      F8	  80
SPIDAT				  DATA	      F7	  79
SPIM				  BIT	      FC	 176
SPR0				  BIT	      F8	 172
SPR1				  BIT	      F9	 173
SQRT32				  CODE	    0F14	4472
SQRT320				  CODE	    0F3B	4494
SQRT321				  CODE	    0F40	4496
SQRT322				  CODE	    0FA3	4578
SQRT323				  CODE	    0FA9	4582
SQRT324				  CODE	    0FCC	4606
SQRT3240			  CODE	    0FC7	4604
SQRT325				  CODE	    0FCF	4608
STACK_INIT			  NUMBER    007F	 182
START				  CODE	    000E	 189
STRTBUF				  NUMBER    0054	1611
SUB16				  CODE	    09DB	3114
SUB161				  CODE	    09F0	3131
SUB32				  CODE	    0A42	3231
SUB321				  CODE	    0A5D	3256
SWINIT				  CODE	    15BD	6168
SWITCH1				  NUMBER    0040	 297
SWITCH2				  NUMBER    0041	 298
SWITCHMAP			  NUMBER    0040	 296
SWITCH_INIT			  CODE	    15AF	6160
SWVALID				  BIT	      02	 268
S_ADD16				  CODE	    08F5	2852
S_ADD161			  CODE	    0919	2878
S_ADD162			  CODE	    091D	2880
S_ADD163			  CODE	    0923	2885
S_ADD32				  CODE	    0945	2945
S_ADD321			  CODE	    096D	2976
S_ADD322			  CODE	    096F	2977
S_ADD323			  CODE	    0975	2982
S_CMP16				  CODE	    10BE	4864
S_CMP160			  CODE	    10D1	4881
S_CMP161			  CODE	    10DF	4891
S_CMP162			  CODE	    10ED	4901

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 121



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
S_CMP163			  CODE	    10FC	4913
S_CMP32				  CODE	    113D	4988
S_CMP320			  CODE	    1158	5008
S_CMP321			  CODE	    116C	5022
S_CMP322			  CODE	    1180	5036
S_CMP323			  CODE	    1197	5056
S_DIV16				  CODE	    0BCD	3655
S_DIV161			  CODE	    0BDB	3665
S_DIV32				  CODE	    0C75	3817
S_DIV321			  CODE	    0C85	3829
S_DIV8				  CODE	    0B9B	3594
S_DIV81				  CODE	    0BAC	3600
S_MAC16				  CODE	    0B79	3554
S_MAC161			  CODE	    0B95	3574
S_MUL16				  CODE	    0B2B	3456
S_MUL16ACC1			  CODE	    0B38	3474
S_MUL816			  CODE	    0B45	3493
S_MULDIV			  CODE	    0DA4	4123
S_MULDIV1			  CODE	    0DB4	4135
S_SHIFTLEFT1			  CODE	    1098	4817
S_SHIFTLEFT2			  CODE	    10A0	4823
S_SHIFTLEFT3			  CODE	    10A4	4828
S_SHIFTLEFT32			  CODE	    1090	4813
S_SHIFTRIGHT1			  CODE	    1061	4763
S_SHIFTRIGHT2			  CODE	    1069	4769
S_SHIFTRIGHT20			  CODE	    1075	4775
S_SHIFTRIGHT3			  CODE	    1077	4777
S_SHIFTRIGHT32			  CODE	    1059	4759
S_SQRT32			  CODE	    0FEA	4639
S_SQRT321			  CODE	    0FF8	4647
S_SUB16				  CODE	    099D	3050
S_SUB161			  CODE	    09CB	3085
S_SUB162			  CODE	    09CF	3087
S_SUB163			  CODE	    09D5	3092
S_SUB32				  CODE	    09F8	3153
S_SUB321			  CODE	    0A34	3203
S_SUB322			  CODE	    0A36	3204
S_SUB323			  CODE	    0A3C	3209
T0				  BIT	      B4	 116
T1				  BIT	      B5	 117
T2				  BIT	      90	  94
T2CON				  DATA	      C8	  55
T2EX				  BIT	      91	  95
T3CON				  DATA	      9E	  25
T3FD				  DATA	      9D	  26
TABLE_LU			  CODE	    11EA	5148
TABLE_LU1			  CODE	    120F	5174
TABLE_LU2			  CODE	    1220	5187
TABLE_LU3			  CODE	    1259	5230
TABLE_LU4			  CODE	    126B	5243
TABLE_LU_10			  CODE	    1216	5179
TB8				  BIT	      9B	  99
TCLK				  BIT	      CC	 140
TCON				  DATA	      88	  14
TF0				  BIT	      8D	  91
TF1				  BIT	      8F	  93

ASEM-51 V1.3                                        Copyright (c) 2002 by W.W. Heinz                                        PAGE 122



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TF2				  BIT	      CF	 143
TH0				  DATA	      8C	  18
TH1				  DATA	      8D	  19
TH2				  DATA	      CD	  59
TI				  BIT	      99	  97
TIMECON				  DATA	      A1	  28
TL0				  DATA	      8A	  16
TL1				  DATA	      8B	  17
TL2				  DATA	      CC	  58
TMOD				  DATA	      89	  15
TOETSIN				  CODE	    157B	6102
TOETSTABEL			  CODE	    159F	6129
TOETS_FLANK			  CODE	    14B3	5856
TOETS_INGEDRUKT			  CODE	    14C2	5879
TR0				  BIT	      8C	  90
TR1				  BIT	      8E	  92
TR2				  BIT	      CA	 138
TXD				  BIT	      B1	 113
WCOL				  BIT	      FE	 178
WDCON				  DATA	      C0	  51
WDE				  BIT	      C1	 129
WDIR				  BIT	      C3	 131
WDS				  BIT	      C2	 130
WDWR				  BIT	      C0	 128
WISSEN				  CODE	    048A	1608
WR				  BIT	      B6	 118
XOFF				  NUMBER    0013	1601
XONXOFF				  CODE	    0512	1761
XONXOFF1			  CODE	    051E	1767
XONXOFF2			  CODE	    0519	1764
XONXOFF3			  CODE	    0523	1769
